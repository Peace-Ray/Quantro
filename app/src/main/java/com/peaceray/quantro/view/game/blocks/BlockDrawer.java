package com.peaceray.quantro.view.game.blocks;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.IOException;
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Random;

import com.peaceray.quantro.QuantroApplication;
import com.peaceray.quantro.QuantroPreferences;
import com.peaceray.quantro.consts.GlobalTestSettings;
import com.peaceray.quantro.content.Background;
import com.peaceray.quantro.content.Skin;
import com.peaceray.quantro.model.game.GameBlocksSlice;
import com.peaceray.quantro.model.pieces.Offset;
import com.peaceray.quantro.model.pieces.PieceCatalog;
import com.peaceray.quantro.q.QCombinations;
import com.peaceray.quantro.q.QOrientations;
import com.peaceray.quantro.sound.QuantroSoundPool;
import com.peaceray.quantro.utils.Analytics;
import com.peaceray.quantro.utils.ArrayOps;
import com.peaceray.quantro.utils.Debug;
import com.peaceray.quantro.utils.IntStack;
import com.peaceray.quantro.utils.VersionCapabilities;
import com.peaceray.quantro.utils.VersionSafe;
import com.peaceray.quantro.utils.LooselyBoundedArray.LooselyBoundedArray;
import com.peaceray.quantro.utils.backgroundbuildable.BackgroundBuilder;
import com.peaceray.quantro.utils.backgroundbuildable.BackgroundBuilderListener;
import com.peaceray.quantro.view.colors.ColorOp;
import com.peaceray.quantro.view.drawable.LineShadingDrawable;
import com.peaceray.quantro.view.game.AnimationSettings;
import com.peaceray.quantro.view.game.DrawSettings;
import com.peaceray.quantro.view.game.GameViewMemoryCapabilities;
import com.peaceray.quantro.view.game.blocks.asset.BackgroundAsset;
import com.peaceray.quantro.view.game.blocks.asset.skin.SkinAsset;
import com.peaceray.quantro.view.game.blocks.asset.skin.SkinAssetBuilderFactory;
import com.peaceray.quantro.view.game.blocks.config.BlockDrawerConfigCanvas;
import com.peaceray.quantro.view.game.blocks.config.BlockDrawerConfigRange;
import com.peaceray.quantro.view.game.blocks.effects.FadeEffect;
import com.peaceray.quantro.view.game.blocks.effects.FadeEffectList;
import com.peaceray.quantro.view.game.blocks.effects.GlowEffect;
import com.peaceray.quantro.view.game.blocks.effects.GlowEffectList;
import com.peaceray.quantro.view.game.blocks.effects.SoundEffect;
import com.peaceray.quantro.view.game.blocks.effects.SoundEffectList;

import android.content.Context;
import android.content.res.AssetManager;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.ColorFilter;
import android.graphics.ColorMatrixColorFilter;
import android.graphics.LightingColorFilter;
import android.graphics.LinearGradient;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.graphics.Path;
import android.graphics.PorterDuffColorFilter;
import android.graphics.PorterDuffXfermode;
import android.graphics.PorterDuff;
import android.graphics.Rect;
import android.graphics.RectF;
import android.graphics.Region;
import android.graphics.Shader;
import android.graphics.drawable.Drawable;
import android.graphics.drawable.GradientDrawable;
import android.graphics.drawable.LayerDrawable;
import android.graphics.drawable.PaintDrawable;
import android.graphics.drawable.ShapeDrawable;
import android.graphics.drawable.shapes.RectShape;
import android.util.Log;
import android.util.SparseArray;

/**
 * A class whose static methods allow blockFields and animation frames to be
 * drawn directly on a canvas.
 * 
 * Pass in all the information needed yourself.
 * 
 * Initially this class was a completely 'static' means of drawing blockfields
 * to the Canvas. The specifics of what was draw was determined by the
 * blockfield, the DrawSettings object passed in, and various other metadata
 * such as the number of seconds since a particular game event occurred (used to
 * calculate animation progress). However, with development moving into a
 * graphical redesign of Retro style (Quantro still forthcoming), drawing
 * everything completely from scratch with each iteration is now computationally
 * infeasible. For instance, the Retro style incorporates complex gradients and
 * Gaussian "shadows" to draw block and border shapes. Rendering these from
 * scratch at every tick (possibly even for every block) is much too complex a
 * process to happen in real-time. Two optimizations present themselves:
 * 
 * 1. Clip Invalid Regions: Rather than re-render the entire game field at every
 * tick, retain a record of the most recent draw call - animation frame,
 * blockfield, etc. Use this to determine the portions of the screen which have
 * changed, and only redraw those portions.
 * 
 * 2. Prerender Component Bitmaps: Do not draw the entire blockfield from
 * scratch at each tick. Instead, render reusable bitmaps (for example, the
 * shadows to be applied to a Retro block with a border left, up-left, and up)
 * and apply those to the Canvas.
 * 
 * Optimization 1 is planned for Beta; it should not affect the content drawn to
 * the screen and is a very basic optimization to implement once everything else
 * is in-place. However, by its very nature, it requires that we keep a record
 * of the last blockField drawn. This means we either leave that responsibility
 * to the calling code block (meaning re-implementing it for both GameView and
 * BlockFieldView) or we retain that data ourselves (meaning the BlockDrawer
 * must be explicitly told if it must redraw the entire region rather than
 * assume the result is cached). We prefer the second, meaning any class using
 * the BlockDrawer must allocate one for every Game object / blockfield / screen
 * location (we cannot use the same BlockDrawer instance to draw to multiple
 * screen locations, nor to draw multiple games). NOTE: this optimization may be
 * considered a separate issue from redrawing the background once an occluding
 * element is gone. Redrawing after occlussion may be too difficult to easily
 * handle, in which case BlockDrawer should first draw a bitmap of the entire
 * block field area from the previous tick, then empty and redraw the specific
 * regions that have been updated.
 * 
 * In short, Optimization 1 requires a unique BlockDrawer instance for every
 * draw region / "Game" object pair. This refactoring, and stub methods to
 * optimization helpers, are to be implemented right now and filled in later.
 * 
 * 
 * Optimization 2 is required to implement the new Retro art style. For example,
 * I plan to render 2^8 = 256 "shadow bitmaps", one for every possible
 * configuration of block borders (each of the 8 neighboring blocks may be
 * connected or not connected). These bitmaps should be rendered at the current
 * block dimensions, meaning they require knowledge of DrawSettings content to
 * effectively prerender. Again, two options: duplicate DrawSettings data within
 * the BlockDrawer instance (to be checked against the DrawSettings passed in)
 * OR make DrawSettings an internal class object to BlockDrawer. Because we
 * don't use DrawSettings for anything other than the BlockDrawer, let's do the
 * second. This requires a significant refactoring before implementing any new
 * draw code.
 * 
 * This optimization ties in to the requirements of Optimization 1. We now need
 * a 1-to-1 correspondence between BlockDrawer instances and screen region /
 * Game pairs. DrawSettings should now be instances vars for a BlockDrawer.
 * 
 * Do we still want to allow direct access to them? Maybe... maybe. But why? We
 * don't make any "on the fly" changes to DrawSettings, except for
 * draw=true/false, which can be easily moved to a BlockDrawer instance. All the
 * DrawSettings configuration happens at instantiation, or immediately after
 * (before the next attempt to draw). No reason not to allow for 2 "states" in a
 * BlockDrawer: a configuration state, for setting various DrawSettings and
 * pre-rendering stuff, and a draw state, where we draw to the screen. Another
 * approach would be a "set draw settings and prerender" call, once a
 * DrawSettings object is constructed. That's probably for the best, since we
 * would normally need a complete DrawSettings object to prerender.
 * 
 * 
 * @author Jake
 * 
 */
public class BlockDrawer {

	private static final String TAG = "BlockDrawer";
	private static final boolean DEBUG_LOG = false && Debug.LOG ;
	
	private static final void log( String msg ) {
		Log.d(TAG, msg) ;
	}

	// Storage for an empty region
	private static final Offset OFFSET_NONE = new Offset();
	
	// "Stutter Stable": when stuttering, for how long do we display?
	private static final long STUTTER_DRAW_TIME_MILLISECONDS = 80 ;
	private static final long STUTTER_SOUND_EFFECT_TIME_MILLISECONDS = STUTTER_DRAW_TIME_MILLISECONDS ;
	private static final long STUTTER_SOUND_EFFECT_PENALTY_EXTRA_TIME_MILLISECONDS = 50 ;
	
	// Our context
	private WeakReference<Context> mwrContext;

	// Our draw settings!
	private DrawSettings mDrawSettings;
	private DrawSettings mVeilSettings;
	private AnimationSettings animationSettings;
	private boolean recycled = false;
	// Our memory! Used to pass information between calls.
	private long mLastDrawFallingChunksTime;

	// Our prerendered stuff!
	private int sheetBlockWidth;
	private int sheetBlockHeight;
	private Bitmap innerBorderFillShadowSheet;
	private Bitmap innerBorderDropShadowSheet; // shadows dropped around the
												// shapes (over the background).
	private Rect innerBorderFillShadowSheetBounds;
	private Rect innerBorderDropShadowSheetBounds;
	private Path[] innerBorderDropShadowPath; // region for drawing a low-fi
													// drop shadow (black
													// border).
	private Rect[][] innerBorderDropShadowRects; // equivalent to "Path", but
													// as a list of (unioned)
													// rectangles.

	private Bitmap[][] glowSheet_byGlowType_byGlowIndex;
	private Rect[][] glowSheetBounds_byGlowType_byGlowIndex;
	private Path[][][] glowPath_byGlowType_byGlowIndex_byNeighbors;
	private Bitmap renderScratchBitmap;
	private Bitmap renderScratchColorFilteredBitmap;
	private Canvas renderScratchCanvas;
	private Canvas renderScratchColorFilteredCanvas;
	private Rect renderScratchBounds;

	// private Bitmap [] innerBorderFillShadow_byNeighbors ; // indexed by
	// neighbor connections. Applied to those with QOrientation Inner borders.
	// private Bitmap [][] lockGlow_byGlowIndex_Neighbors ; // indexed by
	// neighbor connections.
	// private Bitmap [][] clearGlow_byGlowIndex_Neighbors ; // indexed by
	// neighbor connections.
	// private Bitmap [][] unlockColumnGlow_byGlowIndex_Neighbors ;
	// private Bitmap [][] metamorphosisGlow_byGlowIndex_Neighbors ;
	private Bitmap[] innerBorderExtrudedWallShadow_bySide; // indexed by
															// "wall placement"
	private Bitmap[] customBitmap_byQOrientation;
	private Rect[] customBitmapBounds_byQOrientation;
	private Path[] innerBorderPath_byNeighbors; // the path covered by the
													// inner border, according
													// to neighbor index. Take
													// the difference from a
													// square for a fill region.
	private Path[][] customFillPath_byQPane_QOrientation; // When the "fill"
																// area is
																// different
																// from the
																// boundaries of
																// the block
																// (normal,
																// inset, or
																// mini) this
																// region, which
																// should be
																// offset from
																// (0,0) to the
																// block
																// position,
																// gives the
																// fill area.
	private Path[][] customBorderPath_byQPane_QOrientation; // When the
																// "border" area
																// is different
																// from the
																// boundaries of
																// the block
																// (normal,
																// inset, or
																// mini) this
																// region, which
																// should be
																// translated
																// from (0,0) to
																// the block
																// position,
																// gives the
																// border area.
	private Bitmap[][] customFillShadow_byQPaneQOrientation; // When the
																// "fill / border"
																// area are
																// different
																// from the
																// boundaries of
																// the block, it
																// may have a
																// different
																// inner shadow
																// set as well.
	private Rect[][] customFillShadowBounds_byQPaneQOrientation;
	private Bitmap[][] customDropShadow_byQPaneQOrientation; // When the
																// "fill / border"
																// area are
																// different
																// from block
																// boundaries,
																// it may have a
																// different
																// drop shadow.
	private Rect[][] customDropShadowBounds_byQPaneQOrientation;
	private Path[][] customDropShadowPath_byQPaneQOrientation; // When not
																	// drawing
																	// bitmap
																	// draw
																	// shadows,
																	// these get
																	// filled
																	// with
																	// black.
	private Drawable[][][][][] innerBorderShine_byQPaneQOrientationCornerCornerDirection; // indexed
																							// by
																							// "corner-to-corner",
																							// moving
																							// rightward
																							// or
																							// downward.
	private Bitmap[][] customBorderShine_byQPaneQOrientation; // Because
																// inset/mini
																// borders are
																// always 1-off
																// squares, we
																// can
																// pregenerate
																// the shine as
																// a bitmap and
																// apply with a
																// color filter
																// for the
																// alpha.
	private Rect[][] customBorderShineBounds_byQPaneQOrientation;
	private Drawable[][][][][] innerBorder_byQPaneQOrientationCornerCornerDirection; // combines
																						// underlying
																						// color
																						// with
																						// shine
																						// above.
																						// Works
																						// for
																						// all
																						// but
																						// "friendly"
																						// borders,
																						// in
																						// which
																						// they
																						// must
																						// be
																						// drawn
																						// independently.
	private Bitmap[][][][][][] innerBorderBitmap_byQPaneQOrientationCornerCornerDirectionWidth; // a
																								// "pre-rendered"
																								// version
																								// of
																								// innerBorderBitmap_byQPaneQOrientationCornerCornerDirectionWidth.
	private Bitmap[][][][][] innerBorderStretchableBitmap_byQPaneQOrientationCornerCornerDirection;
	private Rect[][][][][][] innerBorderBitmapBounds_byQPaneQOrientationCornerCornerDirectionWidth;
	private Rect[][][][][] innerBorderStretchableBitmapBounds_byQPaneQOrientationCornerCornerDirection;

	private int[][][][] innerBorderColorSubstitute_byQPaneQOrientationCornerCorner;
	private Bitmap[][] customBorder_byQPaneQOrientation;
	private Rect[][] customBorderBounds_byQPaneQOrientation;
	private Bitmap[] rowNegativeOneBorder_byQPane;
	private Rect[] rowNegativeOneBorderBounds_byQPane;
	private Bitmap[][][][] friendlyFillBlend_byQPaneQOrientationFromToDirection;
	// A blend "from" (this QO) "to" (neighbor QO) in thespecified direction.
	// Size: 1 pixel by the appropriate side length length.
	// A Bitmap is used here, not a Drawable, because of a strange
	// GradientDrawable.setAlpha() problem that resulted in a perceptually
	// lower opacity for Drawables than neighboring Paints of the same color.
	private Drawable[][][][] friendlyBorderBlend_byQPaneQOrientationFromToDirection;
	
	private Bitmap[][][][] friendlyFillBlendSimplified_byQPaneQOrientationFromToDirection;
	// A blend "from" (this QO) "to" (neighbor QO) in thespecified direction.
	// Size: 1 pixel by the appropriate side length length.
	// A Bitmap is used here, not a Drawable, because of a strange
	// GradientDrawable.setAlpha() problem that resulted in a perceptually
	// lower opacity for Drawables than neighboring Paints of the same color.
	private Drawable[][][][] friendlyBorderBlendSimplified_byQPaneQOrientationFromToDirection;
	
	
	private Drawable[] hashing_byQPane;

	private ColorMatrixColorFilter[] alphaScaleMatrix_byAlphaScaleStepMultiple;
	private float ALPHA_SCALE_STEP_MULTIPLE;
	private static final int ALPHA_SCALE_NUM_STEPS = 1000;

	private SparseArray<ColorFilter> glowColorFilter_byColor;

	private static final int WALL_SIDE_LEFT = 0;
	private static final int WALL_SIDE_TOP = 1;
	private static final int WALL_SIDE_RIGHT = 2;
	private static final int WALL_SIDE_BOTTOM = 3;
	private static final int NUM_WALL_SIDES = 4;

	private static final int DIRECTION_NONE = 0;
	private static final int DIRECTION_RIGHT = 1;
	private static final int DIRECTION_DOWN = 2;
	private static final int NUM_SHINE_DIRECTIONS = 3;
	private static final int DIRECTION_LEFT = 4;
	private static final int DIRECTION_UP = 5;
	private static final int NUM_CONNECTED_DIRECTIONS = 6;

	private static final int NUM_PRERENDERED_BORDER_WIDTHS = 2; // 0 and 1.
	private int PRERENDERED_BLOCK_BORDER_WIDTH;
	private int PRERENDERED_BLOCK_BORDER_HEIGHT;
	private static final int PRERENDERED_STRETCHABLE_BORDER_LENGTH = 32;

	// TODO: add more of these.

	// Other draw parameters
	private boolean visible;

	// we may have larger bitmaps than we should draw. For example,
	// pre-allocating all
	// large bitmaps on application launch is being considered as a way to
	// prevent the
	// OutOfMemory errors resulting from non-compacting garbage collection. We
	// assume
	// that only one BlockDrawer exists which uses pre-allocated Bitmaps, so
	// drawing outside
	// their soft-bounds (the area which we're using) is not a problem; however,
	// measuring
	// the bitmaps directly IS. For that reason, we use Rect objects to
	// represent the "Bounds"
	// of these bitmaps (mBackgroundBitmap and mLastBitmap[] are the only ones
	// given this treatment)
	// and query that rect instead of the bitmap or associated canvas when
	// height or width
	// information is needed.

	// EFFICIENCY STRUCTURES!
	private boolean mHasPreallocatedBitmaps = false;
	private BlockDrawerPreallocatedBitmaps mPreallocatedBitmaps = null;
	private Bitmap mLoadIntoBitmapSheet = null ;
	private Bitmap mLoadIntoBitmapBackground = null ;
	

	private boolean mLastBitmapIsStableSlice;
	private boolean mLastBitmapIsStableSliceIgnoringEffects;
	private boolean mLastBitmapIsStableSliceReadyToAdvanceEffects; // subset of
																	// IgnoringEffects:
																	// are we
																	// ready to
																	// move on?
	private DrawStableFieldType mLastBitmapStableField ;

	// Background assets are drawn in the order presented. We use a two-pass
	// method: first, identifying the last asset (in-order) which has a full
	// alpha (we assume the first presented has a full alpha). For the second
	// pass, beginning at the last full-alpha asset, we draw the backgrounds
	// one over another.
	// Alpha is determined using our animation settings and the time the asset
	// was introduced. Negative introduction times represent immediate,
	// full-alpha
	// deployment.
	// After each draw, we trim down to the last full-alpha background, leaving
	// any zero-alpha backgrounds in the list after this point. We use
	// zero-alpha
	// backgrounds as a way to pre-load backgrounds we intend to introduce
	// later.
	// For now, we use at most 2 backgrounds, and require that the background
	// bitmap
	// exist in the Preallocated structure. Non-preallocated BlockDrawers don't
	// get
	// the luxury of a smooth background transition; we immediately load and
	// snap
	// to the new one, replacing the old.
	private ArrayList<BackgroundAsset> mBackgroundAssets;
	private ArrayList<Long> mBackgroundAssetTimeIntroduced;
	private int mBackroundAssetNumberLastDraw;
	private boolean mBackgroundBitmapClipOrBlitIsBlitting; // only some draw
															// methods prefer
															// blitting.
	private Offset mBackgroundBitmapOffset;

	private ArrayList<SkinAsset> mSkinAssets;
	private ArrayList<Long> mSkinAssetTimeIntroduced;

	private Bitmap[] mLastBitmap; // dimensions = width by 2*height, to allow
									// for vertical movement.
	private Rect[] mLastBitmapBounds;
	private Canvas[] mLastBitmapCanvas;
	private Rect[] mLastBitmapBlitRect;
	private Path[] mLastBitmapClipPath;
	private Path[] mLastBitmapCoveredPath; // as best we can, the area
												// completely covered with
												// blocks. UNDER-FILLED:
												// omitting a covered pixel is
												// OK, including an uncovered
												// pixel is NOT OK. used when
												// drawing to the same QPane -
												// we don't want to draw
												// drop shadows from the 2nd
												// over the 1st, so we clip
												// difference the coverage of
												// the 1st before drawing the
												// 2nd.
	private Path[] mLastBitmapTouchedPath; // as best we can, the area with
												// nonzero alpha. OVER-FILLED:
												// including an empty pixel is
												// OK, omitting a colored pixel
												// is NOT OK. Used to restrict
												// our SEPTUPLE BLITs.
												// BITMAP_FULL gets a
												// clip covering all layers;
												// when copying a particular
												// layer, we might be able to
												// save time
												// by INTERSECT clipping the
												// area touched by that region.
	private GameBlocksSlice mVeilSlice;
	private byte[][][][] mVeilCorners;
	private short[][][] mVeilFillShadows;
	private short[][][][] mVeilDropShadows;
	private boolean mVeiled = false; // should we show the veil?
	private boolean mVeilPossiblyOnScreen; // we have veiled recently enough
											// that the veil might be shown.
	private long mTimeLastVeiling; // since the last time veil() was called
	private long mTimeLastUnveiling; // since the last time unveil() was called
	private long mTimeFirstVeilDraw; // the time we first drew the veil such
										// that it appeared on the screen.
	private boolean mLastBitmapVeiled; // the last bitmap was drawn in a
										// "veiled" style, which may have
										// different setup than otherwise.
	private GameBlocksSlice mLastSlice;
	private BlockDrawerSliceTime mLastSliceTime;
	private boolean mNextSliceNeedsExplicitConfigCanvas; // Although the next
															// slice is possibly
															// consistent, we
															// need to fully
															// redraw all
															// content.
	private boolean mNextSliceBreaksSequence; // we have been informed that the
												// next slice will represent a
												// field
												// change from the last.
	private boolean mNextSlicePossiblyInconsistent; // we have been warned that
													// the next slice MIGHT
													// represent a field change
													// from the last, probably
													// due to a synchronization.
	private boolean mNextSliceDisplacementRowsChanged ;
	
	private boolean mLastBitmapDifferentDisplacement = false ;
	
	private ArrayList<short[][][]> mLastFillShadowSets_byField_byPane;
	private ArrayList<short[][][][]> mLastDropShadowSets_byField_byPane_byUniqueColor;
	private int[] mLastFillShadowSetsColor_byUniqueColor;
	private int[][] mLastFillShadowSetsUniqueColor_byQOrientation_byPane;
	private Paint[] mLastFillShadowSetsColorFilterPaint_byUniqueColor;
	private int[] mLastDropShadowSetsColor_byUniqueColor;
	private int[][] mLastDropShadowSetsUniqueColor_byQOrientation_byPane;
	private Paint[] mLastDropShadowSetsColorFilterPaint_byUniqueColor;
	private ArrayList<byte[][][][]> mLastCorners_byField_byPaneCorner;
	private ArrayList<short[][][]> mLastQOConnectedSets_byField_byPane;
	private ArrayList<byte[][][][]> mLastQOConnectedCorners_byField_byPaneCorner;
	private GlowEffectList mLastEffectsGlow;
	private SoundEffectList mLastEffectsSound;
	private FadeEffectList mLastEffectsFade;
	// specific state metadata: some draw*WithLastSlice methods require specific
	// data be retained to aid in animation; we try to re-calculate everything
	// from scratch when we can, but for some specific animations having
	// instance
	// vars is a big help.
	private int mLastBitmapChunksFalling_drawFallDirectionChangeChunk;
	// the chunk at which we transitioned (or will transition) from
	// raising the floor to falling the chunks
	private int mLastBitmapChunksFalling_drawFallDirectionChangeDistance;
	// the distance (pixels) at which the transition occurred. Will
	// increase from 0 with each call until the transition.
	private boolean mLastBitmapChunksFalling_drawFallDirectionChangeClipped;
	private int mLastBitmapChunksFalling_drawFallDirectionChangeChunkFallDistance;
	private boolean mLastBitmapChunksFalling_animationsFinished;
	// set to 'true' when finished locking; we draw 1 more frame to
	// reposition if ChangeDistance > 0.
	private int mLastBitmapRisingBlockfield_drawHeightOffset;
	// Meta-data useful for Septuple Blits.
	private int mChunksFallingLowestRow; // the lowest "pre-fall" row among
											// currently falling chunks
	private int mChunksFallingLowestRowChunk; // the chunk to which the above
												// belongs
	private int mChunksFallingHighestRow; // the highest "pre-fall" row among
											// currently falling chunks
	private int mChunksFallingHighestRowChunk; // the chunk to which the above
												// belongs
	private int mChunksFallingLowestRow_atLastVolatileAlignment; // the lowest
																	// "pre-fall"
																	// row among
																	// currently
																	// falling
																	// chunks
	private int mChunksFallingLowestRowChunk_atLastVolatileAlignment; // the
																		// chunk
																		// to
																		// which
																		// the
																		// above
																		// belongs
	private int mChunksFallingHighestRow_atLastVolatileAlignment; // the highest
																	// "pre-fall"
																	// row among
																	// currently
																	// falling
																	// chunks
	private int mChunksFallingHighestRowChunk_atLastVolatileAlignment; // the
																		// chunk
																		// to
																		// which
																		// the
																		// above
																		// belongs
	private int mChunksFallingLastChunkHandled;

	// Meta-data useful for metamorphoses
	private boolean mMetamorphosisHasLockGlows;
	private boolean mMetamorphosisHasMetamorphosisGlows;
	private boolean mMetamorphosisHasBoxFades;

	// Meta-data useful for pieces, so we don't overlap w/ ghost(s).
	private Path[] mPieceMask_byQPane = new Path[] { path(), path() };

	private static final int BITMAP_FULL = 0;
	private static final int BITMAP_SEPTUPLE_Q0_STABLE = 1;
	private static final int BITMAP_SEPTUPLE_Q0_VOLATILE = 2;
	private static final int BITMAP_SEPTUPLE_Q1_STABLE = 3;
	private static final int BITMAP_SEPTUPLE_Q1_VOLATILE = 4;
	private static final int BITMAP_SEPTUPLE_3D_STABLE = 5;
	private static final int BITMAP_SEPTUPLE_3D_VOLATILE = 6;

	// these indices go into the 'covered' and 'touching' regions
	// for full bitmap.
	private static final int BITMAP_REGION_FULL_STABLE = 0;
	private static final int BITMAP_REGION_FULL_VOLATILE = 1;

	private int BITMAP_REGION_Q0_STABLE;
	private int BITMAP_REGION_Q0_VOLATILE;
	private int BITMAP_REGION_Q1_STABLE;
	private int BITMAP_REGION_Q1_VOLATILE;
	private int BITMAP_REGION_3D_STABLE;
	private int BITMAP_REGION_3D_VOLATILE;

	private static final int INDEX_FIELD_VEIL = 3;

	private static final int INDEX_FIELD_STABLE = 0;

	private static final int INDEX_FIELD_DISPLACEMENT = 1 ;
	
	private static final int INDEX_FIELD_PIECE_FIELD = 0;
	private static final int INDEX_FIELD_PIECE_PIECE = 2;
	private static final int INDEX_FIELD_PIECE_FIRST_GHOST = 3;
	private static final int INDEX_FIELD_PIECE_STABLE_DROP_SHADOWS = 3;
			// the same as FIRST_GHOST

	private static final int INDEX_FIELD_FALLING_FIELD = 0;
	private static final int INDEX_FIELD_FALLING_CHUNKS = 2;
	private static final int INDEX_FIELD_FALLING_WORKING_SPACE = 3;

	private static final int INDEX_FIELD_CLEARING = 0;

	private static final int INDEX_FIELD_METAMORPHOSIS = 0;
	private static final int INDEX_FIELD_METAMORPHOSIS_PRE = 2;

	private static final int INDEX_FIELD_PUSHING = 0;
	private static final int INDEX_FIELD_PUSHING_PRE = 2;
	
	private static final int NUM_INDEX_FIELDS = 8 ;
	private static final int NUM_INDEX_FIELDS_NO_GHOSTS = 4 ;
	
	// CONVENTION: if the last bitmap drawn is Stable, its corner
	// and shadow information should be stored in '1'.

	private static final int INDEX_CORNER_TL = 0;
	private static final int INDEX_CORNER_TR = 1;
	private static final int INDEX_CORNER_BL = 2;
	private static final int INDEX_CORNER_BR = 3;
	private static final int NUM_INDEX_CORNERS = 4;

	// Some static Offsets to prevent in-method allocation
	private Offset o = new Offset();
	private boolean alignmentOffsetSet = false;
	private Offset alignmentOffset = new Offset();
	private Offset drawDisplacementOffset = new Offset();
	private Offset clipDisplacementOffset = new Offset();
	private Offset canvasTranslationOffset = new Offset();
	private Offset canvasAlignmentOffset = new Offset();
	private Offset regionOffset = new Offset(); // used for method calls that
												// lose access to the Canvas.
	private Offset clipOffset = new Offset();
	private Offset tempOffset = new Offset();
	private Offset tempOffset2 = new Offset();

	private BlockDrawerConfigRange tempConfigRange;
	private BlockDrawerConfigRange mConfigRangeStandard; // 0-Cols,
															// 0-displayedRows.
	private BlockDrawerConfigRange mConfigRangeExtended; // extended by
															// 'extraRows' for
															// certain slice
															// types.
	private BlockDrawerConfigRange mConfigRangeDisplaced; // the "displacing"
															// area of the
															// displaced block
															// region.
															// Represents the
															// largest possible
															// visual area.
	private BlockDrawerConfigRange mConfigRangeFull;
	private BlockDrawerConfigRange mConfigRangeVeil;

	// Some static Regions to prevent in-method allocation
	private Region tempRegion = new Region(); // should only be used within
												// contiguous code blocks w/o
												// method calls; assume this can
												// change in an unspecified way
												// within any method call.

	private boolean[][] tempConnected = new boolean[3][3];
	private float[] tempPointsSrc = new float[8];
	private float[] tempPointsDst = new float[8];
	private RectF tempRectF = new RectF();
	private Rect tempRect = new Rect();
	private Rect tempClipRect = new Rect();
	private Rect tempSrcRect = new Rect();
	private Rect tempDstRect = new Rect();
	private Rect mRectOutOfBounds = new Rect(Integer.MAX_VALUE / 2 - 10,
			Integer.MAX_VALUE / 2 - 10, Integer.MAX_VALUE / 2,
			Integer.MAX_VALUE / 2);
    private RectF mRectFOutOfBounds = new RectF(Integer.MAX_VALUE / 2 - 10,
            Integer.MAX_VALUE / 2 - 10, Integer.MAX_VALUE / 2,
            Integer.MAX_VALUE / 2);
	private Paint tempColorPaint = new Paint(); // a color/alpha paint for
												// filling.
	private Paint tempColorFilterPaint = new Paint(); // a white, colorFilter
														// paint for filling and
														// drawing
	private Paint tempGlowColorFilterPaint = new Paint();
	private Paint tempGlowAlphaFilterPaint = new Paint();
	private Paint tempDitherPaint = new Paint();
	private Paint clearPaint = new Paint(); // a PorterDuff Clear paint which is
											// always 0-alpha, 0-color
	private Paint replaceColorPaint = new Paint(); // a PorterDuff Clear paint
													// whose color/alpha you can
													// set freely
	private Paint replacePaint = new Paint(); // Paint for replacing (has white
												// color).
	private Paint maskFirstPaint = new Paint(); // paint for masking one paint
												// with another (ALPHA_8).
												// Assumes the mask is applied
												// FIRST, and the masked content
												// is drawn on top of it.
	private Paint maskLastPaint = new Paint(); // paint for masking one paint to
												// another (ALPHA_8 presumably).
												// Assumes the alpha mask is
												// drawn LAST, on top of the
												// color or image content to be
												// masked.
	private Paint backgroundDrawPaint = new Paint();
	private Paint backgroundBlitPaint = new Paint();
	private Paint blitPaint = new Paint();
	private Paint blitPaintWithAlpha = new Paint();
	private Paint fillPaint = new Paint(); // used for drawing color fills
	private Paint borderPaint = new Paint(); // used for drawing color borderso
	private Paint sidePaint = new Paint(); // for 3d sides
	private Paint edgePaint = new Paint(); // for 3d shape edges
	private Matrix tempMatrix = new Matrix();
	private ArrayList<short[][]> tempGlowSets;
	private ArrayList<Integer> tempGlowQOs;
	private byte[][] tempTLCorner;
	private byte[][] tempTRCorner;
	private byte[][] tempBLCorner;
	private byte[][] tempBRCorner;
	private int[][] glowCandidates;
	private int[][][] qGlowCandidates;
	private byte[][][] tempBlockfield;
	private short[][] mShadowSets;
	private short[][] mGlowSets;
	private int[] glowCandidateChunk;
	private boolean[][] tempFlood;
	private LooselyBoundedArray tempFloodLBA;
	private boolean[][] tempFlood2;
	private IntStack tempStackR;
	private IntStack tempStackC;

	// Some static Paths to prevent in-method allocation
    private Path clipPath = path();
	private Path tempPath = path();
    private Path tempHashingMask = path();
    private Path qoBorderPath = path();

	private Matrix canvasMatrix = new Matrix();
	private float[] zeroZero = new float[] { 0.0f, 0.0f };
	private float[] zeroZeroDst = new float[2];

	// //////////////////////////////////////////////////////////////////////////
	// PROFILING
	private static final int INDEX_PROFILE_SLICE_NOT_BEHAVIOR = 0;
	private static final int INDEX_PROFILE_SLICE_PIECE_BEHAVIOR_FIELD_CHANGED = 1;
	private static final int INDEX_PROFILE_SLICE_PIECE_BEHAVIOR_PIECE_CHANGED = 2;
	private static final int INDEX_PROFILE_SLICE_PIECE_BEHAVIOR_NOTHING_CHANGED = 3;
	private static final int INDEX_PROFILE_SLICE_PIECE_BEHAVIOR_TOTAL = 4;

	private static final int INDEX_PROFILE_SLICE_METAMORPHOSIS_BEHAVIOR_FIELD_CHANGED = 5;
	private static final int INDEX_PROFILE_SLICE_METAMORPHOSIS_BEHAVIOR_GLOW_CHANGED = 6;
	private static final int INDEX_PROFILE_SLICE_METAMORPHOSIS_BEHAVIOR_FIELD_TRANSITION = 7;
	private static final int INDEX_PROFILE_SLICE_METAMORPHOSIS_BEHAVIOR_GLOW_ANIMATING = 8;
	private static final int INDEX_PROFILE_SLICE_METAMORPHOSIS_BEHAVIOR_TOTAL = 9;

	private static final int INDEX_PROFILE_SLICE_RISING_BEHAVIOR_FIELD_CHANGED = 10;
	private static final int INDEX_PROFILE_SLICE_RISING_BEHAVIOR_GLOW_ANIMATING = 11;
	private static final int INDEX_PROFILE_SLICE_RISING_BEHAVIOR_TOTAL = 12;

	private static final int INDEX_PROFILE_SLICE_CLEARING_BEHAVIOR_FIELD_CHANGED = 13;
	private static final int INDEX_PROFILE_SLICE_CLEARING_BEHAVIOR_EMPHASIZING_ROWS = 14;
	private static final int INDEX_PROFILE_SLICE_CLEARING_BEHAVIOR_FIELD_TRANSITION = 15;
	private static final int INDEX_PROFILE_SLICE_CLEARING_BEHAVIOR_GLOWING_ROWS = 16;
	private static final int INDEX_PROFILE_SLICE_CLEARING_BEHAVIOR_TOTAL = 17;

	private static final int INDEX_PROFILE_SLICE_FALLING_BEHAVIOR_FIELD_CHANGED = 18;
	private static final int INDEX_PROFILE_SLICE_FALLING_BEHAVIOR_UNLOCKING = 19;
	private static final int INDEX_PROFILE_SLICE_FALLING_BEHAVIOR_CHUNK_TRANSITION = 20;
	private static final int INDEX_PROFILE_SLICE_FALLING_BEHAVIOR_CHUNK_FALLING = 21;
	private static final int INDEX_PROFILE_SLICE_FALLING_BEHAVIOR_TOTAL = 22;

	private static final int INDEX_PROFILE_SLICE_STABLE_BEHAVIOR_FIELD_CHANGED = 23;
	private static final int INDEX_PROFILE_SLICE_STABLE_BEHAVIOR_NOTHING_CHANGED = 24;
	private static final int INDEX_PROFILE_SLICE_STABLE_BEHAVIOR_TOTAL = 25;

	private static final int NUM_INDEX_PROFILE_SLICES = 26;

	private static final int INDEX_PROFILE_SLICE_ACTION_CHECK_EQUALITY = 0;
	private static final int INDEX_PROFILE_SLICE_ACTION_SET_SHADOWS_AND_CORNERS = 1;
	private static final int INDEX_PROFILE_SLICE_ACTION_SET_EFFECTS = 2;
	private static final int INDEX_PROFILE_SLICE_ACTION_CLIP = 3;
	private static final int INDEX_PROFILE_SLICE_ACTION_DRAW = 4;
	private static final int INDEX_PROFILE_SLICE_ACTION_BLIT = 5;
	private static final int INDEX_PROFILE_SLICE_ACTION_DRAW_FILL = 6;
	private static final int INDEX_PROFILE_SLICE_ACTION_DRAW_TOP = 7;
	private static final int INDEX_PROFILE_SLICE_ACTION_DRAW_SHADOW = 8;
	private static final int INDEX_PROFILE_SLICE_ACTION_DRAW_DROP_SHADOW = 9;
	private static final int INDEX_PROFILE_SLICE_ACTION_DRAW_BORDER = 10;
	private static final int INDEX_PROFILE_SLICE_ACTION_DRAW_BORDER_SHINE = 11;
	private static final int INDEX_PROFILE_SLICE_ACTION_DRAW_GLOW = 12;
	private static final int INDEX_PROFILE_SLICE_ACTION_DRAW_3D = 13;
	private static final int INDEX_PROFILE_SLICE_ACTION_DRAW_BORDER_DRAWABLE_METHODS = 14;
	private static final int INDEX_PROFILE_SLICE_ACTION_TOTAL = 15;
	private static final int INDEX_PROFILE_SLICE_ACTION_NUMBER = 16;

	private static final int NUM_INDEX_PROFILE_SLICE_ACTIONS = 17;

	private long[][] mProfileMillisSpent = new long[NUM_INDEX_PROFILE_SLICES][NUM_INDEX_PROFILE_SLICE_ACTIONS];
	private int mProfileBehavior;
	private long[] mTickTime = new long[10];
	private int mTickIndex = -1;
	private int mSlicesDrawn = 0;

	private void tick() {
		if (GlobalTestSettings.BLOCK_DRAWER_LOG_PROFILING) {
			mTickIndex++;
			mTickTime[mTickIndex] = System.currentTimeMillis();
		}
	}

	private long tock() {
		return GlobalTestSettings.BLOCK_DRAWER_LOG_PROFILING ? System
				.currentTimeMillis() - mTickTime[mTickIndex--] : 0;
	}

	// TESTING THE EFFICIENCY OF VARIOUS PROGRAM PARTS
	// //////////////////////////////////////////////////////////////////////////

	// Advancing animations! We animate based on a 'milliseconds spent
	// animating'
	// value passed in by callers. The caller has complete control over this
	// value,
	// and we draw based on it. We might, however, REQUEST a specific amount of
	// advancement.
	// For example, when veiled, we might request no advancement at all
	// (ADVANCE_ANIMATION_ZERO).
	// If we just spent a tick setting up an animation (which we expect takes
	// more time than
	// any of the subsequent draw passes) we request ONE millisecond advance.
	// Otherwise,
	// we request ANY.
	public static final int ADVANCE_ANIMATION_ZERO = 0; // advance by 0 millis
														// since last draw
	public static final int ADVANCE_ANIMATION_ONE = 1; // advance by 1 milli
														// since last.
	public static final int ADVANCE_ANIMATION_ANY = 2; // we leave it to the
														// caller.

	public static BlockDrawer newSelfAllocatingBlockDrawer(Context context,
			DrawSettings ds, AnimationSettings as) {
		return new BlockDrawer(context, ds, as);
	}

	public static BlockDrawer newPreAllocatedBlockDrawer(Context context,
			DrawSettings ds, AnimationSettings as) {
		BlockDrawer bd = new BlockDrawer(context, null, as);
		bd.mHasPreallocatedBitmaps = true;
		bd.setDrawSettingsAndPrerender(context, ds);
		return bd;
	}

    // Previous versions heavily relied on the Android Canvas' Region ops to clip and unclip
    // draw areas; the Regions were often constructed as Unions, Intersections, Differences etc.
    // of many different squares. This Canvas function has been deprecated since it allows clips
    // to be extended beyond what the parent View prefers (irrelevant in our case). Instead, use
    // Paths to clip; this produces some odd visual artifacts. For example, adding a rectangle
    // with addRect will produce an empty overlapping region under EVEN_ODD paths, so instead
    // create a new Path and UNION the two. (if WINDING is used to handle the first case, this
    // will instead produce overzealous clipping for empty areas fully contained within another
    // clipped region, such as a hole in a solid wall of blocks).
	
	private static Path path() {
	    return path(Path.FillType.EVEN_ODD);
    }

    private static Path[] paths(int count) {
	    Path[] arr = new Path[count];
	    for (int i = 0; i < count; i++) {
	        arr[i] = path();
        }
	    return arr;
    }
	
	private static Path path(Path.FillType fillType) {
	    Path p = new Path();
	    p.setFillType(fillType);
	    return p;
    }

    private static void reset(Path path) {
	    path.reset();
	    path.setFillType(Path.FillType.EVEN_ODD);
    }

    private static void reset(Path[] paths) {
        for (int i = 0; i < paths.length; i++) {
            reset(paths[i]);
        }
    }

    private static void op(Path pathMain, Path pathSub, Path.Op op) {
	    pathMain.op(pathSub, op);
	    pathMain.setFillType(Path.FillType.EVEN_ODD);
    }

    private static void op(Path pathMain, Path pathA, Path pathB, Path.Op op) {
        pathMain.op(pathA, pathB, op);
        pathMain.setFillType(Path.FillType.EVEN_ODD);
    }

    private final Path tempUnionRectPath = path();

    private void unionRect(Path path, RectF rect, Path.Direction direction) {
        tempUnionRectPath.addRect(rect, direction);
	    op(path, tempUnionRectPath, Path.Op.UNION);
        reset(tempUnionRectPath);
    }

    private void unionRect(Path path, float left, float top, float right, float bottom, Path.Direction dir) {
        tempUnionRectPath.addRect(left, top, right, bottom, dir);
        op(path, tempUnionRectPath, Path.Op.UNION);
        reset(tempUnionRectPath);
    }

	public BlockDrawer(Context context, DrawSettings ds, AnimationSettings as) {
		if (GlobalTestSettings.BLOCK_DRAWER_LOG_PROFILING)
			log("new BlockDrawer: profiling is ON");
		else
			log("new BlockDrawer: profiling is off");
		visible = true;

		if (context != null)
			mwrContext = new WeakReference<Context>(context);

		tempColorFilterPaint.setAntiAlias(true);
		tempColorFilterPaint.setDither(false);

		clearPaint.setColor(0x00000000);
		clearPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR));

		replaceColorPaint.setColor(0xffffffff);
		replaceColorPaint.setXfermode(new PorterDuffXfermode(
				PorterDuff.Mode.SRC));

		replacePaint.setColor(0xffffffff);
		replacePaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC));

		maskFirstPaint.setXfermode(new PorterDuffXfermode(
				PorterDuff.Mode.SRC_IN));
		maskLastPaint
				.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));

		sidePaint.setAntiAlias(true);
		edgePaint.setAntiAlias(true);

		// multiple dithers causes a weird display bug: auras where shadow
		// becomes 0 alpha.
		// tempDitherPaint.setAntiAlias(true) ;
		// tempDitherPaint.setDither(true) ;

		if (ds == null)
			mDrawSettings = null;
		else
			setDrawSettingsAndPrerender(context, ds);

		animationSettings = as;
	}

	public void setAnimationSettings(AnimationSettings as) {
		animationSettings = as;
	}

	public boolean hasDrawSettings() {
		return mDrawSettings != null;
	}

	/**
	 * Takes a copy of the provided DrawSettings object and prerenders any
	 * structures needed to render using those settings. This method may take a
	 * while (certainly faster than responsive UI speed) so it may be to your
	 * advantage to perform the call within some kind of asynchronous operation.
	 * 
	 * @param ds
	 */
	synchronized public void setDrawSettingsAndPrerender(Context context,
			DrawSettings ds) {
		if (ds == null)
			log("prerendering with null mDrawSettings");
		else
			log("prerendering with detail " + ds.drawDetail
					+ ", animation " + ds.drawAnimations + " blit " + ds.getBlit()
					+ " having block size " + ds.size_blockWidth + ", "
					+ ds.size_blockHeight);

		if (context != null)
			mwrContext = new WeakReference<Context>(context);

		if (mHasPreallocatedBitmaps) {
			setDrawSettingsAndPrerenderHelper(context, ds, null,
					mPreallocatedBitmaps);
		} else {
			BlockDrawerPreallocatedBitmaps preallocated = null;

			if (ds != null) {
				Bitmap[] blitBitmaps = BlockDrawer.preallocateBlitBitmaps(
						ds.configCanvas.region.width(),
						ds.configCanvas.region.height(), ds.getBlit(), ds.getScale(),
                        1.0f, ds.drawAnimations);

				log("setDrawSettingsAndPrerender: region is " + ds.configCanvas.region
						+ " blit is " + ds.getBlit() + " backgroundSize is " + ds.loadBackgroundSize) ;
				Bitmap[] backgroundBitmaps = BlockDrawer
						.preallocateBackgroundBitmaps(1,
								ds.configCanvas.region.width(),
								ds.configCanvas.region.height(), ds.getBlit(), ds.getScale(),
								ds.loadBackgroundSize);

				Bitmap[] sheetBitmaps = BlockDrawer.preallocateSheetBitmaps(
						ds.size_blockWidth, ds.size_blockHeight,
						ds.drawDetail);

				preallocated = new BlockDrawerPreallocatedBitmaps(
						ds.size_blockWidth, ds.size_blockHeight);
				preallocated.setBlitBitmaps(blitBitmaps);
				preallocated.setBackgroundBitmaps(backgroundBitmaps);
				preallocated.setSheetBitmaps(sheetBitmaps);
			}

			setDrawSettingsAndPrerenderHelper(context, ds, null, preallocated);
		}
	}

	/**
	 * The standard 'setDrawSettingsAndPrerender' method will use the
	 * mDrawSettings to prerender all necessary Bitmaps at the appropriate size.
	 * For example, an inner shadow bitmap sheet will be rendered according to
	 * the draw settings proportions and the block size.
	 * 
	 * This produces an unnecessary memory overhead for (e.g.) GameView, which
	 * renders three different high-detail draw areas (Game, Next Piece, Reserve
	 * Piece) each with its own shadow bitmaps.
	 * 
	 * Instead, we set the next piece and reserve piece as "Slaves" to the main
	 * blockDrawer. This means that, wherever feasible, those block drawers will
	 * use th prerendered bitmaps referenced in the master rather than their own
	 * rendering. This introduces two potential weaknesses: 1. If the master is
	 * recycled or a new mDrawSettings object provided, the slaves will silently
	 * lose their bitmaps and throw an exception at the next draw which uses
	 * them. This is mitigated by careful notation of master/slave
	 * relationships. Conversely, recycling a slave can (at present) mess up the
	 * master. TODO: fix this? 2. Draws will be slower if (as is quite likely)
	 * the master uses a different block size than the slaves. This is mitigated
	 * by only using 'slave' blockDrawers for low-impact draws such as a
	 * stationary "next piece."
	 * 
	 * @param context
	 * @param ds
	 * @param master
	 */
	synchronized public void setDrawSettingsAndPrerenderAsSlave(
			Context context, DrawSettings ds, BlockDrawer master) {
		if (master == null)
			throw new NullPointerException(
					"I will not be a slave to a nonexistent master.  HITCHSLAPPED!");

		if (context != null)
			mwrContext = new WeakReference<Context>(context);

		if (ds == null)
			log("prerendering with null mDrawSettings");
		else
			log("prerendering as slave with detail " + ds.drawDetail
					+ ", animation " + ds.drawAnimations + " blit " + ds.getBlit()
					+ " having block size " + ds.size_blockWidth + ", "
					+ ds.size_blockHeight);

		if (mHasPreallocatedBitmaps)
			setDrawSettingsAndPrerenderHelper(context, ds, master,
					mPreallocatedBitmaps);
		else {
			BlockDrawerPreallocatedBitmaps preallocated = null;
			if (ds != null) {
				Bitmap[] blitBitmaps = BlockDrawer.preallocateBlitBitmaps(
						ds.configCanvas.region.width(),
						ds.configCanvas.region.height(), ds.getBlit(), ds.getScale(),
                        1.0f, ds.drawAnimations);

				preallocated = new BlockDrawerPreallocatedBitmaps(
						ds.size_blockWidth, ds.size_blockHeight);
				preallocated.setBlitBitmaps(blitBitmaps);
			}
			setDrawSettingsAndPrerenderHelper(context, ds, master, preallocated);
		}
	}

	private void setDrawSettingsAndPrerenderHelper(Context context,
			DrawSettings ds, BlockDrawer master,
			BlockDrawerPreallocatedBitmaps preallocated) {
		// TODO: We don't want to have to regenerate our prerendered stuff
		// if the DrawSettings didn't significantly change. So... don't?

		if (ds != null)
			mDrawSettings = new DrawSettings(ds);
		else if (master != null)
			throw new IllegalArgumentException(
					"Cannot become slave without a DrawSettings object");
		else {
			mDrawSettings = null;
			mVeilSettings = null;
		}

		recycle();

		recycled = false;

		if (mDrawSettings != null) {
			// TODO: if DrawSettings doesn't match, call reset().
			preallocated.resetForReuse();

			// Make a temp range (we need buffer size for this, which is
			// why we didn't do it at construction).
			tempConfigRange = new BlockDrawerConfigRange(
					ds.blockFieldOuterBuffer, ds.blockFieldOuterBuffer);
			mConfigRangeStandard = new BlockDrawerConfigRange(
					ds.blockFieldOuterBuffer, ds.blockFieldOuterBuffer);
			mConfigRangeStandard.set(ds.displayedRows, ds.COLS);
			mConfigRangeExtended = new BlockDrawerConfigRange(
					mConfigRangeStandard);
			mConfigRangeDisplaced = new BlockDrawerConfigRange(
					mConfigRangeStandard);
			// why not just do the top 5 rows?
			mConfigRangeDisplaced.set(Math.max(0, ds.ROWS - 10), ds.ROWS, 0,
					ds.COLS);
			mConfigRangeFull = new BlockDrawerConfigRange(mConfigRangeStandard);
			mConfigRangeFull.set(0, ds.ROWS, 0, ds.COLS);

			// our blit paint is determined by whether we blit full-size.
			blitPaint = new Paint();
			blitPaint.setFilterBitmap(ds.getScale() > 1);
			blitPaintWithAlpha = new Paint();
			blitPaintWithAlpha.setFilterBitmap(ds.getScale() > 1);

			renderScratchBitmap = preallocated.getBlockSizeBitmap(
					"renderScratch", mDrawSettings.size_blockWidth,
					mDrawSettings.size_blockHeight,
					Bitmap.Config.ARGB_8888);
			if (renderScratchBitmap == null) {
				if ( GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP )
					log("Allocate Bitmap: create render scratch");
				renderScratchBitmap = Bitmap.createBitmap(
						mDrawSettings.size_blockWidth,
						mDrawSettings.size_blockHeight,
						Bitmap.Config.ARGB_8888);
			}
			renderScratchColorFilteredBitmap = preallocated.getBlockSizeBitmap(
					"renderScratchColorFiltered",
					mDrawSettings.size_blockWidth,
					mDrawSettings.size_blockHeight,
					Bitmap.Config.ARGB_8888);
			if (renderScratchColorFilteredBitmap == null) {
				log( 
						"Allocate Bitmap: create render scratch color filtered");
				renderScratchColorFilteredBitmap = Bitmap.createBitmap(
						mDrawSettings.size_blockWidth,
						mDrawSettings.size_blockHeight,
						Bitmap.Config.ARGB_8888);
			}
			if ( renderScratchBitmap != null ) {
				renderScratchCanvas = new Canvas(renderScratchBitmap);
			} else {
				renderScratchCanvas = null ;
			}
			if ( renderScratchColorFilteredBitmap != null ) {
				renderScratchColorFilteredCanvas = new Canvas(
						renderScratchColorFilteredBitmap);
			} else {
				renderScratchColorFilteredCanvas = null ;
			}
			renderScratchBounds = new Rect(0, 0,
					mDrawSettings.size_blockWidth,
					mDrawSettings.size_blockHeight);
			// For draw efficiency - a bitmap of the last thing we drew.
			// Unfortunately we
			// can't rely on the canvas to be unchanged, so...
			mLastBitmapIsStableSlice = false;
			mLastBitmapIsStableSliceIgnoringEffects = false;
			mLastBitmapStableField = DrawStableFieldType.STABLE ;
			mNextSliceBreaksSequence = true ;
			mNextSlicePossiblyInconsistent = true ;
			mNextSliceDisplacementRowsChanged = true ;
			if (mDrawSettings.getBlit() == DrawSettings.BLIT_FULL) {
				if (mDrawSettings.drawAnimations >= DrawSettings.DRAW_ANIMATIONS_STABLE_STUTTER) {
					mLastBitmap = new Bitmap[1];
					mLastBitmap[BITMAP_FULL] = preallocated.getBlitBitmaps()[BITMAP_FULL];
					mLastBitmapBounds = new Rect[1];
					mLastBitmapBounds[BITMAP_FULL] = new Rect(0, 0,
							mDrawSettings.width, mDrawSettings.height * 2);
					mBackgroundBitmapOffset = new Offset(0,
							mDrawSettings.height);
				} else {
					mLastBitmap = new Bitmap[1];
					mLastBitmap[BITMAP_FULL] = preallocated.getBlitBitmaps()[BITMAP_FULL];
					mLastBitmapBounds = new Rect[1];
					mLastBitmapBounds[BITMAP_FULL] = new Rect(0, 0,
							mDrawSettings.width, mDrawSettings.height);
					mBackgroundBitmapOffset = new Offset(0, 0);
				}
				mLastBitmapCanvas = new Canvas[1];
				mLastBitmapCanvas[BITMAP_FULL] = new Canvas(
						mLastBitmap[BITMAP_FULL]);
				mLastBitmapBlitRect = new Rect[1];
				mLastBitmapBlitRect[BITMAP_FULL] = new Rect();
				mLastBitmapClipPath = paths(1);

				mLastBitmapCoveredPath = paths(2);
				mLastBitmapTouchedPath = paths(2);

				BITMAP_REGION_Q0_STABLE = BITMAP_REGION_FULL_STABLE;
				BITMAP_REGION_Q1_STABLE = BITMAP_REGION_FULL_STABLE;
				BITMAP_REGION_3D_STABLE = BITMAP_REGION_FULL_STABLE;

				BITMAP_REGION_Q0_VOLATILE = BITMAP_REGION_FULL_VOLATILE;
				BITMAP_REGION_Q1_VOLATILE = BITMAP_REGION_FULL_VOLATILE;
				BITMAP_REGION_3D_VOLATILE = BITMAP_REGION_FULL_VOLATILE;
			} else if (mDrawSettings.getBlit() == DrawSettings.BLIT_SEPTUPLE) {
				// assume animations; there is no other reason for quadruple
				// blit.
				mLastBitmap = new Bitmap[7];
				mLastBitmapCanvas = new Canvas[7];
				mLastBitmapBlitRect = new Rect[7];
				mLastBitmapClipPath = paths(7);
				mLastBitmapCoveredPath = paths(7);
				mLastBitmapTouchedPath = paths(7);
				int width = mDrawSettings.width;
				int height = mDrawSettings.height;

				// Alpha channel is needed for every layer EXCEPT the full
				// layer.
				// Volatile bitmaps are slightly taller, to allow vertical
				// translation
				// w/o losing drop shadow information at the top and bottom
				// edge.
				for (int i = 0; i < 7; i++)
					mLastBitmap[i] = preallocated.getBlitBitmaps()[i];

				int extraBlocksVertFit = (mLastBitmap[BITMAP_FULL].getHeight() - height)
						/ mDrawSettings.size_blockHeight;
				int totalHeight = mDrawSettings.getBehaviorIs_displacement() ? height
						+ extraBlocksVertFit
						* mDrawSettings.size_blockHeight
						: height;

				mLastBitmapBounds = new Rect[7];
				mLastBitmapBounds[BITMAP_FULL] = new Rect(0, 0, width,
						totalHeight);
				mLastBitmapBounds[BITMAP_SEPTUPLE_Q0_STABLE] = new Rect(0, 0,
						width, totalHeight);
				mLastBitmapBounds[BITMAP_SEPTUPLE_Q1_STABLE] = new Rect(0, 0,
						width, totalHeight);
				mLastBitmapBounds[BITMAP_SEPTUPLE_3D_STABLE] = new Rect(0, 0,
						width, totalHeight);
				mLastBitmapBounds[BITMAP_SEPTUPLE_Q0_VOLATILE] = new Rect(0, 0,
						width, totalHeight);
				mLastBitmapBounds[BITMAP_SEPTUPLE_Q1_VOLATILE] = new Rect(0, 0,
						width, totalHeight);
				mLastBitmapBounds[BITMAP_SEPTUPLE_3D_VOLATILE] = new Rect(0, 0,
						width, totalHeight);
				for (int i = 0; i < 7; i++) {
					mLastBitmapCanvas[i] = new Canvas(mLastBitmap[i]);
					mLastBitmapBlitRect[i] = new Rect();
				}
				mBackgroundBitmapOffset = new Offset(0, 0);

				BITMAP_REGION_Q0_STABLE = BITMAP_SEPTUPLE_Q0_STABLE;
				BITMAP_REGION_Q0_VOLATILE = BITMAP_SEPTUPLE_Q0_VOLATILE;
				BITMAP_REGION_Q1_STABLE = BITMAP_SEPTUPLE_Q1_STABLE;
				BITMAP_REGION_Q1_VOLATILE = BITMAP_SEPTUPLE_Q1_VOLATILE;
				BITMAP_REGION_3D_STABLE = BITMAP_SEPTUPLE_3D_STABLE;
				BITMAP_REGION_3D_VOLATILE = BITMAP_SEPTUPLE_3D_VOLATILE;
			} else {
				// blit = NONE
				mBackgroundBitmapOffset = new Offset(
						mDrawSettings.configCanvas.region.left,
						mDrawSettings.configCanvas.region.top);

				mLastBitmapCoveredPath = paths(2);
				mLastBitmapTouchedPath = paths(2);

				BITMAP_REGION_Q0_STABLE = BITMAP_REGION_FULL_STABLE;
				BITMAP_REGION_Q0_VOLATILE = BITMAP_REGION_FULL_VOLATILE;
				BITMAP_REGION_Q1_STABLE = BITMAP_REGION_FULL_STABLE;
				BITMAP_REGION_Q1_VOLATILE = BITMAP_REGION_FULL_VOLATILE;
				BITMAP_REGION_3D_STABLE = BITMAP_REGION_FULL_STABLE;
				BITMAP_REGION_3D_VOLATILE = BITMAP_REGION_FULL_VOLATILE;
			}

			// clear canvases!
			if (mLastBitmapCanvas != null) {
				for (int i = 0; i < mLastBitmapCanvas.length; i++) {
					if (mLastBitmapCanvas[i] != null)
						mLastBitmapCanvas[i].drawPaint(clearPaint);
				}
			}

			// A strange bug is causing bizarre behavior for clipRegion( ...,
			// Region.Op.DIFFERENCE ).
			// This clip is subtracting not just the region itself, but all
			// pixels below its bounds.
			// However, this only seems to occur for the first falling block:
			// best guess is that
			// this is caused by "un-stretched" regions that have never seen
			// content below
			// that line. The below stretches the region out.

			mLastSlice = new GameBlocksSlice(mDrawSettings.ROWS,
					mDrawSettings.COLS, mDrawSettings.ROWS,
					mDrawSettings.blockFieldOuterBuffer);
			mLastSliceTime = new BlockDrawerSliceTime();
			mLastFillShadowSets_byField_byPane = new ArrayList<short[][][]>(NUM_INDEX_FIELDS_NO_GHOSTS);
			mLastCorners_byField_byPaneCorner = new ArrayList<byte[][][][]>(NUM_INDEX_FIELDS);

			mLastQOConnectedSets_byField_byPane = new ArrayList<short[][][]>(NUM_INDEX_FIELDS);
			mLastQOConnectedCorners_byField_byPaneCorner = new ArrayList<byte[][][][]>(NUM_INDEX_FIELDS);
			for (int i = 0; i < NUM_INDEX_FIELDS; i++) {
				if (i < NUM_INDEX_FIELDS_NO_GHOSTS) {
					mLastFillShadowSets_byField_byPane
							.add(new short[2][mDrawSettings.ROWS
									+ mDrawSettings.blockFieldOuterBuffer * 2][mDrawSettings.COLS
									+ mDrawSettings.blockFieldOuterBuffer * 2]);
				}
				mLastCorners_byField_byPaneCorner
						.add(new byte[2][NUM_INDEX_CORNERS][mDrawSettings.ROWS
								+ mDrawSettings.blockFieldOuterBuffer * 2][mDrawSettings.COLS
								+ mDrawSettings.blockFieldOuterBuffer * 2]);

				mLastQOConnectedSets_byField_byPane
						.add(new short[2][mDrawSettings.ROWS
								+ mDrawSettings.blockFieldOuterBuffer * 2][mDrawSettings.COLS
								+ mDrawSettings.blockFieldOuterBuffer * 2]);
				mLastQOConnectedCorners_byField_byPaneCorner
						.add(new byte[2][NUM_INDEX_CORNERS][mDrawSettings.ROWS
								+ mDrawSettings.blockFieldOuterBuffer * 2][mDrawSettings.COLS
								+ mDrawSettings.blockFieldOuterBuffer * 2]);
			}

			mLastDropShadowSets_byField_byPane_byUniqueColor = new ArrayList<short[][][][]>(NUM_INDEX_FIELDS_NO_GHOSTS);
			// count unique colors.
			// count unique colors.
			this.mLastFillShadowSetsColor_byUniqueColor = new int[] { 0xff000000 }; // black
			this.mLastFillShadowSetsUniqueColor_byQOrientation_byPane = new int[QOrientations.NUM][2];
			for (int qp = 0; qp < 2; qp++) {
				for (int i = 0; i < mDrawSettings.qo.length; i++) {
					int qo = mDrawSettings.qo[i];
					int dropColor = mDrawSettings.color_qOrientationQPaneFillShadow[qo][qp];
					int index = -1;
					for (int j = 0; j < mLastFillShadowSetsColor_byUniqueColor.length; j++)
						if (mLastFillShadowSetsColor_byUniqueColor[j] == dropColor)
							index = j;
					if (index < 0) {
						// extend
						int[] ar = new int[mLastFillShadowSetsColor_byUniqueColor.length + 1];
						for (int j = 0; j < mLastFillShadowSetsColor_byUniqueColor.length; j++)
							ar[j] = mLastFillShadowSetsColor_byUniqueColor[j];
						ar[ar.length - 1] = dropColor;
						mLastFillShadowSetsColor_byUniqueColor = ar;
						index = mLastFillShadowSetsColor_byUniqueColor.length - 1;
					}
					mLastFillShadowSetsUniqueColor_byQOrientation_byPane[qo][qp] = index;
				}
			}
			mLastFillShadowSetsColorFilterPaint_byUniqueColor = new Paint[mLastFillShadowSetsColor_byUniqueColor.length];
			for (int i = 0; i < mLastFillShadowSetsColor_byUniqueColor.length; i++) {
				mLastFillShadowSetsColorFilterPaint_byUniqueColor[i] = new Paint();
				mLastFillShadowSetsColorFilterPaint_byUniqueColor[i]
						.setDither(true);
				mLastFillShadowSetsColorFilterPaint_byUniqueColor[i]
						.setColorFilter(new PorterDuffColorFilter(
								mLastFillShadowSetsColor_byUniqueColor[i],
								PorterDuff.Mode.SRC_IN));
			}
			this.mLastDropShadowSetsColor_byUniqueColor = new int[] { 0xff000000 }; // black
			this.mLastDropShadowSetsUniqueColor_byQOrientation_byPane = new int[QOrientations.NUM][2];
			for (int qp = 0; qp < 2; qp++) {
				for (int i = 0; i < mDrawSettings.qo.length; i++) {
					int qo = mDrawSettings.qo[i];
					int dropColor = mDrawSettings.color_qOrientationQPaneDropShadow[qo][qp];
					int index = -1;
					for (int j = 0; j < mLastDropShadowSetsColor_byUniqueColor.length; j++)
						if (mLastDropShadowSetsColor_byUniqueColor[j] == dropColor)
							index = j;
					if (index < 0) {
						// extend
						int[] ar = new int[mLastDropShadowSetsColor_byUniqueColor.length + 1];
						for (int j = 0; j < mLastDropShadowSetsColor_byUniqueColor.length; j++)
							ar[j] = mLastDropShadowSetsColor_byUniqueColor[j];
						ar[ar.length - 1] = dropColor;
						mLastDropShadowSetsColor_byUniqueColor = ar;
						index = mLastDropShadowSetsColor_byUniqueColor.length - 1;
					}
					mLastDropShadowSetsUniqueColor_byQOrientation_byPane[qo][qp] = index;
				}
			}
			mLastDropShadowSetsColorFilterPaint_byUniqueColor = new Paint[mLastDropShadowSetsColor_byUniqueColor.length];
			for (int i = 0; i < mLastDropShadowSetsColor_byUniqueColor.length; i++) {
				mLastDropShadowSetsColorFilterPaint_byUniqueColor[i] = new Paint();
				mLastDropShadowSetsColorFilterPaint_byUniqueColor[i]
						.setDither(true);
				mLastDropShadowSetsColorFilterPaint_byUniqueColor[i]
						.setColorFilter(new PorterDuffColorFilter(
								mLastDropShadowSetsColor_byUniqueColor[i],
								PorterDuff.Mode.SRC_IN));
			}
			for (int i = 0; i < NUM_INDEX_FIELDS_NO_GHOSTS; i++) {
				mLastDropShadowSets_byField_byPane_byUniqueColor
						.add(new short[2][mLastDropShadowSetsColor_byUniqueColor.length][mDrawSettings.ROWS
								+ mDrawSettings.blockFieldOuterBuffer * 2][mDrawSettings.COLS
								+ mDrawSettings.blockFieldOuterBuffer * 2]);
			}

			if (mDrawSettings.drawAnimations != DrawSettings.DRAW_ANIMATIONS_NONE) {
				mLastEffectsGlow = new GlowEffectList(mDrawSettings.ROWS
						+ mDrawSettings.blockFieldOuterBuffer * 2,
						mDrawSettings.COLS
								+ mDrawSettings.blockFieldOuterBuffer * 2);
				mLastEffectsGlow.allocate(8);

				mLastEffectsSound = new SoundEffectList(450); // up to ~1/2
																// second
																// late...?
				mLastEffectsSound.allocate(8);

				mLastEffectsFade = new FadeEffectList(mDrawSettings.ROWS
						+ mDrawSettings.blockFieldOuterBuffer * 2,
						mDrawSettings.COLS
								+ mDrawSettings.blockFieldOuterBuffer * 2);
				mLastEffectsFade.allocate(1);
			}

			// allocate structures that require that we know the number of
			// columns.
			tempGlowSets = new ArrayList<short[][]>();
			tempGlowQOs = new ArrayList<Integer>();

			tempTLCorner = new byte[mDrawSettings.ROWS][mDrawSettings.COLS];
			tempTRCorner = new byte[mDrawSettings.ROWS][mDrawSettings.COLS];
			tempBLCorner = new byte[mDrawSettings.ROWS][mDrawSettings.COLS];
			tempBRCorner = new byte[mDrawSettings.ROWS][mDrawSettings.COLS];

			glowCandidates = new int[mDrawSettings.ROWS][mDrawSettings.COLS];
			qGlowCandidates = new int[2][mDrawSettings.displayedRows][mDrawSettings.COLS];
			tempBlockfield = new byte[2][mDrawSettings.displayedRows
					+ mDrawSettings.blockFieldOuterBuffer * 2][mDrawSettings.COLS
					+ mDrawSettings.blockFieldOuterBuffer * 2];
			glowCandidateChunk = new int[mDrawSettings.displayedRows
					* mDrawSettings.COLS];
			mShadowSets = new short[mDrawSettings.displayedRows
					+ mDrawSettings.blockFieldOuterBuffer * 2][mDrawSettings.COLS
					+ mDrawSettings.blockFieldOuterBuffer * 2];
			mGlowSets = new short[mDrawSettings.displayedRows
					+ mDrawSettings.blockFieldOuterBuffer * 2][mDrawSettings.COLS
					+ mDrawSettings.blockFieldOuterBuffer * 2];
			tempFlood = new boolean[mDrawSettings.displayedRows][mDrawSettings.COLS];
			tempFloodLBA = LooselyBoundedArray
					.newLooselyBoundedArray(tempFlood);
			tempFlood2 = new boolean[mDrawSettings.displayedRows][mDrawSettings.COLS];

			tempStackR = new IntStack(mDrawSettings.displayedRows
					* mDrawSettings.COLS);
			tempStackC = new IntStack(mDrawSettings.displayedRows
					* mDrawSettings.COLS);

			sheetBlockWidth = ds.size_blockWidth;
			sheetBlockHeight = ds.size_blockHeight;
			// set the SheetScaleFactor. We only need this as master, I think.
			if (master == null) {
                // normally we don't need this, as we can have block-sized
                // sheets.
                // unfortunately that's infeasible for low row/col games (i.g.
                // large onscreen block sizes), because we will either need
                // to allocate a huge area to draw the sheet, or our sheet data
                // will extend beyond the provided bitmap.
                if (preallocated.getBlockWidth() < ds.size_blockWidth
                        || preallocated.getBlockHeight() < ds
                        .size_blockHeight) {
                    sheetBlockWidth = preallocated.getBlockWidth();
                    sheetBlockHeight = preallocated.getBlockHeight();
                }
            }


			// Prerender stuff to be prerendered.
			if (!mDrawSettings.draw3D
					&& mDrawSettings.drawDetail >= DrawSettings.DRAW_DETAIL_MID) {
				// static structures which do not imply animation
				generateInnerBorderPaths();
				prerenderInnerBorderFillShadowSheet(context, master,
						preallocated);
				if (mDrawSettings.drawDetail >= DrawSettings.DRAW_DETAIL_MID)
					prerenderInnerBorderDropShadowSheet(context, master,
							preallocated);
				// else
				// generateInnerBorderDropShadowRegions( context ) ;
				// prerenderInnerBorderFillShadow( cache ) ;
				// Make custom border regions, then use them for the custom fill
				// regions.
				generateCustomBorderPaths();
				generateCustomFillRegions();
				prerenderCustomFillShadow(context, preallocated);
				if (mDrawSettings.drawDetail >= DrawSettings.DRAW_DETAIL_MID)
					prerenderCustomDropShadow(context, preallocated);
				else
					generateCustomDropShadowRegions(context);
				generateCustomBitmaps(context, preallocated);
				generateInnerBorderShineDrawables(master);
				prerenderCustomBorderShine(context, preallocated);

				generateInnerBorderDrawables(context, master);

				// inner border bitmaps draw faster than drawables, but take up
				// significant space. Only use these if we plan to animate.
				if (mDrawSettings.drawAnimations > DrawSettings.DRAW_ANIMATIONS_NONE)
					generateInnerBorderBitmaps(context, preallocated);
				prerenderCustomBorder(context, preallocated);

				prerenderRowNegativeOne(preallocated);

				generateHashingDrawable();

				// animation structures
				if (mDrawSettings.drawAnimations != DrawSettings.DRAW_ANIMATIONS_NONE) {
					prerenderGlows(context, preallocated);

					preallocateGlowFilters();
					createGlowColorFilters();
				}

			} else if (mDrawSettings.draw3D
					&& mDrawSettings.drawDetail >= DrawSettings.DRAW_DETAIL_MID) {
				// static structures which do not imply animation
				generateInnerBorderPaths();
				prerenderInnerBorderFillShadowSheet(context, master,
						preallocated);
				if (mDrawSettings.drawDetail >= DrawSettings.DRAW_DETAIL_MID)
					prerenderInnerBorderDropShadowSheet(context, master,
							preallocated);
				// else
				// generateInnerBorderDropShadowRegions( context ) ;
				prerenderInnerBorderExtrudedWallShadow(context, preallocated);
				generateInnerBorderShineDrawables(master);
				// Make custom border regions, then use them for the custom fill
				// regions.
				generateCustomBorderPaths();
				generateCustomFillRegions();
				prerenderCustomFillShadow(context, preallocated);
				if (mDrawSettings.drawDetail >= DrawSettings.DRAW_DETAIL_MID)
					prerenderCustomDropShadow(context, preallocated);
				else
					generateCustomDropShadowRegions(context);
				generateCustomBitmaps(context, preallocated);
				prerenderCustomBorderShine(context, preallocated);
				generateFriendlyBlends(context);

				generateInnerBorderDrawables(context, master);
				if (mDrawSettings.drawAnimations > DrawSettings.DRAW_ANIMATIONS_NONE)
					generateInnerBorderBitmaps(context, preallocated);
				prerenderCustomBorder(context, preallocated);

				prerenderRowNegativeOne(preallocated);

				generateHashingDrawable();

				// animation structures
				if (mDrawSettings.drawAnimations != DrawSettings.DRAW_ANIMATIONS_NONE) {
					prerenderGlows(context, preallocated);

					preallocateGlowFilters();
					createGlowColorFilters();
				}

			} else if (mDrawSettings.drawDetail == DrawSettings.DRAW_DETAIL_LOW) {
				// Make custom border regions, then use them for the custom fill
				// regions.
				generateInnerBorderPaths();
				generateCustomBorderPaths();
				generateCustomFillRegions();
				generateInnerBorderDropShadowRegions(context);
				generateCustomDropShadowRegions(context);

				generateInnerBorderDrawables(context, master);
				prerenderCustomBorder(context, preallocated);

				prerenderRowNegativeOne(preallocated);

				generateHashingDrawable();

				if (mDrawSettings.drawAnimations != DrawSettings.DRAW_ANIMATIONS_NONE) {
					prerenderGlows(context, preallocated);

					createGlowColorFilters();
				}
			}

			// Load the skin!
			mSkinAssets = new ArrayList<SkinAsset>();
			mSkinAssetTimeIntroduced = new ArrayList<Long>();
			SkinAsset.Builder skinAssetBuilder = SkinAssetBuilderFactory
					.getBuilder(context, mDrawSettings.getSkin());
			SkinAsset sa = skinAssetBuilder.buildNow();
			mSkinAssets.add(sa);
			mSkinAssetTimeIntroduced.add(Long.MIN_VALUE);

			// Lastly: load and prep the background.
			mBackgroundAssets = new ArrayList<BackgroundAsset>();
			mBackgroundAssetTimeIntroduced = new ArrayList<Long>();
			mBackroundAssetNumberLastDraw = 0;

			BackgroundAssetBuilderListener listener = new BackgroundAssetBuilderListener(
					sa);
			mBackgroundAssets.add(buildBackgroundAssetNow(context,
					mDrawSettings, sa, mDrawSettings.getBackground(), listener,
					preallocated));
			mBackgroundAssetTimeIntroduced.add(Long.MIN_VALUE);
			// TODO: Baked-in edge shadows should be drawn in the listener.
			// The listener should also handle storage in "preallocated."
			// To do this, we should probably provide (explicitly) a reference
			// to a "SkinAsset" or "ShadowAsset" or whatnot.
			// For now though, this is the only location we make a
			// BackgroundAsset.

			preallocated.setRenderedDrawSettings(mDrawSettings);
		}

		if (ds != null
				&& animationSettings != null
				&& mDrawSettings.drawAnimations > DrawSettings.DRAW_ANIMATIONS_NONE) {
			mVeilSettings = makeVeilSettings(mDrawSettings);
			mConfigRangeVeil = new BlockDrawerConfigRange(
					mVeilSettings.blockFieldOuterBuffer,
					mVeilSettings.blockFieldOuterBuffer);
			mConfigRangeVeil.set(mVeilSettings.displayedRows,
					mVeilSettings.COLS);
			pregenerateVeilSlice(mVeilSettings);
		}
	}

	/**
	 * Returns the next "preloaded" background, if any. Otherwise null.
	 * 
	 * NOTE: don't call this immediately after 'shufflePreload.' We load
	 * background assets in the background; this call requires that they have
	 * been loaded already, and may cause a significant delay.
	 * 
	 * @return
	 */
	public Background getShufflePreloadedBackground() {
		if (mBackgroundAssets.size() < 2)
			return null;

		return mBackgroundAssets.get(1).getBackground();
	}

	/**
	 * Has no immediate effect on what is drawn to screen. Rather, this is a
	 * method which warns the BlockDrawer of an imminent background swap. We
	 * generally would like to call this method well in advance of the actual
	 * shuffle.
	 * 
	 * Current policy: at most 2 backgrounds / skins at a time. Most of the
	 * time, we will draw only 1 background/skin. This method will use the 2nd
	 * background asset slot, preloading content into it. We return whether this
	 * preload was successful (if we are currently transitioning between assets,
	 * we can't preload one, since that exceeds our 2-background limit).
	 * 
	 * Note: because we tend to load assets in the background, you should limit
	 * your calls to this method to one-per-setting. Don't keep calling this
	 * "just to make sure."
	 * 
	 * @param background
	 */
	public boolean shufflePreload(Context context, Skin skin,
			Background background) {
		// Do four things.
		// First, check that we are in a completely incompatible
		// state with this preload. Return 'false' if that's the case.
		// Second, check that we match this preload exactly. Return 'true' if
		// that's the case.
		// Third, check that we need to roll back, and do it if so.
		// Fourth, add this preload and return 'true.'

		// FIRST: Check for completely incompatible state.
		// Incompatible states are: > 2 cached, or we are in the process
		// of transition.
		if (mSkinAssets.size() > 2)
			return false;
		if (mSkinAssets.size() == 2) {
			Long timeIntroduced = mSkinAssetTimeIntroduced.get(1);
			if (timeIntroduced != null && timeIntroduced.longValue() >= 0)
				return false;
		}

		if (mBackgroundAssets.size() > 2)
			return false;
		if (mBackgroundAssets.size() == 2) {
			Long timeIntroduced = mBackgroundAssetTimeIntroduced.get(1);
			if (timeIntroduced != null && timeIntroduced.longValue() >= 0)
				return false;
		}

		// SECOND: Check if we match the preload exactly.
		boolean skinMatch = false, bgMatch = false;
		if (skin == null)
			skinMatch = mSkinAssets.size() == 1;
		else if (mSkinAssets.size() > 1) {
			SkinAsset sa = mSkinAssets.get(1);
			skinMatch = sa.getSkin().equals(skin);
		}
		if (background == null)
			bgMatch = mBackgroundAssets.size() == 1;
		else if (mBackgroundAssets.size() > 1) {
			BackgroundAsset ba = mBackgroundAssets.get(1);
			bgMatch = ba.getBackground().equals(background);
		}

		if (skinMatch && bgMatch)
			return true;

		// THREE: Roll back if present.
		// trim down to 1 in each.
		while (mSkinAssets.size() > 1) {
			mSkinAssets.remove(1);
			mSkinAssetTimeIntroduced.remove(1);
		}
		while (mBackgroundAssets.size() > 1) {
			mBackgroundAssets.remove(1);
			mBackgroundAssetTimeIntroduced.remove(1);
		}

		// FOUR: Add the new one.
		SkinAsset sa = mSkinAssets.get(0);
		if (skin != null) {
			SkinAsset.Builder skinAssetBuilder = SkinAssetBuilderFactory
					.getBuilder(context, skin);
			sa = skinAssetBuilder.build();
			mSkinAssets.add(sa);
			mSkinAssetTimeIntroduced.add(null);
		}

		if (background != null) {
			BackgroundAssetBuilderListener listener = new BackgroundAssetBuilderListener(
					sa);
			mBackgroundAssets.add(buildBackgroundAsset(context, mDrawSettings,
					sa, background, listener, mPreallocatedBitmaps));
			mBackgroundAssetTimeIntroduced.add(null);
			
			//log("shufflePreload: did build background asset") ;
		}
		return true;
	}

	/**
	 * Performs a skin / background shuffle immediately. If you properly
	 * preloaded the shuffle, there shouldn't be much of a delay. If you didn't,
	 * this call will produce a rather large delay.
	 * 
	 * @param context
	 * @param background
	 */
	public boolean shuffleTo(Context context, Skin skin, Background background,
			BlockDrawerSliceTime sliceTime) {
		if (!shufflePreload(context, skin, background)) {
			//log("shuffleTo: failed preload test.");
			// strip down to a single and skin.
			while (mBackgroundAssets.size() > 1) {
				mBackgroundAssets.remove(1);
				mBackgroundAssetTimeIntroduced.remove(1);
			}
			while (mSkinAssets.size() > 1) {
				mSkinAssets.remove(1);
				mSkinAssetTimeIntroduced.remove(1);
			}

			if (!shufflePreload(context, skin, background)) {
				//log( 
				//		"shuffleTo: failed preload after clearing all but 1!");
				return false;
			}
		}

		// we've preloaded. Start it by noting the current time.
		long curTime = animationSettings.shuffle_stopWhenPaused() ? sliceTime
				.getUnpaused() : sliceTime.getTotal();

		//log("shuffleTo: setting introduced time as " + curTime);
		if (skin != null)
			mSkinAssetTimeIntroduced.set(1, Long.valueOf(curTime));
		if (background != null)
			mBackgroundAssetTimeIntroduced.set(1, Long.valueOf(curTime));
		return true;
	}

	/**
	 * Performs an IMMEDIATE set-to transition, without any fancy fade-effects.
	 * If the provided Background (or skin) has already been precached or
	 * loaded, will exploit that fact. Otherwise this method may cause a delay.
	 * 
	 * Note: if the provided skin/background is currently displayed, and no fade
	 * is ongoing, this method has no effect.
	 * 
	 * If the provided skin / background is next in an ongoing or future fade,
	 * it is set to be exactly the current skin / background (short-circuiting
	 * the fade).
	 * 
	 * Otherwise, we load and then switch.
	 * 
	 * NOTE: As a predictable side-effect, this call will cancel any existing or
	 * scheduled background transition, but MIGHT not effect preloading. Call
	 * getShufflePreloadedBackground() to check whether the upcoming background
	 * is preloaded or not, and correct this if needed.
	 * 
	 * @param context
	 * @param skin
	 * @param background
	 * @return
	 */
	public void setToImmediately(Context context, Skin skin,
			Background background) {

		// Do the skin first.

		// Do the background next.
		if (background != null) {
			if (mBackgroundAssets.get(0).getBackground().equals(background)) {
				// current asset is the right one. Cancel any transition.
				if (mBackgroundAssets.size() > 1) {
					// if in a transition, force a full redraw...
					if (this.mBackgroundAssetTimeIntroduced.get(1) != null)
						this.mBackroundAssetNumberLastDraw = 2;
					this.mBackgroundAssetTimeIntroduced.set(1, null);
					// don't 'unload', just de-introduce the next.
				}
			} else if (mBackgroundAssets.size() > 1
					&& mBackgroundAssets.get(1).getBackground()
							.equals(background)) {
				// NEXT asset is the right one. Make it the first asset.
				recycleBackgroundAsset(0);
				mBackgroundAssetTimeIntroduced.set(0, Long.valueOf(0));
				this.mBackroundAssetNumberLastDraw = 2; // force a redraw.
			} else {
				// it's not the first and not the second. Reload from scratch.
				while (mBackgroundAssets.size() > 0) {
					recycleBackgroundAsset(0);
				}

				SkinAsset sa = mSkinAssets.get(0);
				BackgroundAssetBuilderListener listener = new BackgroundAssetBuilderListener(
						sa);
				mBackgroundAssets.add(buildBackgroundAssetNow(context,
						mDrawSettings, sa, background, listener,
						mPreallocatedBitmaps));
				mBackgroundAssetTimeIntroduced.add(null);

				// force a redraw
				this.mBackroundAssetNumberLastDraw = 2;
			}
		}
	}

	public static BlockDrawerPreallocatedBitmaps preallocateBitmaps(
			int maxWidth, int maxHeight, int maxBlockWidth, int maxBlockHeight,
			int blit, int scale, float septBlitStableHeightFactor, int maxDetail,
			int maxAnimation, int loadSize, int bgSize, int numBGs) {

		BlockDrawerPreallocatedBitmaps preallocated = new BlockDrawerPreallocatedBitmaps(
				maxBlockWidth, maxBlockHeight);

		// preallocate blits
		preallocated.setBlitBitmaps(preallocateBlitBitmaps(maxWidth, maxHeight,
				blit, scale, septBlitStableHeightFactor, maxAnimation));

		// preallocate background
		preallocated.setBackgroundBitmaps(preallocateBackgroundBitmaps(numBGs,
				maxWidth, maxHeight, blit, scale, bgSize));

		// preallocate sheets
		preallocated.setSheetBitmaps(preallocateSheetBitmaps(maxBlockWidth,
				maxBlockHeight, maxDetail));

		// preallocate row negative one
		preallocated.setRowNegativeOneBitmaps(preallocateRowNegativeOneBitmaps(
				maxWidth, maxBlockHeight));

		// preallocated unstretchable borders
		preallocated
				.setUnstretchableBorderBitmaps_byDirection(preallocateUnstretchableBorderBitmaps(
						maxBlockWidth, maxBlockHeight, maxDetail));

		// preallocate stretchable borders
		preallocated
				.setStretchableBorderBitmaps_byDirection(preallocateStretchableBorderBitmaps(maxDetail));

		// preallocate block-size images.
		preallocated.setBlockSizeBitmaps(preallocateBlockSizeBitmaps(
				maxBlockWidth, maxBlockHeight, maxDetail));

		// return our preallocated bitmap cache
		return preallocated;

	}

	public static BlockDrawerPreallocatedBitmaps preallocateBitmapsForSlave(
			int maxWidth, int maxHeight, int maxBlockWidth, int maxBlockHeight,
			int blit, int scale, int maxDetail, int maxAnimation, int loadSize, int bgSize) {

		BlockDrawerPreallocatedBitmaps preallocated = new BlockDrawerPreallocatedBitmaps(
				maxBlockWidth, maxBlockHeight);

		// preallocate blits
		preallocated.setBlitBitmaps(preallocateBlitBitmaps(maxWidth, maxHeight,
				blit, scale, 1.0f, maxAnimation));

		// no background...

		// no sheets...

		// no unstretchable borders...

		// no stretchable borders...

		// preallocate block-size images.
		preallocated.setBlockSizeBitmaps(preallocateBlockSizeBitmaps(
				maxBlockWidth, maxBlockHeight, maxDetail));

		// return our preallocated bitmap cache
		return preallocated;
	}

	private static long totalBytes(Bitmap[][] bitmaps) {
		long num = 0;
		for (int i = 0; i < bitmaps.length; i++)
			num += totalBytes(bitmaps[i]);

		return num;
	}

	private static long totalBytes(Bitmap[] bitmaps) {
		long num = 0;
		for (int i = 0; i < bitmaps.length; i++)
			num += totalBytes(bitmaps[i]);

		return num;
	}

	private static long totalBytes(Bitmap b) {
		if (b != null) {
			int bytesPerPixel = 4;
			switch (b.getConfig()) {
			case ALPHA_8:
				bytesPerPixel = 1;
				break;
			case ARGB_4444:
				bytesPerPixel = 2;
				break;
			case ARGB_8888:
				bytesPerPixel = 4;
				break;
			case RGB_565:
				bytesPerPixel = 2;
				break;
			}

			return bytesPerPixel * b.getWidth() * b.getHeight();
		}
		return 0;
	}

	/**
	 * Allocates an array of bitmaps used for blitting. The provided maxWidth,
	 * maxHeight should be used as a guide for the maximum screen dimensions
	 * (draw size).
	 * 
	 * Behavior differs based on 'blit' and 'animation.'
	 * 
	 * BLIT_SEPTUPLE: returns a length-7 array, where some entries are the exact
	 * dimensions provided, and some are slightly taller.
	 * 
	 * BLIT_FULL: return a length-1 array, where the width matches and the
	 * height is determined by animation: double for ALL , exact otherwise.
	 * 
	 * BLIT_NONE: return 'null.'
	 * 
	 * @param maxWidth
	 * @param maxHeight
	 * @param blit
	 * @param animation
	 * @return
	 */
	private static Bitmap[] preallocateBlitBitmaps(int maxWidth, int maxHeight,
			int blit, int scale, float septBitStableHeightFactor, int animation) {

		Bitmap[] b = null;

		int width = (int) Math.ceil(((float)maxWidth) / scale);
        int height = (int) Math.ceil(((float)maxHeight) / scale);

		switch (blit) {
		case DrawSettings.BLIT_SEPTUPLE:
			b = new Bitmap[7];
			b[BITMAP_FULL] = Bitmap.createBitmap(width,
					(int) Math.ceil(height * septBitStableHeightFactor),
					Bitmap.Config.ARGB_8888);
			b[BITMAP_SEPTUPLE_Q0_STABLE] = Bitmap.createBitmap(width,
					(int) Math.ceil(height * septBitStableHeightFactor),
					Bitmap.Config.ARGB_8888);
			b[BITMAP_SEPTUPLE_Q1_STABLE] = Bitmap.createBitmap(width,
					(int) Math.ceil(height * septBitStableHeightFactor),
					Bitmap.Config.ARGB_8888);
			b[BITMAP_SEPTUPLE_3D_STABLE] = Bitmap.createBitmap(width,
					(int) Math.ceil(height * septBitStableHeightFactor),
					Bitmap.Config.ARGB_8888);
			b[BITMAP_SEPTUPLE_Q0_VOLATILE] = Bitmap.createBitmap(width,
					(int) Math.ceil(height * 1.1), Bitmap.Config.ARGB_8888);
			b[BITMAP_SEPTUPLE_Q1_VOLATILE] = Bitmap.createBitmap(width,
					(int) Math.ceil(height * 1.1), Bitmap.Config.ARGB_8888);
			b[BITMAP_SEPTUPLE_3D_VOLATILE] = Bitmap.createBitmap(width,
					(int) Math.ceil(height * 1.1), Bitmap.Config.ARGB_8888);
			if ( GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP )
				log("Allocate Bitmap: " + (totalBytes(b) / 1024.0)
						+ "kB     create septuple blit area @ " + scale);
			break;

		case DrawSettings.BLIT_FULL:
			b = new Bitmap[1];
			if (animation >= DrawSettings.DRAW_ANIMATIONS_STABLE_STUTTER)
				b[0] = Bitmap.createBitmap(width, height * 2,
						Bitmap.Config.ARGB_8888);
			else
				b[0] = Bitmap.createBitmap(width, height,
						Bitmap.Config.ARGB_8888);
			if ( GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP )
				log("Allocate Bitmap: " + (totalBytes(b) / 1024.0)
						+ "kB     create full blit area @ " + scale);
			break;
		}

		return b;
	}

	/**
	 * Preallocates a bitmaps used to store the game background.
	 * 
	 * @param numBitmaps
     * @param maxFieldWidth
     * @param maxFieldHeight
     * @param blit
     * @param bgSize
	 * @return
	 */
	private static Bitmap[] preallocateBackgroundBitmaps(int numBitmaps,
			int maxFieldWidth, int maxFieldHeight, int blit, int scale, int bgSize) {

        maxFieldWidth = (int) Math.ceil(maxFieldWidth / ((float)scale));
        maxFieldHeight = (int) Math.ceil(maxFieldHeight / ((float)scale));

		int w = 0, h = 0; // bounded by bgSize.
		switch (bgSize) {
		case DrawSettings.IMAGES_SIZE_HUGE:
			w = Integer.MAX_VALUE;
			h = Integer.MAX_VALUE;
			// these will be set to min with maxFieldWidth / Height.
			break;
		case DrawSettings.IMAGES_SIZE_LARGE:
			w = 480;
			h = 800;
			break;
		case DrawSettings.IMAGES_SIZE_MID:
			w = 240;
			h = 400;
			break;
		case DrawSettings.IMAGES_SIZE_SMALL:
			w = 120;
			h = 200;
			break;
		}
		
		log("preallocating Background Bitmaps: bgSize " + bgSize + " w, h " + w + ", " + h + " and max field " + maxFieldWidth + ", " + maxFieldHeight) ;

		maxFieldWidth = Math.min(maxFieldWidth, w);
		maxFieldHeight = Math.min(maxFieldHeight, h);

		Bitmap[] b = new Bitmap[numBitmaps];
		for (int i = 0; i < numBitmaps; i++) {
			b[i] = Bitmap.createBitmap(maxFieldWidth, maxFieldHeight,
					Bitmap.Config.RGB_565);
		}
		if ( GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP )
			log("Allocate Bitmap: " + (totalBytes(b) / 1024.0)
				+ "kB     create background bitmaps (*" + numBitmaps + ")");
		return b;
	}

	private static Bitmap[] preallocateSheetBitmaps(int blockWidth,
			int blockHeight, int drawDetail) {

		// We generate 4 sheet bitmaps.  They represent fill shadow, drop shadow,
		// lock glows, and clear glows.
		// using a 16x16 full-size bitmap. If drawDetail does not allow shadows,
		// we return a length-2 array of 'nulls.'

		if (drawDetail <= DrawSettings.DRAW_DETAIL_LOW)
			return new Bitmap[] { null, null };

		Bitmap[] b = new Bitmap[4];
		for (int i = 0; i < b.length; i++)
			b[i] = Bitmap.createBitmap(blockWidth * 16, blockHeight * 16,
					Bitmap.Config.ALPHA_8);
		if ( GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP )
			log("Allocate Bitmap: " + (totalBytes(b) / 1024.0)
					+ "kB     create sheet bitmaps (*4)");

		return b;
	}

	public static Bitmap[] preallocateRowNegativeOneBitmaps(int maxWidth,
			int maxBlockHeight) {

		Bitmap[] b = new Bitmap[2];

		int height = (int) Math.ceil(maxBlockHeight * 0.1);

		for (int i = 0; i < 2; i++)
			b[i] = Bitmap.createBitmap(maxWidth, height,
					Bitmap.Config.ARGB_8888);
		if ( GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP )
			log("Allocate Bitmap: " + (totalBytes(b) / 1024.0)
				+ "kB     create row negative one bitmaps");

		return b;
	}

	public static Bitmap[][] preallocateUnstretchableBorderBitmaps(
			int maxBlockWidth, int maxBlockHeight, int maxDetail) {

		if (maxDetail <= DrawSettings.DRAW_DETAIL_LOW)
			return new Bitmap[][] { new Bitmap[0], new Bitmap[0] };

		int numBorders = 2 * 8 * 7;
		// qpanes * corner_combinations * qorientations

		Bitmap[][] bitmaps = new Bitmap[NUM_SHINE_DIRECTIONS][];
		for (int d = 0; d < NUM_SHINE_DIRECTIONS; d++) {
			bitmaps[d] = new Bitmap[numBorders * NUM_PRERENDERED_BORDER_WIDTHS];
			for (int w = 0; w < NUM_PRERENDERED_BORDER_WIDTHS; w++) {
				int width, height;
				if (d == DIRECTION_RIGHT) {
					width = maxBlockWidth * (w + 1);
					height = (int) Math.ceil(maxBlockHeight / 10.0);
				} else {
					width = (int) Math.ceil(maxBlockWidth / 10.0);
					height = maxBlockHeight * (w + 1);
				}

				for (int b = 0; b < numBorders; b++) {
					bitmaps[d][b + w * numBorders] = Bitmap.createBitmap(width,
							height, Bitmap.Config.ARGB_8888);
				}
			}
		}

		if ( GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP )
			log("Allocate Bitmap: " + (totalBytes(bitmaps) / 1024.0)
				+ "kB     create unstretchable border bitmaps");

		return bitmaps;
	}

	public static Bitmap[][] preallocateStretchableBorderBitmaps(int drawDetail) {

		if (drawDetail <= DrawSettings.DRAW_DETAIL_LOW)
			return new Bitmap[][] { new Bitmap[0], new Bitmap[0] };

		// As with (most) preallocations, we are robust to running out of them.
		// For now, do the absolute MAX. Suppose we represent 2(qpanes) *
		// 13(qorientations).

		int numBorders = 2 * 8 * 13;
		// qpanes * corner_combinations * qorientations
		Bitmap[][] bitmaps = new Bitmap[NUM_SHINE_DIRECTIONS][];
		for (int d = 0; d < NUM_SHINE_DIRECTIONS; d++) {
			bitmaps[d] = new Bitmap[numBorders];
			int width, height;
			if (d == DIRECTION_RIGHT) {
				width = PRERENDERED_STRETCHABLE_BORDER_LENGTH;
				height = 1;
			} else {
				width = 1;
				height = PRERENDERED_STRETCHABLE_BORDER_LENGTH;
			}

			for (int b = 0; b < numBorders; b++) {
				bitmaps[d][b] = Bitmap.createBitmap(width, height,
						Bitmap.Config.ARGB_8888);
			}
		}

		if ( GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP )
			log("Allocate Bitmap: " + (totalBytes(bitmaps) / 1024.0)
				+ "kB    create stretchable border bitmaps");

		return bitmaps;
	}

	public static Bitmap[] preallocateBlockSizeBitmaps(int maxBlockWidth,
			int maxBlockHeight, int maxDetail) {

		if (maxDetail <= DrawSettings.DRAW_DETAIL_LOW)
			return new Bitmap[0];

		// How many? We use block-size bitmaps for many things. For now,
		// set up 6 of them:
		// 4 inset fill shadows,
		// 4 inset drop shadows.

		int numFillShadows = 4;
		int numDropShadows = 4;
		int numColorBlocks = 1; // extruded wall shadow (needs color)
		int numCustomShines = 4; // Flash, U, UL_0, UL_1.
		int numCustomBorders = 6; // F0, F1, U0, U1, UL_0, UL_1.
		int numCustomFills = 1; // Flash.
		int numRenderScratch = 2; // render and color filtered render

		int total = numFillShadows + numDropShadows + numColorBlocks
				+ numCustomShines + numCustomBorders + numCustomFills
				+ numRenderScratch;

		Bitmap[] b = new Bitmap[total];

		int index = 0;
		for (int i = 0; i < numFillShadows; i++)
			b[index++] = Bitmap.createBitmap(maxBlockWidth, maxBlockHeight,
					Bitmap.Config.ALPHA_8);
		for (int i = 0; i < numDropShadows; i++)
			b[index++] = Bitmap.createBitmap(maxBlockWidth, maxBlockHeight,
					Bitmap.Config.ALPHA_8);
		for (int i = 0; i < numColorBlocks; i++)
			b[index++] = Bitmap.createBitmap(maxBlockWidth, maxBlockHeight,
					Bitmap.Config.ARGB_8888);
		for (int i = 0; i < numCustomShines; i++)
			b[index++] = Bitmap.createBitmap(maxBlockWidth, maxBlockHeight,
					Bitmap.Config.ARGB_8888);
		for (int i = 0; i < numCustomBorders; i++)
			b[index++] = Bitmap.createBitmap(maxBlockWidth, maxBlockHeight,
					Bitmap.Config.ARGB_8888);
		for (int i = 0; i < numCustomFills; i++)
			b[index++] = Bitmap.createBitmap(maxBlockWidth, maxBlockHeight,
					Bitmap.Config.ARGB_8888);
		for (int i = 0; i < numRenderScratch; i++)
			b[index++] = Bitmap.createBitmap(maxBlockWidth, maxBlockHeight,
					Bitmap.Config.ARGB_8888);

		if ( GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP )
			log("Allocate Bitmap: " + (totalBytes(b) / 1024.0)
				+ "kB    create block size bitmaps");

		return b;
	}

	public static int bitmapLoadBufferMaxSize(int screenWidth,
			int screenHeight, int blockWidth, int blockHeight, int maxDetail,
			int loadImageSize, int loadBackgroundSize) {

		// We generate a single byte-array large enough to contain any
		// image we might load from our assets. The purpose of this
		// is to perform a single, one-time allocation which is
		// then used for every 'load from file' operation, or at least those
		// which use a large amount of memory. We synchronize all access
		// to this buffer (when it is provided via
		// receivePreallocatedBitmapLoadBuffer).

		// There is a danger here -- because the load buffer must be large
		// enough
		// to contain EVERY possible image load (but only 1 at once), it
		// represents
		// a larger-than-normal memory allocation for most load operations.
		// However,
		// we think this is an acceptable risk. Memory crashes simply do not
		// occur
		// during the first (or second, or even third) game load -- they happen
		// after
		// a great deal of memory fragmentation has occurred, and always during
		// the
		// allocation for an image load. This prevents image-load allocations,
		// and
		// allows only allocations for necessary image space. It is up to
		// each 'load' method to use this buffer responsibly, or not at all.

		// What is the maximum size we can reasonably expect to load?
		long size = 0;

		// the largest non-background images are the shadow sheets. The
		// sizes supported are 20x20, 40x40, 80x80, and in each case we increase
		// this by a factor of 256: 16 by 16. Images are in 32-bit color,
		// meaning
		// we multiply this number (pixels) by 4 to get number of bytes.

		// One final caveat: LOW or MINIMAL detail does not require sheet loads.
		if (maxDetail >= DrawSettings.DRAW_DETAIL_MID) {
			long dimen = nextLargestLoadDimension(blockWidth, blockHeight,
					loadImageSize);
			// this is the length of a side of 1 square of the sheet.
			size = Math.max(size, dimen * dimen * 256 * 4);
			// ( dimen * dimen ) // pixels in a square
			// * 256 // squares in a sheet
			// * 4 // bytes in a pixel
			// = bytes in a sheet
		}

		// Background images are a bit simpler; there are only 3 sizes
		// available (at last count): 120x200, 240x400, 480x800. These
		// may be upscaled later but our load buffer should match one of these.
		int bgW = getBackgroundLoadResolutionWidth(screenWidth, screenHeight,
				loadBackgroundSize);
		int bgH = getBackgroundLoadResolutionHeight(screenWidth, screenHeight,
				loadBackgroundSize);

		if (bgW > 0 && bgH > 0) {
			size = Math.max(size, bgW * bgH * 4);
		}

		// Report int overflow
		if (size != ((int) size))
			return -1;

		return (int) size;
	}

	public void receivePreallocatedBitmaps(
			BlockDrawerPreallocatedBitmaps preallocated) {
		if (!mHasPreallocatedBitmaps)
			throw new IllegalStateException(
					"This block drawer not configured to received preallocated bitmaps");

		recycle();
		this.mPreallocatedBitmaps = preallocated;
	}
	
	public void receiveLoadIntoBitmapSheet( Bitmap loadInto ) {
		mLoadIntoBitmapSheet = loadInto ;
	}
	
	public void receiveLoadIntoBitmapBackground( Bitmap loadInto ) {
		mLoadIntoBitmapBackground = loadInto ;
	}
	
	

	private DrawSettings makeVeilSettings(DrawSettings template) {
		// We use the drawSettings drawRegion as the veil draw region.
		// For now, use the same ROWS and COLS as well (we may want to e.g.
		// enforce a different number of columns for Retro so the blocks don't
		// directly line up).

		Rect region = new Rect(template.configCanvas.region);
		region.right += template.size_blockWidth * template.getScale();
		region.offset(-template.size_blockWidth / 2, 0);
		return template.makeVeil(region, template.ROWS, template.COLS + 1);
	}

	private void pregenerateVeilSlice(DrawSettings veil) {
		// we want a consistent veil, even with trivial destructions
		// / reconstructions of our drawSettings and other structures. We only
		// remake a veil if
		// its rows and columns have changed, or it contains a value
		// which is not valid according to the provided veil.
		boolean newSlice = mVeilSlice == null || mVeilSlice.rows() != veil.ROWS
				|| mVeilSlice.cols() != veil.COLS;
		if (!newSlice) {
			byte[][][] field = mVeilSlice.getBlockfieldStable();
			for (int row = 0; row < veil.ROWS && !newSlice; row++) {
				int r = row + veil.blockFieldOuterBuffer;
				for (int col = 0; col < veil.COLS && !newSlice; col++) {
					int c = col + veil.blockFieldOuterBuffer;
					int qo = field[0][r][c];
					boolean found = qo == veil.veil_qo_main;
					for (int i = 0; i < veil.veil_qo.length && !found; i++)
						found = found || veil.veil_qo[i] == qo;
					newSlice = newSlice || !found;
				}
			}
		}

		if (newSlice) {
			GameBlocksSlice gbs = new GameBlocksSlice(veil.ROWS, veil.COLS, 0,
					veil.blockFieldOuterBuffer);

			// populate in q0. We require that a QOrientation
			// cannot border itself.
			Random random = new Random();
			byte[][][] field = gbs.getBlockfieldStable();
			for (int row = 0; row < veil.ROWS; row++) {
				int r = row + veil.blockFieldOuterBuffer;
				for (int col = 0; col < veil.COLS; col++) {
					int c = col + veil.blockFieldOuterBuffer;

					byte qo = (random.nextBoolean() && veil.veil_qo_main > 0) ? veil.veil_qo_main
							: veil.veil_qo[random.nextInt(veil.veil_qo.length)];

					/*
					 * // barred from using the QO to the left or below. while (
					 * qo == field[0][r-1][c] || qo == field[0][r][c-1] ) qo =
					 * veil.veil_qo[random.nextInt( veil.veil_qo.length )] ;
					 */

					field[0][r][c] = qo;
				}
			}

			// connect! Any piece with a clear majority among its neighbors
			// should become
			// that color.
			/*
			 * int [] count = new int[QOrientations.NUM] ; for ( int row = 0;
			 * row < veil.ROWS; row++ ) { int r = row +
			 * veil.blockFieldOuterBuffer ; for ( int col = 0; col < veil.COLS;
			 * col++ ) { int c = col + veil.blockFieldOuterBuffer ;
			 * 
			 * for ( int i = 0; i < count.length; i++ ) count[i] = 0 ;
			 * 
			 * count[ field[0][r-1][c] ]++ ; count[ field[0][r+1][c] ]++ ;
			 * count[ field[0][r][c-1] ]++ ; count[ field[0][r][c+1] ]++ ;
			 * 
			 * int majorityCount = 0 ; int majorityQO = 0 ;
			 * 
			 * for ( int i = 1; i < count.length; i++ ) { if ( count[i] >
			 * majorityCount + 1 ) { majorityCount = count[i] ; majorityQO = i ;
			 * } else if ( count[i] >= majorityCount -1 ) { majorityQO = -1 ; }
			 * }
			 * 
			 * if ( majorityQO > -1 ) field[0][r][c] = majorityQO ; } }
			 */

			mVeilFillShadows = new short[2][veil.ROWS + 2
					* veil.blockFieldOuterBuffer][veil.COLS + 2
					* veil.blockFieldOuterBuffer];
			mVeilDropShadows = new short[2][mLastDropShadowSetsColor_byUniqueColor.length][veil.ROWS
					+ 2 * veil.blockFieldOuterBuffer][veil.COLS + 2
					* veil.blockFieldOuterBuffer];
			mVeilCorners = new byte[2][4][veil.ROWS + 2
					* veil.blockFieldOuterBuffer][veil.COLS + 2
					* veil.blockFieldOuterBuffer];

			// set
			setShadowsAndCorners(veil, field, mConfigRangeVeil, Consts.QPANE_0,
					mVeilFillShadows, mVeilDropShadows, mVeilCorners);
			mVeilSlice = gbs;
		}
	}

	private void emptyLastBitmapInformation() {
		// For draw efficiency - a bitmap of the last thing we drew.
		// Unfortunately we
		// can't rely on the canvas to be unchanged, so...
		if (mLastBitmap != null && !mHasPreallocatedBitmaps) // ONLY do this if
																// we
																// haven't been
																// provided with
																// preallocated
																// bitmaps!
			for (int i = 0; i < mLastBitmap.length; i++)
				if (mLastBitmap[i] != null && !mLastBitmap[i].isRecycled())
					mLastBitmap[i].recycle();
		mLastBitmap = null;
		mLastBitmapCanvas = null;
		mLastBitmapBlitRect = null;

		mLastSlice = null;
		mLastFillShadowSets_byField_byPane = null;
		mLastDropShadowSets_byField_byPane_byUniqueColor = null;
		mLastCorners_byField_byPaneCorner = null;
		mLastEffectsGlow = null;
		mLastEffectsSound = null;
		mLastEffectsFade = null;
	}

	private void emptyMiddlemen() {
		if (renderScratchBitmap != null
				&& (!mHasPreallocatedBitmaps || !mPreallocatedBitmaps
						.hasBlockSizeBitmap(renderScratchBitmap)))
			renderScratchBitmap.recycle();
		if (renderScratchColorFilteredBitmap != null
				&& (!mHasPreallocatedBitmaps || !mPreallocatedBitmaps
						.hasBlockSizeBitmap(renderScratchColorFilteredBitmap)))
			renderScratchColorFilteredBitmap.recycle();
		renderScratchBitmap = null;
		renderScratchColorFilteredBitmap = null;
		renderScratchCanvas = null;
		renderScratchColorFilteredCanvas = null;
		renderScratchBounds = null;
	}

	private void emptyTempData() {
		tempGlowSets = null;
		tempGlowQOs = null;

		tempTLCorner = null;
		tempTRCorner = null;
		tempBLCorner = null;
		tempBRCorner = null;

		glowCandidates = null;
		qGlowCandidates = null;
		tempBlockfield = null;
		glowCandidateChunk = null;
		mShadowSets = null;
		mGlowSets = null;
		tempFlood = null;
		tempFlood2 = null;

		tempStackR = null;
		tempStackC = null;
	}

	private void emptyPrerenderedArrays() {
		// innerBorderFillShadow_byNeighbors = null ;
		// lockGlow_byGlowIndex_Neighbors = null ; // indexed by neighbor
		// connections.
		// clearGlow_byGlowIndex_Neighbors = null ; // indexed by neighbor
		// connections.
		// lockGlow_byGlowIndex_Neighbors = null ;
		// unlockColumnGlow_byGlowIndex_Neighbors = null ;

		glowSheet_byGlowType_byGlowIndex = null;
		glowSheetBounds_byGlowType_byGlowIndex = null;

		alphaScaleMatrix_byAlphaScaleStepMultiple = null;
		glowColorFilter_byColor = null;

		glowPath_byGlowType_byGlowIndex_byNeighbors = null;

		innerBorderFillShadowSheetBounds = null;
		innerBorderDropShadowSheetBounds = null;
		innerBorderDropShadowPath = null;
		innerBorderDropShadowRects = null;

		if (innerBorderExtrudedWallShadow_bySide != null)
			for (int i = 0; i < innerBorderExtrudedWallShadow_bySide.length; i++)
				if (innerBorderExtrudedWallShadow_bySide[i] != null
						&& !innerBorderExtrudedWallShadow_bySide[i]
								.isRecycled()
						&& (!this.mHasPreallocatedBitmaps || !mPreallocatedBitmaps
								.hasBlockSizeBitmap(innerBorderExtrudedWallShadow_bySide[i])))
					innerBorderExtrudedWallShadow_bySide[i].recycle();
		innerBorderExtrudedWallShadow_bySide = null; // indexed by
														// "wall placement"

		if (customBitmap_byQOrientation != null)
			for (int i = 0; i < customBitmap_byQOrientation.length; i++)
				if (customBitmap_byQOrientation[i] != null
						&& !customBitmap_byQOrientation[i].isRecycled()
						&& (!mHasPreallocatedBitmaps || !mPreallocatedBitmaps
								.hasBlockSizeBitmap(customBitmap_byQOrientation[i])))
					customBitmap_byQOrientation[i].recycle();
		customBitmap_byQOrientation = null;

		customFillPath_byQPane_QOrientation = null; // When the "fill" area is
														// different from the
														// boundaries of the
														// block (normal, inset,
														// or mini) this region,
														// which should be
														// offset from (0,0) to
														// the block position,
														// gives the fill area.
		customBorderPath_byQPane_QOrientation = null; // When the "border"
														// area is different
														// from the boundaries
														// of the block (normal,
														// inset, or mini) this
														// region, which should
														// be translated from
														// (0,0) to the block
														// position, gives the
														// border area.
		customFillShadow_byQPaneQOrientation = null; // When the "fill / border"
														// area are different
														// from the boundaries
														// of the block, it may
														// have a different
														// inner shadow set as
														// well.
		customDropShadow_byQPaneQOrientation = null;
		customDropShadowPath_byQPaneQOrientation = null;
		innerBorderShine_byQPaneQOrientationCornerCornerDirection = null; // indexed
																			// by
																			// "corner-to-corner",
																			// moving
																			// rightward
																			// or
																			// downward.
		customBorderShine_byQPaneQOrientation = null; // Because inset/mini
														// borders are always
														// 1-off squares, we can
														// pregenerate the shine
														// as a bitmap and apply
														// with a color filter
														// for the alpha.
		innerBorder_byQPaneQOrientationCornerCornerDirection = null; // indexed
																		// by
																		// "corner-to-corner",
																		// moving
																		// rightward
																		// or
																		// downward.
		innerBorderColorSubstitute_byQPaneQOrientationCornerCorner = null; // indexed
																			// by
																			// "corner-to-corner",
																			// moving
																			// rightward
																			// or
																			// downward.

		if (innerBorderBitmap_byQPaneQOrientationCornerCornerDirectionWidth != null)
			for (int i = 0; i < innerBorderBitmap_byQPaneQOrientationCornerCornerDirectionWidth.length; i++)
				for (int j = 0; j < innerBorderBitmap_byQPaneQOrientationCornerCornerDirectionWidth[i].length; j++)
					for (int k = 0; innerBorderBitmap_byQPaneQOrientationCornerCornerDirectionWidth[i][j] != null
							&& k < innerBorderBitmap_byQPaneQOrientationCornerCornerDirectionWidth[i][j].length; k++)
						for (int l = 0; innerBorderBitmap_byQPaneQOrientationCornerCornerDirectionWidth[i][j][k] != null
								&& l < innerBorderBitmap_byQPaneQOrientationCornerCornerDirectionWidth[i][j][k].length; l++)
							for (int m = 0; innerBorderBitmap_byQPaneQOrientationCornerCornerDirectionWidth[i][j][k][m] != null
									&& m < innerBorderBitmap_byQPaneQOrientationCornerCornerDirectionWidth[i][j][k][l].length; m++)
								for (int n = 0; innerBorderBitmap_byQPaneQOrientationCornerCornerDirectionWidth[i][j][k][m][n] != null
										&& n < innerBorderBitmap_byQPaneQOrientationCornerCornerDirectionWidth[i][j][k][l][m].length; n++) {
									Bitmap b = innerBorderBitmap_byQPaneQOrientationCornerCornerDirectionWidth[i][j][k][l][m][n];
									if (b != null
											&& !b.isRecycled()
											&& (!mHasPreallocatedBitmaps || !mPreallocatedBitmaps
													.hasUnstretchableBorderBitmap(
															m, b)))
										b.recycle();
								}
		innerBorderBitmap_byQPaneQOrientationCornerCornerDirectionWidth = null;
		innerBorderBitmapBounds_byQPaneQOrientationCornerCornerDirectionWidth = null;

		if (innerBorderStretchableBitmap_byQPaneQOrientationCornerCornerDirection != null)
			for (int i = 0; i < innerBorderStretchableBitmap_byQPaneQOrientationCornerCornerDirection.length; i++)
				for (int j = 0; j < innerBorderStretchableBitmap_byQPaneQOrientationCornerCornerDirection[i].length; j++)
					for (int k = 0; innerBorderStretchableBitmap_byQPaneQOrientationCornerCornerDirection[i][j] != null
							&& k < innerBorderStretchableBitmap_byQPaneQOrientationCornerCornerDirection[i][j].length; k++)
						for (int l = 0; innerBorderStretchableBitmap_byQPaneQOrientationCornerCornerDirection[i][j][k] != null
								&& l < innerBorderStretchableBitmap_byQPaneQOrientationCornerCornerDirection[i][j][k].length; l++)
							for (int m = 0; innerBorderStretchableBitmap_byQPaneQOrientationCornerCornerDirection[i][j][k][m] != null
									&& m < innerBorderStretchableBitmap_byQPaneQOrientationCornerCornerDirection[i][j][k][l].length; m++) {
								Bitmap b = innerBorderStretchableBitmap_byQPaneQOrientationCornerCornerDirection[i][j][k][l][m];
								if (b != null
										&& !b.isRecycled()
										&& (!mHasPreallocatedBitmaps || !mPreallocatedBitmaps
												.hasStretchableBorderBitmap(m,
														b)))
									b.recycle();
							}
		innerBorderStretchableBitmap_byQPaneQOrientationCornerCornerDirection = null;
		innerBorderStretchableBitmapBounds_byQPaneQOrientationCornerCornerDirection = null;

		if (customBorder_byQPaneQOrientation != null)
			for (int i = 0; i < customBorder_byQPaneQOrientation.length; i++)
				for (int j = 0; j < customBorder_byQPaneQOrientation[i].length; j++)
					if (customBorder_byQPaneQOrientation[i][j] != null
							&& !customBorder_byQPaneQOrientation[i][j]
									.isRecycled()
							&& (!mHasPreallocatedBitmaps || !mPreallocatedBitmaps
									.hasBlockSizeBitmap(customBorder_byQPaneQOrientation[i][j])))
						customBorder_byQPaneQOrientation[i][j].recycle();
		customBorder_byQPaneQOrientation = null;
		customBorderBounds_byQPaneQOrientation = null;

		if (rowNegativeOneBorder_byQPane != null)
			for (int i = 0; i < rowNegativeOneBorder_byQPane.length; i++)
				if (rowNegativeOneBorder_byQPane[i] != null
						&& !rowNegativeOneBorder_byQPane[i].isRecycled()
						&& (!mHasPreallocatedBitmaps || !mPreallocatedBitmaps
								.hasRowNegativeOneBitmap(rowNegativeOneBorder_byQPane[i])))
					rowNegativeOneBorder_byQPane[i].recycle();
		rowNegativeOneBorder_byQPane = null;

		friendlyFillBlend_byQPaneQOrientationFromToDirection = null;
		friendlyBorderBlend_byQPaneQOrientationFromToDirection = null;
		friendlyFillBlendSimplified_byQPaneQOrientationFromToDirection = null;
		friendlyBorderBlendSimplified_byQPaneQOrientationFromToDirection = null ;
	}

	synchronized public void recycle() {
		log("recycling block drawer");
		emptyBackgroundAssets();
		emptyLastBitmapInformation();
		emptyMiddlemen();
		emptyTempData();
		emptyPrerenderedArrays();
		System.gc();
		recycled = true;
	}

	synchronized public boolean isRecycled() {
		return recycled;
	}

	private void emptyBackgroundAssets() {
		// Calls to recycle on a background asset are safe;
		// if they use a preallocated Bitmap, it will not be recycled.
		if (mBackgroundAssets != null) {
			Iterator<BackgroundAsset> iter = mBackgroundAssets.iterator();
			for (; iter.hasNext();) {
				BackgroundAsset ba = iter.next();
				if (ba != null && !ba.isRecycled()) {
					ba.recycle();
				}
			}
		}
		mBackgroundAssets = null;
		mBackgroundAssetTimeIntroduced = null;
	}

	private BackgroundAsset buildBackgroundAsset(Context context,
			DrawSettings ds, SkinAsset sa, Background background,
			BackgroundBuilderListener<BackgroundAsset> listener,
			BlockDrawerPreallocatedBitmaps preallocated) {
		return buildBackgroundAsset(context, ds, sa, background, listener,
				preallocated, false);
	}

	private BackgroundAsset buildBackgroundAssetNow(Context context,
			DrawSettings ds, SkinAsset sa, Background background,
			BackgroundBuilderListener<BackgroundAsset> listener,
			BlockDrawerPreallocatedBitmaps preallocated) {
		return buildBackgroundAsset(context, ds, sa, background, listener,
				preallocated, true);
	}

	private BackgroundAsset buildBackgroundAsset(Context context,
			DrawSettings ds, SkinAsset sa, Background background,
			BackgroundBuilderListener<BackgroundAsset> listener,
			BlockDrawerPreallocatedBitmaps preallocated, boolean buildNow) {
		BackgroundAsset.Builder builder = new BackgroundAsset.Builder(context);
		builder.setBackground(background)
				.setBackgroundSize(ds.loadBackgroundSize)
				.setLoadLimits(ds.loadBackgroundSize, Integer.MAX_VALUE,
						Integer.MAX_VALUE).setTarget(ds.configCanvas.region);
		builder.setLoadIntoBitmap(mLoadIntoBitmapBackground, true) ;

		// check if we have a preallocated and prerendered bitmap.
		// TODO: Change preallocated and SkinAsset to perform a check.
		DrawSettings preallocatedDS = preallocated.getRenderedDrawSettings();
		boolean rendered = preallocatedDS != null;
		rendered = rendered && ds.width == preallocatedDS.width;
		rendered = rendered && ds.height == preallocatedDS.height;
		rendered = rendered
				&& ds.configCanvas.region
						.equals(preallocatedDS.configCanvas.region);
		rendered = rendered
				&& dropShadowSheetsAreExactCopies(ds, preallocatedDS);
		rendered = rendered
				&& ds.behavior_background == preallocatedDS.behavior_background;
		rendered = rendered && background.hasImage();
		Bitmap preallocatedBackground = preallocated
				.getBackgroundBitmap(background);
		Rect prerenderedRect = preallocated.getBackgroundBitmapBounds(
				preallocatedBackground, background);

		if (rendered && preallocatedBackground != null
				&& prerenderedRect != null)
			builder.setPrerenderedBitmap(preallocatedBackground,
					prerenderedRect);
		else if (preallocatedBackground != null)
			builder.setPreallocatedBitmap(preallocatedBackground);

		if (buildNow)
			return builder.buildNow(listener);

		return builder.build(listener);
	}

	private void prerenderInnerBorderFillShadowSheet(Context context,
			BlockDrawer master, BlockDrawerPreallocatedBitmaps preallocated) {
		// Inner border fill shadow sheet. Represents shadows cast by inner
		// borders,
		// arranged in a 16 x 16 sheet. (many of these will go unused, but meh).
		// Will be applied to any QOrientation fill that is 1. render in fill
		// (not inset),
		// and 2. rendered with "Inner" borders. Drawn as a black-with-alpha
		// "shadow"
		// that is drawn on top of the actual fill color.

		// first things first: see if we can skip all this based on the master.
		if (master != null && master.innerBorderFillShadowSheet != null
				&& !master.innerBorderFillShadowSheet.isRecycled()) {
			if (sheetsAreScaledCopies(
					this.mDrawSettings.proportion_innerShadowGaussianRadius,
					this.mDrawSettings.proportion_innerShadowXOffset,
					this.mDrawSettings.proportion_innerShadowYOffset,
					this.mDrawSettings.alpha_innerShadow,
					master.mDrawSettings.proportion_innerShadowGaussianRadius,
					master.mDrawSettings.proportion_innerShadowXOffset,
					master.mDrawSettings.proportion_innerShadowYOffset,
					master.mDrawSettings.alpha_innerShadow)) {

				// copy the master's.
				log("taking reference to master's innerBorderFillShadowSheet");
				this.innerBorderFillShadowSheet = master.innerBorderFillShadowSheet;
				this.innerBorderFillShadowSheetBounds = new Rect(
						master.innerBorderFillShadowSheetBounds);
				return;

			} else
				throw new IllegalArgumentException(
						"Master is set, but inner border fill shadow sheets are not scaled copies!");
		}

		// We use "innerBorderFillShadowSheet" as the key, and ignore whether it
		// has previously been named; instead, we explicitly look for an exact
		// drawSettings
		// match.
		innerBorderFillShadowSheet = preallocated
				.getSheetBitmap("innerBorderFillShadowSheet");
		if (innerBorderFillShadowSheet == null) {
			innerBorderFillShadowSheet = Bitmap.createBitmap(
					sheetBlockWidth * 16, sheetBlockHeight * 16,
					Bitmap.Config.ALPHA_8);
			if ( GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP )
				log("Allocate Bitmap: create innerBorderFillShadowSheet");
		}

		innerBorderFillShadowSheetBounds = new Rect(0, 0, sheetBlockWidth * 16,
				sheetBlockHeight * 16);

		DrawSettings preallocatedDS = preallocated.getRenderedDrawSettings();
		if (!fillShadowSheetsAreExactCopies(mDrawSettings, preallocatedDS)) {

			log( 
					"rendering innerBorderFillShadow as preallocated drawSettings is null or does not match");

			// draw two shadows: edge and offset.
			Canvas sheetCanvas = new Canvas(innerBorderFillShadowSheet);
			sheetCanvas.drawPaint(clearPaint);

			try {
				for (int i = 0; i < mDrawSettings.proportion_innerShadowGaussianRadius.length; i++) {
					float radius = mDrawSettings.proportion_innerShadowGaussianRadius[i];
					float offsetX = mDrawSettings.proportion_innerShadowXOffset[i];
					float offsetY = mDrawSettings.proportion_innerShadowYOffset[i];
					float alphaScale = mDrawSettings.alpha_innerShadow[i] / 255.0f;

					drawShadowSheet(mDrawSettings, context, mLoadIntoBitmapSheet,
							SHEET_SET_OVERSIZED, radius, offsetX, offsetY,
							sheetCanvas, null, sheetBlockWidth,
							sheetBlockHeight, alphaScale);
				}

			} catch (IOException e) {
				e.printStackTrace();
				throw new RuntimeException("Error when drawing shadow sheet");
			}
		} else
			log( 
					"retaining innerBorderFillShadow as preallocated has an exact match");
	}

	/**
	 * Provided with a bitmap and an (x,y) location within it, sets the provided
	 * Rect object to exactly the pixel (x,y) and then expands it as much as
	 * possible without going beyond the bounds of the rectangle or including
	 * pixels with nonzero alpha values.
	 * 
	 * Returns whether the resulting rectangle contains at least one pixel. If
	 * (x,y) is outside the bitmap bounds or has nonzero alpha, 'false' is
	 * returned and the value stored in 'r' should not be used (it may not have
	 * been changed).
	 * 
	 * Expansion method: we prefer to expand outward symmetrically (square
	 * shape) until one edge lies adjacent to a boundary (nonzero alpha or image
	 * boundary). Other edges will continue to expand.
	 * 
	 * This method supports only ARGB_8888 bitmaps; ALPHA_8 does not support
	 * getPixel().
	 * 
	 * @param r
	 * @param b
	 * @param x
	 * @param y
	 * @return
	 */
	private boolean expandWithinEmptyBitmapPixels(Rect r, Bitmap b, int x, int y) {
		// sanity check
		if (x < 0 || y < 0 || x >= b.getWidth() || y >= b.getHeight())
			return false;
		if (b.getConfig() != Bitmap.Config.ARGB_8888)
			throw new IllegalArgumentException(
					"Supports only ARGB_8888 bitmaps.");
		if (Color.alpha(b.getPixel(x, y)) != 0)
			return false;

		r.set(x, y, x + 1, y + 1);
		boolean expandLeft = true, expandRight = true, expandUp = true, expandDown = true;
		while (expandLeft || expandRight || expandUp || expandDown) {
			expandLeft = expandLeft && shouldExpand(r, b, -1, 0);
			if (expandLeft)
				r.left--;
			expandUp = expandUp && shouldExpand(r, b, 0, -1);
			if (expandUp)
				r.top--;
			expandRight = expandRight && shouldExpand(r, b, 1, 0);
			if (expandRight)
				r.right++;
			expandDown = expandDown && shouldExpand(r, b, 0, 1);
			if (expandDown)
				r.bottom++;
		}

		return true;
	}

	private boolean shouldExpand(Rect r, Bitmap b, int xDir, int yDir) {
		if (xDir == 0 && yDir == 0)
			throw new IllegalArgumentException(
					"Include exactly one of xDir, yDir as value {-1, 1}.  The other should be 0.");
		if (xDir != 0 && yDir != 0)
			throw new IllegalArgumentException(
					"Include exactly one of xDir, yDir as value {-1, 1}.  The other should be 0.");
		if (xDir < -1 || xDir > 1 || yDir < -1 || yDir > 1)
			throw new IllegalArgumentException(
					"Include exactly one of xDir, yDir as value {-1, 1}.  The other should be 0.");

		if (xDir == -1 && r.left <= 0)
			return false;
		if (yDir == -1 && r.top <= 0)
			return false;
		if (xDir == 1 && r.right >= b.getWidth())
			return false;
		if (yDir == 1 && r.bottom >= b.getHeight())
			return false;

		// try expansion!
		if (xDir != 0) {
			// horizontal expansion.
			int x = xDir > 0 ? r.right : r.left - 1;
			for (int y = r.top; y < r.bottom; y++)
				if (Color.alpha(b.getPixel(x, y)) != 0)
					return false;
		}

		if (yDir != 0) {
			int y = yDir > 0 ? r.bottom : r.top - 1;
			for (int x = r.left; x < r.right; x++)
				if (Color.alpha(b.getPixel(x, y)) != 0)
					return false;
		}

		return true;
	}

	private void prerenderCustomFillShadow(Context context,
			BlockDrawerPreallocatedBitmaps preallocated) {

		if (customFillShadow_byQPaneQOrientation == null) {
			customFillShadow_byQPaneQOrientation = new Bitmap[2][QOrientations.NUM];
			customFillShadowBounds_byQPaneQOrientation = new Rect[2][QOrientations.NUM];
		}

		for (int qp = 0; qp < 2; qp++) {
			for (int qo = 0; qo < QOrientations.NUM; qo++) {
				customFillShadow_byQPaneQOrientation[qp][qo] = null;
				customFillShadowBounds_byQPaneQOrientation[qp][qo] = null;
			}
		}

		// Edge shadow gaussian radius and shadow alpha?
		float radius = 0;
		int alpha = 0;

		for (int i = 0; i < mDrawSettings.proportion_innerShadowGaussianRadius.length; i++) {
			if (mDrawSettings.proportion_innerShadowXOffset[i] == 0
					&& mDrawSettings.proportion_innerShadowYOffset[i] == 0) {
				radius = mDrawSettings.proportion_innerShadowGaussianRadius[i];
				alpha = mDrawSettings.alpha_innerShadow[i];
			}
		}

		// Inset borders.
		boolean has = false;
		for (int qo = 0; qo < QOrientations.NUM; qo++)
			has = has
					|| mDrawSettings.behavior_qo_fill[qo] == DrawSettings.BEHAVIOR_QO_FILL_PAINT_Q_ORIENTATION_INSET;

		if (has) {

			int xInset = mDrawSettings.size_innerBorderXInset
					+ mDrawSettings.size_innerBorderWidth;
			int yInset = mDrawSettings.size_innerBorderYInset
					+ mDrawSettings.size_innerBorderHeight;

			StringBuilder sb = new StringBuilder();
			sb.append("customFillShadow");
			sb.append("_").append(mDrawSettings.size_blockWidth)
					.append("_").append(mDrawSettings.size_blockHeight);
			sb.append("_").append(xInset).append("_").append(yInset);
			sb.append("_").append(radius).append("_").append(alpha);
			String key = sb.toString();

			Bitmap b;
			Rect bounds;
			boolean rendered = false;
			try {
				if (preallocated.hasBlockSizeBitmapInUse(key)
						|| (preallocated.hasBlockSizeBitmap(key) && preallocated
								.getRenderedDrawSettings() != null))
					rendered = true;

				// if rendered, the data is already here.
				b = preallocated.getBlockSizeBitmap(key,
						mDrawSettings.size_blockWidth,
						mDrawSettings.size_blockHeight,
						Bitmap.Config.ALPHA_8);

				if (!rendered) {
					// clear?
					if (b != null) {
						Canvas c = new Canvas(b);
						c.drawPaint(clearPaint);
					}
					b = prerenderInsetFillShadowBitmap(b, mDrawSettings,
							context, xInset, yInset, radius, alpha);
				}
				bounds = new Rect(0, 0, mDrawSettings.size_blockWidth,
						mDrawSettings.size_blockHeight);
			} catch (IOException exc) {
				exc.printStackTrace();
				throw new RuntimeException("Failure loading shadow data");
			}

			// place in our custom bitmap array.
			for (int qp = 0; qp < 2; qp++) {
				for (int qo = 0; qo < QOrientations.NUM; qo++) {
					if (mDrawSettings.behavior_qo_fill[qo] == DrawSettings.BEHAVIOR_QO_FILL_PAINT_Q_ORIENTATION_INSET) {
						customFillShadow_byQPaneQOrientation[qp][qo] = b;
						customFillShadowBounds_byQPaneQOrientation[qp][qo] = bounds;
					}
				}
			}
		}

		// Mini borders. Smaller than inset.
		has = false;
		for (int qo = 0; qo < QOrientations.NUM; qo++)
			has = has
					|| mDrawSettings.behavior_qo_fill[qo] == DrawSettings.BEHAVIOR_QO_FILL_PAINT_Q_ORIENTATION_MINI;

		if (has) {

			int xInset = mDrawSettings.size_miniBorderXInset
					+ mDrawSettings.size_miniBorderWidth;
			int yInset = mDrawSettings.size_miniBorderYInset
					+ mDrawSettings.size_miniBorderHeight;

			StringBuilder sb = new StringBuilder();
			sb.append("customFillShadow");
			sb.append("_").append(mDrawSettings.size_blockWidth)
					.append("_").append(mDrawSettings.size_blockHeight);
			sb.append("_").append(xInset).append("_").append(yInset);
			sb.append("_").append(radius).append("_").append(alpha);
			String key = sb.toString();

			Bitmap b;
			Rect bounds;
			boolean rendered = false;
			try {
				if (preallocated.hasBlockSizeBitmapInUse(key)
						|| (preallocated.hasBlockSizeBitmap(key) && preallocated
								.getRenderedDrawSettings() != null))
					rendered = true;

				// if rendered, the data is already here.
				b = preallocated.getBlockSizeBitmap(key,
						mDrawSettings.size_blockWidth,
						mDrawSettings.size_blockHeight,
						Bitmap.Config.ALPHA_8);

				if (!rendered) {
					// clear?
					if (b != null) {
						Canvas c = new Canvas(b);
						c.drawPaint(clearPaint);
					}
					b = prerenderInsetFillShadowBitmap(b, mDrawSettings,
							context, xInset, yInset, radius, alpha);
				}
				bounds = new Rect(0, 0, mDrawSettings.size_blockWidth,
						mDrawSettings.size_blockHeight);
			} catch (IOException exc) {
				exc.printStackTrace();
				throw new RuntimeException("Failure loading shadow data");
			}
			// put in the cache and in our records
			// log("putting bitmap " + bitmap + " in cache") ;

			// place in our custom bitmap array.
			for (int qp = 0; qp < 2; qp++) {
				for (int qo = 0; qo < QOrientations.NUM; qo++) {
					if (mDrawSettings.behavior_qo_fill[qo] == DrawSettings.BEHAVIOR_QO_FILL_PAINT_Q_ORIENTATION_MINI) {
						customFillShadow_byQPaneQOrientation[qp][qo] = b;
						customFillShadowBounds_byQPaneQOrientation[qp][qo] = bounds;
					}
				}
			}
		}

		// Mini non-overlapping borders. Same size as "mini", but with certain
		// pixels
		// omitted. We can easily generate this my getting the inset shadow
		// bitmap to
		// mini dimensions, then drawing it to a canvas with the "fill region"
		// applied
		// as a clip.
		has = false;
		for (int qo = 0; qo < QOrientations.NUM; qo++)
			has = has
					|| mDrawSettings.behavior_qo_fill[qo] == DrawSettings.BEHAVIOR_QO_FILL_PAINT_Q_ORIENTATION_MINI_NONOVERLAP;

		if (has) {
			int xInset = mDrawSettings.size_miniBorderXInset
					+ mDrawSettings.size_miniBorderWidth;
			int yInset = mDrawSettings.size_miniBorderYInset
					+ mDrawSettings.size_miniBorderHeight;

			StringBuilder sb = new StringBuilder();
			sb.append("customFillShadow");
			sb.append("_").append(mDrawSettings.size_blockWidth)
					.append("_").append(mDrawSettings.size_blockHeight);
			sb.append("_").append(xInset).append("_").append(yInset);
			sb.append("_").append(radius).append("_").append(alpha);
			String key = sb.toString();

			Bitmap b = null;
			boolean rendered = false;
			try {
				if (preallocated.hasBlockSizeBitmapInUse(key)
						|| (preallocated.hasBlockSizeBitmap(key) && preallocated
								.getRenderedDrawSettings() != null))
					rendered = true;

				// if rendered, the data is already here.
				b = preallocated.getBlockSizeBitmap(key,
						mDrawSettings.size_blockWidth,
						mDrawSettings.size_blockHeight,
						Bitmap.Config.ALPHA_8);

				if (!rendered) {
					// clear?
					if (b != null) {
						Canvas c = new Canvas(b);
						c.drawPaint(clearPaint);
					}
					b = prerenderInsetFillShadowBitmap(b, mDrawSettings,
							context, xInset, yInset, radius, alpha);
				}
			} catch (IOException exc) {
				exc.printStackTrace();
				throw new RuntimeException("Failure loading shadow data");
			}
			// put in the cache and in our records
			// log("putting bitmap " + bitmap + " in cache") ;

			Path path_q0 = null;
			Path path_q1 = null;
			for (int i = 0; i < QOrientations.NUM; i++) {
				if (mDrawSettings.behavior_qo_fill[i] == DrawSettings.BEHAVIOR_QO_FILL_PAINT_Q_ORIENTATION_MINI_NONOVERLAP) {
					path_q0 = customFillPath_byQPane_QOrientation[0][i];
					path_q1 = customFillPath_byQPane_QOrientation[1][i];
				}
			}

			Canvas c;

			sb = new StringBuilder();
			sb.append("customFillShadowMiniNonOverlap");
			sb.append("_").append(b.getWidth()).append("_")
					.append(b.getHeight());
			sb.append("_").append(xInset).append("_").append(yInset);
			sb.append("_").append(radius).append("_").append(alpha);
			sb.append("_").append(mDrawSettings.size_qXOffset).append("_")
					.append(mDrawSettings.size_qYOffset);
			String key_q0 = sb.toString() + "_q0";
			String key_q1 = sb.toString() + "_q1";

			Bitmap b_q0, b_q1;

			rendered = false;
			if (preallocated.hasBlockSizeBitmapInUse(key_q0)
					|| (preallocated.hasBlockSizeBitmap(key_q0) && preallocated
							.getRenderedDrawSettings() != null))
				rendered = true;
			b_q0 = preallocated.getBlockSizeBitmap(key_q0, b.getWidth(),
					b.getHeight(), Bitmap.Config.ALPHA_8);
			if (b_q0 == null) {
				if ( GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP )
					log("Allocate Bitmap: custom fill shadow");
				b_q0 = Bitmap.createBitmap(b.getWidth(), b.getHeight(),
						Bitmap.Config.ALPHA_8);
			}
			if (!rendered) {
				c = new Canvas(b_q0);
                c.drawPaint(clearPaint);
				c.clipPath(path_q0);
				c.drawBitmap(b, 0, 0, null);
			}
			Rect bounds_q0 = new Rect(0, 0, mDrawSettings.size_blockWidth,
					mDrawSettings.size_blockHeight);

			rendered = false;
			if (preallocated.hasBlockSizeBitmapInUse(key_q1)
					|| (preallocated.hasBlockSizeBitmap(key_q1) && preallocated
							.getRenderedDrawSettings() != null))
				rendered = true;
			b_q1 = preallocated.getBlockSizeBitmap(key_q1, b.getWidth(),
					b.getHeight(), Bitmap.Config.ALPHA_8);
			if (b_q1 == null) {
				if ( GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP )
					log("Allocate Bitmap: custom fill shadow");
				b_q1 = Bitmap.createBitmap(b.getWidth(), b.getHeight(),
						Bitmap.Config.ALPHA_8);
			}
			if (!rendered) {
				c = new Canvas(b_q1);
				c.drawPaint(clearPaint);
				c.clipPath(path_q1);
				c.drawBitmap(b, 0, 0, null);
			}
			Rect bounds_q1 = new Rect(0, 0, mDrawSettings.size_blockWidth,
					mDrawSettings.size_blockHeight);

			// place in our custom bitmap array.
			for (int qo = 0; qo < QOrientations.NUM; qo++) {
				if (mDrawSettings.behavior_qo_fill[qo] == DrawSettings.BEHAVIOR_QO_FILL_PAINT_Q_ORIENTATION_MINI_NONOVERLAP) {
					customFillShadow_byQPaneQOrientation[0][qo] = b_q0;
					customFillShadow_byQPaneQOrientation[1][qo] = b_q1;

					customFillShadowBounds_byQPaneQOrientation[0][qo] = bounds_q0;
					customFillShadowBounds_byQPaneQOrientation[1][qo] = bounds_q1;
				}
			}
		}
		
		// INNER shadows combined with a border chevron.
		has = false;
		for (int qo = 0; qo < QOrientations.NUM; qo++)
			has = has
					|| ( mDrawSettings.behavior_qo_bitmap[qo] == DrawSettings.BEHAVIOR_QO_BITMAP_CHEVRON_BORDER
							&& mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_INNER ) ;
		
		if ( has ) {
			// render this bitmap, then set it for everthang.
			StringBuilder sb = new StringBuilder();
			sb.append("chevronBorderShadow");
			sb.append("_").append(mDrawSettings.size_blockWidth)
					.append("_").append(mDrawSettings.size_blockHeight);
			sb.append("_").append(Skin.toStringEncoding(mDrawSettings.getSkin())) ;
			String key = sb.toString();

			Bitmap b = null;
			boolean rendered = false;
			if (preallocated.hasBlockSizeBitmapInUse(key)
					|| (preallocated.hasBlockSizeBitmap(key) && preallocated
							.getRenderedDrawSettings() != null))
				rendered = true;

			// if rendered, the data is already here.
			b = preallocated.getBlockSizeBitmap(key,
					mDrawSettings.size_blockWidth,
					mDrawSettings.size_blockHeight,
					Bitmap.Config.ALPHA_8);

			if (!rendered) {
				// clear?
				if (b != null) {
					Canvas c = new Canvas(b);
					c.drawPaint(clearPaint);
				}
				
				b = renderBorderChevronInnerShadowBitmap(b,
						mDrawSettings, context,
						mDrawSettings.proportion_innerShadowGaussianRadius,
						mDrawSettings.proportion_innerShadowXOffset, 
						mDrawSettings.proportion_innerShadowYOffset, 
						mDrawSettings.alpha_innerShadow) ;
			}
			
			// now get the reverse: inverted version.
			sb = new StringBuilder();
			sb.append("chevronBorderShadowInverted");
			sb.append("_").append(mDrawSettings.size_blockWidth)
					.append("_").append(mDrawSettings.size_blockHeight);
			sb.append("_").append(Skin.toStringEncoding(mDrawSettings.getSkin())) ;
			key = sb.toString();

			Bitmap bInverted = null;
			rendered = false;
			if (preallocated.hasBlockSizeBitmapInUse(key)
					|| (preallocated.hasBlockSizeBitmap(key) && preallocated
							.getRenderedDrawSettings() != null))
				rendered = true;

			// if rendered, the data is already here.
			bInverted = preallocated.getBlockSizeBitmap(key,
					mDrawSettings.size_blockWidth,
					mDrawSettings.size_blockHeight,
					Bitmap.Config.ALPHA_8);
			
			if ( !rendered ) {
				Matrix matrixInvert = new Matrix() ;
				matrixInvert.preScale(1.0f, -1.0f) ;
				matrixInvert.postTranslate(0, mDrawSettings.size_blockHeight) ;
				
				// clear?
				if ( bInverted != null ) {
					Canvas c = new Canvas(bInverted) ;
					c.drawPaint(clearPaint) ;
					
					c.drawBitmap(b, matrixInvert, null) ;
				} else {
					bInverted = Bitmap.createBitmap(
							b, 0, 0,
							mDrawSettings.size_blockWidth,
							mDrawSettings.size_blockHeight,
							matrixInvert, true) ;
				}
			}
			
			Rect bounds = new Rect( 0, 0,
					mDrawSettings.size_blockWidth,
					mDrawSettings.size_blockHeight ) ;
			
			// place in our custom bitmap array.
			for (int qp = 0; qp < 2; qp++) {
				for (int qo = 0; qo < QOrientations.NUM; qo++) {
					if ( mDrawSettings.behavior_qo_bitmap[qo] == DrawSettings.BEHAVIOR_QO_BITMAP_CHEVRON_BORDER
							&& mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_INNER ) {
						
						
						if ( qo == QOrientations.PUSH_UP || qo == QOrientations.PUSH_UP_ACTIVE )
							customFillShadow_byQPaneQOrientation[qp][qo] = bInverted ;
						else
							customFillShadow_byQPaneQOrientation[qp][qo] = b;
						customFillShadowBounds_byQPaneQOrientation[qp][qo] = bounds;
					}
				}
			}
		}
		
	}

	private void prerenderInnerBorderExtrudedWallShadow(Context context,
			BlockDrawerPreallocatedBitmaps preallocated) {
		// Inner Border Fill Shadows. These represent shadows cast
		// by inner borders, and will be applied to any QOrientation fill
		// that is 1. rendered in fill (not inset), and 2. rendered with
		// "Inner" borders.
		// For now, we render
		// that as black-with-alpha "shadow" layers that are
		// drawn on top of the fill color.

		if (innerBorderExtrudedWallShadow_bySide == null)
			innerBorderExtrudedWallShadow_bySide = new Bitmap[NUM_WALL_SIDES];

		for (int wallSide = 0; wallSide < NUM_WALL_SIDES; wallSide++) {
			// We iterate through wall sides; left happens before right, and top
			// before bottom.
			// It is worth noting that the general shadow shape for Middle and
			// Last are
			// identical between left and right,
			// and between top and bottom.
			// It also worth noting that for left and top, First == Middle.
			// Finally, for left and top, Alone == Last.
			// BUT! We can't really exploit this, because we want a very
			// simple draw algorithm, whereas these wall placements are actually
			// offset from each other a little bit; shadows for the middle
			// section
			// are NOT draw to the exact same boundaries as First sections, for
			// example.
			// We render the bitmaps so that we can very simply place and draw a
			// bitmap
			// without regard to the specific dimensions of the wall or with any
			// skew.
			// We place bitmap boundaries according to the assumed L,R,T,B
			// boundaries
			// of the wall using qOffset and block sizes, NOT border sizes.
			// Those are
			// factored in in the initial rendering.

			Bitmap bitmap;
			try {
				bitmap = prerenderInnerBorderExtrudedWallShadow(preallocated,
						mDrawSettings, context, wallSide);
			} catch (IOException exc) {
				exc.printStackTrace();
				throw new RuntimeException("Failure loading shadow data");
			}
			// put in the cache and in our records
			// log("putting bitmap " + bitmap + " in cache") ;
			innerBorderExtrudedWallShadow_bySide[wallSide] = bitmap;
		}
	}

	private void prerenderInnerBorderDropShadowSheet(Context context,
			BlockDrawer master, BlockDrawerPreallocatedBitmaps preallocated) {
		// Inner border drop shadow sheet. Represents shadows cast by inner
		// borders, cast on to
		// the background,
		// arranged in a 16 x 16 sheet. (many of these will go unused, but meh).
		// Will be applied to any QOrientation fill that is 1. render in fill
		// (not inset),
		// and 2. rendered with "Inner" borders. Drawn as a black-with-alpha
		// "shadow"
		// that is drawn on top of the actual fill color.

		// first things first: see if we can skip all this based on the master.
		if (master != null && master.innerBorderDropShadowSheet != null
				&& !master.innerBorderDropShadowSheet.isRecycled()) {
			if (sheetsAreScaledCopies(
					this.mDrawSettings.proportion_outerShadowGaussianRadius,
					this.mDrawSettings.proportion_outerShadowXOffset,
					this.mDrawSettings.proportion_outerShadowYOffset,
					this.mDrawSettings.alpha_dropShadow,
					master.mDrawSettings.proportion_outerShadowGaussianRadius,
					master.mDrawSettings.proportion_outerShadowXOffset,
					master.mDrawSettings.proportion_outerShadowYOffset,
					master.mDrawSettings.alpha_dropShadow)) {

				// copy the master's.
				log( 
						"taking reference to master's innerBorderDropShadowSheet");
				this.innerBorderDropShadowSheet = master.innerBorderDropShadowSheet;
				this.innerBorderDropShadowSheetBounds = new Rect(
						master.innerBorderDropShadowSheetBounds);
				return;

			} else
				throw new IllegalArgumentException(
						"Master provided, but drop shadow sheets are not scaled copies.");
		}

		innerBorderDropShadowSheet = preallocated
				.getSheetBitmap("innerBorderDropShadowSheet");

		if (innerBorderDropShadowSheet == null) {
			innerBorderDropShadowSheet = Bitmap.createBitmap(
					sheetBlockWidth * 16, sheetBlockHeight * 16,
					Bitmap.Config.ALPHA_8);
			if ( GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP )
				log("Allocate Bitmap: create innerBorderDropShadowSheet");
		}
		innerBorderDropShadowSheetBounds = new Rect(0, 0, sheetBlockWidth * 16,
				sheetBlockHeight * 16);

		DrawSettings preallocatedDS = preallocated.getRenderedDrawSettings();
		if (!dropShadowSheetsAreExactCopies(mDrawSettings, preallocatedDS)) {
			log( 
					"rendering innerBorderDropShadow as preallocated drawSettings is null or not an exact match");

			// draw two shadows: edge and offset.
			Canvas sheetCanvas = new Canvas(innerBorderDropShadowSheet);
			sheetCanvas.drawPaint(clearPaint);

			try {
				for (int i = 0; i < mDrawSettings.proportion_outerShadowGaussianRadius.length; i++) {
					float radius = mDrawSettings.proportion_outerShadowGaussianRadius[i];
					float offsetX = mDrawSettings.proportion_outerShadowXOffset[i];
					float offsetY = mDrawSettings.proportion_outerShadowYOffset[i];
					float alphaScale = mDrawSettings.alpha_dropShadow[i] / 255.0f;

					// log("drawShadow sheet with " + radius + ", " +
					// offsetX + ", " + offsetY + ", " + alphaScale) ;

					drawShadowSheet(mDrawSettings, context, mLoadIntoBitmapSheet,
							SHEET_SET_EXACT,
							radius, offsetX, offsetY, sheetCanvas, null,
							sheetBlockWidth, sheetBlockHeight, alphaScale);
				}
            } catch (IOException e) {
				e.printStackTrace();
				throw new RuntimeException("Error when drawing shadow sheet");
			}
		} else
			log( 
					"retaining innerBorderDropShadow as preallocated has an exact match");
	}

	private void generateInnerBorderDropShadowRegions(Context context) {
		// Inner border drop shadow regions. Represents shadows cast by inner
		// borders, cast on to
		// the background,
		// arranged in a 16 x 16 sheet. (many of these will go unused, but meh).
		// Will be applied to any QOrientation fill that is 1. render in fill
		// (not inset),
		// and 2. rendered with "Inner" borders. We draw as a full-black (no
		// alpha) color
		// within this region.

		int sW = estimateDropShadowWidth(mDrawSettings); // shadowWidth
		int sH = estimateDropShadowHeight(mDrawSettings); // shadowHeight

		innerBorderDropShadowPath = new Path[256];
		innerBorderDropShadowRects = new Rect[256][8];
		// generate for every possible index...
		for (int i = 0; i < 256; i++) {
			neighborsByIndex(i, tempConnected, 1, 1);

			Path p = path();
			// include the appropriate rectangles. we try to use no more than 4.
			if (!tempConnected[0][1]) // left edge
			    unionRect(p, 0, 0, sW, mDrawSettings.size_blockHeight,
						Path.Direction.CW);
			if (!tempConnected[1][0]) // top edge
				unionRect(p, 0, 0, mDrawSettings.size_blockWidth, sH,
						Path.Direction.CW);
			if (!tempConnected[2][1]) // right edge
				unionRect(p, mDrawSettings.size_blockWidth - sW, 0,
						mDrawSettings.size_blockWidth,
						mDrawSettings.size_blockHeight, Path.Direction.CW);
			if (!tempConnected[1][2]) // bottom edge
				unionRect(p, 0, mDrawSettings.size_blockHeight - sH,
						mDrawSettings.size_blockWidth,
						mDrawSettings.size_blockHeight, Path.Direction.CW);

			// now the corners. Don't bother including if we already have
			// a side that covers them.
			if (!tempConnected[0][0]
					&& (tempConnected[0][1] && tempConnected[1][0])) // top-left
				unionRect(p, 0, 0, sW, sH, Path.Direction.CW);
			if (!tempConnected[2][0]
					&& (tempConnected[2][1] && tempConnected[1][0])) // top-right
				unionRect(p, mDrawSettings.size_blockWidth - sW, 0,
						mDrawSettings.size_blockWidth, sH, Path.Direction.CW);
			if (!tempConnected[0][2]
					&& (tempConnected[0][1] && tempConnected[1][2])) // bottom-left
				unionRect(p, 0, mDrawSettings.size_blockHeight - sH, sW,
						mDrawSettings.size_blockHeight, Path.Direction.CW);
			if (!tempConnected[2][2]
					&& (tempConnected[2][1] && tempConnected[1][2])) // bottom-right
				unionRect(p, mDrawSettings.size_blockWidth - sW,
						mDrawSettings.size_blockHeight - sH,
						mDrawSettings.size_blockWidth,
						mDrawSettings.size_blockHeight, Path.Direction.CW);

			innerBorderDropShadowPath[i] = p;

			if (!tempConnected[0][1]) // left edge
				innerBorderDropShadowRects[i][0] = new Rect(0, sH, sW,
						mDrawSettings.size_blockHeight - sH);
			if (!tempConnected[1][0]) // top edge
				innerBorderDropShadowRects[i][1] = new Rect(sW, 0,
						mDrawSettings.size_blockWidth - sW, sH);
			if (!tempConnected[2][1]) // right edge
				innerBorderDropShadowRects[i][2] = new Rect(
						mDrawSettings.size_blockWidth - sW, sH,
						mDrawSettings.size_blockWidth,
						mDrawSettings.size_blockHeight - sH);
			if (!tempConnected[1][2]) // bottom edge
				innerBorderDropShadowRects[i][3] = new Rect(sW,
						mDrawSettings.size_blockHeight - sH,
						mDrawSettings.size_blockWidth - sW,
						mDrawSettings.size_blockHeight);

			// now the corners. Don't bother including if we already have
			// a side that covers them.
			if (!tempConnected[0][0] || !tempConnected[0][1]
					|| !tempConnected[1][0]) // top-left
				innerBorderDropShadowRects[i][4] = new Rect(0, 0, sW, sH);
			if (!tempConnected[2][0] || !tempConnected[2][1]
					|| !tempConnected[1][0]) // top-right
				innerBorderDropShadowRects[i][5] = new Rect(
						mDrawSettings.size_blockWidth - sW, 0,
						mDrawSettings.size_blockWidth, sH);
			if (!tempConnected[0][2] || !tempConnected[0][1]
					|| !tempConnected[1][2]) // bottom-left
				innerBorderDropShadowRects[i][6] = new Rect(0,
						mDrawSettings.size_blockHeight - sH, sW,
						mDrawSettings.size_blockHeight);
			if (!tempConnected[2][2] || !tempConnected[2][1]
					|| !tempConnected[1][2]) // bottom-right
				innerBorderDropShadowRects[i][7] = new Rect(
						mDrawSettings.size_blockWidth - sW,
						mDrawSettings.size_blockHeight - sH,
						mDrawSettings.size_blockWidth,
						mDrawSettings.size_blockHeight);

		}
	}

	private void prerenderCustomDropShadow(Context context,
			BlockDrawerPreallocatedBitmaps preallocated) {

		// TODO TODO TODO TODO:
		// Fill this in for custom draw shadows! We will likely need to draw
		// them
		// as oversized bitmaps, but is it necessary to 3x3 them? They really
		// should be
		// something close to 1.2x1.2, if not 1x1 (since custom shadows are
		// always
		// inset into the square, and may not reach outside of it!).

		if (customDropShadow_byQPaneQOrientation == null) {
			customDropShadow_byQPaneQOrientation = new Bitmap[2][QOrientations.NUM];
			customDropShadowBounds_byQPaneQOrientation = new Rect[2][QOrientations.NUM];
		}

		for (int qp = 0; qp < 2; qp++) {
			for (int qo = 0; qo < QOrientations.NUM; qo++) {
				customDropShadow_byQPaneQOrientation[qp][qo] = null;
				customDropShadowBounds_byQPaneQOrientation[qp][qo] = null;
			}
		}

		StringBuilder sb = new StringBuilder();
		sb.append("customDrowShadow");
		sb.append("_").append(mDrawSettings.size_blockWidth).append("_")
				.append(mDrawSettings.size_blockHeight);
		for (int i = 0; i < mDrawSettings.proportion_outerShadowGaussianRadius.length; i++) {
			sb.append("_").append(
					mDrawSettings.proportion_outerShadowGaussianRadius[i]);
			sb.append("_").append(mDrawSettings.size_outerShadowXOffset[i]);
			sb.append("_").append(mDrawSettings.size_outerShadowYOffset[i]);
			sb.append("_").append(mDrawSettings.alpha_dropShadow[i]);
		}
		String keyTemplate = sb.toString();

		// Inset borders.
		boolean has = false;
		for (int qo = 0; qo < QOrientations.NUM; qo++)
			has = has
					|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INSET;

		if (has) {
			Bitmap b;
			Rect bounds;

			String key = keyTemplate + "_"
					+ mDrawSettings.proportion_innerBorderXInset + "_"
					+ mDrawSettings.proportion_innerBorderYInset + "_"
					+ mDrawSettings.size_innerBorderXInset + "_"
					+ mDrawSettings.size_innerBorderYInset;

			boolean rendered = preallocated.hasBlockSizeBitmapInUse(key)
					|| (preallocated.hasBlockSizeBitmap(key) && preallocated
							.getRenderedDrawSettings() != null);

			b = preallocated.getBlockSizeBitmap(key,
					mDrawSettings.size_blockWidth,
					mDrawSettings.size_blockHeight, Bitmap.Config.ALPHA_8);

			if (!rendered) {
				if (b != null) {
					Canvas c = new Canvas(b);
					c.drawPaint(clearPaint);
				}
				b = renderInsetDropShadowBitmap(b, mDrawSettings, context,
						mDrawSettings.proportion_innerBorderXInset,
						mDrawSettings.proportion_innerBorderYInset,
						mDrawSettings.size_innerBorderXInset,
						mDrawSettings.size_innerBorderYInset,
						mDrawSettings.proportion_outerShadowGaussianRadius,
						mDrawSettings.size_outerShadowXOffset,
						mDrawSettings.size_outerShadowYOffset,
						mDrawSettings.alpha_dropShadow);
			}
			bounds = new Rect(0, 0, mDrawSettings.size_blockWidth,
					mDrawSettings.size_blockHeight);

			// place in our custom bitmap array.
			for (int qp = 0; qp < 2; qp++) {
				for (int qo = 0; qo < QOrientations.NUM; qo++) {
					if (mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INSET) {
						customDropShadow_byQPaneQOrientation[qp][qo] = b;
						customDropShadowBounds_byQPaneQOrientation[qp][qo] = bounds;
					}
				}
			}
		}

		// Mini borders. Smaller than inset.
		has = false;
		for (int qo = 0; qo < QOrientations.NUM; qo++)
			has = has
					|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI;

		if (has) {
			Bitmap b;
			Rect bounds;

			String key = keyTemplate + "_"
					+ mDrawSettings.proportion_miniBorderXInset + "_"
					+ mDrawSettings.proportion_miniBorderYInset + "_"
					+ mDrawSettings.size_miniBorderXInset + "_"
					+ mDrawSettings.size_miniBorderYInset;

			boolean rendered = preallocated.hasBlockSizeBitmapInUse(key)
					|| (preallocated.hasBlockSizeBitmap(key) && preallocated
							.getRenderedDrawSettings() != null);

			b = preallocated.getBlockSizeBitmap(key,
					mDrawSettings.size_blockWidth,
					mDrawSettings.size_blockHeight, Bitmap.Config.ALPHA_8);

			if (!rendered) {
				if (b != null) {
					Canvas c = new Canvas(b);
					c.drawPaint(clearPaint);
				}
				b = renderInsetDropShadowBitmap(b, mDrawSettings, context,
						mDrawSettings.proportion_miniBorderXInset,
						mDrawSettings.proportion_miniBorderYInset,
						mDrawSettings.size_miniBorderXInset,
						mDrawSettings.size_miniBorderYInset,
						mDrawSettings.proportion_outerShadowGaussianRadius,
						mDrawSettings.size_outerShadowXOffset,
						mDrawSettings.size_outerShadowYOffset,
						mDrawSettings.alpha_dropShadow);
			}
			bounds = new Rect(0, 0, mDrawSettings.size_blockWidth,
					mDrawSettings.size_blockHeight);

			// place in our custom bitmap array.
			for (int qp = 0; qp < 2; qp++) {
				for (int qo = 0; qo < QOrientations.NUM; qo++) {
					if (mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI) {
						customDropShadow_byQPaneQOrientation[qp][qo] = b;
						customDropShadowBounds_byQPaneQOrientation[qp][qo] = bounds;
					}
				}
			}
		}

		// Mini chain-link borders. Same size as "mini", but with certain pixels
		// omitted and bonus shadows in the center area. Two complications:
		// first,
		// we render the drop shadows clipped so that they do NOT appear where
		// the
		// other QOrientation block lies (similar to inner shadows). Second, we
		// add ADDITIONAL shadows (on Q0) within the empty space between links.
		// In both cases (thankfully) the actual shadows we draw are independent
		// of the overlap style.
		has = false;
		for (int qo = 0; qo < QOrientations.NUM; qo++)
			has = has
					|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_VERTICAL_OVER
					|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_HORIZONTAL_OVER;

		if (has) {

			String key = keyTemplate + "_"
					+ mDrawSettings.proportion_miniBorderXInset + "_"
					+ mDrawSettings.proportion_miniBorderYInset + "_"
					+ mDrawSettings.size_miniBorderXInset + "_"
					+ mDrawSettings.size_miniBorderYInset;

			boolean rendered = preallocated.hasBlockSizeBitmapInUse(key)
					|| (preallocated.hasBlockSizeBitmap(key) && preallocated
							.getRenderedDrawSettings() != null);

			Bitmap b = preallocated.getBlockSizeBitmap(key,
					mDrawSettings.size_blockWidth,
					mDrawSettings.size_blockHeight, Bitmap.Config.ALPHA_8);

			if (!rendered) {
				if (b != null) {
					Canvas c = new Canvas(b);
					c.drawPaint(clearPaint);
				}
				b = renderInsetDropShadowBitmap(b, mDrawSettings, context,
						mDrawSettings.proportion_miniBorderXInset,
						mDrawSettings.proportion_miniBorderYInset,
						mDrawSettings.size_miniBorderXInset,
						mDrawSettings.size_miniBorderYInset,
						mDrawSettings.proportion_outerShadowGaussianRadius,
						mDrawSettings.size_outerShadowXOffset,
						mDrawSettings.size_outerShadowYOffset,
						mDrawSettings.alpha_dropShadow);
			}

			sb = new StringBuilder();
			sb.append("customDrowShadowMiniNonOverlap");
			sb.append("_").append(mDrawSettings.size_blockWidth)
					.append("_").append(mDrawSettings.size_blockHeight);
			for (int i = 0; i < mDrawSettings.proportion_outerShadowGaussianRadius.length; i++) {
				sb.append("_").append(
						mDrawSettings.proportion_outerShadowGaussianRadius[i]);
				sb.append("_").append(mDrawSettings.size_outerShadowXOffset[i]);
				sb.append("_").append(mDrawSettings.size_outerShadowYOffset[i]);
				sb.append("_").append(mDrawSettings.alpha_dropShadow[i]);
			}
			sb.append("_").append(mDrawSettings.proportion_miniBorderXInset);
			sb.append("_").append(mDrawSettings.proportion_miniBorderYInset);
			sb.append("_").append(mDrawSettings.size_miniBorderXInset);
			sb.append("_").append(mDrawSettings.size_miniBorderYInset);

			key = sb.toString();
			String key_q0 = key + "_q0";
			String key_q1 = key + "_q1";

			Bitmap bq0, bq1;

			// Note that there is no difference between HORIZONTAL and VERTICAL
			// versions, but
			// there IS a difference between Q0 and Q1.

			rendered = false;
			if (preallocated.hasBlockSizeBitmapInUse(key_q0)
					|| (preallocated.hasBlockSizeBitmap(key_q0) && preallocated
							.getRenderedDrawSettings() != null))
				rendered = true;
			bq0 = preallocated.getBlockSizeBitmap(key_q0, b.getWidth(),
					b.getHeight(), Bitmap.Config.ALPHA_8);
			if (bq0 == null) {
				if ( GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP )
					log("Allocate Bitmap: custom drop shadow");
				bq0 = Bitmap.createBitmap(b.getWidth(), b.getHeight(),
						Bitmap.Config.ALPHA_8);
			}
			if (!rendered) {
				Canvas c0 = new Canvas(bq0);
				c0.drawPaint(clearPaint);
				// step 1: clip the overlap of q1 and draw.
				tempRect.set(mDrawSettings.size_miniBorderXInset,
						mDrawSettings.size_miniBorderYInset,
						mDrawSettings.size_blockWidth
								- mDrawSettings.size_miniBorderXInset,
						mDrawSettings.size_blockHeight
								- mDrawSettings.size_miniBorderYInset);
				tempRect.offset(mDrawSettings.size_qXOffset,
						mDrawSettings.size_qYOffset);
				c0.save();
				c0.clipRect(tempRect, Region.Op.DIFFERENCE);
				c0.drawBitmap(b, 0, 0, null);
				c0.restore();
			}
			Rect bounds_q0 = new Rect(0, 0, mDrawSettings.size_blockWidth,
					mDrawSettings.size_blockHeight);

			// bq 1?
			rendered = false;
			if (preallocated.hasBlockSizeBitmapInUse(key_q1)
					|| (preallocated.hasBlockSizeBitmap(key_q1) && preallocated
							.getRenderedDrawSettings() != null))
				rendered = true;
			bq1 = preallocated.getBlockSizeBitmap(key_q1, b.getWidth(),
					b.getHeight(), Bitmap.Config.ALPHA_8);
			if (bq1 == null) {
				if ( GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP )
					log("Allocate Bitmap: custom drop shadow");
				bq1 = Bitmap.createBitmap(b.getWidth(), b.getHeight(),
						Bitmap.Config.ALPHA_8);
			}
			if (!rendered) {
				Canvas c1 = new Canvas(bq1);
				c1.drawPaint(clearPaint);
				// step 1: clip the overlap of q1 and draw.
				tempRect.set(mDrawSettings.size_miniBorderXInset,
						mDrawSettings.size_miniBorderYInset,
						mDrawSettings.size_blockWidth
								- mDrawSettings.size_miniBorderXInset,
						mDrawSettings.size_blockHeight
								- mDrawSettings.size_miniBorderYInset);
				tempRect.offset(-mDrawSettings.size_qXOffset,
						-mDrawSettings.size_qYOffset);
				c1.save();
				c1.clipRect(tempRect, Region.Op.DIFFERENCE);
				c1.drawBitmap(b, 0, 0, null);
				c1.restore();

				// get the coordinates of the fill area (NOT including the
				// border).
				// First
				// find the boundaries of the q0 area...
				int left = mDrawSettings.size_miniBorderXInset
						+ mDrawSettings.size_miniBorderWidth;
				int top = mDrawSettings.size_miniBorderYInset
						+ mDrawSettings.size_miniBorderHeight;
				int right = mDrawSettings.size_blockWidth - left;
				int bottom = mDrawSettings.size_blockHeight - top;
				// now revise slightly according to qOffset.
				left += (mDrawSettings.size_qXOffset > 0 ? 0
						: mDrawSettings.size_qXOffset);
				top -= (mDrawSettings.size_qYOffset > 0 ? 0
						: mDrawSettings.size_qYOffset);
				right -= (mDrawSettings.size_qXOffset > 0 ? mDrawSettings
						.size_qXOffset : 0);
				bottom -= (mDrawSettings.size_qYOffset > 0 ? mDrawSettings
						.size_qYOffset : 0);

				// now clip the "overlap" area.
				// Edges are:
				// left + ( qXOffset > 0 ? qXOffset : 0 )
				// top + ( qYOffset > 0 ? qYOffset : 0 )
				// right + ( qXOffset > 0 ? 0 : qXOffset )
				tempRect.set(left, top, right, bottom);
				c1.clipRect(tempRect);
				// draw 2 shadow set bitmaps: the "corner up-left" (aligned
				// top-left) and
				// "corner down-right" (aligned bottom-right).
				// remember that "connected" uses x/y, NOT row/col.
				int sheetBlockWidth = innerBorderDropShadowSheet.getWidth() / 16;
				int sheetBlockHeight = innerBorderDropShadowSheet.getHeight() / 16;
				// top-left corner: disconnect every slot with at least one
				// index 0.
				for (int x = 0; x < 3; x++)
					for (int y = 0; y < 3; y++)
						tempConnected[x][y] = (x != 0 && y != 0);
				int index = indexByNeighbors(tempConnected, 1, 1);
				indexByNeighbors_sheetRect(tempSrcRect, index, sheetBlockWidth,
						sheetBlockHeight);
				// we scale the result to block size, with top-left at - you
				// guessed
				// it - top left.
				tempDstRect.set(0, 0, mDrawSettings.size_blockWidth,
						mDrawSettings.size_blockHeight);
				tempDstRect.offset(left, top);
				tempColorPaint.setColor(0xff000000);
				tempColorPaint.setAlpha(192); // HACK HACK HACK: we apply an
												// alpha
												// here because
												// a full-alpha looks visually
												// pretty bad.
												// Was 128, but that was a
												// little too dim.
				c1.drawBitmap(innerBorderDropShadowSheet, tempSrcRect,
						tempDstRect, tempColorPaint);
				// And now the bottom-right. Corner: disconnect every slot with
				// at
				// least one index 2.
				for (int x = 0; x < 3; x++)
					for (int y = 0; y < 3; y++)
						tempConnected[x][y] = (x != 2 && y != 2);
				index = indexByNeighbors(tempConnected, 1, 1);
				indexByNeighbors_sheetRect(tempSrcRect, index, sheetBlockWidth,
						sheetBlockHeight);
				// we scale the result to block size, with bottom-right at
				// bottom-right.
				// we can do that by offsetting to top-left alignment, then
				// pulling
				// up-left
				// by blockwidth, and finally down-right by the size of the
				// overlap
				// area.
				tempDstRect.set(0, 0, mDrawSettings.size_blockWidth,
						mDrawSettings.size_blockHeight);
				tempDstRect.offset(left, top);
				tempDstRect.offset(-mDrawSettings.size_blockWidth,
						-mDrawSettings.size_blockHeight);
				tempDstRect.offset(right - left, bottom - top);
				c1.drawBitmap(innerBorderDropShadowSheet, tempSrcRect,
						tempDstRect, tempColorPaint);
			}

			Rect bounds_q1 = new Rect(0, 0, mDrawSettings.size_blockWidth,
					mDrawSettings.size_blockHeight);

			// place in our custom bitmap array.
			for (int qo = 0; qo < QOrientations.NUM; qo++) {
				if (mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_VERTICAL_OVER
						|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_HORIZONTAL_OVER) {
					customDropShadow_byQPaneQOrientation[0][qo] = bq0;
					customDropShadowBounds_byQPaneQOrientation[0][qo] = bounds_q0;

					customDropShadow_byQPaneQOrientation[1][qo] = bq1;
					customDropShadowBounds_byQPaneQOrientation[1][qo] = bounds_q1;
				}
			}
		}
	}

	private void generateCustomDropShadowRegions(Context context) {

		if (customDropShadowPath_byQPaneQOrientation == null)
			customDropShadowPath_byQPaneQOrientation = new Path[2][QOrientations.NUM];

		int sW = estimateDropShadowWidth(mDrawSettings); // shadowWidth
		int sH = estimateDropShadowHeight(mDrawSettings); // shadowHeight

		// Inset borders.
		boolean has = false;
		for (int qo = 0; qo < QOrientations.NUM; qo++)
			has = has
					|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INSET;

		if (has) {
			// a 1-pixel boundary around the inset block. Easy peasy!
			// log("generating Inset drop shadow regions") ;
			tempRectF.set(mDrawSettings.size_innerBorderXInset,
					mDrawSettings.size_innerBorderYInset,
					mDrawSettings.size_blockWidth
							- mDrawSettings.size_innerBorderXInset,
					mDrawSettings.size_blockHeight
							- mDrawSettings.size_innerBorderYInset);
			Path p = path();
			unionRect(p, tempRectF, Path.Direction.CW);

			tempRectF.inset(-sW, -sH); // grow by the shadow size
            reset(tempPath);
            unionRect(tempPath, tempRectF, Path.Direction.CW);

           op(p, tempPath, Path.Op.REVERSE_DIFFERENCE); // Only tempRect not including the inner area.

			// place in our custom region array.
			for (int qp = 0; qp < 2; qp++)
				for (int qo = 0; qo < QOrientations.NUM; qo++)
					if (mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INSET)
						customDropShadowPath_byQPaneQOrientation[qp][qo] = p;
		}

		// Mini borders. Smaller than inset.
		has = false;
		for (int qo = 0; qo < QOrientations.NUM; qo++)
			has = has
					|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI;

		if (has) {
			// a 1-pixel boundary around the inset block. Easy peasy!
			tempRectF.set(mDrawSettings.size_miniBorderXInset,
					mDrawSettings.size_miniBorderYInset,
					mDrawSettings.size_blockWidth
							- mDrawSettings.size_miniBorderXInset,
					mDrawSettings.size_blockHeight
							- mDrawSettings.size_miniBorderYInset);
			Path p = path();
			unionRect(p, tempRectF, Path.Direction.CW);

			tempRectF.inset(-sW, -sH); // grow by the shadow size
            reset(tempPath);
            unionRect(tempPath, tempRectF, Path.Direction.CW);

		op(p, tempPath, Path.Op.REVERSE_DIFFERENCE); // Only tempRect not including the inner area.

			// place in our custom region array.
			for (int qp = 0; qp < 2; qp++)
				for (int qo = 0; qo < QOrientations.NUM; qo++)
					if (mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI)
						customDropShadowPath_byQPaneQOrientation[qp][qo] = p;
		}

		// Mini chain-link borders. Same size as "mini", but with certain pixels
		// omitted and bonus shadows in the center area. Two complications:
		// first,
		// we render the drop shadows clipped so that they do NOT appear where
		// the
		// other QOrientation block lies (similar to inner shadows). Second, we
		// add ADDITIONAL shadows (on Q0) within the empty space between links.
		// In both cases (thankfully) the actual shadows we draw are independent
		// of the overlap style.
		has = false;
		for (int qo = 0; qo < QOrientations.NUM; qo++)
			has = has
					|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_VERTICAL_OVER
					|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_HORIZONTAL_OVER;

		if (has) {
			// we start by getting a generic drop shadow region. We will apply
			// specific
			// adjustments for QO and Q1 versions.
			tempRectF.set(mDrawSettings.size_miniBorderXInset,
					mDrawSettings.size_miniBorderYInset,
					mDrawSettings.size_blockWidth
							- mDrawSettings.size_miniBorderXInset,
					mDrawSettings.size_blockHeight
							- mDrawSettings.size_miniBorderYInset);

			Path p = path();
			unionRect(p, tempRectF, Path.Direction.CW);

			tempRectF.inset(-sW, -sH); // grow by the shadow size
            reset(tempPath);
            unionRect(tempPath, tempRectF, Path.Direction.CW);
           op(p, tempPath, Path.Op.REVERSE_DIFFERENCE); // Only tempRect not including the inner area.

			// the q0 version is this with a difference clip of the area covered
			// by q1. q1's is
			// this with a q0 difference clip, PLUS the "inner region" between
			// the links.
            Path p0 = new Path(p);
			tempRectF.set(mDrawSettings.size_miniBorderXInset,
					mDrawSettings.size_miniBorderYInset,
					mDrawSettings.size_blockWidth
							- mDrawSettings.size_miniBorderXInset,
					mDrawSettings.size_blockHeight
							- mDrawSettings.size_miniBorderYInset);
			tempRectF.offset(mDrawSettings.size_qXOffset,
					mDrawSettings.size_qYOffset);
            reset(tempPath);
            unionRect(tempPath, tempRectF, Path.Direction.CW);
			op(p0, tempPath, Path.Op.DIFFERENCE); // do not include this area.

			Path p1 = new Path(p);
			tempRectF.set(mDrawSettings.size_miniBorderXInset,
					mDrawSettings.size_miniBorderYInset,
					mDrawSettings.size_blockWidth
							- mDrawSettings.size_miniBorderXInset,
					mDrawSettings.size_blockHeight
							- mDrawSettings.size_miniBorderYInset);
			tempRectF.offset(-mDrawSettings.size_qXOffset,
					-mDrawSettings.size_qYOffset);
            reset(tempPath);
            unionRect(tempPath, tempRectF, Path.Direction.CW);
			op(p1, tempPath, Path.Op.DIFFERENCE); // do not include this area.

			// get the coordinates of the fill area (NOT including the border).
			// First
			// find the boundaries of the q0 area...
			int left = mDrawSettings.size_miniBorderXInset
					+ mDrawSettings.size_miniBorderWidth;
			int top = mDrawSettings.size_miniBorderYInset
					+ mDrawSettings.size_miniBorderHeight;
			int right = mDrawSettings.size_blockWidth - left;
			int bottom = mDrawSettings.size_blockHeight - top;
			// now revise slightly according to qOffset.
			left += (mDrawSettings.size_qXOffset > 0 ? 0 : mDrawSettings
					.size_qXOffset);
			top -= (mDrawSettings.size_qYOffset > 0 ? 0 : mDrawSettings
					.size_qYOffset);
			right -= (mDrawSettings.size_qXOffset > 0 ? mDrawSettings
					.size_qXOffset : 0);
			bottom -= (mDrawSettings.size_qYOffset > 0 ? mDrawSettings
					.size_qYOffset : 0);
			tempRectF.set(left, top, right, bottom);

            reset(tempPath);
			unionRect(tempPath, tempRectF, Path.Direction.CW);
			op(p1, tempPath, Path.Op.UNION);

			tempRectF.inset(sW, sH);
            reset(tempPath);
			unionRect(tempPath, tempRectF, Path.Direction.CW);
		    op(p1, tempPath, Path.Op.DIFFERENCE);
			// that's it for p1!

			// place in our custom bitmap array.
			for (int qo = 0; qo < QOrientations.NUM; qo++) {
				if (mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_VERTICAL_OVER
						|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_HORIZONTAL_OVER) {
					customDropShadowPath_byQPaneQOrientation[0][qo] = p0;
					customDropShadowPath_byQPaneQOrientation[1][qo] = p1;
				}
			}
		}
	}

	private void prerenderGlows(Context context,
			BlockDrawerPreallocatedBitmaps preallocated) {

		if (this.glowSheet_byGlowType_byGlowIndex == null) {
			this.glowSheet_byGlowType_byGlowIndex = new Bitmap[Consts.NUM_GLOWS][];
			this.glowSheetBounds_byGlowType_byGlowIndex = new Rect[Consts.NUM_GLOWS][];
			this.glowPath_byGlowType_byGlowIndex_byNeighbors = new Path[Consts.NUM_GLOWS][][];
			for (int i = 0; i < Consts.NUM_GLOWS; i++) {
				glowSheet_byGlowType_byGlowIndex[i] = new Bitmap[mDrawSettings.glow_size[i].length];
				glowSheetBounds_byGlowType_byGlowIndex[i] = new Rect[mDrawSettings.glow_size[i].length];
				glowPath_byGlowType_byGlowIndex_byNeighbors[i] = new Path[mDrawSettings.glow_size[i].length][];
			}
		}

		for (int glowType = 0; glowType < Consts.NUM_GLOWS; glowType++) {
			if (mDrawSettings.glowDrawStyle == DrawSettings.GLOW_DRAW_STYLE_BOX)
				presetGlowPaths(context, glowType,
                        glowPath_byGlowType_byGlowIndex_byNeighbors,
						mDrawSettings.glow_size);
			else if (mDrawSettings.glowDrawStyle == DrawSettings.GLOW_DRAW_STYLE_FADE)
				prerenderNormalizedGlowSheets(context, preallocated, glowType,
						glowSheet_byGlowType_byGlowIndex,
						glowSheetBounds_byGlowType_byGlowIndex,
						mDrawSettings.glow_radius);
			else if (mDrawSettings.glowDrawStyle == DrawSettings.GLOW_DRAW_STYLE_FLARE)
				prerenderGlowSheets(context, preallocated, glowType,
						glowSheet_byGlowType_byGlowIndex,
						glowSheetBounds_byGlowType_byGlowIndex,
						mDrawSettings.glow_radius);
		}
	}

	private void prerenderGlowSheets(Context context,
			BlockDrawerPreallocatedBitmaps preallocated, int glowType,
			Bitmap[][] glowSheets_byGlowType,
			Rect[][] glowSheetBounds_byGlowType, float[][] glowRadius_byGlowType) {

		if (glowSheets_byGlowType[glowType] == null) {
			glowSheets_byGlowType[glowType] = new Bitmap[glowRadius_byGlowType[glowType].length];
			glowSheetBounds_byGlowType[glowType] = new Rect[glowRadius_byGlowType[glowType].length];
		}

		prerenderGlowSheets(context, preallocated,
				glowSheets_byGlowType[glowType],
				glowSheetBounds_byGlowType[glowType],
				glowRadius_byGlowType[glowType]);
	}

	private void prerenderNormalizedGlowSheets(Context context,
			BlockDrawerPreallocatedBitmaps preallocated, int glowType,
			Bitmap[][] glowSheets_byGlowType,
			Rect[][] glowSheetBounds_byGlowType, float[][] glowRadius_byGlowType) {

		if (glowSheets_byGlowType[glowType] == null) {
			glowSheets_byGlowType[glowType] = new Bitmap[glowRadius_byGlowType[glowType].length];
			glowSheetBounds_byGlowType[glowType] = new Rect[glowRadius_byGlowType[glowType].length];
		}

		prerenderNormalizedGlowSheets(context, preallocated,
				glowSheets_byGlowType[glowType],
				glowSheetBounds_byGlowType[glowType],
				glowRadius_byGlowType[glowType]);
	}

	private void presetGlowPaths(Context context, int glowType,
                                 Path[][][] glowPaths_byGlowType, int[][] glowRadius_byGlowType) {

		if (glowPaths_byGlowType[glowType] == null) {
			glowPaths_byGlowType[glowType] = new Path[glowRadius_byGlowType[glowType].length][];
		}

		presetGlowPaths(context, glowPaths_byGlowType[glowType],
				glowRadius_byGlowType[glowType]);
	}

	/**
	 * Prerenders the glow sheets for the specified list of glowRadiuses. Uses
	 * draw settings' information for block sizes.
	 * 
	 * If possible, will use existing shadow sheet renders inside the provided
	 * 'preallocated' container.
	 * 
	 * @param context
	 * @param preallocated
	 * @param glowSheets
	 * @param glowSheetBounds
	 * @param glowRadius
	 */
	private void prerenderGlowSheets(Context context,
			BlockDrawerPreallocatedBitmaps preallocated, Bitmap[] glowSheets,
			Rect[] glowSheetBounds, float[] glowRadius) {

		// For now, we render
		// as white-with-alpha "glow" layers that are
		// drawn with a ColorFilter applying a new alpha and (optionally) color.
		// 1. block height, width (obviously)
		// 2. glow gaussian radius
		//
		// It is important to note that although Quantro and Retro lock glows
		// are drawn very differently (in short, Retro BLOCKS glow, Quantro
		// SEAMS
		// glow), this method prepares an identical structure in each case
		// - a "glow sheet" bitmap. Thus, this method is completely agnostic
		// w.r.t. Quantro or Retro mode (and w.r.t. the particular type of
		// glow it represents - lock, clear, etc.).

		// NOTE: Ensure that the resulting Key uniquely and exactly describes
		// the
		// Bitmap, EVEN IF DRAW SETTINGS CHANGE.
		StringBuilder sb = new StringBuilder();
		sb.append("glowSheet");
		sb.append("_").append(sheetBlockWidth);
		sb.append("_").append(sheetBlockHeight);
		String keyStub = sb.toString();

		for (int i = 0; i < glowRadius.length; i++) {

			glowSheetBounds[i] = new Rect(0, 0, sheetBlockWidth * 16,
					sheetBlockHeight * 16);

			sb = new StringBuilder();
			sb.append(keyStub);
			sb.append("_").append(glowRadius[i]);
			String key = sb.toString();

			// If the sheet is currently in use, then (because keys are unique
			// and exact)
			// it has already been filled with the right data. If the sheet is
			// not in use,
			// but our rendered draw settings are not null, then (because the
			// key is unique
			// and exact, AND because we always make sure to set
			// renderedDrawSettings to
			// null open a failure to setDrawSettings) it has already been
			// filled with the
			// right data.
			if (preallocated.hasSheetBitmapInUse(key)
					|| (preallocated.hasSheetBitmap(key) && preallocated
							.getRenderedDrawSettings() != null))
				glowSheets[i] = preallocated.getSheetBitmap(key);

			if (glowSheets[i] == null) {
				// a new sheet bitmap.
				glowSheets[i] = preallocated.getSheetBitmap(key);

				if (glowSheets[i] == null) {
					glowSheets[i] = Bitmap.createBitmap(sheetBlockWidth * 16,
							sheetBlockHeight * 16, Bitmap.Config.ALPHA_8);
					if ( GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP )
						log("Allocate Bitmap: create glow sheet");
				}

				Canvas sheetCanvas = new Canvas(glowSheets[i]);
				sheetCanvas.drawPaint(clearPaint);

				try {
					drawShadowSheet(mDrawSettings, context, mLoadIntoBitmapSheet,
							SHEET_SET_EXACT,
							glowRadius[i], 0, 0, sheetCanvas, null,
							sheetBlockWidth, sheetBlockHeight, 1); // we
																	// filter
																	// color/alpha
																	// at
																	// render
																	// time

				} catch (IOException e) {
					e.printStackTrace();
					throw new RuntimeException("Error when drawing glow sheet");
				}
			} else if (GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP)
				log( 
						"skipping glow sheet as we already have a rendered sheet to match");
		}

	}

	private void prerenderNormalizedGlowSheets(Context context,
			BlockDrawerPreallocatedBitmaps preallocated, Bitmap[] glowSheets,
			Rect[] glowSheetBounds, float[] glowRadius) {

		// For now, we render
		// as white-with-alpha "glow" layers that are
		// drawn with a ColorFilter applying a new alpha and (optionally) color.
		// 1. block height, width (obviously)
		// 2. glow gaussian radius
		//
		// It is important to note that although Quantro and Retro lock glows
		// are drawn very differently (in short, Retro BLOCKS glow, Quantro
		// SEAMS
		// glow), this method prepares an identical structure in each case
		// - a "glow sheet" bitmap. Thus, this method is completely agnostic
		// w.r.t. Quantro or Retro mode (and w.r.t. the particular type of
		// glow it represents - lock, clear, etc.).

		// NOTE: Ensure that the resulting Key uniquely and exactly describes
		// the
		// Bitmap, EVEN IF DRAW SETTINGS CHANGE.
		StringBuilder sb = new StringBuilder();
		sb.append("glowSheetNormalized");
		sb.append("_").append(sheetBlockWidth);
		sb.append("_").append(sheetBlockHeight);
		String keyStub = sb.toString();

		for (int i = 0; i < glowRadius.length; i++) {

			glowSheetBounds[i] = new Rect(0, 0, sheetBlockWidth * 16,
					sheetBlockHeight * 16);

			sb = new StringBuilder();
			sb.append(keyStub);
			sb.append("_").append(glowRadius[i]);
			String key = sb.toString();

			// If the sheet is currently in use, then (because keys are unique
			// and exact)
			// it has already been filled with the right data. If the sheet is
			// not in use,
			// but our rendered draw settings are not null, then (because the
			// key is unique
			// and exact, AND because we always make sure to set
			// renderedDrawSettings to
			// null open a failure to setDrawSettings) it has already been
			// filled with the
			// right data.
			if (preallocated.hasSheetBitmapInUse(key)
					|| (preallocated.hasSheetBitmap(key) && preallocated
							.getRenderedDrawSettings() != null))
				glowSheets[i] = preallocated.getSheetBitmap(key);

			if (glowSheets[i] == null) {
				// a new sheet bitmap.
				glowSheets[i] = preallocated.getSheetBitmap(key);

				if (glowSheets[i] == null) {
					glowSheets[i] = Bitmap.createBitmap(sheetBlockWidth * 16,
							sheetBlockHeight * 16, Bitmap.Config.ALPHA_8);
					if ( GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP )
						log("Allocate Bitmap: create normalized glow sheet");
				}

				// draw two shadows: edge and offset.
				Canvas sheetCanvas = new Canvas(glowSheets[i]);
				sheetCanvas.drawPaint(clearPaint);
				try {
					drawShadowSheet(mDrawSettings, context, mLoadIntoBitmapSheet,
							SHEET_SET_EXACT,
							glowRadius[i], 0, 0, sheetCanvas, null,
							sheetBlockWidth, sheetBlockHeight, 3.5f); // we
																		// filter
																		// color/alpha
																		// at
																		// render
																		// time

				} catch (IOException e) {
					e.printStackTrace();
					throw new RuntimeException("Error when drawing glow sheet");
				}
			} else if (GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP)
				log( 
						"skipping normalized glow sheet as we already have a rendered sheet to match");
		}

	}

	private void presetGlowPaths(Context context, Path[][] pathArray,
                                 int[] glowRadius) {
		// Regions are (0,0) oriented collections of rectangles, based on the
		// connectivity of the neighbors.

		for (int i = 0; i < glowRadius.length; i++) {

			int size = glowRadius[i];

			pathArray[i] = new Path[256];

			int bWidth = mDrawSettings.size_blockWidth;
			int bHeight = mDrawSettings.size_blockHeight;

			tempConnected[1][1] = true;
			for (int a = 0; a < 2; a++) {
				for (int b = 0; b < 2; b++) {
					for (int c = 0; c < 2; c++) {
						for (int d = 0; d < 2; d++) {
							for (int e = 0; e < 2; e++) {
								for (int f = 0; f < 2; f++) {
									for (int g = 0; g < 2; g++) {
										for (int h = 0; h < 2; h++) {
											tempConnected[0][0] = a == 0;
											tempConnected[0][1] = b == 0;
											tempConnected[0][2] = c == 0;
											tempConnected[1][0] = d == 0;
											tempConnected[1][2] = e == 0;
											tempConnected[2][0] = f == 0;
											tempConnected[2][1] = g == 0;
											tempConnected[2][2] = h == 0;

											indexByNeighbors_sanityFix(
													tempConnected, 1, 1);
											int neighborIndex = indexByNeighbors(
													tempConnected, 1, 1);

											Path p = path();
											// remember, temp connected is
											// (x,y), not row,col.
											if (!tempConnected[0][0])
												unionRect(p, 0, 0, size, size,
														Path.Direction.CW);
											if (!tempConnected[0][1])
												unionRect(p, 0, 0, size, bHeight,
														Path.Direction.CW);
											if (!tempConnected[0][2])
												unionRect(p, 0, bHeight - size, size,
														bHeight,
														Path.Direction.CW);
											if (!tempConnected[1][0])
												unionRect(p, 0, 0, bWidth, size,
														Path.Direction.CW);
											if (!tempConnected[1][2])
												unionRect(p, 0, bHeight - size, bWidth,
														bHeight,
														Path.Direction.CW);
											if (!tempConnected[2][0])
												unionRect(p, bWidth - size, 0, bWidth,
														size, Path.Direction.CW);
											if (!tempConnected[2][1])
												unionRect(p, bWidth - size, 0, bWidth,
														bHeight,
														Path.Direction.CW);
											if (!tempConnected[2][2])
												unionRect(p, bWidth - size, bHeight
														- size, bWidth,
														bHeight,
														Path.Direction.CW);

											pathArray[i][neighborIndex] = p;
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	private void preallocateGlowFilters() {
		if (mDrawSettings.drawAnimations != DrawSettings.DRAW_ANIMATIONS_NONE) {
			if (mDrawSettings.glowDrawStyle == DrawSettings.GLOW_DRAW_STYLE_FLARE) {
				// flares use a color matrix color filter to scale alpha
				// arbitrarily.
				// find the max glow alpha...
				float maxAlphaNormalized = 0;
				for (int i = 0; i < mDrawSettings.glow_alphaPeakNormalized.length; i++) {
					if (mDrawSettings.glow_alphaPeakNormalized[i] != null) {
						for (int j = 0; j < mDrawSettings.glow_alphaPeakNormalized[i].length; j++) {
							maxAlphaNormalized = Math
									.max(maxAlphaNormalized,
											mDrawSettings.glow_alphaPeakNormalized[i][j]);
						}
					}
				}

				ALPHA_SCALE_STEP_MULTIPLE = maxAlphaNormalized
						/ ALPHA_SCALE_NUM_STEPS;

				alphaScaleMatrix_byAlphaScaleStepMultiple = new ColorMatrixColorFilter[ALPHA_SCALE_NUM_STEPS];
				for (int i = 0; i < ALPHA_SCALE_NUM_STEPS; i++) {
					float a = i * ALPHA_SCALE_STEP_MULTIPLE;
					ColorMatrixColorFilter filter = new ColorMatrixColorFilter(
							new float[] { 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
									1, 0, 0, 0, 0, 0, a, 0 });
					alphaScaleMatrix_byAlphaScaleStepMultiple[i] = filter;
				}
			}
		}
	}

	private void createGlowColorFilters() {

		// We create a Hashtable of color filters, indexed by color (as an
		// Integer).
		// Create these by iterating through every qOrientation and lightening
		// amount
		// present in our glow settings.
		glowColorFilter_byColor = new SparseArray<ColorFilter>();

		int color;

		// for completeness, we iterate over ALL glows.
		for (int glowType = 0; glowType < Consts.NUM_GLOWS; glowType++) {
			for (int i = 0; i < mDrawSettings.glow_color[glowType].length; i++) {
				if (mDrawSettings.glow_color[glowType][i] == DrawSettings.GlowColor.WHITE) {
					// white: independent of qorientation.
					color = ColorOp
							.shade(mDrawSettings.glow_lightenBy[glowType][i]);
					color = ColorOp.setAlphaForColor(255, color);
					if (glowColorFilter_byColor.get(color) == null) {
						glowColorFilter_byColor.put(color,
								new LightingColorFilter(0, color));
					}
				} else {
					// Iterate through all QOrientations featured in the game.
					for (int qo_index = 0; qo_index < mDrawSettings.qo.length; qo_index++) {
						for (int qp = 0; qp < 2; qp++) {
							int qo = mDrawSettings.qo[qo_index];
							color = ColorOp
									.shadeColor(
											mDrawSettings.glow_lightenBy[glowType][i],
											mDrawSettings.color_qOrientationQPaneGlowColor[qo][qp]);
							color = ColorOp.setAlphaForColor(255, color);
							if (glowColorFilter_byColor.get(color) == null) {
								ColorFilter cf = new LightingColorFilter(0,
										color);
								glowColorFilter_byColor.put(color, cf);
								if ( GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP ) {
									log( 
											"making color filter for color "
													+ Color.red(color) + ", "
													+ Color.green(color) + ", "
													+ Color.blue(color)
													+ ", filter is " + cf);
								}
							}

						}
					}
				}
			}
		}
	}

	private void generateInnerBorderShineDrawables(BlockDrawer master) {

		if (master != null && innerBorderShineDrawablesIdentical(this, master)) {
			this.innerBorderShine_byQPaneQOrientationCornerCornerDirection = master.innerBorderShine_byQPaneQOrientationCornerCornerDirection;
			return;
		}

		if (innerBorderShine_byQPaneQOrientationCornerCornerDirection == null)
			innerBorderShine_byQPaneQOrientationCornerCornerDirection = new Drawable[2][QOrientations.NUM][][][];

		// empty.
		for (int qp = 0; qp < 2; qp++)
			for (int i = 0; i < QOrientations.NUM; i++)
				innerBorderShine_byQPaneQOrientationCornerCornerDirection[qp][i] = null;

		// Generate a GradientDrawable for every connected pair of corners.
		// For every corner pair - "top left to top right", for example -
		// there are 4 possible permutations of convexity. We need to
		// handle each one.
		int[][] cornerCombinations = new int[][] {
				// top-left to top-right
				new int[] { DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX,
						DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX },
				new int[] { DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX,
						DrawSettings.CORNER_INNER_LEFT_TOP_CONCAVE },
				new int[] { DrawSettings.CORNER_INNER_RIGHT_TOP_CONCAVE,
						DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX },
				new int[] { DrawSettings.CORNER_INNER_RIGHT_TOP_CONCAVE,
						DrawSettings.CORNER_INNER_LEFT_TOP_CONCAVE },
				// top-left to bottom-left
				new int[] { DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX,
						DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX },
				new int[] { DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX,
						DrawSettings.CORNER_INNER_LEFT_TOP_CONCAVE },
				new int[] { DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONCAVE,
						DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX },
				new int[] { DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONCAVE,
						DrawSettings.CORNER_INNER_LEFT_TOP_CONCAVE },
				// bottom-left to bottom-right
				new int[] { DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX,
						DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX },
				new int[] { DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX,
						DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONCAVE },
				new int[] { DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONCAVE,
						DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX },
				new int[] { DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONCAVE,
						DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONCAVE },
				// top-right to bottom-right
				new int[] { DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX,
						DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX },
				new int[] { DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX,
						DrawSettings.CORNER_INNER_RIGHT_TOP_CONCAVE },
				new int[] { DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONCAVE,
						DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX },
				new int[] { DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONCAVE,
						DrawSettings.CORNER_INNER_RIGHT_TOP_CONCAVE }, };

		int[] directions = new int[] {
				// top-left to top-right
				DIRECTION_RIGHT,
				DIRECTION_RIGHT,
				DIRECTION_RIGHT,
				DIRECTION_RIGHT,
				// top-left to bottom-left
				DIRECTION_DOWN,
				DIRECTION_DOWN,
				DIRECTION_DOWN,
				DIRECTION_DOWN,
				// bottom-left to bottom-right
				DIRECTION_RIGHT,
				DIRECTION_RIGHT,
				DIRECTION_RIGHT,
				DIRECTION_RIGHT,
				// top-right to bottom-right
				DIRECTION_DOWN,
				DIRECTION_DOWN,
				DIRECTION_DOWN,
				DIRECTION_DOWN, };

		// Only generate drawables if either color has an alpha > 0, AND this
		// qo exists in the drawSettings, AND has non-default shine behavior.
		for (int qp = 0; qp < 2; qp++) {
			for (int qo_index = 0; qo_index < mDrawSettings.qo.length; qo_index++) {
				byte qo = mDrawSettings.qo[qo_index];
				innerBorderShine_byQPaneQOrientationCornerCornerDirection[qp][qo] = new Drawable[DrawSettings.NUM_CORNERS][][];
				// examine the color values for each possible corner
				// combination.
				for (int i = 0; i < cornerCombinations.length; i++) {
					int c0 = cornerCombinations[i][0];
					int c1 = cornerCombinations[i][1];

					if (innerBorderShine_byQPaneQOrientationCornerCornerDirection[qp][qo][c0] == null)
						innerBorderShine_byQPaneQOrientationCornerCornerDirection[qp][qo][c0] = new Drawable[DrawSettings.NUM_CORNERS][BlockDrawer.NUM_SHINE_DIRECTIONS];

					// make a gradient Drawable. I'm reluctant to use
					// the cache for this, even though I expect many
					// drawables
					// will be the same; other BlockDrawers can read
					// from the cache, and Drawables are mutable - in fact,
					// we rely on their mutability when drawing with
					// different
					// alphas.
					int d = directions[i] ;
					if (c0 == c1)
						d = DIRECTION_NONE;
					
					Drawable borderDrawable = this.makeBorderDrawable(mDrawSettings, qp, qo, false, c0, c1, d) ;
					
					innerBorderShine_byQPaneQOrientationCornerCornerDirection[qp][qo][c0][c1][d] = borderDrawable ;
				}
			}
		}
	}

	private static final boolean innerBorderShineDrawablesIdentical(
			BlockDrawer bd1, BlockDrawer bd2) {
		// the two will have identical BorderShine drawables if
		// every QO has identical shine behavior, the same QOs are represented
		// in
		// their draw settings, and the shine colors themselves match.

		// This method will never produce a false positive; however, it might
		// produce false negatives.

		for (int qp = 0; qp < 2; qp++)
			for (byte qo = 0; qo < QOrientations.NUM; qo++)
				for (int j = 0; j < DrawSettings.NUM_CORNERS; j++)
					if (bd1.mDrawSettings.getColor_borderShine(qp, qo, j) != bd2.mDrawSettings.getColor_borderShine(qp, qo, j))
						return false;

		if (bd1.mDrawSettings.qo.length != bd2.mDrawSettings.qo.length)
			return false;
		for (int i = 0; i < bd1.mDrawSettings.qo.length; i++)
			if (bd1.mDrawSettings.qo[i] != bd2.mDrawSettings.qo[i])
				return false;

		return true;
	}
	
	
	/**
	 * Constructs and returns a Drawable suitable for drawing the specified block
	 * border and all included shines.
	 * 
	 * If 'includeBorder' is true, the drawable will include the underlying border
	 * color.  If false, only the shine will be drawn, making the returned object
	 * suitable for drawing the shine OVER an existing border color patch.
	 * @param qPane
	 * @param qOrientation
	 * @param includeBorder
	 * @param cornerFrom
	 * @param cornerTo
	 * @param direction
	 * @return
	 */
	private Drawable makeBorderDrawable(
			DrawSettings ds,
			int qPane, byte qOrientation,
			boolean includeBorder, int cornerFrom, int cornerTo, int direction ) {
		
		Drawable [] layers = new Drawable[ds.getNumber_borderShine(qPane, qOrientation) + (includeBorder ? 1 : 0)] ;
		int index = 0 ;
		if ( includeBorder ) {
			layers[index++] = makeBorderLayerDrawable( ds, qPane, qOrientation, -1, cornerFrom, cornerTo, direction ) ;
		}
		
		for ( int i = 0; i < ds.getNumber_borderShine(qPane, qOrientation); i++ ) {
			layers[index++] = makeBorderLayerDrawable( ds, qPane, qOrientation, i, cornerFrom, cornerTo, direction) ;
		}
		
		if ( layers.length == 1 )
			return layers[0] ;
		
		return new LayerDrawable( layers ) ;
		
	}
	
	
	/**
	 * Makes the appropriate Drawable for the specified "layer number."
	 * 
	 * Layer numbers :
	 * 
	 * -1: the border color itself, as a fixed-color GradientDrawable.
	 * 0: shine number 0, if present in DrawSettings, otherwise error.
	 * ...
	 * k: shine number k, if present in DrawSettings, otherwise error.
	 *
     * @param ds
	 * @param qPane
	 * @param qOrientation
     * @param layerNumber
	 * @param cornerFrom
	 * @param cornerTo
	 * @param direction
	 * @return
	 */
	private Drawable makeBorderLayerDrawable(
			DrawSettings ds,
			int qPane, byte qOrientation,
			int layerNumber, int cornerFrom, int cornerTo, int direction ) {
		
		if ( layerNumber == -1 ) {
			int color = ds.color_qOrientationQPaneBorder[qOrientation][qPane] ;
			return new GradientDrawable( GradientDrawable.Orientation.LEFT_RIGHT,
					new int[] { color, color } ) ;
		} else {
			int [] colors = ds.getColor_borderShine(qPane, qOrientation, layerNumber, cornerFrom, cornerTo) ;
			float [] positions = ds.getPositions_borderShine(qPane, qOrientation, layerNumber, cornerFrom, cornerTo) ;
			
			if ( colors == null )
				return null ;
			
			return makeGradientDrawable( colors, positions, direction ) ;
		}
	}
	

	private void prerenderCustomBorderShine(Context context,
			BlockDrawerPreallocatedBitmaps preallocated) {
		if (customBorderShine_byQPaneQOrientation == null) {
			customBorderShine_byQPaneQOrientation = new Bitmap[2][QOrientations.NUM];
			customBorderShineBounds_byQPaneQOrientation = new Rect[2][QOrientations.NUM];
		}

		for (int qp = 0; qp < 2; qp++) {
			for (int i = 0; i < QOrientations.NUM; i++) {
				customBorderShine_byQPaneQOrientation[qp][i] = null;
				customBorderShineBounds_byQPaneQOrientation[qp][i] = null;
			}
		}

		// Because of the sheer number of details going into configuring
		// this shine, and its basic simplity, we don't bother storing it in the
		// cache.
		boolean[][] created = new boolean[2][QOrientations.NUM];
		for (int qc = 0; qc < QCombinations.NUM; qc++) {
			for (int qp = 0; qp < 2; qp++) {
				byte qo = QCombinations.expandedPane(qc, qp);
				if (created[qp][qo])
					continue;
				boolean has = false;
				for (int i = 0; i < mDrawSettings.qo.length; i++)
					if (mDrawSettings.qo[i] == qo)
						has = true;
				if (!has)
					continue;
				created[qp][qo] = true;
				if (mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INSET
						|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI
						|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_HORIZONTAL_OVER
						|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_VERTICAL_OVER) {

					int outerLeft, outerTop, outerRight, outerBottom;
					int innerLeft, innerTop, innerRight, innerBottom;

					// We assume that the inner border shines have already been
					// generated.
					// An inset border is just an inner border, slightly inset,
					// that covers
					// exactly one square. We can easily prerender this as a
					// bitmap to
					// be applied over the entire square.
					if (mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INSET) {
						outerLeft = mDrawSettings.size_innerBorderXInset;
						outerTop = mDrawSettings.size_innerBorderYInset;
						outerRight = mDrawSettings.size_blockWidth
								- mDrawSettings.size_innerBorderXInset;
						outerBottom = mDrawSettings.size_blockHeight
								- mDrawSettings.size_innerBorderYInset;
						innerLeft = outerLeft
								+ mDrawSettings.size_innerBorderWidth;
						innerTop = outerTop
								+ mDrawSettings.size_innerBorderHeight;
						innerRight = outerRight
								- mDrawSettings.size_innerBorderWidth;
						innerBottom = outerBottom
								- mDrawSettings.size_innerBorderHeight;
					} else {
						outerLeft = mDrawSettings.size_miniBorderXInset;
						outerTop = mDrawSettings.size_miniBorderYInset;
						outerRight = mDrawSettings.size_blockWidth
								- mDrawSettings.size_miniBorderXInset;
						outerBottom = mDrawSettings.size_blockHeight
								- mDrawSettings.size_miniBorderYInset;
						innerLeft = outerLeft
								+ mDrawSettings.size_miniBorderWidth;
						innerTop = outerTop
								+ mDrawSettings.size_miniBorderHeight;
						innerRight = outerRight
								- mDrawSettings.size_miniBorderWidth;
						innerBottom = outerBottom
								- mDrawSettings.size_miniBorderHeight;
					}
					
					// This block describes a "complete" square border, with four corners and
					// four walls.  Corners are easy: just write the corner shine colors,
					// since they are already "aggregated" and contain all successive shine draws.
					// Walls require access to the colors and position of the border shines.
					
					int shineTL = mDrawSettings.getColor_borderShine(qp, qo, DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX) ;
					int shineTR = mDrawSettings.getColor_borderShine(qp, qo, DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX) ;
					int shineBL = mDrawSettings.getColor_borderShine(qp, qo, DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX) ;
					int shineBR = mDrawSettings.getColor_borderShine(qp, qo, DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX) ;

					int [][][] sideColors = new int[4][mDrawSettings.getNumber_borderShine(qp, qo)][] ;
					float [][][] sidePositions = new float[4][mDrawSettings.getNumber_borderShine(qp, qo)][] ;
					for ( int wall = 0; wall < NUM_WALL_SIDES; wall++ ) {
						int c0 = -1, c1 = -1;
						switch( wall ) {
						case WALL_SIDE_LEFT:
							c0 = DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX ;
							c1 = DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX ;
							break ;
						case WALL_SIDE_RIGHT:
							c0 = DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX ;
							c1 = DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX ;
							break ;
						case WALL_SIDE_TOP:
							c0 = DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX ;
							c1 = DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX ;
							break ;
						case WALL_SIDE_BOTTOM:
							c0 = DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX ;
							c1 = DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX ;
							break ;
						}
						for ( int shineNum = 0; shineNum < mDrawSettings.getNumber_borderShine(qp, qo); shineNum++ ) {
							sideColors[wall][shineNum] = mDrawSettings.getColor_borderShine(qp, qo, shineNum, c0, c1) ;
							sidePositions[wall][shineNum] = mDrawSettings.getPositions_borderShine(qp, qo, shineNum, c0, c1) ;
						}
					}
					
					// Define this shine using the 8 positions and 4 colors. If
					// CHAIN_LINK, also
					// include the border behavior and qp.
					StringBuilder sb = new StringBuilder();
					sb.append("customBorderShine");
					sb.append("_").append(outerLeft).append("_")
							.append(innerLeft);
					sb.append("_").append(outerRight).append("_")
							.append(innerRight);
					sb.append("_").append(outerTop).append("_")
							.append(innerTop);
					sb.append("_").append(outerBottom).append("_")
							.append(innerBottom);
					
					sb.append("_").append(shineTL).append("_").append(shineTR);
					sb.append("_").append(shineBL).append("_").append(shineBR);
					for ( int wall = 0; wall < NUM_WALL_SIDES; wall++ ) {
						sb.append("_w").append(wall) ;
						for ( int shineNum = 0; shineNum < mDrawSettings.getNumber_borderShine(qp, qo); shineNum++ ) {
							sb.append("_s").append(shineNum) ;
							for ( int k = 0; k < sideColors[wall][shineNum].length; k++ ) {
								sb.append("_c").append(sideColors[wall][shineNum][k]) ;
								if ( sidePositions[wall][shineNum] != null )
									sb.append("_p").append(sidePositions[wall][shineNum][k]) ;
							}
						}
					}

					if (mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_HORIZONTAL_OVER
							|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_VERTICAL_OVER) {

						sb.append("_").append(
								mDrawSettings.behavior_qo_border[qo]);
						sb.append("_").append(qp);
					}

					String key = sb.toString();

					boolean rendered = preallocated
							.hasBlockSizeBitmapInUse(key)
							|| (preallocated.hasBlockSizeBitmap(key) && preallocated
									.getRenderedDrawSettings() != null);

					Bitmap b = preallocated.getBlockSizeBitmap(key,
							mDrawSettings.size_blockWidth,
							mDrawSettings.size_blockHeight,
							Bitmap.Config.ARGB_8888);

					if (b == null) {
						b = Bitmap.createBitmap(
								mDrawSettings.size_blockWidth,
								mDrawSettings.size_blockHeight,
								Bitmap.Config.ARGB_8888);
						if ( GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP )
							log("Allocate Bitmap: create custom border shine");
					}

					if (!rendered) {

						Canvas canvas = new Canvas(b);
						canvas.drawPaint(clearPaint);

						// Apply a region if we're using one; in particular, if
						// we
						// have
						// HORIZONTAL_OVER or VERTICAL_OVER.
						if (mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_HORIZONTAL_OVER
								|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_VERTICAL_OVER) {
						    canvas.clipPath(customBorderPath_byQPane_QOrientation[qp][qo]);
						}

						// draw the 4 corners, then connect them.
						tempColorPaint.setColor(shineTL);
						canvas.drawRect(outerLeft, outerTop, innerLeft,
								innerTop, tempColorPaint);
						tempColorPaint.setColor(shineTR);
						canvas.drawRect(innerRight, outerTop, outerRight,
								innerTop, tempColorPaint);
						tempColorPaint.setColor(shineBL);
						canvas.drawRect(outerLeft, innerBottom, innerLeft,
								outerBottom, tempColorPaint);
						tempColorPaint.setColor(shineBR);
						canvas.drawRect(innerRight, innerBottom, outerRight,
								outerBottom, tempColorPaint);

						Drawable[][][] innerBorderShine = innerBorderShine_byQPaneQOrientationCornerCornerDirection[qp][qo];

						Drawable d;
						d = innerBorderShine[DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX][DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX][BlockDrawer.DIRECTION_RIGHT];
						d.setBounds(innerLeft, outerTop, innerRight, innerTop);
						d.draw(canvas);

						d = innerBorderShine[DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX][DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX][BlockDrawer.DIRECTION_DOWN];
						d.setBounds(outerLeft, innerTop, innerLeft, innerBottom);
						d.draw(canvas);

						d = innerBorderShine[DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX][DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX][BlockDrawer.DIRECTION_DOWN];
						d.setBounds(innerRight, innerTop, outerRight,
								innerBottom);
						d.draw(canvas);

						d = innerBorderShine[DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX][DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX][BlockDrawer.DIRECTION_RIGHT];
						d.setBounds(innerLeft, innerBottom, innerRight,
								outerBottom);
						d.draw(canvas);

						if (mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_HORIZONTAL_OVER
								|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_VERTICAL_OVER) {

							// CHAIN LINK BORDER SELF-SHADOW
							// HACK HACK HACK!!! This is technically a shadow
							// and
							// shouldn't be drawn as a border shine, but this is
							// a
							// convenient way to set it up and we need to get
							// things
							// moving. We already have a clip region, so we
							// could
							// just draw the shadow on top.
							// TODO: Move this to a real shadow layer.
							try {
								renderFullSizeEdgeShadowToRenderScratch(
										mDrawSettings, context, 1);
							} catch (IOException e) {
								e.printStackTrace();
								throw new RuntimeException(
										"Failed loading shadow data");
							}

							// render!
							int[] xOffset = new int[2];
							int[] yOffset = new int[2];
							clipPath.set(customBorderPath_byQPane_QOrientation[qp][qo]);
							if (mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_HORIZONTAL_OVER) {
								// shadows on the vertical portion. Try to put
								// the
								// center of
								// the shadow at the x-coordinate of the
								// intersected
								// vertical
								// bar. If qpane offset goes right from this qp,
								// move right,
								// otherwise left. This is a hack, remember, so
								// try
								// just
								// offsetting by 1/2 block width (even though
								// this
								// doesn't
								// exactly center the shadow bitmap over the
								// center
								// of the border
								// bar).
								xOffset[0] = xOffset[1] = (mDrawSettings
										.size_qXOffset > 0 == (qp == 0)) ? mDrawSettings
										.size_qXOffset : -mDrawSettings
										.size_qXOffset;
								// Clip to only this edge.
								if (xOffset[0] > 0) {
                                    reset(tempPath);
								    unionRect(tempPath, 
                                            mDrawSettings.size_blockWidth
                                                    - mDrawSettings.size_miniBorderXInset
                                                    - mDrawSettings.size_miniBorderWidth,
                                            0,
                                            mDrawSettings.size_blockWidth,
                                            mDrawSettings.size_blockHeight,
                                            Path.Direction.CW
                                    );
								   op(clipPath, tempPath, Path.Op.INTERSECT);
								} else {
                                    reset(tempPath);
								    unionRect(tempPath, 0, 0,
													mDrawSettings.size_miniBorderXInset
															+ mDrawSettings.size_miniBorderWidth,
													mDrawSettings.size_blockHeight,
													Path.Direction.CW);
								    op(clipPath, tempPath, Path.Op.INTERSECT);
								}
								// Now we need to draw twice, with two different
								// y
								// offsets;
								// one for each end coming out from under the
								// border.
								int qYOffAbs = Math.abs(mDrawSettings
										.size_qYOffset);
								if (mDrawSettings.size_qYOffset > 0 == (qp == 0)) {
									// qoffset moves down.
									yOffset[0] = mDrawSettings.size_miniBorderYInset
											+ qYOffAbs
											+ mDrawSettings.size_miniBorderHeight;
									yOffset[1] = -mDrawSettings
											.size_blockHeight
											+ qYOffAbs
											+ mDrawSettings.size_miniBorderYInset;
								} else {
									// qoffset moves up.
									yOffset[0] = -qYOffAbs
											- mDrawSettings.size_miniBorderYInset
											- mDrawSettings.size_miniBorderHeight;
									yOffset[1] = mDrawSettings
											.size_blockHeight
											- qYOffAbs
											- mDrawSettings.size_miniBorderYInset;
								}
							} else if (mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_VERTICAL_OVER) {
								// shadows on the horizontal portion.
								yOffset[0] = yOffset[1] = (mDrawSettings
										.size_qYOffset > 0 == (qp == 0)) ? mDrawSettings
										.size_qYOffset : -mDrawSettings
										.size_qYOffset;
								// Clip to only this edge.
								if (yOffset[0] > 0) {
                                    reset(tempPath);
								    unionRect(tempPath, 0,
													mDrawSettings
															.size_blockHeight
															- mDrawSettings.size_miniBorderYInset
															- mDrawSettings.size_miniBorderHeight,
													mDrawSettings
															.size_blockWidth,
													mDrawSettings
															.size_blockHeight,
													Path.Direction.CW);
								    op(clipPath, tempPath, Path.Op.INTERSECT);
								} else {
                                    reset(tempPath);
								    unionRect(tempPath, 0,
													0,
													mDrawSettings
															.size_blockWidth,
													mDrawSettings.size_miniBorderYInset
															+ mDrawSettings.size_miniBorderHeight,
													Path.Direction.CW);
								    op(clipPath, tempPath, Path.Op.INTERSECT);
								}
								int qXOffAbs = Math.abs(mDrawSettings
										.size_qXOffset);
								if (mDrawSettings.size_qXOffset > 0 == (qp == 0)) {
									xOffset[0] = -mDrawSettings
											.size_blockWidth + qXOffAbs;
									xOffset[1] = qXOffAbs
											+ mDrawSettings.size_miniBorderWidth;
								} else {
									// qoffset moves left
									xOffset[0] = -qXOffAbs
											- mDrawSettings.size_miniBorderWidth;
									xOffset[1] = mDrawSettings
											.size_blockWidth - qXOffAbs;
								}
								if (mDrawSettings.size_qXOffset > 0 == (qp == 0)) {
									// qoffset moves down.
									xOffset[0] = mDrawSettings.size_miniBorderXInset
											+ qXOffAbs
											+ mDrawSettings.size_miniBorderWidth;
									xOffset[1] = -mDrawSettings
											.size_blockWidth
											+ qXOffAbs
											+ mDrawSettings.size_miniBorderXInset;
								} else {
									// qoffset moves up.
									xOffset[0] = -qXOffAbs
											- mDrawSettings.size_miniBorderXInset
											- mDrawSettings.size_miniBorderWidth;
									xOffset[1] = mDrawSettings
											.size_blockWidth
											- qXOffAbs
											- mDrawSettings.size_miniBorderXInset;
								}
							}

							canvas.clipPath(clipPath);
							canvas.drawBitmap(renderScratchBitmap, xOffset[0],
									yOffset[0], null);
							canvas.drawBitmap(renderScratchBitmap, xOffset[1],
									yOffset[1], null);
						}
					}

					customBorderShine_byQPaneQOrientation[qp][qo] = b;
					customBorderShineBounds_byQPaneQOrientation[qp][qo] = new Rect(
							0, 0, mDrawSettings.size_blockWidth,
							mDrawSettings.size_blockHeight);
				}
			}
		}
	}

	private void generateCustomFillRegions() {

		if (customFillPath_byQPane_QOrientation == null)
			customFillPath_byQPane_QOrientation = new Path[2][QOrientations.NUM];

		// set nulls
		for (int q = 0; q < 2; q++)
			for (int i = 0; i < QOrientations.NUM; i++)
				customFillPath_byQPane_QOrientation[q][i] = null;

		// Generate bitmaps according to DrawSettings...
		boolean[][] created = new boolean[2][QOrientations.NUM];
		for (int qc = 0; qc < QCombinations.NUM; qc++) {
			for (int qp = 0; qp < 2; qp++) {
				int qo = QCombinations.expandedPane(qc, qp);
				if (created[qp][qo])
					continue;
				created[qp][qo] = true;
				if (mDrawSettings.behavior_qo_fill[qo] == DrawSettings.BEHAVIOR_QO_FILL_PAINT_Q_ORIENTATION_MINI_NONOVERLAP) {

					// Create a region which covers the mini area, but NOT that
					// covered by
					// the other mini region in the other qpane. There are a few
					// complications.
					Path path = path();
					// get the boundaries of this rect, and set
                    unionRect(path, 
                            mDrawSettings.size_miniBorderXInset,
                            mDrawSettings.size_miniBorderYInset,
                            mDrawSettings.size_blockWidth - mDrawSettings.size_miniBorderXInset,
                            mDrawSettings.size_blockHeight - mDrawSettings.size_miniBorderYInset,
                            Path.Direction.CW);
					// get the "outer region" of the other QPane, which DOES include the border.
                    reset(tempPath);
					unionRect(tempPath, 
							mDrawSettings.size_miniBorderXInset
									+ mDrawSettings.size_qXOffset
									* (qp == 0 ? 1 : -1),
							mDrawSettings.size_miniBorderYInset
									+ mDrawSettings.size_qYOffset
									* (qp == 0 ? 1 : -1),
							mDrawSettings.size_blockWidth
									- mDrawSettings.size_miniBorderXInset
									+ mDrawSettings.size_qXOffset
									* (qp == 0 ? 1 : -1),
							mDrawSettings.size_blockHeight
									- mDrawSettings.size_miniBorderYInset
									+ mDrawSettings.size_qYOffset
									* (qp == 0 ? 1 : -1),
                            Path.Direction.CW);
					// This is the "outer region" of the other QPane.
                    op(path, tempPath, Path.Op.DIFFERENCE);

					// Okay, we have (almost) everything. What we DON'T have is
					// the border of
					// this block, where that border passes into the other
					// QPane's fill region.
					// This is fine for drawing the block itself, since we would
					// cover this with
					// a border anyway. However, it's NOT fine for ghosts; we
					// end up with a strange
					// looking set of "L" shapes, not the locked boxes we
					// expect. To fix this,
					// take the union of this and the associated custom border
					// region.
                    op(path, this.customBorderPath_byQPane_QOrientation[qp][qo], Path.Op.UNION);

					customFillPath_byQPane_QOrientation[qp][qo] = path;
				}
			}
		}
	}

	private void generateInnerBorderPaths() {
		if (this.innerBorderPath_byNeighbors == null)
			innerBorderPath_byNeighbors = new Path[BlockDrawer
					.indexByNeighbors_num()];

		int bW = mDrawSettings.size_borderWidth;
		int bH = mDrawSettings.size_borderHeight;

		// each should be a region, aligned to 0,0, of the area covered by the
		// inner border
		// according to the provided "connected" array. Remember that inner
		// borders
		// are sanity-fixed.
		for (int index = 0; index < indexByNeighbors_num(); index++) {
			neighborsByIndex(index, tempConnected, 1, 1);
			indexByNeighbors_sanityFix(tempConnected, 1, 1);

			// construct a region for this.
			Path p = path();

			// include the appropriate rectangles. we try to use no more than 4.
			if (!tempConnected[0][1]) // left edge
				unionRect(p, 0, 0, bW, mDrawSettings.size_blockHeight,
						Path.Direction.CW);
			if (!tempConnected[1][0]) // top edge
				unionRect(p, 0, 0, mDrawSettings.size_blockWidth, bH,
						Path.Direction.CW);
			if (!tempConnected[2][1]) // right edge
				unionRect(p, mDrawSettings.size_blockWidth - bW, 0,
						mDrawSettings.size_blockWidth,
						mDrawSettings.size_blockHeight, Path.Direction.CW);
			if (!tempConnected[1][2]) // bottom edge
				unionRect(p, 0, mDrawSettings.size_blockHeight - bH,
						mDrawSettings.size_blockWidth,
						mDrawSettings.size_blockHeight, Path.Direction.CW);

			// now the corners. Don't bother including if we already have
			// a side that covers them.
			if (!tempConnected[0][0]
					&& (tempConnected[0][1] && tempConnected[1][0])) // top-left
				unionRect(p, 0, 0, bW, bH, Path.Direction.CW);
			if (!tempConnected[2][0]
					&& (tempConnected[2][1] && tempConnected[1][0])) // top-right
				unionRect(p, mDrawSettings.size_blockWidth - bW, 0,
						mDrawSettings.size_blockWidth, bH, Path.Direction.CW);
			if (!tempConnected[0][2]
					&& (tempConnected[0][1] && tempConnected[1][2])) // bottom-left
				unionRect(p, 0, mDrawSettings.size_blockHeight - bH, bW,
						mDrawSettings.size_blockHeight, Path.Direction.CW);
			if (!tempConnected[2][2]
					&& (tempConnected[2][1] && tempConnected[1][2])) // bottom-right
				unionRect(p, mDrawSettings.size_blockWidth - bW,
						mDrawSettings.size_blockHeight - bH,
						mDrawSettings.size_blockWidth,
						mDrawSettings.size_blockHeight, Path.Direction.CW);

            innerBorderPath_byNeighbors[index] = p;
		}
	}

	private void generateCustomBorderPaths() {

		if (customBorderPath_byQPane_QOrientation == null)
			customBorderPath_byQPane_QOrientation = new Path[2][QOrientations.NUM];

		// set nulls
		for (int q = 0; q < 2; q++)
			for (int i = 0; i < QOrientations.NUM; i++)
				customBorderPath_byQPane_QOrientation[q][i] = null;

		// Generate bitmaps according to DrawSettings...
		boolean[][] created = new boolean[2][QOrientations.NUM];
		for (int qc = 0; qc < QCombinations.NUM; qc++) {
			for (int qp = 0; qp < 2; qp++) {
				int qo = QCombinations.expandedPane(qc, qp);
				if (created[qp][qo])
					continue;
				created[qp][qo] = true;
				if (mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_HORIZONTAL_OVER
						|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_VERTICAL_OVER) {

					// Create a path which describes exactly the border area of this
					// qOrientation at this qPane, not including the area where the other
					// QPane overlaps it. First make the region for the border itself.
					Path path = path();
					// get the boundaries of this border
                    unionRect(path, mDrawSettings.size_miniBorderXInset,
							mDrawSettings.size_miniBorderYInset,
							mDrawSettings.size_blockWidth
									- mDrawSettings.size_miniBorderXInset,
							mDrawSettings.size_blockHeight
									- mDrawSettings.size_miniBorderYInset,
                            Path.Direction.CW);
					// remove the interior to get exactly the border itself.
                    reset(tempPath);
                    unionRect(tempPath, mDrawSettings.size_miniBorderXInset
							+ mDrawSettings.size_miniBorderWidth,
							mDrawSettings.size_miniBorderYInset
									+ mDrawSettings.size_miniBorderHeight,
							mDrawSettings.size_blockWidth
									- mDrawSettings.size_miniBorderXInset
									- mDrawSettings.size_miniBorderWidth,
							mDrawSettings.size_blockHeight
									- mDrawSettings.size_miniBorderYInset
									- mDrawSettings.size_miniBorderHeight,
                            Path.Direction.CW);
                    op(path, tempPath, Path.Op.DIFFERENCE);

					// Now we have the border, but the other QPane will pass
					// over it either in vertical
					// or horizontal. One way to accomplish this is to get the
					// "over" rectangles for
					// the other QPane and subtract them from this region.
					if (mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_VERTICAL_OVER) {
						// Get the "vertical" bars and subtract them.
						tempRectF.set(mDrawSettings.size_miniBorderXInset
								+ mDrawSettings.size_qXOffset
								* (qp == 0 ? 1 : -1),
								mDrawSettings.size_miniBorderYInset
										+ mDrawSettings.size_qYOffset
										* (qp == 0 ? 1 : -1), 0, // we set this
																	// below
								mDrawSettings.size_blockHeight
										- mDrawSettings.size_miniBorderYInset
										+ mDrawSettings.size_qYOffset
										* (qp == 0 ? 1 : -1));
						tempRectF.right = tempRectF.left + mDrawSettings.size_miniBorderWidth;
                        reset(tempPath);
						unionRect(tempPath, tempRectF, Path.Direction.CW);
						op(path, tempPath, Path.Op.DIFFERENCE);

						tempRectF.set(
								0, // we set this below
								mDrawSettings.size_miniBorderYInset
										+ mDrawSettings.size_qYOffset
										* (qp == 0 ? 1 : -1),
								mDrawSettings.size_blockWidth
										- mDrawSettings.size_miniBorderXInset
										+ mDrawSettings.size_qXOffset
										* (qp == 0 ? 1 : -1), // we set this
																// below
								mDrawSettings.size_blockHeight
										- mDrawSettings.size_miniBorderYInset
										+ mDrawSettings.size_qYOffset
										* (qp == 0 ? 1 : -1));
						tempRectF.left = tempRectF.right - mDrawSettings.size_miniBorderWidth;
                        reset(tempPath);
                        unionRect(tempPath, tempRectF, Path.Direction.CW);
						op(path, tempPath, Path.Op.DIFFERENCE);
					} else {
						// Get the "horizontal" bars and subtract them.
						tempRectF.set(mDrawSettings.size_miniBorderXInset
								+ mDrawSettings.size_qXOffset
								* (qp == 0 ? 1 : -1),
								mDrawSettings.size_miniBorderYInset
										+ mDrawSettings.size_qYOffset
										* (qp == 0 ? 1 : -1),
								mDrawSettings.size_blockWidth
										- mDrawSettings.size_miniBorderXInset
										+ mDrawSettings.size_qXOffset
										* (qp == 0 ? 1 : -1), 0); // set below
						tempRectF.bottom = tempRectF.top + mDrawSettings.size_miniBorderHeight;
                        reset(tempPath);
                        unionRect(tempPath, tempRectF, Path.Direction.CW);
						op(path, tempPath, Path.Op.DIFFERENCE);

						tempRectF.set(mDrawSettings.size_miniBorderXInset
								+ mDrawSettings.size_qXOffset
								* (qp == 0 ? 1 : -1),
								0, // we set below
								mDrawSettings.size_blockWidth
										- mDrawSettings.size_miniBorderXInset
										+ mDrawSettings.size_qXOffset
										* (qp == 0 ? 1 : -1),
								mDrawSettings.size_blockHeight
										- mDrawSettings.size_miniBorderYInset
										+ mDrawSettings.size_qYOffset
										* (qp == 0 ? 1 : -1));
						tempRectF.top = tempRectF.bottom - mDrawSettings.size_miniBorderHeight;
                        reset(tempPath);
                        unionRect(tempPath, tempRectF, Path.Direction.CW);
						op(path, tempPath, Path.Op.DIFFERENCE);
					}

					customBorderPath_byQPane_QOrientation[qp][qo] = path;
				}

				else if (mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI) {
					// Create a region which describes exactly the border area
					// of this
					// qOrientation at this qPane.
					Path path = path();
					// get the boundaries of this border
					tempRectF.set(mDrawSettings.size_miniBorderXInset,
							mDrawSettings.size_miniBorderYInset,
							mDrawSettings.size_blockWidth
									- mDrawSettings.size_miniBorderXInset,
							mDrawSettings.size_blockHeight
									- mDrawSettings.size_miniBorderYInset);
					unionRect(path, tempRectF, Path.Direction.CW);
					// remove the interior to get exactly the border itself.
					tempRectF.set(mDrawSettings.size_miniBorderXInset
							+ mDrawSettings.size_miniBorderWidth,
							mDrawSettings.size_miniBorderYInset
									+ mDrawSettings.size_miniBorderHeight,
							mDrawSettings.size_blockWidth
									- mDrawSettings.size_miniBorderXInset
									- mDrawSettings.size_miniBorderWidth,
							mDrawSettings.size_blockHeight
									- mDrawSettings.size_miniBorderYInset
									- mDrawSettings.size_miniBorderHeight);
					reset(tempPath);
					unionRect(tempPath, tempRectF, Path.Direction.CW);
					op(path, tempPath, Path.Op.DIFFERENCE);

					customBorderPath_byQPane_QOrientation[qp][qo] = path;
				}

				else if (mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INSET) {
					// Create a region which describes exactly the border area
					// of this
					// qOrientation at this qPane.
					Path path = path();
					// get the boundaries of this border
					unionRect(path, mDrawSettings.size_innerBorderXInset,
							mDrawSettings.size_innerBorderYInset,
							mDrawSettings.size_blockWidth
									- mDrawSettings.size_innerBorderXInset,
							mDrawSettings.size_blockHeight
									- mDrawSettings.size_innerBorderYInset,
                            Path.Direction.CW);
					// remove the interior to get exactly the border itself.
					tempRectF.set(mDrawSettings.size_innerBorderXInset
							+ mDrawSettings.size_innerBorderWidth,
							mDrawSettings.size_innerBorderYInset
									+ mDrawSettings.size_innerBorderHeight,
							mDrawSettings.size_blockWidth
									- mDrawSettings.size_innerBorderXInset
									- mDrawSettings.size_innerBorderWidth,
							mDrawSettings.size_blockHeight
									- mDrawSettings.size_innerBorderYInset
									- mDrawSettings.size_innerBorderHeight);
                    reset(tempPath);
                    unionRect(tempPath, tempRectF, Path.Direction.CW);
					op(path, tempPath, Path.Op.DIFFERENCE);

					customBorderPath_byQPane_QOrientation[qp][qo] = path;
				}

				else if (mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_INNER) {
					Path path = path();

					unionRect(path, 0, 0,
                            mDrawSettings.size_blockWidth,
							mDrawSettings.size_blockHeight,
                            Path.Direction.CW);
					// remove the interior to get exactly the border itself.
					tempRectF.set(mDrawSettings.size_borderWidth,
							mDrawSettings.size_borderHeight,
							mDrawSettings.size_blockWidth
									- mDrawSettings.size_borderWidth,
							mDrawSettings.size_blockHeight
									- mDrawSettings.size_borderHeight);
                    reset(tempPath);
                    unionRect(tempPath, tempRectF, Path.Direction.CW);
					op(path, tempPath, Path.Op.DIFFERENCE);

					customBorderPath_byQPane_QOrientation[qp][qo] = path;
				}
			}
		}
	}

	private void generateCustomBitmaps(Context context,
			BlockDrawerPreallocatedBitmaps preallocated) {

		if (customBitmap_byQOrientation == null) {
			customBitmap_byQOrientation = new Bitmap[QOrientations.NUM];
			customBitmapBounds_byQOrientation = new Rect[QOrientations.NUM];
		}

		// set nulls
		for (int i = 0; i < QOrientations.NUM; i++) {
			customBitmap_byQOrientation[i] = null;
			customBitmapBounds_byQOrientation[i] = null;
		}

		// Generate bitmaps according to DrawSettings...
		for (int qo = 0; qo < QOrientations.NUM; qo++) {
			if (mDrawSettings.behavior_qo_top[qo] == DrawSettings.BEHAVIOR_QO_TOP_CUSTOM_BITMAP) {

				if ( mDrawSettings.behavior_qo_bitmap[qo] == DrawSettings.BEHAVIOR_QO_BITMAP_FLASH_STRIPE ) {
					// A flash bitmap is determined by its width, height, inset
					// height
					// and width (which may be 0, based on draw settings
					// behavior),
					// and colors.
					int wInset = 0, hInset = 0;

					if (mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_INNER
							|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER
							|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE) {
						wInset = mDrawSettings.size_borderWidth;
						hInset = mDrawSettings.size_borderHeight;
					} else if (mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_PANE_INSET
							|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INSET) {
						wInset = mDrawSettings.size_innerBorderXInset
								+ mDrawSettings.size_innerBorderWidth;
						hInset = mDrawSettings.size_innerBorderYInset
								+ mDrawSettings.size_innerBorderHeight;
					}

					int burstColor = mDrawSettings.color_qOrientationDetailColors[qo][DrawSettings.DETAIL_FLASH_BURST];
					int stripeColor = mDrawSettings.color_qOrientationDetailColors[qo][DrawSettings.DETAIL_FLASH_STRIPE];

					StringBuilder sb = new StringBuilder();
					sb.append("customBitmapFlashStripe");
					sb.append("_").append(mDrawSettings.size_blockWidth);
					sb.append("_").append(mDrawSettings.size_blockHeight);
					sb.append("_").append(wInset).append("_").append(hInset);
					sb.append("_").append(burstColor).append("_")
							.append(stripeColor);

					String key = sb.toString();

					boolean rendered = preallocated
							.hasBlockSizeBitmapInUse(key)
							|| (preallocated.hasBlockSizeBitmap(key) && preallocated
									.getRenderedDrawSettings() != null);

					Bitmap bitmap = preallocated.getBlockSizeBitmap(key,
							mDrawSettings.size_blockWidth,
							mDrawSettings.size_blockHeight,
							Bitmap.Config.ARGB_8888);

					if (!rendered) {
						// prerender.
						try {
							// This call will clear the bitmap before drawing
							// content.
							bitmap = renderFlashBitmap(bitmap, mDrawSettings,
									context, burstColor, stripeColor, wInset,
									hInset);
						} catch (IOException exc) {
							exc.printStackTrace();
							throw new RuntimeException(
									"Failure loading shadow data");
						}
					}
					customBitmap_byQOrientation[qo] = bitmap;
					customBitmapBounds_byQOrientation[qo] = new Rect(0, 0,
							mDrawSettings.size_blockWidth,
							mDrawSettings.size_blockHeight);
				}

				else if ( mDrawSettings.behavior_qo_bitmap[qo] == DrawSettings.BEHAVIOR_QO_BITMAP_CHEVRON_TOP ) {
					// a chevron!
					// A flash bitmap is determined by its width, height, inset
					// height
					// and width (which may be 0, based on draw settings
					// behavior),
					// and colors.
					int wInset = 0, hInset = 0;

					if (mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_INNER
							|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER
							|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE) {
						wInset = mDrawSettings.size_borderWidth;
						hInset = mDrawSettings.size_borderHeight;
					} else if (mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_PANE_INSET
							|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INSET) {
						wInset = mDrawSettings.size_innerBorderXInset
								+ mDrawSettings.size_innerBorderWidth;
						hInset = mDrawSettings.size_innerBorderYInset
								+ mDrawSettings.size_innerBorderHeight;
					} else if (mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI
							|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_HORIZONTAL_OVER
							|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_VERTICAL_OVER) {
						wInset = mDrawSettings.size_miniBorderXInset
								+ mDrawSettings.size_miniBorderWidth;
						hInset = mDrawSettings.size_miniBorderYInset
								+ mDrawSettings.size_miniBorderHeight;
					}

					int chevronColor = mDrawSettings.color_qOrientationDetailColors[qo][DrawSettings.DETAIL_CHEVRON];
					boolean invert = qo != QOrientations.PUSH_UP_ACTIVE && qo != QOrientations.PUSH_UP ;

					StringBuilder sb = new StringBuilder();
					sb.append("customBitmapChevronTop");
					sb.append("_").append(mDrawSettings.size_blockWidth);
					sb.append("_").append(mDrawSettings.size_blockHeight);
					sb.append("_").append(wInset).append("_").append(hInset);
					sb.append("_").append(chevronColor);
					sb.append("_").append(invert);

					String key = sb.toString();

					boolean rendered = preallocated
							.hasBlockSizeBitmapInUse(key)
							|| (preallocated.hasBlockSizeBitmap(key) && preallocated
									.getRenderedDrawSettings() != null);

					Bitmap bitmap = preallocated.getBlockSizeBitmap(key,
							mDrawSettings.size_blockWidth,
							mDrawSettings.size_blockHeight,
							Bitmap.Config.ARGB_8888);

					if (!rendered) {
						// prerender.
						// This call will clear the bitmap before drawing
						// content.
						bitmap = this.renderChevronBitmap(bitmap,
								mDrawSettings, context, chevronColor, chevronColor,
								invert, true, (byte)-1, -1, wInset, hInset);
					}
					customBitmap_byQOrientation[qo] = bitmap;
					customBitmapBounds_byQOrientation[qo] = new Rect(0, 0,
							mDrawSettings.size_blockWidth,
							mDrawSettings.size_blockHeight);
				}

			}
		}
	}

	private void generateFriendlyBlends(Context context) {

		// For now, we use friendly blends only in a linear direction.
		// Blends fail in other cases. Friendly fill blends are possible
		// within a QO that has friendly blend, provided it and the "from"
		// block have friendly borders. Friendly border blends have a
		// very similar approach.

		friendlyFillBlend_byQPaneQOrientationFromToDirection = new Bitmap[2][QOrientations.NUM][][];
		friendlyBorderBlend_byQPaneQOrientationFromToDirection = new Drawable[2][QOrientations.NUM][][];
		friendlyFillBlendSimplified_byQPaneQOrientationFromToDirection = new Bitmap[2][QOrientations.NUM][][] ;
		friendlyBorderBlendSimplified_byQPaneQOrientationFromToDirection = new Drawable[2][QOrientations.NUM][][] ;

		for (int qp = 0; qp < 2; qp++) {
			for (int qc = 0; qc < QCombinations.NUM; qc++) {
				
				int q0 = QCombinations.expandedPane(qc, qp) ;

				if ( friendlyFillBlend_byQPaneQOrientationFromToDirection[qp][q0] == null ) {
					
					friendlyFillBlend_byQPaneQOrientationFromToDirection[qp][q0] = null;
					if (mDrawSettings.behavior_qo_fill[q0] == DrawSettings.BEHAVIOR_QO_FILL_PAINT_Q_ORIENTATION_FRIENDLY_BLEND) {
						friendlyFillBlend_byQPaneQOrientationFromToDirection[qp][q0] = new Bitmap[QOrientations.NUM][NUM_CONNECTED_DIRECTIONS];
						friendlyFillBlendSimplified_byQPaneQOrientationFromToDirection[qp][q0] = new Bitmap[QOrientations.NUM][NUM_CONNECTED_DIRECTIONS] ;
						Bitmap[][] blends = friendlyFillBlend_byQPaneQOrientationFromToDirection[qp][q0];
						for (int qc1 = 0; qc1 < QCombinations.NUM; qc1++) {
							int q1 = QCombinations.expandedPane(qc1, qp) ;
							if ( blends[q1][DIRECTION_LEFT] == null ) {
								for (int d = 0; d < NUM_CONNECTED_DIRECTIONS; d++)
									blends[q1][d] = null;
								if ( q0 != q1
										&& (mDrawSettings.behavior_qo_border[q0] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY || mDrawSettings.behavior_qo_border[q0] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY_BLEND)
										&& (mDrawSettings.behavior_qo_border[q1] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY || mDrawSettings.behavior_qo_border[q1] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY_BLEND)) {
									// friendly! blend them.
									int color0 = mDrawSettings.color_qOrientationQPaneFill[q0][qp];
									int color1 = mDrawSettings.color_qOrientationQPaneFill[q1][qp];
									
									if ( color0 != color1 ) {
										
										makeFillBlendsByDirection( color0, color1, blends[q1] ) ;
										
										if ( GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP ) {
											log("creating blend from " + q0 + " to " + q1 + " colors " + ColorOp.toString(color0) + ", "+  ColorOp.toString(color1)) ;
										}
									}
									
									if ( color0 == mDrawSettings.colorSimplified_qOrientationQPaneFill[q0][qp] &&
											color1 == mDrawSettings.color_qOrientationQPaneFill[q1][qp] ) {
										friendlyFillBlendSimplified_byQPaneQOrientationFromToDirection[qp][q0][q1] =
											friendlyFillBlend_byQPaneQOrientationFromToDirection[qp][q0][q1] ;
									} else {
										// make our own.
										friendlyFillBlendSimplified_byQPaneQOrientationFromToDirection[qp][q0][q1] = new Bitmap[NUM_CONNECTED_DIRECTIONS] ;
										makeFillBlendsByDirection(
												mDrawSettings.colorSimplified_qOrientationQPaneFill[q0][qp],
												mDrawSettings.colorSimplified_qOrientationQPaneFill[q1][qp],
												friendlyFillBlendSimplified_byQPaneQOrientationFromToDirection[qp][q0][q1] ) ;
									}
								}
							}
						}
					}
	
					friendlyBorderBlend_byQPaneQOrientationFromToDirection[qp][q0] = null;
					friendlyBorderBlendSimplified_byQPaneQOrientationFromToDirection[qp][q0] = null ;
					if (mDrawSettings.behavior_qo_border[q0] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY_BLEND) {
						friendlyBorderBlend_byQPaneQOrientationFromToDirection[qp][q0] = new Drawable[QOrientations.NUM][NUM_CONNECTED_DIRECTIONS];
						friendlyBorderBlendSimplified_byQPaneQOrientationFromToDirection[qp][q0] = new Drawable[QOrientations.NUM][NUM_CONNECTED_DIRECTIONS];
						
						Drawable[][] blends = friendlyBorderBlend_byQPaneQOrientationFromToDirection[qp][q0];
						Drawable[][] blendsSimplified = friendlyBorderBlendSimplified_byQPaneQOrientationFromToDirection[qp][q0];
						
						for (int q1 = 0; q1 < QOrientations.NUM; q1++) {
							for (int d = 0; d < NUM_CONNECTED_DIRECTIONS; d++) {
								blends[q1][d] = null;
								blendsSimplified[q1][d] = null ;
							}
							if (q0 != q1
									&& (mDrawSettings.behavior_qo_border[q1] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY || mDrawSettings.behavior_qo_border[q1] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY_BLEND)) {
								// friendly! blend them.
								int color0 = mDrawSettings.color_qOrientationQPaneBorder[q0][qp];
								int color1 = mDrawSettings.color_qOrientationQPaneBorder[q1][qp];
	
								makeDrawableBlendsByDirection( color0, color1, blends[q1] ) ;
								makeDrawableBlendsByDirection(
										mDrawSettings.colorSimplified_qOrientationQPaneBorder[q0][qp],
										mDrawSettings.colorSimplified_qOrientationQPaneBorder[q0][qp],
										blendsSimplified[q1] ) ;
							}
						}
					}
				}
			}
		}
	}
	
	
	private void makeDrawableBlendsByDirection( int color0, int color1, Drawable [] blends ) {
		blends[DIRECTION_LEFT] = new GradientDrawable(
				GradientDrawable.Orientation.RIGHT_LEFT,
				new int[] { color0, color1 });
		blends[DIRECTION_RIGHT] = new GradientDrawable(
				GradientDrawable.Orientation.LEFT_RIGHT,
				new int[] { color0, color1 });
		blends[DIRECTION_UP] = new GradientDrawable(
				GradientDrawable.Orientation.BOTTOM_TOP,
				new int[] { color0, color1 });
		blends[DIRECTION_DOWN] = new GradientDrawable(
				GradientDrawable.Orientation.TOP_BOTTOM,
				new int[] { color0, color1 });
	}
	
	
	private void makeFillBlendsByDirection( int color0, int color1, Bitmap [] blends ) {
		Drawable [] drawableBlend = new Drawable[NUM_CONNECTED_DIRECTIONS] ;
		drawableBlend[DIRECTION_LEFT] = new GradientDrawable(
				GradientDrawable.Orientation.RIGHT_LEFT,
				new int[] { color0, color1 });
		drawableBlend[DIRECTION_RIGHT] = new GradientDrawable(
				GradientDrawable.Orientation.LEFT_RIGHT,
				new int[] { color0, color1 });
		drawableBlend[DIRECTION_UP] = new GradientDrawable(
				GradientDrawable.Orientation.BOTTOM_TOP,
				new int[] { color0, color1 });
		drawableBlend[DIRECTION_DOWN] = new GradientDrawable(
				GradientDrawable.Orientation.TOP_BOTTOM,
				new int[] { color0, color1 });
		
		for ( int i = 0; i < NUM_CONNECTED_DIRECTIONS; i++ ) {
			int width = 0, height = 0 ;
			switch( i ) {
			case DIRECTION_LEFT:
			case DIRECTION_RIGHT:
				width = mDrawSettings.size_blockWidth ;
				height = 1 ;
				break ;
			case DIRECTION_UP:
			case DIRECTION_DOWN:
				width = 1 ;
				height = mDrawSettings.size_blockHeight ;
				break ;
			}
			if ( width > 0 && height > 0 ) {
				Bitmap b = Bitmap.createBitmap(
						width, height, Bitmap.Config.ARGB_8888) ;
				Canvas c = new Canvas(b) ;
				drawableBlend[i].setBounds(0, 0, width, height) ;
				drawableBlend[i].draw(c) ;
				blends[i] = b ;
			}
		}
	}
	

	/**
	 * Generates drawables that represent both the border and the underlying
	 * border "shine." These drawables can serve as a replacement to the
	 * two-pass "border and shine" which appeared to take up the majority of
	 * time in our initial profiling tests. With current draw settings this
	 * drawable should be fully opaque, and we can set it as such.
	 * 
	 * Also by current draw settings, this border drawable should be used for
	 * any InnerBorder drawable.
	 * 
	 * @param context
     * @param master
	 */
	private void generateInnerBorderDrawables(Context context,
			BlockDrawer master) {
		if (master != null && innerBorderDrawablesIdentical(this, master)) {
			innerBorder_byQPaneQOrientationCornerCornerDirection = master.innerBorder_byQPaneQOrientationCornerCornerDirection;
			innerBorderColorSubstitute_byQPaneQOrientationCornerCorner = master.innerBorderColorSubstitute_byQPaneQOrientationCornerCorner;
			return;
		}

		if (innerBorder_byQPaneQOrientationCornerCornerDirection == null)
			innerBorder_byQPaneQOrientationCornerCornerDirection = new Drawable[2][QOrientations.NUM][][][];
		if (innerBorderColorSubstitute_byQPaneQOrientationCornerCorner == null)
			innerBorderColorSubstitute_byQPaneQOrientationCornerCorner = new int[2][QOrientations.NUM][][];

		// set to null everywhere; we will the generate the appropriate
		// values for possible corner combinations.
		for (int qp = 0; qp < 2; qp++)
			for (int qo = 0; qo < QOrientations.NUM; qo++) {
				innerBorder_byQPaneQOrientationCornerCornerDirection[qp][qo] = null;
				innerBorderColorSubstitute_byQPaneQOrientationCornerCorner[qp][qo] = null;
			}

		// Generate a Drawable - GradientDrawable or ColorDrawable - for every
		// connected pair of corners.
		// For every corner pair - "top left to top right", for example -
		// there are 4 possible permutations of convexity. We need to
		// handle each one. Additionally, we have as a special case
		// a "same to same" connection which represents the corner itself, not
		// the bar between corners.
		int[][] cornerCombinations = new int[][] {
				// top-left to top-right
				new int[] { DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX,
						DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX },
				new int[] { DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX,
						DrawSettings.CORNER_INNER_LEFT_TOP_CONCAVE },
				new int[] { DrawSettings.CORNER_INNER_RIGHT_TOP_CONCAVE,
						DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX },
				new int[] { DrawSettings.CORNER_INNER_RIGHT_TOP_CONCAVE,
						DrawSettings.CORNER_INNER_LEFT_TOP_CONCAVE },
				// top-left to bottom-left
				new int[] { DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX,
						DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX },
				new int[] { DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX,
						DrawSettings.CORNER_INNER_LEFT_TOP_CONCAVE },
				new int[] { DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONCAVE,
						DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX },
				new int[] { DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONCAVE,
						DrawSettings.CORNER_INNER_LEFT_TOP_CONCAVE },
				// bottom-left to bottom-right
				new int[] { DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX,
						DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX },
				new int[] { DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX,
						DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONCAVE },
				new int[] { DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONCAVE,
						DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX },
				new int[] { DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONCAVE,
						DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONCAVE },
				// top-right to bottom-right
				new int[] { DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX,
						DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX },
				new int[] { DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX,
						DrawSettings.CORNER_INNER_RIGHT_TOP_CONCAVE },
				new int[] { DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONCAVE,
						DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX },
				new int[] { DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONCAVE,
						DrawSettings.CORNER_INNER_RIGHT_TOP_CONCAVE },
				// same to same
				new int[] { DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX,
						DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX },
				new int[] { DrawSettings.CORNER_INNER_LEFT_TOP_CONCAVE,
						DrawSettings.CORNER_INNER_LEFT_TOP_CONCAVE },
				new int[] { DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX,
						DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX },
				new int[] { DrawSettings.CORNER_INNER_RIGHT_TOP_CONCAVE,
						DrawSettings.CORNER_INNER_RIGHT_TOP_CONCAVE },
				new int[] { DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX,
						DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX },
				new int[] { DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONCAVE,
						DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONCAVE },
				new int[] { DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX,
						DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX },
				new int[] { DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONCAVE,
						DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONCAVE },

		};

		int[] directions = new int[] {
				// top-left to top-right
				DIRECTION_RIGHT,
				DIRECTION_RIGHT,
				DIRECTION_RIGHT,
				DIRECTION_RIGHT,
				// top-left to bottom-left
				DIRECTION_DOWN,
				DIRECTION_DOWN,
				DIRECTION_DOWN,
				DIRECTION_DOWN,
				// bottom-left to bottom-right
				DIRECTION_RIGHT,
				DIRECTION_RIGHT,
				DIRECTION_RIGHT,
				DIRECTION_RIGHT,
				// top-right to bottom-right
				DIRECTION_DOWN,
				DIRECTION_DOWN,
				DIRECTION_DOWN,
				DIRECTION_DOWN, };

		// Only generate this drawable if either color has an alpha > 0. Colors
		// are
		for (int qp = 0; qp < 2; qp++) {
			for (int qo_index = 0; qo_index < mDrawSettings.qo.length; qo_index++) {
				byte qo = mDrawSettings.qo[qo_index];
				if (!QCombinations.occursInPane(qo, qp))
					continue;

				innerBorder_byQPaneQOrientationCornerCornerDirection[qp][qo] = new Drawable[DrawSettings.NUM_CORNERS][][];
				innerBorderColorSubstitute_byQPaneQOrientationCornerCorner[qp][qo] = new int[DrawSettings.NUM_CORNERS][];

				for (int i = 0; i < cornerCombinations.length; i++) {
					int c0 = cornerCombinations[i][0];
					int c1 = cornerCombinations[i][1];

					if (innerBorder_byQPaneQOrientationCornerCornerDirection[qp][qo][c0] == null) {
						innerBorder_byQPaneQOrientationCornerCornerDirection[qp][qo][c0] = new Drawable[DrawSettings.NUM_CORNERS][BlockDrawer.NUM_SHINE_DIRECTIONS];
						innerBorderColorSubstitute_byQPaneQOrientationCornerCorner[qp][qo][c0] = new int[DrawSettings.NUM_CORNERS];
					}
					
					int shineColorFrom = mDrawSettings.getColor_borderShine(qp, qo, c0) ;
					int shineColorTo = mDrawSettings.getColor_borderShine(qp, qo, c1) ;

					int borderColor = mDrawSettings.color_qOrientationQPaneBorder[qo][qp];
					int colorFrom = ColorOp
							.composeAOverB(shineColorFrom, borderColor);
					int colorTo = ColorOp
							.composeAOverB(shineColorTo, borderColor);

					int colorAvg = ColorOp.colorAverage(colorFrom, colorTo);

					if (GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP)
						log( 
								"creating shine for qo " + qo + " with colors "
										+ ColorOp.toString(colorFrom) + " to "
										+ ColorOp.toString(colorTo)
										+ ": had border color "
										+ ColorOp.toString(borderColor));

					// we draw this shine OVER the existing border color.
					
					// make a gradient Drawable or ColorDrawable. I'm
					// reluctant to use
					// the cache for this, even though I expect many
					// drawables
					// will be the same; other BlockDrawers can read
					// from the cache, and Drawables are mutable - in fact,
					// we rely on their mutability when drawing with
					// different alphas.
					
					
					
					int d = DIRECTION_NONE ;
					if ( i < directions.length )
						d = directions[i] ;
					
					if (c0 != c1 && mDrawSettings.getNumber_borderShine(qp, qo) > 0) {
						Drawable drawable = this.makeBorderDrawable(mDrawSettings, qp, qo, true, c0, c1, d) ;
						innerBorder_byQPaneQOrientationCornerCornerDirection[qp][qo][c0][c1][d] = drawable ;
					} else {
						innerBorderColorSubstitute_byQPaneQOrientationCornerCorner[qp][qo][c0][c1] = colorAvg;
					}
				}
			}
		}
	}

	private static final boolean innerBorderDrawablesIdentical(BlockDrawer bd1,
			BlockDrawer bd2) {
		// The inner border drawables will be identical if
		// 1. the shines are identical, and 2. the qorientation
		// border colors and alphas are identical. Note
		// that the shines being equal necessitates that
		// the have the same QOs and shine behavior.

		if (!BlockDrawer.innerBorderShineDrawablesIdentical(bd1, bd2))
			return false;

		for (int qp = 0; qp < 2; qp++)
			for (int qo = 0; qo < QOrientations.NUM; qo++)
				if (bd1.mDrawSettings.color_qOrientationQPaneBorder[qo][qp] != bd2.mDrawSettings.color_qOrientationQPaneBorder[qo][qp])
					return false;

		// we don't need to check border alphas, since they are applied at
		// draw-time,
		// and not baked into the drawables.
		return true;
	}

	/**
	 * Generates Bitmaps representing a prerendered version of
	 * innerBorder_byQPaneQOrientationCornerCornerDirection.
	 * 
	 * These bitmaps are drawn instead of the Drawables (when available) to
	 * avoid the overhead of resizing and recalculating pixel values for
	 * gradients.
	 * 
	 * However, they come at a cost - a Bitmap is much more memory-hungry than a
	 * GradientDrawable that renders into that bitmap. For that reason, we do
	 * our best to limit the number of bitmaps actually created.
	 * 
	 * @param context
     * @param preallocated
	 */
	private void generateInnerBorderBitmaps(Context context,
			BlockDrawerPreallocatedBitmaps preallocated) {
		if (innerBorderBitmap_byQPaneQOrientationCornerCornerDirectionWidth == null) {
			innerBorderBitmap_byQPaneQOrientationCornerCornerDirectionWidth = new Bitmap[2][QOrientations.NUM][][][][];
			innerBorderBitmapBounds_byQPaneQOrientationCornerCornerDirectionWidth = new Rect[2][QOrientations.NUM][][][][];
		}
		if (innerBorderStretchableBitmap_byQPaneQOrientationCornerCornerDirection == null) {
			innerBorderStretchableBitmap_byQPaneQOrientationCornerCornerDirection = new Bitmap[2][QOrientations.NUM][][][];
			innerBorderStretchableBitmapBounds_byQPaneQOrientationCornerCornerDirection = new Rect[2][QOrientations.NUM][][][];
		}

		// set to null everywhere; we will the generate the appropriate
		// values for possible corner combinations.
		for (int qp = 0; qp < 2; qp++)
			for (int qo = 0; qo < QOrientations.NUM; qo++) {
				innerBorderBitmap_byQPaneQOrientationCornerCornerDirectionWidth[qp][qo] = null;
				innerBorderStretchableBitmap_byQPaneQOrientationCornerCornerDirection[qp][qo] = null;
			}

		// first restriction: we only generate these for a very limited set of
		// expected
		// QOrientations.
		int[] qCombinationsUsed;
		boolean[] stretchableOnly;
		if (mDrawSettings.draw3D) {
			qCombinationsUsed = new int[] { QCombinations.S0, QCombinations.S1,
					QCombinations.ST, QCombinations.ST_INACTIVE,
					QCombinations.SL_ACTIVE, QCombinations.SL_INACTIVE };
			stretchableOnly = new boolean[] { false, false, false, false,
					false, false };
		} else {
			qCombinationsUsed = new int[] { QCombinations.R0, QCombinations.R1,
					QCombinations.R2, QCombinations.R3, QCombinations.R4,
					QCombinations.R5, QCombinations.R6 };
			stretchableOnly = new boolean[] { false, false, false, false,
					false, false, false };
		}

		// we generate bitmaps for all inequal corner combinations. However, we
		// always check whether the
		// relevant colors match a previously generated value - if so, we just
		// copy the bitmap reference.
		//
		// As for width, we use "blockWidth/Height - 1 border pair." In other
		// words, for width 0, it is
		// the size of 1 block not including the left and right (or top and
		// bottom) borders. For width 1,
		// it is the full width of one block, plus 1 block not including left
		// and right borders.

		// Generate a Drawable - GradientDrawable or ColorDrawable - for every
		// connected pair of corners.
		// For every corner pair - "top left to top right", for example -
		// there are 4 possible permutations of convexity. We need to
		// handle each one. Additionally, we have as a special case
		// a "same to same" connection which represents the corner itself, not
		// the bar between corners.
		int[][] cornerCombinations = new int[][] {
				// top-left to top-right
				new int[] { DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX,
						DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX },
				new int[] { DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX,
						DrawSettings.CORNER_INNER_LEFT_TOP_CONCAVE },
				new int[] { DrawSettings.CORNER_INNER_RIGHT_TOP_CONCAVE,
						DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX },
				new int[] { DrawSettings.CORNER_INNER_RIGHT_TOP_CONCAVE,
						DrawSettings.CORNER_INNER_LEFT_TOP_CONCAVE },
				// top-left to bottom-left
				new int[] { DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX,
						DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX },
				new int[] { DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX,
						DrawSettings.CORNER_INNER_LEFT_TOP_CONCAVE },
				new int[] { DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONCAVE,
						DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX },
				new int[] { DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONCAVE,
						DrawSettings.CORNER_INNER_LEFT_TOP_CONCAVE },
				// bottom-left to bottom-right
				new int[] { DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX,
						DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX },
				new int[] { DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX,
						DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONCAVE },
				new int[] { DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONCAVE,
						DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX },
				new int[] { DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONCAVE,
						DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONCAVE },
				// top-right to bottom-right
				new int[] { DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX,
						DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX },
				new int[] { DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX,
						DrawSettings.CORNER_INNER_RIGHT_TOP_CONCAVE },
				new int[] { DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONCAVE,
						DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX },
				new int[] { DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONCAVE,
						DrawSettings.CORNER_INNER_RIGHT_TOP_CONCAVE }, };

		int[] cornerCombinationDirection = new int[] {
				// top-left to top-right
				DIRECTION_RIGHT, DIRECTION_RIGHT, DIRECTION_RIGHT,
				DIRECTION_RIGHT,
				// top-left to bottom-left
				DIRECTION_DOWN, DIRECTION_DOWN, DIRECTION_DOWN, DIRECTION_DOWN,
				// bottom-left to bottom-right
				DIRECTION_RIGHT, DIRECTION_RIGHT, DIRECTION_RIGHT,
				DIRECTION_RIGHT,
				// top-right to bottom-right
				DIRECTION_DOWN, DIRECTION_DOWN, DIRECTION_DOWN, DIRECTION_DOWN };

		// //////////////////////////////////////////////////////
		// FIXED WIDTH.
		if (preallocated.getNumUnstretchableBorderBitmaps() > 0) {
			for (int w = 0; w < NUM_PRERENDERED_BORDER_WIDTHS; w++) {
				boolean[][] created = new boolean[2][QOrientations.NUM];
				for (int qc_index = 0; qc_index < qCombinationsUsed.length; qc_index++) {
					int qc = qCombinationsUsed[qc_index];
					boolean includeFixedWidth = !stretchableOnly[qc_index];
					for (int qp = 0; qp < 2; qp++) {
						byte qo = QCombinations.expandedPane(qc, qp);
						if (created[qp][qo] || qo == QOrientations.NO)
							continue;
						created[qp][qo] = true;
						if (innerBorderBitmap_byQPaneQOrientationCornerCornerDirectionWidth[qp][qo] == null) {
							innerBorderBitmap_byQPaneQOrientationCornerCornerDirectionWidth[qp][qo] = new Bitmap[DrawSettings.NUM_CORNERS][][][];
							innerBorderBitmapBounds_byQPaneQOrientationCornerCornerDirectionWidth[qp][qo] = new Rect[DrawSettings.NUM_CORNERS][][][];
						}
						// examine the color values for each possible corner
						// combination.
						for (int i = 0; i < cornerCombinations.length; i++) {
							int direction = cornerCombinationDirection[i];

							int c0 = cornerCombinations[i][0];
							int c1 = cornerCombinations[i][1];

							if (innerBorderBitmap_byQPaneQOrientationCornerCornerDirectionWidth[qp][qo][c0] == null) {
								innerBorderBitmap_byQPaneQOrientationCornerCornerDirectionWidth[qp][qo][c0] = new Bitmap[DrawSettings.NUM_CORNERS][BlockDrawer.NUM_SHINE_DIRECTIONS][BlockDrawer.NUM_PRERENDERED_BORDER_WIDTHS];
								innerBorderBitmapBounds_byQPaneQOrientationCornerCornerDirectionWidth[qp][qo][c0] = new Rect[DrawSettings.NUM_CORNERS][BlockDrawer.NUM_SHINE_DIRECTIONS][BlockDrawer.NUM_PRERENDERED_BORDER_WIDTHS];
							}
							
							// dimensions are based on width and direction.
							int width, height;
							if (direction == DIRECTION_RIGHT) {
								width = mDrawSettings.size_blockWidth
										* (w + 1)
										- mDrawSettings.size_borderWidth * 2;
								height = mDrawSettings.size_borderHeight;
							} else {
								width = mDrawSettings.size_borderWidth;
								height = mDrawSettings.size_blockHeight
										* (w + 1)
										- mDrawSettings.size_borderHeight * 2;
							}

							Bitmap b;
							Rect bounds = new Rect(0, 0, width, height);

							StringBuilder sb = new StringBuilder();
							sb.append("innerBorderUnstretchableBitmap");
							sb.append("_").append(direction);
							sb.append("_").append(mDrawSettings.color_qOrientationQPaneBorder[qo][qp]) ;
							for ( int shineNumber = 0; shineNumber < mDrawSettings.getNumber_borderShine(qp, qo); shineNumber++ ) {
								int [] colors = mDrawSettings.getColor_borderShine(qp, qo, shineNumber, c0, c1) ;
								float [] positions = mDrawSettings.getPositions_borderShine(qp, qo, shineNumber, c0, c1) ;
								if ( colors != null ) {
									for ( int k = 0; k < colors.length; k++ ) {
										sb.append("_c").append(colors[k]) ;
										if ( positions != null )
											sb.append("_p").append(positions[k]) ;
									}
								}
							}
							
							sb.append("_").append(width).append("_")
									.append(height);
							String key = sb.toString();

							if (preallocated
									.hasUnstretchableBorderBitmapInUse(
											direction, key)
									|| (preallocated
											.hasUnstretchableBorderBitmap(
													direction, key) && preallocated
											.getRenderedDrawSettings() != null)) {

								b = preallocated
										.getUnstretchableBorderBitmap(
												direction, key, width,
												height);
							} else {
								// get for rendering
								b = preallocated
										.getUnstretchableBorderBitmap(
												direction, key, width,
												height);
								if (b == null) {
									log( 
											"skipping unstretchable border bitmap; no preallocated version available.");
									continue;
								}


								Drawable borderDrawable = this.makeBorderDrawable(mDrawSettings, qp, qo, true, c0, c1, direction) ;
								
								Canvas c = new Canvas(b);
								c.drawPaint(clearPaint);
								borderDrawable.setBounds(bounds);
								borderDrawable.draw(c);
							}

							innerBorderBitmap_byQPaneQOrientationCornerCornerDirectionWidth[qp][qo][c0][c1][direction][w] = b;
							innerBorderBitmapBounds_byQPaneQOrientationCornerCornerDirectionWidth[qp][qo][c0][c1][direction][w] = bounds;
						}
					}
				}
			}
		} else {
			log( 
					"Skipping unstretchable border bitmaps: none preallocated");
		}

		// Only generate this drawable if either color has an alpha > 0. Colors
		// are
		if (preallocated.getNumStretchableBorderBitmaps() > 0) {
			boolean[][] created = new boolean[2][QOrientations.NUM];
			for (int qc_index = 0; qc_index < qCombinationsUsed.length; qc_index++) {
				int qc = qCombinationsUsed[qc_index];
				for (int qp = 0; qp < 2; qp++) {
					byte qo = QCombinations.expandedPane(qc, qp);
					if (created[qp][qo] || qo == QOrientations.NO)
						continue;
					created[qp][qo] = true;
					if (innerBorderStretchableBitmap_byQPaneQOrientationCornerCornerDirection[qp][qo] == null) {
						innerBorderStretchableBitmap_byQPaneQOrientationCornerCornerDirection[qp][qo] = new Bitmap[DrawSettings.NUM_CORNERS][][];
						innerBorderStretchableBitmapBounds_byQPaneQOrientationCornerCornerDirection[qp][qo] = new Rect[DrawSettings.NUM_CORNERS][][];
					}
					// examine the color values for each possible corner
					// combination.
					for (int i = 0; i < cornerCombinations.length; i++) {
						int c0 = cornerCombinations[i][0];
						int c1 = cornerCombinations[i][1];

						if (innerBorderStretchableBitmap_byQPaneQOrientationCornerCornerDirection[qp][qo][c0] == null) {
							innerBorderStretchableBitmap_byQPaneQOrientationCornerCornerDirection[qp][qo][c0] = new Bitmap[DrawSettings.NUM_CORNERS][BlockDrawer.NUM_SHINE_DIRECTIONS];
							innerBorderStretchableBitmapBounds_byQPaneQOrientationCornerCornerDirection[qp][qo][c0] = new Rect[DrawSettings.NUM_CORNERS][BlockDrawer.NUM_SHINE_DIRECTIONS];
						}

						// //////////////////////////////////////////////////////
						// FIXED WIDTH.

						// we should have a bitmap here. However, we might
						// have already
						// rendered this!
						int direction = cornerCombinationDirection[i];

						Bitmap b;
						Rect bounds;

						StringBuilder sb = new StringBuilder();
						sb.append("innerBorderStretchableBitmap");
						sb.append("_").append(direction);
						sb.append("_").append(mDrawSettings.color_qOrientationQPaneBorder[qo][qp]) ;
						for ( int shineNumber = 0; shineNumber < mDrawSettings.getNumber_borderShine(qp, qo); shineNumber++ ) {
							int [] colors = mDrawSettings.getColor_borderShine(qp, qo, shineNumber, c0, c1) ;
							float [] positions = mDrawSettings.getPositions_borderShine(qp, qo, shineNumber, c0, c1) ;
							if ( colors != null ) {
								for ( int k = 0; k < colors.length; k++ ) {
									sb.append("_c").append(colors[k]) ;
									if ( positions != null )
										sb.append("_p").append(positions[k]) ;
								}
							}
						}
						String key = sb.toString();

						// key tells us exactly what's there, so we don't
						// need to check
						// DrawSettings for a match. However, it's important
						// that it HAS
						// a draw settings, since
						if (preallocated.hasStretchableBorderBitmapInUse(
								direction, key)
								|| (preallocated.getRenderedDrawSettings() != null && preallocated
										.hasStretchableBorderBitmap(
												direction, key))) {
							b = preallocated.getStretchableBorderBitmap(
									direction, key);
							bounds = new Rect(0, 0, b.getWidth(),
									b.getHeight());
						} else {

							b = preallocated.getStretchableBorderBitmap(
									direction, key);
							if (b == null) {
								log( 
										"skipping stretchable border bitmap; no preallocated version available.");
								continue;
							} else {
								// dimensions are based on width and
								// direction.
								// create a bitmap of the appropriate
								// dimensions
								// and render
								// a gradient drawable within it.
								
								Drawable borderDrawable = this.makeBorderDrawable(mDrawSettings, qp, qo, true, c0, c1, direction) ;

								Canvas c = new Canvas(b);
								c.drawPaint(clearPaint);
								bounds = new Rect(0, 0, b.getWidth(),
										b.getHeight());
								borderDrawable.setBounds(bounds);
								borderDrawable.draw(c);
							}
						}
						innerBorderStretchableBitmap_byQPaneQOrientationCornerCornerDirection[qp][qo][c0][c1][direction] = b;
						innerBorderStretchableBitmapBounds_byQPaneQOrientationCornerCornerDirection[qp][qo][c0][c1][direction] = bounds;
					}
				}
			}
		} else {
			log("Skipping stretchable border bitmaps: none preallocated");
		}
	}

	private void prerenderCustomBorder(Context context,
			BlockDrawerPreallocatedBitmaps preallocated) {
		if (customBorder_byQPaneQOrientation == null) {
			customBorder_byQPaneQOrientation = new Bitmap[2][QOrientations.NUM];
			customBorderBounds_byQPaneQOrientation = new Rect[2][QOrientations.NUM];
		}

		for (int qp = 0; qp < 2; qp++) {
			for (int i = 0; i < QOrientations.NUM; i++) {
				customBorder_byQPaneQOrientation[qp][i] = null;
				customBorderBounds_byQPaneQOrientation[qp][i] = null;
			}
		}

		PRERENDERED_BLOCK_BORDER_WIDTH = mDrawSettings.size_borderWidth;
		PRERENDERED_BLOCK_BORDER_HEIGHT = mDrawSettings.size_borderHeight;

		// Because of the sheer number of details going into configuring
		// this shine, and its basic simplity, we don't bother storing it in the
		// cache.
		boolean[][] created = new boolean[2][QOrientations.NUM];
		for (int qc = 0; qc < QCombinations.NUM; qc++) {
			for (int qp = 0; qp < 2; qp++) {
				byte qo = QCombinations.expandedPane(qc, qp);
				if (created[qp][qo])
					continue;
				boolean has = false;
				for (int i = 0; i < mDrawSettings.qo.length; i++)
					if (mDrawSettings.qo[i] == qo)
						has = true;
				if (!has)
					continue;
				created[qp][qo] = true;
				if (mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INSET
						|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI
						|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_HORIZONTAL_OVER
						|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_VERTICAL_OVER) {

					int outerLeft, outerTop, outerRight, outerBottom;
					int innerLeft, innerTop, innerRight, innerBottom;

					// We assume that the inner border shines have already been
					// generated.
					// An inset border is just an inner border, slightly inset,
					// that covers
					// exactly one square. We can easily prerender this as a
					// bitmap to
					// be applied over the entire square.
					if (mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INSET) {
						outerLeft = mDrawSettings.size_innerBorderXInset;
						outerTop = mDrawSettings.size_innerBorderYInset;
						outerRight = mDrawSettings.size_blockWidth
								- mDrawSettings.size_innerBorderXInset;
						outerBottom = mDrawSettings.size_blockHeight
								- mDrawSettings.size_innerBorderYInset;
						innerLeft = outerLeft
								+ mDrawSettings.size_innerBorderWidth;
						innerTop = outerTop
								+ mDrawSettings.size_innerBorderHeight;
						innerRight = outerRight
								- mDrawSettings.size_innerBorderWidth;
						innerBottom = outerBottom
								- mDrawSettings.size_innerBorderHeight;
					} else {
						outerLeft = mDrawSettings.size_miniBorderXInset;
						outerTop = mDrawSettings.size_miniBorderYInset;
						outerRight = mDrawSettings.size_blockWidth
								- mDrawSettings.size_miniBorderXInset;
						outerBottom = mDrawSettings.size_blockHeight
								- mDrawSettings.size_miniBorderYInset;
						innerLeft = outerLeft
								+ mDrawSettings.size_miniBorderWidth;
						innerTop = outerTop
								+ mDrawSettings.size_miniBorderHeight;
						innerRight = outerRight
								- mDrawSettings.size_miniBorderWidth;
						innerBottom = outerBottom
								- mDrawSettings.size_miniBorderHeight;
					}

					int colorBorder = mDrawSettings.color_qOrientationQPaneBorder[qo][qp];
					int shineTL = mDrawSettings.getColor_borderShine(qp, qo, DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX) ;
					int shineTR = mDrawSettings.getColor_borderShine(qp, qo, DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX) ;
					int shineBL = mDrawSettings.getColor_borderShine(qp, qo, DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX) ;
					int shineBR = mDrawSettings.getColor_borderShine(qp, qo, DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX) ;

					int [][][] sideColors = new int[4][mDrawSettings.getNumber_borderShine(qp, qo)][] ;
					float [][][] sidePositions = new float[4][mDrawSettings.getNumber_borderShine(qp, qo)][] ;
					for ( int wall = 0; wall < NUM_WALL_SIDES; wall++ ) {
						int c0 = -1, c1 = -1;
						switch( wall ) {
						case WALL_SIDE_LEFT:
							c0 = DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX ;
							c1 = DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX ;
							break ;
						case WALL_SIDE_RIGHT:
							c0 = DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX ;
							c1 = DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX ;
							break ;
						case WALL_SIDE_TOP:
							c0 = DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX ;
							c1 = DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX ;
							break ;
						case WALL_SIDE_BOTTOM:
							c0 = DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX ;
							c1 = DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX ;
							break ;
						}
						for ( int shineNum = 0; shineNum < mDrawSettings.getNumber_borderShine(qp, qo); shineNum++ ) {
							sideColors[wall][shineNum] = mDrawSettings.getColor_borderShine(qp, qo, shineNum, c0, c1) ;
							sidePositions[wall][shineNum] = mDrawSettings.getPositions_borderShine(qp, qo, shineNum, c0, c1) ;
						}
					}
					// Define this shine using the 8 positions and 4 colors. If
					// CHAIN_LINK, also
					// include the border behavior and qp.
					StringBuilder sb = new StringBuilder();
					sb.append("customBorder");
					sb.append("_").append(outerLeft).append("_")
							.append(innerLeft);
					sb.append("_").append(outerRight).append("_")
							.append(innerRight);
					sb.append("_").append(outerTop).append("_")
							.append(innerTop);
					sb.append("_").append(outerBottom).append("_")
							.append(innerBottom);
					sb.append("_").append(colorBorder);
					
					sb.append("_").append(shineTL).append("_").append(shineTR);
					sb.append("_").append(shineBL).append("_").append(shineBR);
					for ( int wall = 0; wall < NUM_WALL_SIDES; wall++ ) {
						sb.append("_w").append(wall) ;
						for ( int shineNum = 0; shineNum < mDrawSettings.getNumber_borderShine(qp, qo); shineNum++ ) {
							sb.append("_s").append(shineNum) ;
							for ( int k = 0; k < sideColors[wall][shineNum].length; k++ ) {
								sb.append("_c").append(sideColors[wall][shineNum][k]) ;
								if ( sidePositions[wall][shineNum] != null )
									sb.append("_p").append(sidePositions[wall][shineNum][k]) ;
							}
						}
					}
					
					if (mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_HORIZONTAL_OVER
							|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_VERTICAL_OVER) {

						sb.append("_").append(
								mDrawSettings.behavior_qo_border[qo]);
						sb.append("_").append(qp);
					}

					String key = sb.toString();

					boolean rendered = preallocated
							.hasBlockSizeBitmapInUse(key)
							|| (preallocated.hasBlockSizeBitmap(key) && preallocated
									.getRenderedDrawSettings() != null);

					Bitmap b = preallocated.getBlockSizeBitmap(key,
							mDrawSettings.size_blockWidth,
							mDrawSettings.size_blockHeight,
							Bitmap.Config.ARGB_8888);

					if (b == null) {
						if ( GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP )
							log("Allocate Bitmap: create custom border");
						b = Bitmap.createBitmap(
								mDrawSettings.size_blockWidth,
								mDrawSettings.size_blockHeight,
								Bitmap.Config.ARGB_8888);
					}

					if (!rendered) {

						Canvas canvas = new Canvas(b);
						canvas.drawPaint(clearPaint);

						canvas.save();

						// Apply a region if we're using one; in particular, if we have HORIZONTAL_OVER or VERTICAL_OVER.
						if (mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_HORIZONTAL_OVER
								|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_VERTICAL_OVER) {
							canvas.clipPath(customBorderPath_byQPane_QOrientation[qp][qo]);
						}

						// draw the 4 corners, then connect them.
						// Use 'borderPaint' as the under color, and
						// 'tempColorPaint' as the shine.
						borderPaint.setColor(mDrawSettings.color_qOrientationQPaneBorder[qo][qp]);
						tempColorPaint.setColor(shineTL);
						canvas.drawRect(outerLeft, outerTop, innerLeft,
								innerTop, borderPaint);
						canvas.drawRect(outerLeft, outerTop, innerLeft,
								innerTop, tempColorPaint);
						
						tempColorPaint.setColor(shineTR);
						canvas.drawRect(innerRight, outerTop, outerRight,
								innerTop, borderPaint);
						canvas.drawRect(innerRight, outerTop, outerRight,
								innerTop, tempColorPaint);
						
						tempColorPaint.setColor(shineBL);
						canvas.drawRect(outerLeft, innerBottom, innerLeft,
								outerBottom, borderPaint);
						canvas.drawRect(outerLeft, innerBottom, innerLeft,
								outerBottom, tempColorPaint);
						
						tempColorPaint.setColor(shineBR);
						canvas.drawRect(innerRight, innerBottom, outerRight,
								outerBottom, borderPaint);
						canvas.drawRect(innerRight, innerBottom, outerRight,
								outerBottom, tempColorPaint);

						Drawable d;
						int c;
						d = innerBorder_byQPaneQOrientationCornerCornerDirection[qp][qo][DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX][DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX][BlockDrawer.DIRECTION_RIGHT];
						c = innerBorderColorSubstitute_byQPaneQOrientationCornerCorner[qp][qo][DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX][DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX];
						if (d != null) {
							d.setBounds(innerLeft, outerTop, innerRight,
									innerTop);
							d.draw(canvas);
						} else {
							tempColorPaint.setColor(c);
							canvas.drawRect(innerLeft, outerTop, innerRight,
									innerTop, tempColorPaint);
						}

						d = innerBorder_byQPaneQOrientationCornerCornerDirection[qp][qo][DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX][DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX][BlockDrawer.DIRECTION_DOWN];
						c = innerBorderColorSubstitute_byQPaneQOrientationCornerCorner[qp][qo][DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX][DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX];
						if (d != null) {
							d.setBounds(outerLeft, innerTop, innerLeft,
									innerBottom);
							d.draw(canvas);
						} else {
							tempColorPaint.setColor(c);
							canvas.drawRect(outerLeft, innerTop, innerLeft,
									innerBottom, tempColorPaint);
						}

						d = innerBorder_byQPaneQOrientationCornerCornerDirection[qp][qo][DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX][DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX][BlockDrawer.DIRECTION_DOWN];
						c = innerBorderColorSubstitute_byQPaneQOrientationCornerCorner[qp][qo][DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX][DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX];
						if (d != null) {
							d.setBounds(innerRight, innerTop, outerRight,
									innerBottom);
							d.draw(canvas);
						} else {
							tempColorPaint.setColor(c);
							canvas.drawRect(innerRight, innerTop, outerRight,
									innerBottom, tempColorPaint);
						}

						d = innerBorder_byQPaneQOrientationCornerCornerDirection[qp][qo][DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX][DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX][BlockDrawer.DIRECTION_RIGHT];
						c = innerBorderColorSubstitute_byQPaneQOrientationCornerCorner[qp][qo][DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX][DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX];
						if (d != null) {
							d.setBounds(innerLeft, innerBottom, innerRight,
									outerBottom);
							d.draw(canvas);
						} else {
							tempColorPaint.setColor(c);
							canvas.drawRect(innerLeft, innerBottom, innerRight,
									outerBottom, tempColorPaint);
						}

						// done with main render
                        canvas.restore();

						if (mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_HORIZONTAL_OVER
								|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_VERTICAL_OVER) {

							// CHAIN LINK BORDER SELF-SHADOW
							// HACK HACK HACK!!! This is technically a shadow
							// and
							// shouldn't be drawn as a border shine, but this is
							// a
							// convenient way to set it up and we need to get
							// things
							// moving. We already have a clip region, so we
							// could
							// just draw the shadow on top.

							try {
								renderFullSizeEdgeShadowToRenderScratch(
										mDrawSettings, context, 1);
							} catch (IOException e) {
								log("Failed loading shadow data");
								e.printStackTrace();
								throw new RuntimeException(
										"Failed loading shadow data");
							}

							// render!
							int[] xOffset = new int[2];
							int[] yOffset = new int[2];
							clipPath.set(customBorderPath_byQPane_QOrientation[qp][qo]);
							if (mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_HORIZONTAL_OVER) {
								// shadows on the vertical portion. Try to put
								// the
								// center of
								// the shadow at the x-coordinate of the
								// intersected
								// vertical
								// bar. If qpane offset goes right from this qp,
								// move right,
								// otherwise left. This is a hack, remember, so
								// try
								// just
								// offsetting by 1/2 block width (even though
								// this
								// doesn't
								// exactly center the shadow bitmap over the
								// center
								// of the border
								// bar).
								xOffset[0] = xOffset[1] = (mDrawSettings
										.size_qXOffset > 0 == (qp == 0)) ? mDrawSettings
										.size_qXOffset : -mDrawSettings
										.size_qXOffset;
								// Clip to only this edge.
								if (xOffset[0] > 0) {
								    reset(tempPath);
								    unionRect(tempPath, mDrawSettings
                                                    .size_blockWidth
                                                    - mDrawSettings.size_miniBorderXInset
                                                    - mDrawSettings.size_miniBorderWidth,
                                            0,
                                            mDrawSettings
                                                    .size_blockWidth,
                                            mDrawSettings
                                                    .size_blockHeight,
                                            Path.Direction.CW);
								    op(clipPath, tempPath, Path.Op.INTERSECT);
								} else {
                                    reset(tempPath);
                                    unionRect(tempPath, 0, 0,
                                            mDrawSettings.size_miniBorderXInset + mDrawSettings.size_miniBorderWidth,
                                            mDrawSettings.size_blockHeight,
                                            Path.Direction.CW);
                                    op(clipPath, tempPath, Path.Op.INTERSECT);
								}
								// Now we need to draw twice, with two different
								// y
								// offsets;
								// one for each end coming out from under the
								// border.
								int qYOffAbs = Math.abs(mDrawSettings
										.size_qYOffset);
								if (mDrawSettings.size_qYOffset > 0 == (qp == 0)) {
									// qoffset moves down.
									yOffset[0] = mDrawSettings.size_miniBorderYInset
											+ qYOffAbs
											+ mDrawSettings.size_miniBorderHeight;
									yOffset[1] = -mDrawSettings
											.size_blockHeight
											+ qYOffAbs
											+ mDrawSettings.size_miniBorderYInset;
								} else {
									// qoffset moves up.
									yOffset[0] = -qYOffAbs
											- mDrawSettings.size_miniBorderYInset
											- mDrawSettings.size_miniBorderHeight;
									yOffset[1] = mDrawSettings
											.size_blockHeight
											- qYOffAbs
											- mDrawSettings.size_miniBorderYInset;
								}
							} else if (mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_VERTICAL_OVER) {
								// shadows on the horizontal portion.
								yOffset[0] = yOffset[1] = (mDrawSettings
										.size_qYOffset > 0 == (qp == 0)) ? mDrawSettings
										.size_qYOffset : -mDrawSettings
										.size_qYOffset;
								// Clip to only this edge.
								if (yOffset[0] > 0) {
                                    reset(tempPath);
                                    unionRect(tempPath, 0,
                                            mDrawSettings
                                                    .size_blockHeight
                                                    - mDrawSettings.size_miniBorderYInset
                                                    - mDrawSettings.size_miniBorderHeight,
                                            mDrawSettings.size_blockWidth,
                                            mDrawSettings.size_blockHeight,
                                            Path.Direction.CW);
                                    op(clipPath, tempPath, Path.Op.INTERSECT);
								} else {
                                    reset(tempPath);
                                    unionRect(tempPath, 0, 0,
                                            mDrawSettings.size_blockWidth,
                                            mDrawSettings.size_miniBorderYInset + mDrawSettings.size_miniBorderHeight,
                                            Path.Direction.CW);
                                    op(clipPath, tempPath, Path.Op.INTERSECT);
								}
								int qXOffAbs = Math.abs(mDrawSettings
										.size_qXOffset);
								if (mDrawSettings.size_qXOffset > 0 == (qp == 0)) {
									xOffset[0] = -mDrawSettings
											.size_blockWidth + qXOffAbs;
									xOffset[1] = qXOffAbs
											+ mDrawSettings.size_miniBorderWidth;
								} else {
									// qoffset moves left
									xOffset[0] = -qXOffAbs
											- mDrawSettings.size_miniBorderWidth;
									xOffset[1] = mDrawSettings
											.size_blockWidth - qXOffAbs;
								}
								if (mDrawSettings.size_qXOffset > 0 == (qp == 0)) {
									// qoffset moves down.
									xOffset[0] = mDrawSettings.size_miniBorderXInset
											+ qXOffAbs
											+ mDrawSettings.size_miniBorderWidth;
									xOffset[1] = -mDrawSettings
											.size_blockWidth
											+ qXOffAbs
											+ mDrawSettings.size_miniBorderXInset;
								} else {
									// qoffset moves up.
									xOffset[0] = -qXOffAbs
											- mDrawSettings.size_miniBorderXInset
											- mDrawSettings.size_miniBorderWidth;
									xOffset[1] = mDrawSettings
											.size_blockWidth
											- qXOffAbs
											- mDrawSettings.size_miniBorderXInset;
								}
							}

							canvas.save();
							canvas.clipPath(clipPath);
							canvas.drawBitmap(renderScratchBitmap, xOffset[0],
									yOffset[0], null);
							canvas.drawBitmap(renderScratchBitmap, xOffset[1],
									yOffset[1], null);
							canvas.restore();
						}

					}

					customBorder_byQPaneQOrientation[qp][qo] = b;
					customBorderBounds_byQPaneQOrientation[qp][qo] = new Rect(
							0, 0, mDrawSettings.size_blockWidth,
							mDrawSettings.size_blockHeight);
				}
				
				else if ( mDrawSettings.behavior_qo_bitmap[qo] == DrawSettings.BEHAVIOR_QO_BITMAP_CHEVRON_BORDER ) {
					// a custom border: draw the chevron stripe as if it is a border.  Do
					// this in two steps: draw the chevron, then draw the border around it.
					int wInset = 0, hInset = 0;

					if (mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_INNER
							|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER
							|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE) {
						wInset = mDrawSettings.size_borderWidth;
						hInset = mDrawSettings.size_borderHeight;
					} else if (mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_PANE_INSET
							|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INSET) {
						wInset = mDrawSettings.size_innerBorderXInset
								+ mDrawSettings.size_innerBorderWidth;
						hInset = mDrawSettings.size_innerBorderYInset
								+ mDrawSettings.size_innerBorderHeight;
					} else if (mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI
							|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_HORIZONTAL_OVER
							|| mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_VERTICAL_OVER) {
						wInset = mDrawSettings.size_miniBorderXInset
								+ mDrawSettings.size_miniBorderWidth;
						hInset = mDrawSettings.size_miniBorderYInset
								+ mDrawSettings.size_miniBorderHeight;
					}

					boolean invert = qo != QOrientations.PUSH_UP_ACTIVE && qo != QOrientations.PUSH_UP ;

					StringBuilder sb = new StringBuilder();
					sb.append("customBitmapChevronBorder");
					sb.append("_").append(mDrawSettings.size_blockWidth);
					sb.append("_").append(mDrawSettings.size_blockHeight);
					sb.append("_").append(wInset).append("_").append(hInset);
					sb.append("_").append(Skin.toStringEncoding(mDrawSettings.getSkin()));
					sb.append("_").append(invert);

					String key = sb.toString();

					boolean rendered = preallocated
							.hasBlockSizeBitmapInUse(key)
							|| (preallocated.hasBlockSizeBitmap(key) && preallocated
									.getRenderedDrawSettings() != null);

					Bitmap bitmap = preallocated.getBlockSizeBitmap(key,
							mDrawSettings.size_blockWidth,
							mDrawSettings.size_blockHeight,
							Bitmap.Config.ARGB_8888);

					if (!rendered) {
						// prerender.
						// This call will clear the bitmap before drawing
						// content.
						bitmap = this.renderChevronBitmap(bitmap,
								mDrawSettings, context, -1, -1,
								invert, false, (byte)qo, qp, wInset, hInset);
						
						
						Canvas canvas = new Canvas(bitmap) ;
						
						int outerLeft, outerTop, outerRight, outerBottom;
						int innerLeft, innerTop, innerRight, innerBottom;

						// We assume that the inner border shines have already been
						// generated.
						// An inset border is just an inner border, slightly inset,
						// that covers
						// exactly one square. We can easily prerender this as a
						// bitmap to
						// be applied over the entire square.
						if ( mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_INNER ) {
							outerLeft = outerTop = 0 ;
							outerRight = mDrawSettings.size_blockWidth ;
							outerBottom = mDrawSettings.size_blockHeight ;
							innerLeft = outerLeft + mDrawSettings.size_borderWidth ;
							innerTop = outerTop + mDrawSettings.size_borderHeight ;
							innerRight = outerRight - mDrawSettings.size_borderWidth ;
							innerBottom = outerBottom - mDrawSettings.size_borderHeight ;
						} else if (mDrawSettings.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INSET) {
							outerLeft = mDrawSettings.size_innerBorderXInset;
							outerTop = mDrawSettings.size_innerBorderYInset;
							outerRight = mDrawSettings.size_blockWidth
									- mDrawSettings.size_innerBorderXInset;
							outerBottom = mDrawSettings.size_blockHeight
									- mDrawSettings.size_innerBorderYInset;
							innerLeft = outerLeft
									+ mDrawSettings.size_innerBorderWidth;
							innerTop = outerTop
									+ mDrawSettings.size_innerBorderHeight;
							innerRight = outerRight
									- mDrawSettings.size_innerBorderWidth;
							innerBottom = outerBottom
									- mDrawSettings.size_innerBorderHeight;
						} else {
							outerLeft = mDrawSettings.size_miniBorderXInset;
							outerTop = mDrawSettings.size_miniBorderYInset;
							outerRight = mDrawSettings.size_blockWidth
									- mDrawSettings.size_miniBorderXInset;
							outerBottom = mDrawSettings.size_blockHeight
									- mDrawSettings.size_miniBorderYInset;
							innerLeft = outerLeft
									+ mDrawSettings.size_miniBorderWidth;
							innerTop = outerTop
									+ mDrawSettings.size_miniBorderHeight;
							innerRight = outerRight
									- mDrawSettings.size_miniBorderWidth;
							innerBottom = outerBottom
									- mDrawSettings.size_miniBorderHeight;
						}
						
						int shineTL = mDrawSettings.getColor_borderShine(qp, qo, DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX) ;
						int shineTR = mDrawSettings.getColor_borderShine(qp, qo, DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX) ;
						int shineBL = mDrawSettings.getColor_borderShine(qp, qo, DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX) ;
						int shineBR = mDrawSettings.getColor_borderShine(qp, qo, DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX) ;
						
						// now draw the border itself.
						// draw the 4 corners, then connect them.
						// Use 'borderPaint' as the under color, and
						// 'tempColorPaint' as the shine.
						borderPaint.setColor(mDrawSettings.color_qOrientationQPaneBorder[qo][qp]);
						tempColorPaint.setColor(shineTL);
						canvas.drawRect(outerLeft, outerTop, innerLeft,
								innerTop, borderPaint);
						canvas.drawRect(outerLeft, outerTop, innerLeft,
								innerTop, tempColorPaint);
						
						tempColorPaint.setColor(shineTR);
						canvas.drawRect(innerRight, outerTop, outerRight,
								innerTop, borderPaint);
						canvas.drawRect(innerRight, outerTop, outerRight,
								innerTop, tempColorPaint);
						
						tempColorPaint.setColor(shineBL);
						canvas.drawRect(outerLeft, innerBottom, innerLeft,
								outerBottom, borderPaint);
						canvas.drawRect(outerLeft, innerBottom, innerLeft,
								outerBottom, tempColorPaint);
						
						tempColorPaint.setColor(shineBR);
						canvas.drawRect(innerRight, innerBottom, outerRight,
								outerBottom, borderPaint);
						canvas.drawRect(innerRight, innerBottom, outerRight,
								outerBottom, tempColorPaint);

						Drawable d;
						int c;
						d = innerBorder_byQPaneQOrientationCornerCornerDirection[qp][qo][DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX][DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX][BlockDrawer.DIRECTION_RIGHT];
						c = innerBorderColorSubstitute_byQPaneQOrientationCornerCorner[qp][qo][DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX][DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX];
						if (d != null) {
							d.setBounds(innerLeft, outerTop, innerRight,
									innerTop);
							d.draw(canvas);
						} else {
							tempColorPaint.setColor(c);
							canvas.drawRect(innerLeft, outerTop, innerRight,
									innerTop, tempColorPaint);
						}

						d = innerBorder_byQPaneQOrientationCornerCornerDirection[qp][qo][DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX][DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX][BlockDrawer.DIRECTION_DOWN];
						c = innerBorderColorSubstitute_byQPaneQOrientationCornerCorner[qp][qo][DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX][DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX];
						if (d != null) {
							d.setBounds(outerLeft, innerTop, innerLeft,
									innerBottom);
							d.draw(canvas);
						} else {
							tempColorPaint.setColor(c);
							canvas.drawRect(outerLeft, innerTop, innerLeft,
									innerBottom, tempColorPaint);
						}

						d = innerBorder_byQPaneQOrientationCornerCornerDirection[qp][qo][DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX][DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX][BlockDrawer.DIRECTION_DOWN];
						c = innerBorderColorSubstitute_byQPaneQOrientationCornerCorner[qp][qo][DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX][DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX];
						if (d != null) {
							d.setBounds(innerRight, innerTop, outerRight,
									innerBottom);
							d.draw(canvas);
						} else {
							tempColorPaint.setColor(c);
							canvas.drawRect(innerRight, innerTop, outerRight,
									innerBottom, tempColorPaint);
						}

						d = innerBorder_byQPaneQOrientationCornerCornerDirection[qp][qo][DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX][DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX][BlockDrawer.DIRECTION_RIGHT];
						c = innerBorderColorSubstitute_byQPaneQOrientationCornerCorner[qp][qo][DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX][DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX];
						if (d != null) {
							d.setBounds(innerLeft, innerBottom, innerRight,
									outerBottom);
							d.draw(canvas);
						} else {
							tempColorPaint.setColor(c);
							canvas.drawRect(innerLeft, innerBottom, innerRight,
									outerBottom, tempColorPaint);
						}
					}
					
					
					customBorder_byQPaneQOrientation[qp][qo] = bitmap;
					customBorderBounds_byQPaneQOrientation[qp][qo] = new Rect(
							0, 0, mDrawSettings.size_blockWidth,
							mDrawSettings.size_blockHeight);
				}
			}
		}
	}

	private void prerenderRowNegativeOne(
			BlockDrawerPreallocatedBitmaps preallocated) {
		if (rowNegativeOneBorder_byQPane == null) {
			rowNegativeOneBorder_byQPane = new Bitmap[2];
			rowNegativeOneBorderBounds_byQPane = new Rect[2];
		}
		for (int i = 0; i < 2; i++) {
			rowNegativeOneBorder_byQPane[i] = null;
			rowNegativeOneBorderBounds_byQPane[i] = null;
		}

		// render as a bitmap showing the "top" of the relevant QPane.
		if ((mDrawSettings.draw3D || mDrawSettings.getBehaviorIs_displacement())
				&& preallocated.getRowNegativeOneBitmaps() != null) {
			for (int qp = 0; qp < 2; qp++) {
				int shineColor0, shineColor1, color;

				shineColor0 = mDrawSettings.getColor_rowGuideBorderShine(qp, DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX) ;
				shineColor1 = mDrawSettings.getColor_rowGuideBorderShine(qp, DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX) ;
				
				color = mDrawSettings.color_qPaneBottomGuide[qp];

				Drawable d = new GradientDrawable(
						GradientDrawable.Orientation.LEFT_RIGHT, new int[] {
								shineColor0, shineColor1 });

				int left_x = mDrawSettings.getBlockXPosition(qp, 0);
				int right_x = mDrawSettings.getBlockXPosition(qp,
						mDrawSettings.COLS);
				int bottom_y = mDrawSettings.getBlockYPosition(qp, -1);
				int top_y = bottom_y - mDrawSettings.size_borderHeight;
				int width = right_x - left_x;
				int height = bottom_y - top_y;

				Bitmap b = preallocated.getRowNegativeOneBitmaps()[qp];
				Canvas c = new Canvas(b);
				c.drawPaint(clearPaint);
				c.drawColor(color);
				d.setBounds(0, 0, width, height);
				d.draw(c);

				rowNegativeOneBorder_byQPane[qp] = b;
				rowNegativeOneBorderBounds_byQPane[qp] = new Rect(0, 0, width,
						height);
			}
		}
	}

	private void generateHashingDrawable() {
		hashing_byQPane = new Drawable[2];
		for (int qp = 0; qp < 2; qp++) {
			LineShadingDrawable d = new LineShadingDrawable();
			d.setColor(mDrawSettings.color_qOrientationQPaneFill[qp == 0 ? QOrientations.S0
					: QOrientations.S1][qp]);
			d.setLineSeparation(mDrawSettings.size_hashingLineSpacing[qp]);
			d.setLineWidth(mDrawSettings.size_hashingLineWidth[qp]);
			d.setLineVector(mDrawSettings.hashingVector_qPane[qp]);
			if (mDrawSettings.drawDetail >= DrawSettings.DRAW_DETAIL_MID
					&& mDrawSettings.size_hashingLineShadowLayerRadius[qp] > 0)
				d.setShadowLayer(
						mDrawSettings.size_hashingLineShadowLayerRadius[qp],
						0xff000000);
			hashing_byQPane[qp] = d;
		}
	}

	/**
	 * Sets whether this BlockDrawer will draw anything to the canvas upon a
	 * call to "draw*." If true (default) normal operation occurs. If false,
	 * calls to draw* will not affect the Canvas, but WILL update any animation
	 * timing as if a draw occurred.
	 * 
	 * @param vis
	 */
	public void setVisible(boolean vis) {
		visible = vis;
	}

	synchronized public final void redrawLastGameBlocksSlice(Canvas canvas,
			BlockDrawerConfigCanvas configCanvas) {

		if (recycled)
			return;

		this.drawGameBlocksSlice(canvas, null, mLastSlice, mLastSliceTime,
				configCanvas);
		this.mNextSliceNeedsExplicitConfigCanvas = true;
	}

	synchronized public final void drawStableGameBlocksSlice(Canvas canvas,
			GameBlocksSlice slice, BlockDrawerSliceTime sliceTime) {

		drawStableGameBlocksSlice(canvas, slice, sliceTime, 255);
	}

	synchronized public final void drawStableGameBlocksSlice(Canvas canvas,
			GameBlocksSlice slice, BlockDrawerSliceTime sliceTime, int blitAlpha) {

		if (recycled)
			return;

		if (mLastSlice == null || !mLastSlice.fits(slice)) {
			mLastSlice = new GameBlocksSlice(slice);
			mNextSliceBreaksSequence = true;
			mNextSlicePossiblyInconsistent = true;
			mNextSliceDisplacementRowsChanged = true ;
		}
		drawStableWithLastSlice(canvas, null, slice, sliceTime, null, blitAlpha);
	}

	synchronized public final void drawMinimumProfileGameBlocksSlice(
			Canvas canvas, GameBlocksSlice slice, BlockDrawerSliceTime sliceTime) {

		drawMinimumProfileGameBlocksSlice(canvas, slice, sliceTime, 255);
	}

	synchronized public final void drawMinimumProfileGameBlocksSlice(
			Canvas canvas, GameBlocksSlice slice,
			BlockDrawerSliceTime sliceTime, int blitAlpha) {

		if (recycled)
			return;

		if (mLastSlice == null || !mLastSlice.fits(slice)) {
			mLastSlice = new GameBlocksSlice(slice);
			mNextSliceBreaksSequence = true;
			mNextSlicePossiblyInconsistent = true;
			mNextSliceDisplacementRowsChanged = true ;
		}
		drawStableWithLastSlice(canvas, null, slice, sliceTime, null,
				DrawStableFieldType.MINIMUM_PROFILE, blitAlpha);
	}

	synchronized public final void nextGameBlocksSliceBreaksSequence() {
		mNextSliceBreaksSequence = true;
		mNextSliceDisplacementRowsChanged = true ;
		clearEffects();
	}

	synchronized public final void nextGameBlocksSliceMayBeInconsistent() {
		mNextSlicePossiblyInconsistent = true;
	}
	
	synchronized public final void nextGameBlocksSliceDisplacementChanged() {
		mNextSliceDisplacementRowsChanged = true ;
	}

	synchronized public final void veil(BlockDrawerSliceTime sliceTime) {
		// log("veil at " + sliceTime.getTotal()) ;
		mVeiled = true;
		mVeilPossiblyOnScreen = true;
		mTimeLastVeiling = sliceTime.getTotal();
		mTimeFirstVeilDraw = -1;
	}

	synchronized public final void unveil(BlockDrawerSliceTime sliceTime) {
		// log("unveil at " + sliceTime.getTotal()) ;
		mVeiled = false;
		mVeilPossiblyOnScreen = true;
		mTimeLastUnveiling = sliceTime.getTotal();
		mTimeFirstVeilDraw = -1;
	}

	synchronized public final void rewindVeil(long delta) {
		if (mVeiled)
			mTimeLastVeiling += delta;
		else
			mTimeLastUnveiling += delta;

		if (mTimeFirstVeilDraw > 0)
			mTimeFirstVeilDraw += delta;
	}

	synchronized public final boolean veiled() {
		return mVeiled;
	}

	synchronized public final boolean veiledFully(BlockDrawerSliceTime sliceTime) {

		// We are fully veild if:
		// mVeiled is set, AND
		// EITHER:
		// 1. We have been recycled
		// 2. We have had enough time to pull the veil into place.
		if ( !mVeiled )
			return false ;
		long timeVeiling = timeDrawingVeil( sliceTime, false ) ;
		return recycled || veiledPixelHeight(timeVeiling) == veiledPixelHeight(timeVeiling + 1000) ;
	}

	synchronized public final boolean veilOnScreen(
			BlockDrawerSliceTime sliceTime) {
		// if ( sliceTime.getTotal() < mTimeLastVeiling )
		// log("veilOnScreen at " + sliceTime.getTotal() + " with veil "
		// + mVeiled + " last time at " + mTimeLastVeiling + " and unveiling " +
		// mTimeLastVeiling) ;
		boolean onScreen = mVeiled
				|| (mVeilPossiblyOnScreen && unveiledPixelHeight(sliceTime
						.getTotal() - mTimeLastUnveiling) < mDrawSettings.height);
		mVeilPossiblyOnScreen = onScreen;
		return onScreen;
	}

	synchronized public final boolean willDrawVeilPixels(
			BlockDrawerSliceTime sliceTime) {
		// if ( sliceTime.getTotal() < mTimeLastVeiling )
		// log("veilOnScreen at " + sliceTime.getTotal() + " with veil "
		// + mVeiled + " last time at " + mTimeLastVeiling + " and unveiling " +
		// mTimeLastVeiling) ;
		return veilOnScreen(sliceTime) && mDrawSettings != null
				&& mDrawSettings.getBlit() != DrawSettings.BLIT_NONE;
	}

	synchronized private final int unveiledPixelHeight(long timeUnveiling) {
		return (int) Math.round(mDrawSettings.size_blockHeight
				* animationSettings.distanceUnveiled(
						timeUnveiling,
						(float) mDrawSettings.height
								/ (float) mDrawSettings.size_blockHeight));
	}

	synchronized private final int veiledPixelHeight(long timeVeiling) {
		return (int) Math.round(mDrawSettings.size_blockHeight
				* animationSettings.distanceVeiled(
						timeVeiling,
						(float) mDrawSettings.height
								/ (float) mDrawSettings.size_blockHeight));
	}
	
	synchronized private final long timeDrawingVeil(BlockDrawerSliceTime sliceTime, boolean drawingNow) {
		long timeVeiling ;
		if (mTimeFirstVeilDraw == -1) {
			timeVeiling = 0;
			if ( drawingNow )
				mTimeFirstVeilDraw = 0;
		} else if (mTimeFirstVeilDraw == 0) {
			timeVeiling = 1;
			if ( drawingNow )
				mTimeFirstVeilDraw = sliceTime.getTotal() - 1;
		} else
			timeVeiling = sliceTime.getTotal() - mTimeFirstVeilDraw;
		
		return timeVeiling ;
	}

	/**
	 * Advances time for an entirely new slice. This slice is advanced in the
	 * foreground; it will be drawn before the next call to 'advance.'
	 * 
	 * @param slice
	 * @param sliceTime
	 * @param millis
	 *            The amount of time since the last advance.
	 * @param isPaused
	 *            Is the game currently paused?
	 */
	synchronized public final void advanceNewSliceInForeground(
			GameBlocksSlice slice, BlockDrawerSliceTime sliceTime, long millis,
			boolean isPaused) {

		if (isPaused || veilOnScreen(sliceTime))
			sliceTime.advanceToNewSlicePaused(millis);
		else
			sliceTime.advanceToNewSlice(millis);

		// how long would this take to draw?
		sliceTime.setSliceTimeNeeded(drawGameBlocksSliceTimeToComplete(slice));

		// hold new slices to give 1 animation step to build structures
		sliceTime.setSliceHeld(true);
	}

	/**
	 * Advances time for an entirely new slice. This slice is advanced in the
	 * foreground; it will be drawn before the next call to "advance"
	 * 
	 * @param slice
	 * @param sliceTime
	 */
	synchronized public final void advanceSliceInForeground(
			GameBlocksSlice slice, BlockDrawerSliceTime sliceTime, long millis,
			boolean isPaused) {

		if (isPaused || veilOnScreen(sliceTime))
			sliceTime.advancePaused(millis);
		else
			sliceTime.advance(millis);

		// unhold old slices to play animations
		sliceTime.setSliceHeld(false);
	}

	/**
	 * Advances time for an entirely new slice. This slice is advanced in the
	 * background; it will not be drawn.
	 * 
	 * @param slice
	 * @param sliceTime
	 */
	synchronized public final void advanceNewSliceInBackground(
			GameBlocksSlice slice, BlockDrawerSliceTime sliceTime, long millis,
			boolean isPaused) {

		// don't hold new slices.
		sliceTime.setSliceHeld(false);
		if (isPaused || veilOnScreen(sliceTime))
			sliceTime.advanceToNewSlicePaused(millis);
		else
			sliceTime.advanceToNewSlice(millis);

		// how long would this take to draw?
		sliceTime.setSliceTimeNeeded(drawGameBlocksSliceTimeToComplete(slice));

		// hold new slices to give 1 animation step to build structures
		sliceTime.setSliceHeld(true);
	}

	/**
	 * Advances time for an entirely new slice. This slice is advanced in the
	 * background; it will not be drawn.
	 * 
	 * @param slice
	 * @param sliceTime
	 */
	synchronized public final void advanceSliceInBackground(
			GameBlocksSlice slice, BlockDrawerSliceTime sliceTime, long millis,
			boolean isPaused) {

		if (isPaused || veilOnScreen(sliceTime))
			sliceTime.advancePaused(millis);
		else
			sliceTime.advance(millis);
		// unhold old slices to play animations
		sliceTime.setSliceHeld(false);
	}

	/**
	 * "Pretends" to draw the provided block slice. Returns the number of
	 * milliseconds before, in this BlockDrawer's opinion, it is appropriate to
	 * request a new slice (e.g., if all animations would be complete had this
	 * slice been drawn). One should hold on to the slice until this amount of
	 * time passes. The purpose is to delay the advancement of an echoed game
	 * until the animations would have finished; basically, we want to be able
	 * to switch to actually drawing this slice at any moment without wasting
	 * CPU cycles simulating it before we need to.
	 * 
	 * This method may be safely called without interfering with optimized
	 * drawing, even with inconsistent slices. The main purpose here is to
	 * provide a replacement for the previous "visible" setting in multiple
	 * BlockDrawers.
	 * 
	 * In short, call draw() with the single game being displayed, and
	 * draw...Pretend() for all other games being echoed. When the displayed
	 * game changes, first call nextGameBlocksSliceWillBeInconsistent() and then
	 * begin draw()ing slices from the new game and draw...Pretend()ing the
	 * original game.
	 * 
	 * Sidenote: the purpose of this method, rather than visible/invisible as an
	 * instance variable, is to compensate for the massive memory requirements
	 * of a BlockDrawer after the optimization changes. It is completely
	 * inappropriate now to allocate a unique BlockDrawer object for every Game
	 * object, as we did before; each will allocate (at the very least, assuming
	 * good cache behavior) a Bitmap double the size of the associated draw
	 * area. Therefore, as a convention, we will allow at most one BlockDrawer
	 * object for any given screen pixel to limit the total size of these cache
	 * Bitmaps.
	 */
	synchronized public final long drawGameBlocksSliceTimeToComplete(
			GameBlocksSlice slice) {

		switch( mDrawSettings.drawAnimations ) {
		case DrawSettings.DRAW_ANIMATIONS_ALL:
			switch (slice.getBlocksState()) {
			case GameBlocksSlice.BLOCKS_STABLE:
				// stable is always ready to advance
				return 0;
	
			case GameBlocksSlice.BLOCKS_PIECE_FALLING:
				// falling has no animations to draw; it is always ready to draw
				return 0;
	
			case GameBlocksSlice.BLOCKS_CHUNKS_FALLING:
				// We need to examine each chunk individually. A chunk will take a
				// certain amount of time to fall, and then a certain amount of time
				// (possibly 0) to animate locking.
				int qo = PieceCatalog.getQCombination(slice.getPieceType());
				boolean riseAndFade = slice.getChunksArePieceComponents()
						&& qo >= 0
						&& qo < QOrientations.NUM
						&& mDrawSettings.behavior_qo_falling_chunk[PieceCatalog
								.getQCombination(slice.getPieceType())] == DrawSettings.BEHAVIOR_QO_FALLING_CHUNK_PIECE_TYPE_PIECE_COMPONENT_RISE_AND_FADE;
				long maxTime = 0;
				if (riseAndFade)
					maxTime = animationSettings.time_riseFade;
				else {
					for (int i = slice.getFirstChunk(); i < slice.getFirstChunk()
							+ slice.getNumChunks(); i++) {
						int d = slice.getFallDistances()[i];
						if (d >= 0) {
							long fallTime = animationSettings.fall_timeToFallDistance[d];
							int numGlows = 0;
							if (d > 0 || slice.getChunksArePieceComponents()) {
								for (int qp = 0; qp < 2; qp++)
									numGlows = Math.max(
											numGlows,
											setLockGlows(mDrawSettings,
													slice.getChunks()[i],
													slice.getBlockfields()[i], qp,
													true, null, null, 0, 0));
								if (numGlows > 0)
									fallTime += animationSettings
											.lockGlowTimeToFinish(0, 1, 0);
							}
	
							maxTime = Math.max(maxTime, fallTime);
						}
					}
				}
				// if there are columns to unlock, add the necessary time.
				if (slice.getNumUnlockedColumns() > 0)
					maxTime += animationSettings.unlockColumnGlowTotalTime(0, 1, 0);
				return maxTime;
	
			case GameBlocksSlice.BLOCKS_ROWS_CLEARING:
				// clearing is simple - it's done when we finished emphasizing
				// and glowing the clear.
				return animationSettings.clearEmphTotalTime(
						mDrawSettings.alpha_lockedFill,
						mDrawSettings.alpha_emphFill)
						+ animationSettings.clearGlowTimeToFinish(0, 1, 0);
	
			case GameBlocksSlice.BLOCKS_METAMORPHOSIZING:
				// metamorphosis takes time based on lock and block glows. Determine
				// if we have any before counting the time for them.
				long lockGlowTime = animationSettings.lockGlowTimeToFinish(0, 1, 0);
				long blockGlowTime = animationSettings
						.metamorphosisGlowTimeToFinish(0, 1, 0);
	
				byte[][][] pre_field = slice.getMetamorphosisPreBlockfield();
				byte[][][] post_field = slice.getMetamorphosisPostBlockfield();
	
				boolean hasLockGlows = false;
				boolean hasBlockGlows = false;
	
				ArrayOps.setEmpty(tempBlockfield);
				for (int qp = 0; qp < 2; qp++) {
					if (!hasLockGlows) {
						for (int row = 0; row < mDrawSettings.displayedRows; row++) {
							int r = row + mDrawSettings.blockFieldOuterBuffer;
							for (int col = 0; col < mDrawSettings.COLS; col++) {
								int c = col + mDrawSettings.blockFieldOuterBuffer;
								byte pre_qo = pre_field[qp][r][c];
								byte post_qo = post_field[qp][r][c];
								if (pre_qo != post_qo
										&& (mDrawSettings.behavior_qo_metamorphosis_from[pre_qo] == DrawSettings.BEHAVIOR_QO_METAMORPHOSIS_LOCK_GLOW || mDrawSettings.behavior_qo_metamorphosis_to[post_qo] == DrawSettings.BEHAVIOR_QO_METAMORPHOSIS_LOCK_GLOW)) {
									tempBlockfield[qp][r][c] = pre_qo;
								}
							}
						}
						if (0 < setLockGlows(mDrawSettings, tempBlockfield,
								post_field, qp, false, null, null, 0, 0))
							hasLockGlows = true;
					}
					if (!hasBlockGlows) {
						for (int row = 0; row < mDrawSettings.displayedRows; row++) {
							int r = row + mDrawSettings.blockFieldOuterBuffer;
							for (int col = 0; col < mDrawSettings.COLS; col++) {
								int c = col + mDrawSettings.blockFieldOuterBuffer;
								byte pre_qo = pre_field[qp][r][c];
								byte post_qo = post_field[qp][r][c];
								if (pre_qo != post_qo
										&& (mDrawSettings.behavior_qo_metamorphosis_from[pre_qo] == DrawSettings.BEHAVIOR_QO_METAMORPHOSIS_GLOW || mDrawSettings.behavior_qo_metamorphosis_to[post_qo] == DrawSettings.BEHAVIOR_QO_METAMORPHOSIS_GLOW)) {
									tempBlockfield[qp][r][c] = pre_qo;
								} else {
									tempBlockfield[qp][r][c] = QOrientations.NO;
								}
							}
						}
						if (0 < setMetamorphosisBlockGlows(mDrawSettings,
								pre_field, post_field, qp, null, null, 0, 0))
							hasBlockGlows = true;
					}
				}
				return Math.max(1, (hasLockGlows ? lockGlowTime : 0)
						+ (hasBlockGlows ? blockGlowTime : 0));
	
			case GameBlocksSlice.BLOCKS_PUSHING_ROWS:
				// We are finished adding rows if 1. we have waited enough time to
				// rise
				// to the specified height, AND 2. if there are any glows to draw,
				// they
				// are complete.
				long timeToRise = animationSettings.timeToPushDistance(
						slice.getNumRowsPushedDown(), slice.getNumRowsPushedUp());
				int numGlows = 0;
				int numNewRows = slice.getNumRowsAddedByPush()
						+ slice.getNumRowsAddedByTransfer();
				for (int qp = 0; qp < 2; qp++)
					numGlows = Math.max(
							numGlows,
							setRisingLockGlows(mDrawSettings,
									slice.getBlockfieldStable(), numNewRows, qp,
									null, null, 0, numNewRows));
				return Math.max(
						timeToRise,
						numGlows > 0 ? animationSettings.timeToPushMinimum(
								slice.getNumRowsPushedDown(),
								slice.getNumRowsPushedUp())
								+ animationSettings.lockGlowTimeToFinish(0, 1, 0)
								: 0);
			}
			break ;
			
			
		case DrawSettings.DRAW_ANIMATIONS_STABLE_STUTTER:
			// takes the standard stutter time for transition states; otherwise zero.
			switch( slice.getBlocksState() ) {
			case GameBlocksSlice.BLOCKS_STABLE:
			case GameBlocksSlice.BLOCKS_PIECE_FALLING:
				return 0 ;
			case GameBlocksSlice.BLOCKS_CHUNKS_FALLING:
			case GameBlocksSlice.BLOCKS_ROWS_CLEARING:
			case GameBlocksSlice.BLOCKS_METAMORPHOSIZING:
			case GameBlocksSlice.BLOCKS_PUSHING_ROWS:
				return STUTTER_DRAW_TIME_MILLISECONDS ;
			}
			break ;
			
		
		case DrawSettings.DRAW_ANIMATIONS_NONE:
			// no time at all.  We don't draw animations.
			return 0 ;
		}

		throw new RuntimeException("what the hell kind of state is "
				+ slice.getBlocksState());
	}

	/**
	 * Returns whether the most recently drawn slice included limited-duration
	 * animations of any form. A "limited duration" animation is one that will
	 * advance if the time advances, AND has a specified (and predictable)
	 * end-time that we will reach if we continue to advance the time.
	 * 
	 * Will return 'true' if: We are drawing an "animated" slice that has not
	 * yet ended; for example chunks falling, rows clearing, etc. In other
	 * words, continuing to advance time will eventually "end" these animations.
	 * We have "effects" to draw that represent visual events (probably from
	 * previous slices), and those effects will fade over time -- in other
	 * words, continuing to advance time will eventually "end" these animations.
	 * 
	 * This method is used when we want to pause or suspend a game, but only
	 * after all its important animations play out. Note that we should NOT use
	 * this method to determine "when to advance" from one animation to the
	 * next. BlockDrawer will often "linger" animations from one slice to the
	 * next, and this method will return 'true' in that case even when it is
	 * appropriate to advance slices. Additionally, even if this is not the
	 * case, BlockDrawer will often take an extra tick (an extra 'frame') to
	 * finish animating stuff. This represents the fact that we need to draw the
	 * "stable" or "new" state before being "finished" animating it. If we rely
	 * on this method to advance slices, it will cause a 1 frame delay each
	 * time.
	 * 
	 * @return
	 */
	synchronized public final boolean drawGameBlocksSliceLastDrawDidAnimateGame() {
		
		// Only DRAW_ANIMATIONS_ALL has specific behavior for this method.  Read
		// the documentation for this method closely: STABLE_STUTTER animations will
		// NEVER change over time (i.e., advancing SliceTime without moving to a different
		// slice).
		if ( mDrawSettings.drawAnimations == DrawSettings.DRAW_ANIMATIONS_ALL ) {
			if (mLastSlice == null)
				return false;
			if (mLastSliceTime == null)
				return false;
			long timeToComplete = drawGameBlocksSliceTimeToComplete(mLastSlice);
			if (timeToComplete > 0 && timeToComplete < mLastSliceTime.getSlice())
				return true;
			if (mLastEffectsGlow.sizeActive(mLastSliceTime) > 0)
				return true;
			if (mLastEffectsFade.sizeActive(mLastSliceTime) > 0)
				return true;
		}

		return false;
	}

	synchronized public final boolean drawGameBlocksSlice(Canvas canvas,
			QuantroSoundPool pool, GameBlocksSlice slice,
			BlockDrawerSliceTime sliceTime) {

		return drawGameBlocksSlice(canvas, pool, slice, sliceTime, null);

	}

	/**
	 * Draws the current blocks slice. Returns whether, in this BlockDrawer's
	 * opinion, it is appropriate to request a new slice (e.g., if all
	 * animations are complete). Will only return 'false' if increasing the
	 * millisSpentDrawingSlice will change the displayed images.
	 */
	synchronized public final boolean drawGameBlocksSlice(Canvas canvas,
			QuantroSoundPool pool, GameBlocksSlice slice,
			BlockDrawerSliceTime sliceTime, BlockDrawerConfigCanvas configCanvas) {

		// log("drawSlice " + slice.getBlocksStateString() +
		// " at slice time " + sliceTime.getSlice() + " unpaused " +
		// sliceTime.getUnpaused()) ;

		if (recycled)
			return true;

		if (GlobalTestSettings.BLOCK_DRAWER_LOG_PROFILING) {
			mSlicesDrawn++;
			if (mSlicesDrawn % 1000 == 0)
				printProfileSummary();
		}

		if (mTickIndex >= 0)
			Log.e(TAG,"tick leak! " + mTickIndex + " " + slice.getBlocksState());

		mProfileBehavior = INDEX_PROFILE_SLICE_NOT_BEHAVIOR;

		if (mLastSlice == null || !mLastSlice.fits(slice)) {
			mLastSlice = new GameBlocksSlice(slice);
			mNextSliceBreaksSequence = true;
			mNextSlicePossiblyInconsistent = true;
			mNextSliceDisplacementRowsChanged = true ;
		}
		
		
		// SHORT-CIRCUIT.
		if (mLastSlice != null && !sliceTime.hasBeenDrawnEver()
				&& mLastSliceTime != null && mLastSliceTime.hasBeenDrawnEver()) {
			if (shouldHoldToDrawLingeringEffects(slice, sliceTime)) {
				mLastSliceTime.advanceToReferenceUnpaused(sliceTime);
				// update displacement
				mLastSlice.setDisplacement(slice.getDisplacement()) ;
				boolean mayBeInconsistent = this.mNextSlicePossiblyInconsistent;
				boolean displacementChanged = this.mNextSliceDisplacementRowsChanged ;
				mNextSlicePossiblyInconsistent = false;
				mNextSliceDisplacementRowsChanged = false;
				drawGameBlocksSlice(canvas, pool, mLastSlice, mLastSliceTime,
						configCanvas);
				mNextSlicePossiblyInconsistent = mayBeInconsistent;
				mNextSliceDisplacementRowsChanged = displacementChanged ;
				sliceTime.setSliceHeld(true);
				// hold the next advance.
				return false; // not complete
			}
		}
		
		
		// If the slice changed, so did the displacement.
		if ( this.mNextSliceBreaksSequence )
			mNextSliceDisplacementRowsChanged = true ;
		if ( this.mNextSlicePossiblyInconsistent ) {
			if ( mDrawSettings.getBehaviorIs_displacement() &&
					!ArrayOps.areEqual(mLastSlice.getDisplacementBlockfield(), slice.getDisplacementBlockfield()) )
				mNextSliceDisplacementRowsChanged = true ;
		}
		
		if ( mNextSliceDisplacementRowsChanged ) {
			if ( mDrawSettings.getBehaviorIs_displacement() ) {
				// Update the displacement metadata!
				byte[][][] field = slice.getDisplacementBlockfield() ;
				byte[][][][] corners = mLastCorners_byField_byPaneCorner.get(INDEX_FIELD_DISPLACEMENT);
				setShadowsAndCorners(mDrawSettings, field, mConfigRangeStandard,
						null, null, corners);
			}
					
			mNextSliceDisplacementRowsChanged = false ;
			mLastBitmapDifferentDisplacement = true ;
		}
		

		switch( mDrawSettings.drawAnimations ) {
		case DrawSettings.DRAW_ANIMATIONS_ALL:
			// Optimized version!
			if (mLastSlice != null) {
				switch (slice.getBlocksState()) {
				case GameBlocksSlice.BLOCKS_STABLE:
					drawStableWithLastSlice(canvas, pool, slice, sliceTime,
							configCanvas, 255);
					break;
	
				case GameBlocksSlice.BLOCKS_PIECE_FALLING:
					drawPieceFallingInBlockFieldWithLastSlice(canvas, pool, slice,
							sliceTime, configCanvas);
					break;
	
				case GameBlocksSlice.BLOCKS_CHUNKS_FALLING:
					drawChunksFallingWithLastSlice(canvas, pool, slice, sliceTime,
							configCanvas);
					break;
	
				case GameBlocksSlice.BLOCKS_ROWS_CLEARING:
					drawRowsClearingWithLastSlice(canvas, pool, slice, sliceTime,
							configCanvas);
					break;
	
				case GameBlocksSlice.BLOCKS_METAMORPHOSIZING:
					drawMetamorphosisWithLastSlice(canvas, pool, slice, sliceTime,
							configCanvas);
					break;
	
				case GameBlocksSlice.BLOCKS_PUSHING_ROWS:
					drawPushingBlockFieldWithLastSlice(canvas, pool, slice,
							sliceTime, configCanvas);
					break;
	
				default:
					throw new IllegalArgumentException(
							"mLastSlice is null; can't draw slice of state "
									+ slice.getBlocksState());
				}
			}
			break ;
			
			
			
		case DrawSettings.DRAW_ANIMATIONS_STABLE_STUTTER:
			// "stable stutter" through animations.  In short,
			// for stable or "piece" slices, we simply display the slice
			// as normal.  For other, "transition" slices, we display
			// the "before" ("initial") state for the appropriate
			// stutter time, then move on.
			if (mLastSlice != null) {
				// most of our draw methods are designed for animations; furthermore,
				// they assume animations are allowed to play out in full (transitioning
				// from INITIAL to STABLE) before advancing.  We therefore need to
				// ready ourselves for a full redraw if necessary.  Assumption: when a
				// piece is falling, we are informed every time the piece state changes.
				// This assumption allows us to avoid a complete redraw with each player
				// action (we prefer a minimum redraw in that case, to keep frame rate up).
				if ( mLastSlice.getBlocksState() != slice.getBlocksState() ||
								( sliceTime != null && !sliceTime.hasBeenDrawnEver()
										&& slice.getBlocksState() != GameBlocksSlice.BLOCKS_PIECE_FALLING ) ) {
					// force a redraw.  We can't predict that things haven't
					// changed -- in fact, they probably HAVE changed, since
					// this means we animated something.
					mNextSliceBreaksSequence = true ;
					
					drawGameBlocksSlice_addStutterSoundEffects( slice, sliceTime ) ;
				}
				
				switch (slice.getBlocksState()) {
				case GameBlocksSlice.BLOCKS_STABLE:
					drawStableWithLastSlice(canvas, pool, slice, sliceTime,
							configCanvas, 255);
					break;
	
				case GameBlocksSlice.BLOCKS_PIECE_FALLING:
					drawPieceFallingInBlockFieldWithLastSlice(canvas, pool, slice,
							sliceTime, configCanvas);
					break;
	
				default:
					drawStableWithLastSlice(canvas, pool, slice, sliceTime,
							configCanvas, DrawStableFieldType.INITIAL,
							255) ;
					break ;
				}
			}
			break ;
			

		case DrawSettings.DRAW_ANIMATIONS_NONE:
			// only draw stable...
			if ( mLastSlice != null ) {
				switch( slice.getBlocksState() ) {
				case GameBlocksSlice.BLOCKS_PIECE_FALLING:
					drawPieceFallingInBlockFieldWithLastSlice(canvas, pool, slice,
							sliceTime, configCanvas);
					break ;
					
				case GameBlocksSlice.BLOCKS_STABLE:
				default:
					drawStableWithLastSlice(canvas, pool, slice, sliceTime,
							configCanvas, 255);
					break ;
				}
				
			}
			break ;
		}
		
		mLastBitmapDifferentDisplacement = false ;

		recycleOccludedBackgroundAssets(sliceTime);

		return finishedAnimatingLastSlice(sliceTime);
	}
	
	
	
	/**
	 * The provided slice is new.  Add the appropriate 'stutter' sound effects with
	 * the appropriate timing and delays!
	 * 
	 * @param slice
	 * @param sliceTime
	 */
	private void drawGameBlocksSlice_addStutterSoundEffects( GameBlocksSlice slice, BlockDrawerSliceTime sliceTime ) {
		
		// We don't like dealing with "slice relative" sound effects, because we don't necessarily
		// hold on to slices indefinitely.  We immediately put things in "unpaused relative"
		// notation instead.
		BlockDrawerSliceTime.RelativeTo relativeTo = BlockDrawerSliceTime.RelativeTo.UNPAUSED ;
		long delay = sliceTime.convert(STUTTER_SOUND_EFFECT_TIME_MILLISECONDS,
				BlockDrawerSliceTime.RelativeTo.SLICE,
				BlockDrawerSliceTime.RelativeTo.UNPAUSED ) ;
		
		switch ( slice.getBlocksState() ) {
		case GameBlocksSlice.BLOCKS_STABLE:
			break ;
		case GameBlocksSlice.BLOCKS_PIECE_FALLING:
			break ;
		case GameBlocksSlice.BLOCKS_CHUNKS_FALLING:
			if ( hasColumnUnlockGlows( slice ) ) {
				mLastEffectsSound.addColumnUnlocked(
						relativeTo, delay, slice.getPieceType());
			}
			break ;
		case GameBlocksSlice.BLOCKS_ROWS_CLEARING:
			// sounds play when the "gap" appears between rows.
			this.drawRowsClearingWithLastSlice_helperAddSoundEffects(
					slice, relativeTo, delay, 0, STUTTER_SOUND_EFFECT_PENALTY_EXTRA_TIME_MILLISECONDS) ;		// no clear emphasis, even in Quantro.
			break ;
		case GameBlocksSlice.BLOCKS_METAMORPHOSIZING:
			break ;
		case GameBlocksSlice.BLOCKS_PUSHING_ROWS:
			// sounds play when the new rows appear.
			// Adds garbage and row push sound effects.  Does NOT add 'enter' effects.
			drawPushedBlockFieldWithLastSlice_helperAddRowPushSoundEffects(
					slice, relativeTo, delay ) ;
			break ;
		}
	}
	

	/**
	 * A simple, efficient helper method for drawing the same (non-animated)
	 * slice multiple times. If you know that the next draw is the same as the
	 * last -- for example, if you are drawing a "NextPiece" or a simplified
	 * "opponent's game preview" that does not animate and has not changed, this
	 * method will re-blit exactly what was drawn last time to the same position
	 * on the canvas.
	 * 
	 * This method will throw an exception if called using BLIT_SEPTUPLE or
	 * BLIT_NONE.
	 * 
	 * @param canvas
	 */
	public void reblitLastGameBlocksSlice(Canvas canvas) {
		if (mDrawSettings.getBlit() == DrawSettings.BLIT_NONE)
			throw new IllegalStateException(
					"Cannot reblit when blit behavior is NONE");
		if (mDrawSettings.getBlit() == DrawSettings.BLIT_SEPTUPLE)
			throw new IllegalStateException(
					"Cannot reblit when blit behavior is SEPTUPLE");

		canvas.drawBitmap(mLastBitmap[BITMAP_FULL],
				mLastBitmapBounds[BITMAP_FULL],
				mLastBitmapBlitRect[BITMAP_FULL], blitPaint);
	}

	/**
	 * A simple, efficient helper method for drawing the same (non-animated)
	 * slice multiple times. If you know that the next draw is the same as the
	 * last -- for example, if you are drawing a "NextPiece" or a simplified
	 * "opponent's game preview" that does not animate and has not changed, this
	 * method will re-blit exactly what was drawn last time to the same position
	 * on the canvas.
	 * 
	 * This method will throw an exception if called using BLIT_QUADRUPLE or
	 * BLIT_NONE.
	 * 
	 * @param canvas
	 */
	public void reblitLastGameBlocksSlice(Canvas canvas, int blitAlpha) {
		if (mDrawSettings.getBlit() == DrawSettings.BLIT_NONE)
			throw new IllegalStateException(
					"Cannot reblit when blit behavior is NONE");

		if (blitAlpha == 255)
			canvas.drawBitmap(mLastBitmap[BITMAP_FULL],
					mLastBitmapBounds[BITMAP_FULL],
					mLastBitmapBlitRect[BITMAP_FULL], blitPaint);
		else {
			blitPaintWithAlpha.setAlpha(blitAlpha);
			canvas.drawBitmap(mLastBitmap[BITMAP_FULL],
					mLastBitmapBounds[BITMAP_FULL],
					mLastBitmapBlitRect[BITMAP_FULL], blitPaintWithAlpha);
		}
	}
	

	private final void fullBlitDrawBackground(DrawSettings drawSettings,
			Canvas canvas, Offset offsetBackground,
			BlockDrawerSliceTime sliceTime,
			BlockDrawerConfigCanvas.Background background, int stableAlpha,
			int volatileAlpha, int blockRegionYOffset) {

	    canvas.save();

		if (mLastSliceTime != null
				&& this.backgroundLayerChanged(mLastSliceTime, sliceTime)
				&& background == BlockDrawerConfigCanvas.Background.DEFAULT) {
			// full clip.
			// maybe reduce this to a full clip of those areas not covered by
			// blocks?
			tempDstRect.set(offsetBackground.x, offsetBackground.y,
					offsetBackground.x + drawSettings.width, offsetBackground.y
							+ drawSettings.height);
			canvas.clipRect(tempDstRect, Region.Op.INTERSECT);
		}

		// We displace the touched / covered regions by their current
		// displacement before drawing the blit background.
		if (blockRegionYOffset != 0) {
			mLastBitmapCoveredPath[BITMAP_REGION_FULL_STABLE].offset(0,
					blockRegionYOffset);
			if (mLastBitmapCoveredPath[BITMAP_REGION_FULL_VOLATILE] != mLastBitmapCoveredPath[BITMAP_REGION_FULL_STABLE]) {
				mLastBitmapCoveredPath[BITMAP_REGION_FULL_VOLATILE]
						.offset(0, blockRegionYOffset);
			}
		}

		// Background: clip the difference to remove opaque COVERED blocks.
		canvas.save();
		if (stableAlpha == 255) {
		    canvas.clipPath(this.mLastBitmapCoveredPath[BITMAP_REGION_FULL_STABLE], Region.Op.DIFFERENCE);
		}
		if (volatileAlpha == 255) {
		    canvas.clipPath(this.mLastBitmapCoveredPath[BITMAP_REGION_FULL_VOLATILE], Region.Op.DIFFERENCE);
		}

		drawBackgroundBehaviorToCanvas(drawSettings, canvas, offsetBackground,
				sliceTime, background);
		canvas.restore();

		// Block backing: UNION those which are covered and draw.
		// STABLE takes precedence in which alpha is used.
		// Note: we caculate this union, and then INTERSECT it
		// with the current clip.
		if (stableAlpha == volatileAlpha) {
			reset(tempPath);
			op(
			        tempPath,
			        mLastBitmapCoveredPath[BITMAP_REGION_FULL_STABLE],
                    mLastBitmapCoveredPath[BITMAP_REGION_FULL_VOLATILE],
                    Path.Op.UNION
            );

			canvas.save();
			canvas.clipPath(tempPath);
			canvas.drawColor(ColorOp.setAlphaForColor(stableAlpha,
					mDrawSettings.color_background_piece));
			canvas.restore();
		} else {
			// Draw the STABLE background everywhere STABLE occurs; draw
			// the VOLATILE background in those places where VOLATILE
			// exits but STABLE does not.
			canvas.save();
			canvas.clipPath(mLastBitmapCoveredPath[BITMAP_REGION_FULL_STABLE]);
			canvas.drawColor(ColorOp.setAlphaForColor(stableAlpha,
					mDrawSettings.color_background_piece));
			canvas.restore();

			op(
			        tempPath,
                    mLastBitmapCoveredPath[BITMAP_REGION_FULL_VOLATILE],
                    mLastBitmapCoveredPath[BITMAP_REGION_FULL_STABLE],
                    Path.Op.DIFFERENCE
            );

			canvas.save();
			canvas.clipPath(tempPath);
			canvas.drawColor(ColorOp.setAlphaForColor(volatileAlpha,
					mDrawSettings.color_background_piece));
			canvas.restore();
		}

		if (blockRegionYOffset != 0) {
			mLastBitmapCoveredPath[BITMAP_REGION_FULL_STABLE].offset(0,
					-blockRegionYOffset);
			if (mLastBitmapCoveredPath[BITMAP_REGION_FULL_VOLATILE] != mLastBitmapCoveredPath[BITMAP_REGION_FULL_STABLE]) {
				mLastBitmapCoveredPath[BITMAP_REGION_FULL_VOLATILE]
						.offset(0, -blockRegionYOffset);
			}
		}

		// that's it.
        canvas.restore();
	}

	/**
	 * Draws the background to the provided canvas, according to our draw
	 * settings.
	 */
	private final void drawBackgroundBehaviorToCanvas(
			DrawSettings drawSettings, Canvas canvas, Offset offsetBackground,
			BlockDrawerSliceTime sliceTime,
			BlockDrawerConfigCanvas.Background background) {

		if (background == BlockDrawerConfigCanvas.Background.NONE) {
			return;
		}

		if (background == BlockDrawerConfigCanvas.Background.CLEAR
				|| (background == null && mBackgroundAssets != null && drawSettings.behavior_background == DrawSettings.BEHAVIOR_BACKGROUND_BLIT_IMAGE)) {
			canvas.drawPaint(clearPaint);
			return;
		}

		if (background == BlockDrawerConfigCanvas.Background.DEFAULT
				&& mBackgroundAssets != null
				&& drawSettings.getBehaviorIs_backgroundBlit()) {
			canvas.drawPaint(clearPaint);
			return;
		}

		// draw background
		// draw background: happens in 2 different steps. If we draw 'all,' we
		// fill
		// now. Otherwise, if BLOCK_FILL, we draw twice - first to set the
		// background
		// color, second to draw the fills themselves.
		if ((Color.alpha(drawSettings.getBackground().getColor()) != 255 && (drawSettings.behavior_background == DrawSettings.BEHAVIOR_BACKGROUND_ALL_EMPTY || drawSettings.behavior_background == DrawSettings.BEHAVIOR_BACKGROUND_EMPTY_AND_PIECE))
				|| drawSettings.behavior_background == DrawSettings.BEHAVIOR_BACKGROUND_BLOCK_FILL)
			canvas.drawPaint(clearPaint);

		if (mBackgroundAssets != null
				&& (((drawSettings.behavior_background == DrawSettings.BEHAVIOR_BACKGROUND_ALL_EMPTY || drawSettings.behavior_background == DrawSettings.BEHAVIOR_BACKGROUND_EMPTY_AND_PIECE) && Color
						.alpha(drawSettings.getBackground().getColor()) != 0) || (drawSettings.behavior_background == DrawSettings.BEHAVIOR_BACKGROUND_CLIP_OR_BLIT_IMAGE))) {

			tempDstRect.set(offsetBackground.x, offsetBackground.y,
					offsetBackground.x + drawSettings.width, offsetBackground.y
							+ drawSettings.height);
			drawLayeredBackgroundAssets(canvas, tempDstRect, sliceTime,
					background);
		}
	}

	/**
	 * Draws the background assets, mBackgroundAssets, according to our
	 * animation settings
	 * 
	 * @param canvas
	 * @param dstRect
	 * @param background
	 * @param sliceTime
	 */
	private void drawLayeredBackgroundAssets(Canvas canvas, Rect dstRect,
			BlockDrawerSliceTime sliceTime,
			BlockDrawerConfigCanvas.Background background) {

		int firstVisible = lastOpaqueBackgroundLayer(sliceTime);

		if (animationSettings == null) {
			mBackroundAssetNumberLastDraw = 1;
			BackgroundAsset ba = mBackgroundAssets.get(firstVisible);
			ba.draw(canvas, dstRect, background);
			return;
		}

		for (int i = firstVisible; i < mBackgroundAssets.size(); i++) {
			mBackroundAssetNumberLastDraw = 0;
			BackgroundAsset ba = mBackgroundAssets.get(i);
			long timeVisible = backgroundLayerTimeSpentFadingIn(i, sliceTime);
			float alpha = animationSettings
					.shuffle_backgroundAlphaMult(timeVisible);
			if (alpha > 0) {
				ba.draw(canvas, dstRect, background, alpha);
				mBackroundAssetNumberLastDraw++;
			}
		}
	}

	/**
	 * Recycles and removes BackgroundAssets which are fully occluded by newer
	 * assets. Automatically returns any preallocated bitmaps to the
	 * Preallocated Bitmaps set (if it exists).
	 * 
	 * Note that to be occluded, a Background requires another background above
	 * it which is fully opaque. We do NOT recycle backgrounds which are fully
	 * transparent unless an opaque layer occurs AFTER them; we assume
	 * transparent layers in front of opaque ones are pre-loaded and will
	 * eventually be "faded in."
	 * 
	 * @param sliceTime
	 */
	private void recycleOccludedBackgroundAssets(BlockDrawerSliceTime sliceTime) {

		int firstVisible = lastOpaqueBackgroundLayer(sliceTime);

		// 'first' is also the number of preceeding layers which should
		// be recycled and removed.
		for (int i = 0; i < firstVisible; i++) {
			recycleBackgroundAsset(0);
		}
	}

	private void recycleBackgroundAsset(int index) {
		mBackgroundAssetTimeIntroduced.remove(index);
		BackgroundAsset ba = mBackgroundAssets.remove(index);
		if (ba.isPreallocated() && mHasPreallocatedBitmaps)
			mPreallocatedBitmaps.retireBackgroundBitmap(ba.getBitmap(null));
	}

	/**
	 * Finds and returns the last fully-opaque background layer (as an index
	 * into mBackgroundAssets). All background assets with indices less than
	 * this are fully occluded.
	 * 
	 * @param sliceTime
	 * @return
	 */
	private int lastOpaqueBackgroundLayer(BlockDrawerSliceTime sliceTime) {
		if (animationSettings == null)
			return 0;

		int last = 0;
		for (int i = 0; i < mBackgroundAssets.size(); i++) {
			long timeSpentFadingIn = backgroundLayerTimeSpentFadingIn(i,
					sliceTime);
			if (animationSettings
					.shuffle_backgroundAlphaMult(timeSpentFadingIn) >= 1)
				last = i;
		}

		return last;
	}

	private long backgroundLayerTimeSpentFadingIn(int layerNum,
			BlockDrawerSliceTime sliceTime) {
		Long time = mBackgroundAssetTimeIntroduced.get(layerNum);
		long curTime = animationSettings.shuffle_stopWhenPaused() ? sliceTime
				.getUnpaused() : sliceTime.getTotal();

		long timeVisible = 0;
		if (layerNum == 0)
			timeVisible = Long.MAX_VALUE;
		else if (time != null && time.longValue() >= 0)
			timeVisible = curTime - time.longValue();

		return timeVisible;
	}

	/**
	 * Extremely useful method for clipping purposes. If the background layer
	 * did NOT change, then we can rely on outside clipping information to only
	 * redraw content-changes. If the background layer DID change, we need to
	 * redraw basically the entire thing.
	 * 
	 * @param sliceTimePrev
	 * @param sliceTime
	 * @return
	 */
	private boolean backgroundLayerChanged(BlockDrawerSliceTime sliceTimePrev,
			BlockDrawerSliceTime sliceTime) {

		if (sliceTimePrev == null || sliceTime == null
				|| animationSettings == null)
			return false;

		int firstVisiblePrev = lastOpaqueBackgroundLayer(sliceTimePrev);
		int firstVisible = lastOpaqueBackgroundLayer(sliceTime);

		if (firstVisiblePrev != firstVisible)
			return true;

		if (mBackroundAssetNumberLastDraw > 1)
			return true;

		for (int i = firstVisible; i < mBackgroundAssets.size(); i++) {
			long timePrev = backgroundLayerTimeSpentFadingIn(i, sliceTimePrev);
			long time = backgroundLayerTimeSpentFadingIn(i, sliceTime);

			if (animationSettings.shuffle_backgroundAlphaMult(timePrev) != animationSettings
					.shuffle_backgroundAlphaMult(time))
				return true;
		}

		return false;
	}

	private static final int STYLE_PULSE_FILL = 10;
	private static final int STYLE_NOT_PULSE_FILL = 11;
	private static final int STYLE_ALL = 12;
	private static final int STYLE_FILL = 13;
	private static final int STYLE_TOP = 14;
	private static final int STYLE_FILL_AND_TOP = 15;
	private static final int STYLE_FILL_WITHOUT_BOX = 16;
	private static final int STYLE_FILL_WITHOUT_BOX_AND_TOP = 17;
	private static final int STYLE_ALL_BUT_FILL_AND_TOP = 18;
	private static final int STYLE_FILL_WITHOUT_BOX_AND_TOP_AND_BORDER = 19 ;
	private static final int STYLE_FILL_AND_BORDER = 20 ;
	private static final int STYLE_DROP_SHADOW = 21 ; // ONLY draw the drop
														// shadow.
	
	
	

	/**
	 * Draws the entire pane, including glows (if draw detail is MID or higher).
	 * If glowSetArrays are null or detail is LOW, no glows will be drawn.
	 * 
	 * This method will maintain the current clip on the 'canvas' (possibly
	 * intersecting it and then restoring).
	 * 
	 * 'qpane' should be one of QPANE_*.
	 * 
	 * This method does not draw a background on the canvas; it is intended to
	 * be used (for example) repeatedly on the same canvas to draw different
	 * QPanes.
	 */
	private final void drawBlockFieldQPaneAtAlignmentOffset(
			DrawSettings drawSettings, Canvas canvas, byte[][][] blockField,
			BlockDrawerConfigRange configRange, int qpane, int pieceType,
			Offset alignmentOffset, float alphaMult, int alphaFill,
			float alphaFillPulseScale, int alphaTop, int alphaBorder,
			byte[][] tlCorner, byte[][] trCorner, byte[][] blCorner,
			byte[][] brCorner, byte[][] qo_tlCorner, byte[][] qo_trCorner,
			byte[][] qo_blCorner, byte[][] qo_brCorner,
			short[][] innerShadowSetArray, short[][][] dropShadowSetArray,
			short[][] qo_sets, BlockDrawerSliceTime effectSliceTime,
			int glowStyle, GlowEffectList glows, int fadeType,
			FadeEffectList fadeEffectList) {

		int alphaDrop = 255;
		int alphaShadow = drawSettings.drawDetail >= DrawSettings.DRAW_DETAIL_MID ? 255
				: 0;
		int alpha3DShadow = drawSettings.drawDetail >= DrawSettings.DRAW_DETAIL_MID ? alphaFill
				: 0;

		if (alphaMult >= 0 && alphaMult != 1) {
			alphaFill = Math.round(alphaFill * alphaMult);
			alphaFillPulseScale = Math.round(alphaFillPulseScale * alphaMult);
			alphaTop = Math.round(alphaTop * alphaMult);
			alphaBorder = Math.round(alphaBorder * alphaMult);
			alphaShadow = Math.round(alphaShadow * alphaMult);
			alpha3DShadow = Math.round(alpha3DShadow * alphaMult);
		}

		if (qpane == Consts.QPANE_3D) {
			drawBlockFieldQPane3DAtAlignmentOffset(drawSettings, canvas,
					blockField, null, configRange, alignmentOffset, tlCorner,
					trCorner, blCorner, brCorner, qo_tlCorner, qo_trCorner,
					qo_blCorner, qo_brCorner, null, null, null, null, qo_sets,
					alphaTop, alphaFill, alphaFillPulseScale, alpha3DShadow,
					false, effectSliceTime, fadeType, fadeEffectList);
		} else {
			drawBlockFieldQPane2DAtAlignmentOffset(drawSettings, STYLE_ALL,
					canvas, blockField, configRange, qpane, pieceType,
					alignmentOffset, alphaFill, alphaFillPulseScale, alphaTop,
					alphaMult >= 0 ? alphaMult : 1, alphaBorder,

					alphaShadow,
					alphaDrop,
					// not be drawn.
					tlCorner, // 255 to spot errors: these should
					trCorner, blCorner, brCorner, innerShadowSetArray,
					dropShadowSetArray, effectSliceTime, glowStyle, glows);
		}
	}
	
	private void drawBlockFieldQPane2DAtAlignmentOffset(
			DrawSettings drawSettings, int style, Canvas canvas,
			byte[][][] blockField, BlockDrawerConfigRange configRange,
			int qpane, int pieceType, Offset alignmentOffset, int alphaFill,
			float alphaFillPulseScale, int alphaTop, float alphaTopMult,
			int alphaBorder, int alphaShadow, int alphaDrop,
			byte[][] tlCorner, byte[][] trCorner, byte[][] blCorner, byte[][] brCorner,
			short[][] innerShadowSetArray, short[][][] dropShadowSetArray,
			BlockDrawerSliceTime effectSliceTime, int glowStyle,
			GlowEffectList glows) {
		
		// DON'T use simplified colors.
		drawBlockFieldQPane2DAtAlignmentOffset( drawSettings, style, canvas,
				blockField, configRange, qpane, pieceType, alignmentOffset,
				alphaFill, alphaFillPulseScale, alphaTop, alphaTopMult, alphaBorder,
				alphaShadow, alphaDrop,
				tlCorner, trCorner, blCorner, brCorner,
				innerShadowSetArray, dropShadowSetArray,
				effectSliceTime, glowStyle, false, glows ) ;
		
	}

	private void drawBlockFieldQPane2DAtAlignmentOffset(
			DrawSettings drawSettings, int style, Canvas canvas,
			byte[][][] blockField, BlockDrawerConfigRange configRange,
			int qpane, int pieceType, Offset alignmentOffset, int alphaFill,
			float alphaFillPulseScale, int alphaTop, float alphaTopMult,
			int alphaBorder, int alphaShadow, int alphaDrop,
			byte[][] tlCorner, byte[][] trCorner, byte[][] blCorner, byte[][] brCorner,
			short[][] innerShadowSetArray, short[][][] dropShadowSetArray,
			BlockDrawerSliceTime effectSliceTime, int glowStyle, boolean simplifiedColors,
			GlowEffectList glows) {

		// two different styles. If PULSE_FILL, we only draw the fill color of
		// pulsing
		// blocks. If NOT_PULSE_FILL, draw everything EXCEPT the fill color of
		// pulsing
		// blocks.

		// draw pulse fill...
		if (style == STYLE_PULSE_FILL) {
			tick();
			if (blockField != null)
				drawFillLayerToCanvas(drawSettings, STYLE_PULSE_FILL, canvas,
						blockField, configRange, qpane, alphaFill,
						alphaFillPulseScale, simplifiedColors, alignmentOffset);
			// color
			mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_FILL] += tock();
			return;
		}

		// draw fill...
		if (style == STYLE_FILL) {
			tick();
			if (blockField != null)
				drawFillLayerToCanvas(drawSettings, STYLE_FILL, canvas,
						blockField, configRange, qpane, alphaFill,
						alphaFillPulseScale, simplifiedColors, alignmentOffset);
			mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_FILL] += tock();
			return;
		}
		
		// fill and border...
		if ( style == STYLE_FILL_AND_BORDER ) {
			tick();
			if (blockField != null)
				drawFillLayerToCanvas(drawSettings, STYLE_FILL, canvas,
						blockField, configRange, qpane, alphaFill,
						alphaFillPulseScale, simplifiedColors, alignmentOffset);
			mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_FILL] += tock();
			
			if (blockField != null
					&& tlCorner != null
					&& trCorner != null
					&& blCorner != null
					&& brCorner != null
					&& drawSettings.drawDetail > DrawSettings.DRAW_DETAIL_MINIMAL) {
				tick();
				drawBorderDrawablesToCanvas(drawSettings, canvas, blockField,
						configRange, qpane, tlCorner, trCorner, blCorner,
						brCorner, alphaBorder, simplifiedColors, alignmentOffset);
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_BORDER] += tock();
			}
			
			return;
		}

		if (style == STYLE_FILL_WITHOUT_BOX) {
			tick();
			if (blockField != null)
				drawFillLayerToCanvas(drawSettings, STYLE_FILL_WITHOUT_BOX,
						canvas, blockField, configRange, qpane, alphaFill,
						alphaFillPulseScale, simplifiedColors, alignmentOffset);
			mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_FILL] += tock();
			return;
		}

		// draw top...
		if (style == STYLE_TOP) {
			// top colors
			tick();
			drawTopLayerToCanvas(drawSettings, canvas, blockField, configRange,
					qpane, alphaTop, alphaTopMult, alignmentOffset);
			mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_TOP] += tock();
			return;
		}

		if (style == STYLE_FILL_AND_TOP) {
			tick();
			if (blockField != null)
				drawFillLayerToCanvas(drawSettings, STYLE_FILL, canvas,
						blockField, configRange, qpane, alphaFill,
						alphaFillPulseScale, simplifiedColors, alignmentOffset);
			mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_FILL] += tock();
			// top colors
			tick();
			drawTopLayerToCanvas(drawSettings, canvas, blockField, configRange,
					qpane, alphaTop, alphaTopMult, alignmentOffset);
			mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_TOP] += tock();
			return;
		}

		if (style == STYLE_FILL_WITHOUT_BOX_AND_TOP) {
			tick();
			if (blockField != null)
				drawFillLayerToCanvas(drawSettings, STYLE_FILL_WITHOUT_BOX,
						canvas, blockField, configRange, qpane, alphaFill,
						alphaFillPulseScale, simplifiedColors, alignmentOffset);
			mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_FILL] += tock();
			// top colors
			tick();
			drawTopLayerToCanvas(drawSettings, canvas, blockField, configRange,
					qpane, alphaTop, alphaTopMult, alignmentOffset);
			mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_TOP] += tock();
			return;
		}

		if (style == STYLE_DROP_SHADOW) {
			tick();
			if (blockField != null
					&& dropShadowSetArray != null
					&& drawSettings.drawDetail > DrawSettings.DRAW_DETAIL_MINIMAL)
				drawOuterShadowSetsToCanvas(drawSettings, canvas,
						dropShadowSetArray, blockField, configRange, qpane,
						alphaDrop, alignmentOffset);
			mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_DROP_SHADOW] += tock();
			return;
		}
		
		if ( style == STYLE_FILL_WITHOUT_BOX_AND_TOP_AND_BORDER ) {
			tick();
			if (blockField != null)
				drawFillLayerToCanvas(drawSettings, STYLE_FILL_WITHOUT_BOX,
						canvas, blockField, configRange, qpane, alphaFill,
						alphaFillPulseScale, simplifiedColors, alignmentOffset);
			mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_FILL] += tock();
			// top colors
			tick();
			drawTopLayerToCanvas(drawSettings, canvas, blockField, configRange,
					qpane, alphaTop, alphaTopMult, alignmentOffset);
			mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_TOP] += tock();
			
			if (blockField != null
					&& tlCorner != null
					&& trCorner != null
					&& blCorner != null
					&& brCorner != null
					&& drawSettings.drawDetail > DrawSettings.DRAW_DETAIL_MINIMAL) {
				tick();
				drawBorderDrawablesToCanvas(drawSettings, canvas, blockField,
						configRange, qpane, tlCorner, trCorner, blCorner,
						brCorner, alphaBorder, simplifiedColors, alignmentOffset);
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_BORDER] += tock();
			}
			return;
		}

		// only draw if have a blockfield (obviously)
		if (blockField != null) {
			// outer shadows are drawn first, so the rest of the content can
			// occlude it.
			if (dropShadowSetArray != null
					&& drawSettings.drawDetail > DrawSettings.DRAW_DETAIL_MINIMAL) {
				tick();
				drawOuterShadowSetsToCanvas(drawSettings, canvas,
						dropShadowSetArray, blockField, configRange, qpane,
						alphaDrop, alignmentOffset);
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_DROP_SHADOW] += tock();
			}

			// fill colors. 'style' is either NOT_PULSE_FILL or ALL_FILL, so we
			// can
			// pass it directly to 'drawFill' and then proceed to the rest.
			if (style != STYLE_ALL_BUT_FILL_AND_TOP) {
				tick();
				drawFillLayerToCanvas(drawSettings, style, canvas, blockField,
						configRange, qpane, alphaFill, alphaFillPulseScale,
						simplifiedColors, alignmentOffset);
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_FILL] += tock();
				// top colors
				tick();
				drawTopLayerToCanvas(drawSettings, canvas, blockField,
						configRange, qpane, alphaTop, alphaTopMult,
						alignmentOffset);
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_TOP] += tock();
			}
			// inner shadows
			if (alphaShadow > 0
					&& innerShadowSetArray != null
					&& drawSettings.drawDetail > DrawSettings.DRAW_DETAIL_MINIMAL) {
				// Retro / Quantro inner shadows
				tick();
				drawInnerShadowSetsToCanvas(drawSettings, canvas,
						innerShadowSetArray, blockField, configRange, qpane,
						alphaShadow, alignmentOffset);
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_SHADOW] += tock();
			}
			// border
			if (blockField != null
					&& tlCorner != null
					&& trCorner != null
					&& blCorner != null
					&& brCorner != null
					&& drawSettings.drawDetail > DrawSettings.DRAW_DETAIL_MINIMAL) {
				tick();
				drawBorderDrawablesToCanvas(drawSettings, canvas, blockField,
						configRange, qpane, tlCorner, trCorner, blCorner,
						brCorner, alphaBorder, simplifiedColors, alignmentOffset);
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_BORDER] += tock();
			}
		}

		// Draw glows if we got 'em. Drawing these is independent of drawing
		// blocks.
		int numGlows = glows == null ? 0 : glows.size() ;
			// EffectList.size() is 1% of computation time.  Removing calls to it
			// to reduce CPU load slightly.
		if ( numGlows > 0 ) {
			tick();
			
			// our structures...
			Bitmap[] glowSheet_byGlowIndex = null;
			Rect[] glowSheetBounds_byGlowIndex = null;
			Path[][] glowPath_byGlowIndex_byNeighbors = null;

			// drawSettings structures...
			DrawSettings.GlowColor[] glowColors_array = null;
			float[] glowLightening_array = null;
			float[] glowAlpha_array = null;
			// other data, such as radius, has been covered in
			// our glow sheet / region construction.

			// We iterate as:
			// for TYPE in TYPES:
			// for BEHAVIOR in BEHAVIORS:
			// for GLOW in GLOWS:
			//
			// In other words, we draw all TYPE_1 glows before TYPE_2;
			// we draw all BEHAVIOR_1 glows for TYPE_1 before BEHAVIOR_2 for
			// TYPE_1.

			int firstType, boundsType;
			if (glowStyle == GlowEffect.TYPE_ANY) {
				firstType = GlowEffect.MIN_TYPE;
				boundsType = GlowEffect.NUM_TYPES;
			} else if (glowStyle == GlowEffect.TYPE_NONE) {
				firstType = boundsType = 0; // nothing to iterate over
			} else {
				firstType = glowStyle;
				boundsType = firstType + 1;
			}

			for (int type = firstType; type < boundsType; type++) {
				// set our in-conditional variables according to this type
				int glowIndex = GlowEffect.typeToConstGlowIndex(type);
				glowSheet_byGlowIndex = this.glowSheet_byGlowType_byGlowIndex[glowIndex];
				glowSheetBounds_byGlowIndex = this.glowSheetBounds_byGlowType_byGlowIndex[glowIndex];
				glowPath_byGlowIndex_byNeighbors = this.glowPath_byGlowType_byGlowIndex_byNeighbors[glowIndex];

				glowColors_array = drawSettings.glow_color[glowIndex];
				glowLightening_array = drawSettings.glow_lightenBy[glowIndex];
				glowAlpha_array = drawSettings.glow_alphaPeakNormalized[glowIndex];

				// we might not know what to do here...
				if (glowColors_array == null
						|| (glowSheet_byGlowIndex == null && glowPath_byGlowIndex_byNeighbors == null)) {
					continue;
				}

				// Iterate over the behavior for this glow type.
				for (int index = 0; index < glowColors_array.length; index++) {

					// now iterate over the actual glows.
					for (int i = 0; i < numGlows; i++) {
						GlowEffect glowEffect = glows.get(i);
						if (!glowEffect.isType(type)
								|| glowEffect.qPane() != qpane
								|| !glowEffect.active(effectSliceTime))
							continue;

						long timeSpentGlowing = glowEffect
								.timeSinceStarted(effectSliceTime);
						if (timeSpentGlowing < 0)
							continue;

						float glowAlpha = 0.0f;
						if (type == GlowEffect.TYPE_LOCK)
							glowAlpha = animationSettings
									.lockGlowAlpha(0, glowAlpha_array[index],
											0, timeSpentGlowing);
						else if (type == GlowEffect.TYPE_CLEAR)
							glowAlpha = animationSettings
									.clearGlowAlpha(0, glowAlpha_array[index],
											0, timeSpentGlowing);
						else if (type == GlowEffect.TYPE_METAMORPHOSIS)
							glowAlpha = animationSettings
									.metamorphosisGlowAlpha(0,
											glowAlpha_array[index], 0,
											timeSpentGlowing);
						else if (type == GlowEffect.TYPE_UNLOCK)
							glowAlpha = animationSettings
									.unlockColumnGlowAlpha(0,
											glowAlpha_array[index], 0,
											timeSpentGlowing);
						else if (type == GlowEffect.TYPE_ENTER)
							glowAlpha = animationSettings
									.enterGlowAlpha(0, glowAlpha_array[index],
											0, timeSpentGlowing);

						if (glowAlpha == 0)
							continue;

						// find the appropriate color for the draw
						// (which may or may not be based on the QOrientation
						// tagged for this
						// glow...)
						int qo = glowEffect.qOrientation();
						int qoTriggerPiece = PieceCatalog
								.getQCombination(pieceType);
						int qoQPane = qpane == Consts.QPANE_0 ? QOrientations.S0
								: QOrientations.S1;

						int color = 0xffffffff; // white by default!
						ColorFilter cf = null, af = null;

						switch (glowColors_array[index]) {
						case WHITE:
							color = ColorOp.shade(glowLightening_array[index]);
							break;
						case QPANE:
							color = ColorOp
									.shadeColor(
											glowLightening_array[index],
											drawSettings.color_qOrientationQPaneGlowColor[qoQPane][qpane]);
							break;
						case TRIGGER_QO:
							color = ColorOp
									.shadeColor(
											glowLightening_array[index],
											drawSettings.color_qOrientationQPaneGlowColor[qoTriggerPiece][qpane]);
							break;
						case QO:
							color = ColorOp
									.shadeColor(
											glowLightening_array[index],
											drawSettings.color_qOrientationQPaneGlowColor[qo][qpane]);
							break;
						default:
							throw new IllegalStateException(
									"Don't recognize GlowColor "
											+ glowColors_array[index]);
						}

						color = ColorOp.setAlphaForColor(255, color);

						cf = this.glowColorFilter_byColor == null ? null
								: glowColorFilter_byColor.get(color);

						if (this.alphaScaleMatrix_byAlphaScaleStepMultiple != null) {
							int scaleIndex = (int) Math.floor(glowAlpha
									/ ALPHA_SCALE_STEP_MULTIPLE);
							if (scaleIndex >= alphaScaleMatrix_byAlphaScaleStepMultiple.length)
								scaleIndex = alphaScaleMatrix_byAlphaScaleStepMultiple.length - 1;
							af = alphaScaleMatrix_byAlphaScaleStepMultiple[scaleIndex];
						}

						drawGlowSetArrayToCanvas(drawSettings, canvas,
								glowEffect.directDrawCodeAccess(), configRange,
								color, cf, af, qpane,
								glowSheet_byGlowIndex[index],
								glowSheetBounds_byGlowIndex[index],
								glowPath_byGlowIndex_byNeighbors[index],
								glowAlpha, alignmentOffset);
					}
				}

			}
			mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_GLOW] += tock();
		}
	}

	private void drawBlockFieldQPane3DAtAlignmentOffset(
			DrawSettings drawSettings, Canvas canvas, byte[][][] blockField,
			byte[][][] maskField, BlockDrawerConfigRange configRange,
			Offset alignmentOffset, byte[][] cornerTL, byte[][] cornerTR,
			byte[][] cornerBL, byte[][] cornerBR, byte[][] qo_cornerTL,
			byte[][] qo_cornerTR, byte[][] qo_cornerBL, byte[][] qo_cornerBR,
			byte[][] mask_cornerTL, byte[][] mask_cornerTR,
			byte[][] mask_cornerBL, byte[][] mask_cornerBR, short[][] qo_sets,
			int alphaPrism, int alphaFill, float pulseScaleAlpha,
			int alphaShadow, boolean fillWithBackground,
			BlockDrawerSliceTime effectSliceTime, int fadeEffectType,
			FadeEffectList fadeEffectList) {

		tick();
		if (blockField != null) {
			draw3DLayerToCanvas(drawSettings, canvas, blockField, maskField,
					configRange, alphaPrism, alphaPrism, alphaFill,
					alphaShadow, pulseScaleAlpha, cornerTL, cornerTR, cornerBL,
					cornerBR, qo_cornerTL, qo_cornerTR, qo_cornerBL,
					qo_cornerBR, mask_cornerTL, mask_cornerTR, mask_cornerBL,
					mask_cornerBR, qo_sets, alphaShadow > 0, // full detail?
					alignmentOffset, fillWithBackground);
		}

		if (fadeEffectList != null && !fillWithBackground) {
			byte[][][] effectQOs;
			byte[][][][] effectQOCorners;
			short[][][] effectQOConnectionEncoding;

			int numFades = fadeEffectList.size() ;
			for (int i = 0; i < numFades; i++) {
				FadeEffect fadeEffect = fadeEffectList.get(i);
				if (fadeEffect.isType(fadeEffectType)
						&& fadeEffect.active(effectSliceTime)) {
					switch (fadeEffect.type()) {
					case FadeEffect.TYPE_BOX:
						// A 3D box that fades from pulseScaleAlpha to 0.

						float alphaScale_boxPulse = animationSettings == null ? 0
								: animationSettings.pulseAlpha(
										drawSettings.alphaScale_lockedBoxPulse,
										effectSliceTime.getUnpaused());
						float pulseScaleMult = 1 - fadeEffect
								.proportionComplete(effectSliceTime);
						float boxAlphaMult = alphaScale_boxPulse
								* pulseScaleMult;
						effectQOs = fadeEffect.directQOrientationsAccess();
						effectQOCorners = fadeEffect
								.directQOrientationCornersAccess();
						effectQOConnectionEncoding = fadeEffect
								.directQOrientationEncodedConnectionsAccess();

						if (pulseScaleMult > 0) {
							int fillAlpha = (int) Math.round(alphaFill
									* pulseScaleMult);
							// log("drawing BOX FADE with alpha mult " +
							// pulseScaleMult + " fill alpha " + fillAlpha) ;
							draw3DLayerToCanvas(drawSettings, canvas,
									effectQOs, null, configRange, 0, 0, 0, 0,
									boxAlphaMult, null, null, null, null,
									effectQOCorners[0][INDEX_CORNER_TL],
									effectQOCorners[0][INDEX_CORNER_TR],
									effectQOCorners[0][INDEX_CORNER_BL],
									effectQOCorners[0][INDEX_CORNER_BR], null,
									null, null, null,
									effectQOConnectionEncoding[0],
									alphaShadow > 0, // full detail?
									alignmentOffset, false);
						}
						break;
					}
				}
			}
		}

		mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_3D] += tock();
	}

	/**
	 * Given the provided slice, indicates whether 'timeSpentAnimating' is
	 * sufficient time to fully animate the last slice.
	 * 
	 * Will ignore considerations such as pulsing, fall time, etc. Only
	 * animations which delay the game will be considered.
	 * 
	 * Precondition: the appropriate draw method has been called at the
	 * specified time. For example, if mLastSlice has state PIECE_FALLING, it
	 * was set in 'drawPieceFallingInBlockFieldWithLastSlice' which was called
	 * with the specified times. This allows any instance var set by that draw
	 * method to be read here, if doing so would speed the process of
	 * discovering whether the animation is complete.
	 */
	private boolean finishedAnimatingLastSlice(BlockDrawerSliceTime sliceTime) {
		switch( mDrawSettings.drawAnimations ) {
		case DrawSettings.DRAW_ANIMATIONS_ALL:
			switch (mLastSlice.getBlocksState()) {
			case GameBlocksSlice.BLOCKS_STABLE:
				return true;
	
			case GameBlocksSlice.BLOCKS_PIECE_FALLING:
				return true;
	
			case GameBlocksSlice.BLOCKS_CHUNKS_FALLING:
			case GameBlocksSlice.BLOCKS_ROWS_CLEARING:
			case GameBlocksSlice.BLOCKS_METAMORPHOSIZING:
			case GameBlocksSlice.BLOCKS_PUSHING_ROWS:
				if (mDrawSettings.drawEffects == DrawSettings.DRAW_EFFECTS_IN_SLICE)
					return mLastBitmapIsStableSlice;
				else
					return mLastBitmapIsStableSliceReadyToAdvanceEffects;
	
			default:
				return true;
			}
			
		
		case DrawSettings.DRAW_ANIMATIONS_STABLE_STUTTER:
			switch (mLastSlice.getBlocksState()) {
			case GameBlocksSlice.BLOCKS_STABLE:
				return true;
	
			case GameBlocksSlice.BLOCKS_PIECE_FALLING:
				return true;
	
			case GameBlocksSlice.BLOCKS_CHUNKS_FALLING:
			case GameBlocksSlice.BLOCKS_ROWS_CLEARING:
			case GameBlocksSlice.BLOCKS_METAMORPHOSIZING:
			case GameBlocksSlice.BLOCKS_PUSHING_ROWS:
				return sliceTime.getSlice() >= STUTTER_DRAW_TIME_MILLISECONDS ;
	
			default:
				return true;
			}
			
		case DrawSettings.DRAW_ANIMATIONS_NONE:
			return true ;
		}
		
		// default: yes.
		return true ;
	}

	/**
	 * Sets the provided 'destination' rect to an appropriate place to draw the
	 * provided srcBounds.
	 * 
	 * ASSUMPTION: this method assumes a source rect that is horizontally
	 * matched to the destination. In other words, we want to put the left edge
	 * of srcBounds to the left edge of dstBounds, and the some with the right
	 * edge.
	 * 
	 * This assumption allows us to determine a correct size for the destination
	 * rect, which will match the aspect ratio of the srcBounds.
	 * 
	 * 'sourceRelativeVerticalOffset' is the vertical offset of the source
	 * relative to the destination, scaled using "source pixels." If this value
	 * is negative, we shift the source content upward, drawing it higher in the
	 * destination (proportionally, scaled by the different in pixel size from
	 * the relative widths of source and destination). If positive, the source
	 * will be shifted downward in the destination, proportionally.
	 * 
	 * This offset is relative to top-alignment, putting the top edge of source
	 * at the top edge of destination.
	 */
	private void setCanvasDestinationRect( Rect destination,
			Rect srcBounds, Rect dstBounds,
			int sourceRelativeVerticalOffset) {

		double srcToDestRatio = ((double) dstBounds.width())
				/ ((double) srcBounds.width());

		destination.set(
				dstBounds.left,
				dstBounds.top,
				dstBounds.right,
				(int) Math.round(dstBounds.top + srcBounds.height()
						* srcToDestRatio));

		int dstRelativeVerticalOffset = (int) Math
				.round(sourceRelativeVerticalOffset * srcToDestRatio);
		destination.offset(0, dstRelativeVerticalOffset);
	}

	/**
	 * Draws the provided bitmap to the canvas, using the specified
	 * configCanvas. Other than the draw, the canvas will be unchanged (i.e. no
	 * change to clip after this call).
	 * 
	 * If srcRect is 'null', we use the complete source bitmap.
	 * 
	 * POSTCONDITIONS: 1. The content of 'src', possibly contained in srcRect,
	 * is drawn to 'canvas' according to configCanvas. 2. Neither the clip nor
	 * transformation matrix of 'canvas' have changed. 3. 'tempDstRect' and
	 * 'tempSrcRect' may have been altered.
	 * 
	 * @param canvas
	 *            The canvas to which we draw 'src.'
	 * @param src
	 *            The source bitmap to draw.
	 * @param srcRect
	 *            The region of 'source' to draw. If null, the full bitmap is
	 *            used.
	 * @param configCanvas
	 *            Our canvas configuration. Must not be null.
	 */
	private void drawBitmapToCanvasWithConfig(Canvas canvas, Bitmap src,
			Rect srcRect, GameBlocksSlice slice,
			BlockDrawerConfigCanvas configCanvas, Paint drawPaint) {

		// save our canvas clip; we will restore it at the end of the method.
		canvas.save();

		// if no source rect is provided, alias it to tempSrcRect and
		// set it to the full 'src' image.
		if (srcRect == null) {
			srcRect = tempSrcRect;
			srcRect.set(0, 0, src.getWidth(), src.getHeight());
		}

		Rect target = configCanvas.getRegion();

		if (configCanvas.getClipRegion() != null)
			canvas.clipRect(configCanvas.getClipRegion(), Region.Op.INTERSECT);

		// mLastBitmapBlitRect[BITMAP_FULL] has been set to the blit region.
		// however, here's where we try to max things up.
		switch (configCanvas.getScale()) {
		case FIT_EXACT:
			// explicit alignment is ignored. Draw to exactly the canvas bounds.
			tempDstRect.set(configCanvas.getRegion());
			break;
		case FIT_X_OR_Y:
		case FIT_X:
		case FIT_Y:
			double xScale = ((double) target.width()) / srcRect.width();
			double yScale = ((double) target.height()) / srcRect.height();
			double scale;
			// We downscale the current blit rect to fit either X or Y -- then
			// reposition.
			// Our policy for FIX_X_OR_Y is that the other overshoots (or is
			// exact).
			// in other words, we scale by the LARGER value.
			if (configCanvas.getScale() == BlockDrawerConfigCanvas.Scale.FIT_X
					|| (configCanvas.getScale() == BlockDrawerConfigCanvas.Scale.FIT_X_OR_Y && xScale >= yScale)) {
				scale = xScale;

			} else {
				scale = yScale;
			}
			tempDstRect.set(0, 0, (int) Math.round(srcRect.width() * scale),
					(int) Math.round(srcRect.height() * scale));
			// top-left at target center.
			tempDstRect.offset(target.centerX(), target.centerY());

			// now align
			switch (configCanvas.getAlignment()) {
			case CONTENT_CENTER:
				// attempt to center the CONTENT? We do an extremely simple
				// version of this -- we find the "top row", "bottom row," etc.
				tempOffset.setRowCol(slice.getEdge(), slice.getEdge());
				tempOffset2.setRowCol(
						mDrawSettings.displayedRows + slice.getEdge() + 1,
						slice.cols() + slice.getEdge() + 1);
				shrinkMargins(tempOffset, tempOffset2,
						slice.getBlockfieldStable());
				// now adjust. Assume that the center is DISPLAYED_ROWS *
				// rowHeight / 2
				// and COLS * rowWidth / 2.
				double centerProportionX = (tempOffset2.x < tempOffset.x) ? 0.5
						: ((double) (tempOffset2.x - tempOffset.x))
								/ (slice.cols());
				double centerProportionY = (tempOffset2.y < tempOffset.y) ? 0.5
						: 1.0 - ((double) (tempOffset2.y - tempOffset.y))
								/ (mDrawSettings.displayedRows);
				// centerProportion: proportion left-to-right, or top-to-bottom,
				// where the center occurs.
				// TODO: This implementation assumes our source rect is the
				// bottom portion of the image
				// data.
				// Our top-left is at the target center. Adjust our position to
				// put the center at our
				// current top-left position.
				tempDstRect.offset(
						(int) Math.round(-centerProportionX
								* tempDstRect.width()),
						(int) Math.round(-centerProportionY
								* tempDstRect.height()));

				break;

			case CONTENT_TOP_EMPTY:
				// attempt to place the top of the content ? We do an extremely
				// simple
				// version of this -- we find the "top row", "bottom row," etc.
				// Typically, we do this using the stable blockfield. However,
				// there
				// is one exception: if we are in "piece falling" state, we take
				// the
				// "block field" height, not including piece, unless there are
				// no blocks present.
				// This lets us show
				// the currently falling piece when appropriate, but not when it
				// places
				// the piece too far above the rest of the field for the field
				// to be
				// visible.
				tempOffset.setRowCol(slice.getEdge(), slice.getEdge());
				tempOffset2.setRowCol(
						mDrawSettings.displayedRows + slice.getEdge() + 1,
						slice.cols() + slice.getEdge() + 1);
				shrinkMargins(
						tempOffset,
						tempOffset2,
						slice.getBlocksState() == GameBlocksSlice.BLOCKS_PIECE_FALLING ? slice
								.getPieceFallingBlockfield() : slice
								.getBlockfieldStable());
				int top = tempOffset2.y;
				if (tempOffset2.y >= tempOffset.y)
					top = 1;
				// content is centered by X, top-aligned by Y. We slide upward
				// as-needed
				// to place the content appropriately.
				double topProportionY = ((double) (mDrawSettings.displayedRows
						+ slice.getEdge() - top))
						/ (mDrawSettings.displayedRows);
				if (mDrawSettings.getBlit() == DrawSettings.BLIT_FULL)
					topProportionY = 1.0 - (1.0 - topProportionY) / 2;
				// this is the proportion from the top where the content begins.
				// Place this content 1/10th
				// of the way down. Remember that our top-left is centered. Move
				// 1/2 left,
				// and .4 up (to get 0.1 clearance). Then up again by the
				// appropriate proportion.
				tempDstRect.offset(
						(int) Math.round(-0.5 * tempDstRect.width()),
						(int) Math.round(-0.4 * target.height()
								- (topProportionY * tempDstRect.height())));
				break;

			case NONE:
				// center the whole field? This should have a standard result if
				// the
				// region is identical to our normal blit region.
				// We are top-left centered; move left/up by half size to center
				// the field.
				tempDstRect.offset(
						(int) Math.round(-0.5 * tempDstRect.width()),
						(int) Math.round(-0.5 * tempDstRect.height()));
				break;
			}

			// and snap-to, just in case we overshot.
			int leftExtra = Math.max(
					0,
					Math.min(tempDstRect.left - target.left, tempDstRect.right
							- target.right));
			int rightNeeds = Math.max(
					0,
					Math.min(target.left - tempDstRect.left, target.right
							- tempDstRect.right));
			int topExtra = Math.max(
					0,
					Math.min(tempDstRect.top - target.top, tempDstRect.bottom
							- target.bottom));
			int bottomNeeds = Math.max(
					0,
					Math.min(target.top - tempDstRect.top, target.bottom
							- tempDstRect.bottom));

			tempDstRect.offset(rightNeeds - leftExtra, bottomNeeds - topExtra);

			break;

		case NONE:
			// No fit?
			tempDstRect.set(0, 0, srcRect.width(), srcRect.height());
			tempDstRect.offset(target.centerX(), target.centerY());

		}

		// now draw.
		if (configCanvas.background == BlockDrawerConfigCanvas.Background.CLEAR)
			canvas.drawRect(target, clearPaint);
		canvas.drawBitmap(src, srcRect, tempDstRect, drawPaint);

		// restore canvas.
		canvas.restore();

	}

	/**
	 * An error occurred on the way to the Forum: I realized that our previous
	 * draw method of placing a black background behind each drawn piece
	 * destroys any S0 over S1 layering effects, because S0 will be opaque! We
	 * can't easily correct this by drawing a black background to S1 where S0
	 * exists, because it might overlap the other S1 content and black it out.
	 * 
	 * Instead, we rely on the "covered" clips, which correspond to those pixels
	 * which are independent of the background (and thus, we assume, candidates
	 * for a block-fill).
	 * 
	 * This method draws the entire background BITMAP_FULL, in two steps. First,
	 * it clips DIFFERENCE to remove covered pixels, and draws the background
	 * image. Second, it steps back and then clips INTERSECTION, to draw the
	 * "block background paint."
	 * 
	 */
	private void septupleBlitDrawBackgroundStableOnly(
			BlockDrawerSliceTime sliceTime, BlockDrawerConfigCanvas configCanvas) {
		// prevent constant re-indexing
		Canvas c = mLastBitmapCanvas[BITMAP_FULL];

		// draw to stable
		septupleBlitDrawBackgroundStableOnly(c, sliceTime,
				configCanvas == null ? null : configCanvas.background);
	}

	/**
	 * An error occurred on the way to the Forum: I realized that our previous
	 * draw method of placing a black background behind each drawn piece
	 * destroys any S0 over S1 layering effects, because S0 will be opaque! We
	 * can't easily correct this by drawing a black background to S1 where S0
	 * exists, because it might overlap the other S1 content and black it out.
	 * 
	 * Instead, we rely on the "covered" clips, which correspond to those pixels
	 * which are independent of the background (and thus, we assume, candidates
	 * for a block-fill).
	 * 
	 * This method draws the entire background BITMAP_FULL, in two steps. First,
	 * it clips DIFFERENCE to remove covered pixels, and draws the background
	 * image. Second, it steps back and then clips INTERSECTION, to draw the
	 * "block background paint."
	 * 
	 */
	private void septupleBlitDrawBackgroundStableOnly(Canvas canvas,
			BlockDrawerSliceTime sliceTime,
			BlockDrawerConfigCanvas.Background configCanvasBackground) {

		int BMAP;

		// First: CoveredRegions are set as aligned with their respective
		// Bitmap/Canvas. Translate using BlitRect's top-left to align
		// with BITMAP_FULL.
		for (int i = 0; i < septupleBlitStableOnly_BITMAPS.length; i++) {
			BMAP = septupleBlitStableOnly_BITMAPS[i];
			mLastBitmapCoveredPath[BMAP].offset(
					mLastBitmapBlitRect[BMAP].left,
					mLastBitmapBlitRect[BMAP].top);
		}

		// Step 1: clip the covered difference and draw the background.
		canvas.save();
		for (int i = 0; i < septupleBlitStableOnly_BITMAPS.length; i++) {
			BMAP = septupleBlitStableOnly_BITMAPS[i];
			mLastBitmapCanvas[BITMAP_FULL].clipPath(mLastBitmapCoveredPath[BMAP], Region.Op.DIFFERENCE);
		}
		this.drawBackgroundBehaviorToCanvas(mDrawSettings, canvas,
				mBackgroundBitmapOffset, sliceTime,
				configCanvasBackground != null ? configCanvasBackground
						: BlockDrawerConfigCanvas.Background.DEFAULT);
		canvas.restore();

		// Step 2: INTERSECT the UNION of covered and draw block fill color.
		canvas.save();
		reset(tempPath);
		for (int i = 0; i < septupleBlitStableOnly_BITMAPS.length; i++) {
			BMAP = septupleBlitStableOnly_BITMAPS[i];
			op(tempPath, mLastBitmapCoveredPath[BMAP], Path.Op.UNION);
		}
		canvas.clipPath(tempPath);
		canvas.drawColor(ColorOp.setAlphaForColor(255,
				mDrawSettings.color_background_piece));
		canvas.restore();

		// Last: CoveredRegions should be aligned with their respective
		// Bitmap/Canvas. Un-Translate using BlitRect's top-left to realign
		// with their source bitmap.
		for (int i = 0; i < septupleBlitStableOnly_BITMAPS.length; i++) {
			BMAP = septupleBlitStableOnly_BITMAPS[i];
			mLastBitmapCoveredPath[BMAP].offset(
					-mLastBitmapBlitRect[BMAP].left,
					-mLastBitmapBlitRect[BMAP].top);
		}
	}

	/**
	 * Applies the STABLE layers in order (Q1, 3D, Q0) as specified in
	 * drawSettings as full-bitmap blits onto BITMAP_FULL.
	 * 
	 * Performs no content-analysis of any layer or Bitmap. However, will apply
	 * mLastBitmapTouchedRegion as an INTERSECT clip before each blit.
	 * 
	 * Recommended usage: ensure that mLastBitmapTouchedRegion is set
	 * appropriately for all relevant layers (setting to a fullsize bounding box
	 * is OK but prevents optimized draws). Clip mLastBitmapCanvas[BITMAP_FULL]
	 * to only those pixels which have changed since the last septuple blit. Set
	 * all mLastBitmapBlitRects to the area of BITMAP_FULL to which we should
	 * blit (usually this will be exactly the bounding box of BITMAP_FULL, but
	 * for some draws you may want to offset a bit.
	 * 
	 * Uses these structures:
	 * 
	 * mLastBitmap {Q0_STABLE, 3D_STABLE, Q1_STABLE} mLastBitmapCanvas {FULL}
	 * mLastBitmapBlitRect {Q0_STABLE, 3D_STABLE, Q1_STABLE}
	 * mLastBitmapTouchedRegion {Q0_STABLE, 3D_STABLE, Q1_STABLE}
	 * 
	 */
	private boolean septupleBlitStableOnly(Offset glowOffset, int pieceType,
			BlockDrawerSliceTime sliceTime) {

		boolean stableNow = true;

		// prevent constant re-indexing
		Canvas c = mLastBitmapCanvas[BITMAP_FULL];

		int BMAP;

		// First: TouchedRegions are set as aligned with their respective
		// Bitmap/Canvas. Translate using BlitRect's top-left to align
		// with BITMAP_FULL.
		for (int i = 0; i < septupleBlitStableOnly_BITMAPS.length; i++) {
			BMAP = septupleBlitStableOnly_BITMAPS[i];
			mLastBitmapTouchedPath[BMAP].offset(
					mLastBitmapBlitRect[BMAP].left,
					mLastBitmapBlitRect[BMAP].top);
		}

		// Next: Save, Clip, Blit, Restore.
		// Consts.QPANE_1.
		c.save();
		if (!GlobalTestSettings.GAME_SEPTUPLE_BLIT_FULL_CLIP)
			c.clipPath(mLastBitmapTouchedPath[BITMAP_SEPTUPLE_Q1_STABLE]);
		c.drawBitmap(mLastBitmap[BITMAP_SEPTUPLE_Q1_STABLE],
				mLastBitmapBounds[BITMAP_SEPTUPLE_Q1_STABLE],
				mLastBitmapBlitRect[BITMAP_SEPTUPLE_Q1_STABLE], null);
		c.restore();

		// Consts.QPANE_1 Glow Effects
		// Q1 Glows
		if (glowOffset != null) {
			stableNow = septupleBlitDrawGlows(c, Consts.QPANE_1, glowOffset,
					pieceType, sliceTime) && stableNow;
		}

		// Consts.QPANE_3D
		c.save();
		if (!GlobalTestSettings.GAME_SEPTUPLE_BLIT_FULL_CLIP)
			c.clipPath(mLastBitmapTouchedPath[BITMAP_SEPTUPLE_3D_STABLE]);
		c.drawBitmap(mLastBitmap[BITMAP_SEPTUPLE_3D_STABLE],
				mLastBitmapBounds[BITMAP_SEPTUPLE_3D_STABLE],
				mLastBitmapBlitRect[BITMAP_SEPTUPLE_3D_STABLE], null);
		c.restore();

		// Consts.QPANE_0.
		c.save();
		if (!GlobalTestSettings.GAME_SEPTUPLE_BLIT_FULL_CLIP)
			c.clipPath(mLastBitmapTouchedPath[BITMAP_SEPTUPLE_Q0_STABLE]);
		c.drawBitmap(mLastBitmap[BITMAP_SEPTUPLE_Q0_STABLE],
				mLastBitmapBounds[BITMAP_SEPTUPLE_Q0_STABLE],
				mLastBitmapBlitRect[BITMAP_SEPTUPLE_Q0_STABLE], null);
		c.restore();

		// Consts.QPANE_0 Glow Effects
		if (glowOffset != null) {
			stableNow = septupleBlitDrawGlows(c, Consts.QPANE_0, glowOffset,
					pieceType, sliceTime) && stableNow;
		}

		// Last: TouchedRegions should be aligned with their respective
		// Bitmap/Canvas. Un-Translate using BlitRect's top-left to realign
		// with their source bitmap.
		for (int i = 0; i < septupleBlitStableOnly_BITMAPS.length; i++) {
			BMAP = septupleBlitStableOnly_BITMAPS[i];
			mLastBitmapTouchedPath[BMAP].offset(
					-mLastBitmapBlitRect[BMAP].left,
					-mLastBitmapBlitRect[BMAP].top);
		}

		return stableNow;
	}

	private int[] septupleBlitStableOnly_BITMAPS = new int[] {
			BITMAP_SEPTUPLE_Q1_STABLE, BITMAP_SEPTUPLE_3D_STABLE,
			BITMAP_SEPTUPLE_Q0_STABLE };

	private int[] septupleBlitVolatileOnly_BITMAPS = new int[] {
			BITMAP_SEPTUPLE_Q1_VOLATILE, BITMAP_SEPTUPLE_3D_VOLATILE,
			BITMAP_SEPTUPLE_Q0_VOLATILE };

	/**
	 * An error occurred on the way to the Forum: I realized that our previous
	 * draw method of placing a black background behind each drawn piece
	 * destroys any S0 over S1 layering effects, because S0 will be opaque! We
	 * can't easily correct this by drawing a black background to S1 where S0
	 * exists, because it might overlap the other S1 content and black it out.
	 * 
	 * Instead, we rely on the "covered" clips, which correspond to those pixels
	 * which are independent of the background (and thus, we assume, candidates
	 * for a block-fill).
	 * 
	 * This method draws the entire background BITMAP_FULL, in two steps. First,
	 * it clips DIFFERENCE to remove covered pixels, and draws the background
	 * image. Second, it steps back and then clips INTERSECTION, to draw the
	 * "block background paint."
	 * 
	 */
	private void septupleBlitDrawBackground(BlockDrawerSliceTime sliceTime,
			BlockDrawerConfigCanvas configCanvas) {
		// prevent constant re-indexing
		septupleBlitDrawBackground(sliceTime, configCanvas == null ? null
				: configCanvas.background, 255, 255);
	}

	/**
	 * An error occurred on the way to the Forum: I realized that our previous
	 * draw method of placing a black background behind each drawn piece
	 * destroys any S0 over S1 layering effects, because S0 will be opaque! We
	 * can't easily correct this by drawing a black background to S1 where S0
	 * exists, because it might overlap the other S1 content and black it out.
	 * 
	 * Instead, we rely on the "covered" clips, which correspond to those pixels
	 * which are independent of the background (and thus, we assume, candidates
	 * for a block-fill).
	 * 
	 * This method draws the entire background BITMAP_FULL, in two steps. First,
	 * it clips DIFFERENCE to remove covered pixels, and draws the background
	 * image. Second, it steps back and then clips INTERSECTION, to draw the
	 * "block background paint."
	 * 
	 */
	private void septupleBlitDrawBackground(BlockDrawerSliceTime sliceTime,
			BlockDrawerConfigCanvas configCanvas, int stableAlpha,
			int volatileAlpha) {
		// prevent constant re-indexing
		Canvas c = mLastBitmapCanvas[BITMAP_FULL];
		septupleBlitDrawBackground(c, sliceTime, configCanvas == null ? null
				: configCanvas.background, stableAlpha, volatileAlpha);
	}

	/**
	 * An error occurred on the way to the Forum: I realized that our previous
	 * draw method of placing a black background behind each drawn piece
	 * destroys any S0 over S1 layering effects, because S0 will be opaque! We
	 * can't easily correct this by drawing a black background to S1 where S0
	 * exists, because it might overlap the other S1 content and black it out.
	 * 
	 * Instead, we rely on the "covered" clips, which correspond to those pixels
	 * which are independent of the background (and thus, we assume, candidates
	 * for a block-fill).
	 * 
	 * This method draws the entire background BITMAP_FULL, in two steps. First,
	 * it clips DIFFERENCE to remove covered pixels, and draws the background
	 * image. Second, it steps back and then clips INTERSECTION, to draw the
	 * "block background paint."
	 * 
	 */
	private void septupleBlitDrawBackground(BlockDrawerSliceTime sliceTime,
			BlockDrawerConfigCanvas.Background configCanvasBackground,
			int stableAlpha, int volatileAlpha) {
		// prevent constant re-indexing
		Canvas c = mLastBitmapCanvas[BITMAP_FULL];
		septupleBlitDrawBackground(c, sliceTime, configCanvasBackground,
				stableAlpha, volatileAlpha);
	}

	/**
	 * An error occurred on the way to the Forum: I realized that our previous
	 * draw method of placing a black background behind each drawn piece
	 * destroys any S0 over S1 layering effects, because S0 will be opaque! We
	 * can't easily correct this by drawing a black background to S1 where S0
	 * exists, because it might overlap the other S1 content and black it out.
	 * 
	 * Instead, we rely on the "covered" clips, which correspond to those pixels
	 * which are independent of the background (and thus, we assume, candidates
	 * for a block-fill).
	 * 
	 * This method draws the entire background BITMAP_FULL, in two steps. First,
	 * it clips DIFFERENCE to remove covered pixels, and draws the background
	 * image. Second, it steps back and then clips INTERSECTION, to draw the
	 * "block background paint."
	 * 
	 */
	private void septupleBlitDrawBackground(Canvas canvas,
			BlockDrawerSliceTime sliceTime,
			BlockDrawerConfigCanvas.Background configCanvasBackground,
			int stableAlpha, int volatileAlpha) {

		int BMAP;

		// First: CoveredRegions are set as aligned with their respective
		// Bitmap/Canvas. Translate using BlitRect's top-left to align
		// with BITMAP_FULL.
		for (int i = 0; i < septupleBlit_BITMAPS.length; i++) {
			BMAP = septupleBlit_BITMAPS[i];
			mLastBitmapCoveredPath[BMAP].offset(
					mLastBitmapBlitRect[BMAP].left,
					mLastBitmapBlitRect[BMAP].top);
		}

		// Step 1: clip the covered difference and draw the background.
		canvas.save();
		reset(tempPath);
		if (stableAlpha == 255) {
			for (int i = 0; i < septupleBlitStableOnly_BITMAPS.length; i++) {
				BMAP = septupleBlitStableOnly_BITMAPS[i];
				op(tempPath, mLastBitmapCoveredPath[BMAP], Path.Op.UNION);

			}
		}
		if (volatileAlpha == 255) {
			for (int i = 0; i < septupleBlitVolatileOnly_BITMAPS.length; i++) {
				BMAP = septupleBlitVolatileOnly_BITMAPS[i];
                op(tempPath, mLastBitmapCoveredPath[BMAP], Path.Op.UNION);
			}
		}
        canvas.clipPath(tempPath, Region.Op.DIFFERENCE);
		BlockDrawerConfigCanvas.Background backgroundDefault = mDrawSettings
				.getBehaviorIs_backgroundBlit() ? BlockDrawerConfigCanvas.Background.CLEAR
				: BlockDrawerConfigCanvas.Background.DEFAULT;
		this.drawBackgroundBehaviorToCanvas(mDrawSettings, canvas,
				mBackgroundBitmapOffset, sliceTime,
				configCanvasBackground != null ? configCanvasBackground
						: backgroundDefault);
		canvas.restore();

		// Step 2: INTERSECT the UNION of covered and draw block fill color.
		if (stableAlpha == volatileAlpha) {
			canvas.save();
			reset(tempPath);
			for (int i = 0; i < septupleBlit_BITMAPS.length; i++) {
				BMAP = septupleBlit_BITMAPS[i];
				op(tempPath, mLastBitmapCoveredPath[BMAP], Path.Op.UNION);
			}
			canvas.clipPath(tempPath);
			canvas.drawColor(ColorOp.setAlphaForColor(stableAlpha,
					mDrawSettings.color_background_piece));
			canvas.restore();
		} else {
			// Draw the STABLE background everywhere STABLE occurs; draw the
			// VOLATILE background
			// in those places where VOLATILE exists but STABLE does not.
			canvas.save();
			reset(tempPath);
			for (int i = 0; i < septupleBlitStableOnly_BITMAPS.length; i++) {
				BMAP = septupleBlitStableOnly_BITMAPS[i];
				op(tempPath, mLastBitmapCoveredPath[BMAP], Path.Op.UNION);
			}
			canvas.clipPath(tempPath);
			canvas.drawColor(ColorOp.setAlphaForColor(stableAlpha,
					mDrawSettings.color_background_piece));
			canvas.restore();

			canvas.save();
			reset(tempPath);
			for (int i = 0; i < septupleBlitVolatileOnly_BITMAPS.length; i++) {
				BMAP = septupleBlitVolatileOnly_BITMAPS[i];
				op(tempPath, mLastBitmapCoveredPath[BMAP], Path.Op.UNION);
			}
			for (int i = 0; i < septupleBlitStableOnly_BITMAPS.length; i++) {
				BMAP = septupleBlitStableOnly_BITMAPS[i];
				op(tempPath, mLastBitmapCoveredPath[BMAP], Path.Op.DIFFERENCE);
			}
			canvas.clipPath(tempPath);
			canvas.drawColor(ColorOp.setAlphaForColor(volatileAlpha,
					mDrawSettings.color_background_piece));
			canvas.restore();
		}

		// Last: CoveredRegions should be aligned with their respective
		// Bitmap/Canvas. Un-Translate using BlitRect's top-left to realign
		// with their source bitmap.
		for (int i = 0; i < septupleBlit_BITMAPS.length; i++) {
			BMAP = septupleBlit_BITMAPS[i];
			mLastBitmapCoveredPath[BMAP].offset(
					-mLastBitmapBlitRect[BMAP].left,
					-mLastBitmapBlitRect[BMAP].top);
		}
	}

	private boolean septupleBlit(int stableAlpha, int volatileAlpha,
			Offset glowOffset, int pieceType, BlockDrawerSliceTime sliceTime) {

		return septupleBlit(stableAlpha, volatileAlpha, glowOffset, pieceType,
				sliceTime, false);
	}

	private boolean septupleBlitStableOccludes(int stableAlpha,
			int volatileAlpha, Offset glowOffset, int pieceType,
			BlockDrawerSliceTime sliceTime) {

		return septupleBlit(stableAlpha, volatileAlpha, glowOffset, pieceType,
				sliceTime, true);
	}

	/**
	 * Applies the STABLE and VOLATILE layers in order (Q1, 3D, Q0) as specified
	 * in drawSettings as full-bitmap blits onto BITMAP_FULL.
	 * 
	 * Performs no content-analysis of any layer or Bitmap. However, will apply
	 * mLastBitmapTouchedRegion as an INTERSECT clip before each blit.
	 * 
	 * Compare against septupleBlitStableOnly: before drawing a Q0 or Q1
	 * VOLATILE layer, we apply a difference clip for the associated STABLE
	 * layer's Covered pixels. The main purpose is to prevent VOLATILE's drop
	 * shadow from appearing over STABLE's blocks.
	 * 
	 * Recommended usage: ensure that mLastBitmapTouchedRegion is set
	 * appropriately for all relevant layers (setting to a fullsize bounding box
	 * is OK but prevents optimized draws). Clip mLastBitmapCanvas[BITMAP_FULL]
	 * to only those pixels which have changed since the last septuple blit. Set
	 * all mLastBitmapBlitRects to the area of BITMAP_FULL to which we should
	 * blit (usually this will be exactly the bounding box of BITMAP_FULL, but
	 * for some draws you may want to offset a bit.
	 * 
	 * Uses these structures:
	 * 
	 * mLastBitmap {all but FULL} mLastBitmapCanvas {FULL} mLastBitmapBlitRect
	 * {all but FULL} mLastBitmapCoveredRegion {all STABLE}
	 * mLastBitmapTouchedRegion {all but FULL}
	 * 
	 */
	private boolean septupleBlit(int stableAlpha, int volatileAlpha,
			Offset glowOffset, int pieceType, BlockDrawerSliceTime sliceTime,
			boolean occludingStable) {

		// log("septupleBlit: s1 rect is " +
		// this.mLastBitmapBlitRect[BITMAP_Q1_VOLATILE]) ;

		boolean stableNow = true;

		// prevent constant re-indexing
		Canvas c = mLastBitmapCanvas[BITMAP_FULL];

		int BMAP;

		// First: TouchedRegions are set as aligned with their respective
		// Bitmap/Canvas. Translate using BlitRect's top-left to align
		// with BITMAP_FULL.
		for (int i = 0; i < septupleBlit_BITMAPS.length; i++) {
			BMAP = septupleBlit_BITMAPS[i];
			mLastBitmapTouchedPath[BMAP].offset(
					mLastBitmapBlitRect[BMAP].left,
					mLastBitmapBlitRect[BMAP].top);
		}
		// Same with COVERED regions, but we only bother doing this with
		// StableOnly.
		for (int i = 0; i < septupleBlitStableOnly_BITMAPS.length; i++) {
			BMAP = septupleBlitStableOnly_BITMAPS[i];
			mLastBitmapCoveredPath[BMAP].offset(
					mLastBitmapBlitRect[BMAP].left,
					mLastBitmapBlitRect[BMAP].top);
		}

		// Next: Save, Clip, Blit, Restore.
		// Special case: for VOLATILE, clip DIFFERENCE the stable
		// equivalent's covered region.
		// First: Q1
		if (occludingStable) {
			blitLayerToFull(BITMAP_SEPTUPLE_Q1_VOLATILE, -1, volatileAlpha);
			blitLayerToFull(BITMAP_SEPTUPLE_Q1_STABLE, -1, stableAlpha);
		} else {
			blitLayerToFull(BITMAP_SEPTUPLE_Q1_STABLE, -1, stableAlpha);
			blitLayerToFull(BITMAP_SEPTUPLE_Q1_VOLATILE,
					BITMAP_SEPTUPLE_Q1_STABLE, volatileAlpha);
		}

		// Q1 Glows
		if (glowOffset != null && mDrawSettings.drawQ1) {
			stableNow = septupleBlitDrawGlows(c, Consts.QPANE_1, glowOffset,
					pieceType, sliceTime) && stableNow;
		}

		// Next: 3D
		if (occludingStable) {
			blitLayerToFull(BITMAP_SEPTUPLE_3D_VOLATILE, -1, volatileAlpha);
			blitLayerToFull(BITMAP_SEPTUPLE_3D_STABLE, -1, stableAlpha);
		} else {
			blitLayerToFull(BITMAP_SEPTUPLE_3D_STABLE, -1, stableAlpha);
			blitLayerToFull(BITMAP_SEPTUPLE_3D_VOLATILE,
					BITMAP_SEPTUPLE_3D_STABLE, volatileAlpha);
		}

		// Q0
		if (occludingStable) {
			blitLayerToFull(BITMAP_SEPTUPLE_Q0_VOLATILE, -1, volatileAlpha);
			blitLayerToFull(BITMAP_SEPTUPLE_Q0_STABLE, -1, stableAlpha);
		} else {
			blitLayerToFull(BITMAP_SEPTUPLE_Q0_STABLE, -1, stableAlpha);
			blitLayerToFull(BITMAP_SEPTUPLE_Q0_VOLATILE,
					BITMAP_SEPTUPLE_Q0_STABLE, volatileAlpha);
		}

		// Q0 Glows
		if (glowOffset != null && mDrawSettings.drawQ0) {
			stableNow = septupleBlitDrawGlows(c, Consts.QPANE_0, glowOffset,
					pieceType, sliceTime) && stableNow;
		}

		// Last: TouchedRegions should be aligned with their respective
		// Bitmap/Canvas. Un-Translate using BlitRect's top-left to realign
		// with their source bitmap.
		for (int i = 0; i < septupleBlit_BITMAPS.length; i++) {
			BMAP = septupleBlit_BITMAPS[i];
			mLastBitmapTouchedPath[BMAP].offset(
					-mLastBitmapBlitRect[BMAP].left,
					-mLastBitmapBlitRect[BMAP].top);
		}
		// Same with COVERED regions, but we only bother doing this with
		// StableOnly.
		for (int i = 0; i < septupleBlitStableOnly_BITMAPS.length; i++) {
			BMAP = septupleBlitStableOnly_BITMAPS[i];
			mLastBitmapCoveredPath[BMAP].offset(
					-mLastBitmapBlitRect[BMAP].left,
					-mLastBitmapBlitRect[BMAP].top);
		}

		return stableNow;
	}

	private boolean septupleBlitDrawGlows(Canvas c, int qPane, Offset offset,
			int pieceType, BlockDrawerSliceTime sliceTime) {

		drawBlockFieldQPaneAtAlignmentOffset(mDrawSettings, c, null,
				this.mConfigRangeStandard, qPane, pieceType, offset, -1, 255,
				255,
				255,
				255, // spot errors with this
				null, null, null, null, null, null, null, null, null, null,
				null, sliceTime, GlowEffect.TYPE_ANY, mLastEffectsGlow,
				FadeEffect.TYPE_NONE, null);
		
		
		int numGlows = mLastEffectsGlow.size() ;
		for (int i = 0; i < numGlows; i++) {
			GlowEffect glowEffect = mLastEffectsGlow.get(i);
			if (!glowFinished(glowEffect.type(),
					glowEffect.timeSinceStarted(sliceTime)))
				return false;
		}

		return true;
	}

	private boolean glowFinished(int type, long timeSpentGlowing) {
		switch (type) {
		case GlowEffect.TYPE_CLEAR:
			return animationSettings.clearGlowFinished(0, 255, 0,
					timeSpentGlowing);
		case GlowEffect.TYPE_LOCK:
			return animationSettings.lockGlowFinished(0, 255, 0,
					timeSpentGlowing);
		case GlowEffect.TYPE_METAMORPHOSIS:
			return animationSettings.metamorphosisGlowFinished(0, 255, 0,
					timeSpentGlowing);
		case GlowEffect.TYPE_UNLOCK:
			return animationSettings.unlockColumnGlowFinished(0, 255, 0,
					timeSpentGlowing);
		case GlowEffect.TYPE_ENTER:
			return animationSettings.enterGlowFinished(0, 255, 0,
					timeSpentGlowing);
		case GlowEffect.TYPE_NONE:
			return true;
		case GlowEffect.TYPE_ANY:
			// would "any" type be finished? i.e., if we don't know what
			// type it is, can we confidently declare that it would be finished?
			for (int i = GlowEffect.MIN_TYPE; i < GlowEffect.NUM_TYPES; i++) {
				if (!glowFinished(i, timeSpentGlowing))
					return false;
			}
			return true;
		default:
			return true;
		}
	}

	Paint blitLayerPaint = new Paint();

	private void blitLayerToFull(int bMap, int bMapDifference, int alpha) {
		blitLayer(mLastBitmapCanvas[BITMAP_FULL],
				mLastBitmapTouchedPath[bMap],
				bMapDifference >= 0 ? mLastBitmapCoveredPath[bMapDifference]
						: null, mLastBitmap[bMap], mLastBitmapBounds[bMap],
				mLastBitmapBlitRect[bMap], alpha);
	}

	private void blitLayer(Canvas c, Path intersect, Path difference,
			Bitmap b, Rect bRect, Rect destRect, int alpha) {
		blitLayerPaint.setAlpha(alpha);
		c.save();
		if (intersect != null
				&& !GlobalTestSettings.GAME_SEPTUPLE_BLIT_FULL_CLIP)
			c.clipPath(intersect);
		if (difference != null
				&& !GlobalTestSettings.GAME_SEPTUPLE_BLIT_FULL_CLIP)
			c.clipPath(difference, Region.Op.DIFFERENCE);
		c.drawBitmap(b, bRect, destRect, blitLayerPaint);
		c.restore();
	}

	private void septupleBlit() {
		septupleBlit(255, 255, null, 0, null);
	}

	private void septupleBlit(Offset glowOffset, int pieceType,
			BlockDrawerSliceTime sliceTime) {
		septupleBlit(255, 255, glowOffset, pieceType, sliceTime);
	}

	private int[] septupleBlit_BITMAPS = new int[] { BITMAP_SEPTUPLE_Q1_STABLE,
			BITMAP_SEPTUPLE_Q1_VOLATILE, BITMAP_SEPTUPLE_3D_STABLE,
			BITMAP_SEPTUPLE_3D_VOLATILE, BITMAP_SEPTUPLE_Q0_STABLE,
			BITMAP_SEPTUPLE_Q0_VOLATILE };

	private int[] septupleBlit_ASSOCIATED_STABLE = new int[] { -1,
			BITMAP_SEPTUPLE_Q1_STABLE, -1, -1, -1, BITMAP_SEPTUPLE_Q0_STABLE };

	/**
	 * Prepares the veil based on current BLIT settings and draws it to canvas
	 * at its current position, over the existing field contents.
	 * 
	 * BEHAVIOR: BLIT_SEPTUPLE: uses BITMAP_Q0_VOLATILE to store the veil,
	 * assuming BITMAP_FULL contains everything under it. BLIT_FULL: uses the
     * top-half of the bitmap to store the veil;
	 * blit the bottom half, then the top half. We include the top X pixels of
	 * the bottom half in the veil, representing the drop shadow. BLIT_NONE:
	 * that's a fail.
	 * 
	 * if 'redrawVeil' is true, we assume that our prerendered veil must be
	 * redrawn before any blitting takes place. If 'false' then we assume the
	 * prerendered veil is exactly where we left it.
	 */
	private void drawBitmapFullVeiledToCanvas(Canvas canvas,
			BlockDrawerSliceTime sliceTime, boolean redrawVeil) {

		long timeVeiling = this.timeDrawingVeil(sliceTime, true) ;

		int veilOffset;
		if (mVeiled) {
            veilOffset = this.veiledPixelHeight(timeVeiling);
        } else {
            veilOffset = this.unveiledPixelHeight(timeVeiling);
        }
		int yOffset;

		mVeilPossiblyOnScreen = mVeiled || veilOffset < this.mDrawSettings.height;

		// shift alignment offset - if it's wider than our draw settings
		// canvas area, we need to shift where we draw to compensate.
		if (mVeilSettings.width > mDrawSettings.width)
			alignmentOffset.x -= (mVeilSettings.width - mDrawSettings.width) / 2;

        float upscaleFactor = ((float)mDrawSettings.configCanvas.region.width()) / mDrawSettings.width;

		switch (mDrawSettings.getBlit()) {
		case DrawSettings.BLIT_SEPTUPLE:
			if (redrawVeil) {
				// SEPTUPLE blit gives us the freedom to draw the entire veil
				// (with room to spare
				// for the bottom drop shadow!) in a VOLATILE bitmap.
				// We assume an exact end-to-end fit.

                // NOTE: a call to REPLACE the clip previously appeared here.
                // Verify that no stored clip exists on the canvas through testing.

				mLastBitmapCanvas[BITMAP_SEPTUPLE_Q0_VOLATILE].drawPaint(clearPaint);

				byte[][][] field = mVeilSlice.getBlockfieldStable();

				// Draw the veil.
				drawBlockFieldQPaneAtAlignmentOffset(
						mVeilSettings,
						mLastBitmapCanvas[BITMAP_SEPTUPLE_Q0_VOLATILE],
						field,
						mConfigRangeVeil,
						Consts.QPANE_0,
						-1,
						alignmentOffset,
						-1,
						mVeilSettings.alpha_lockedFill,
						255,
						mVeilSettings.alpha_lockedTop,
						mVeilSettings.alpha_lockedBorder,
						mVeilCorners[Consts.QPANE_0][INDEX_CORNER_TL], // no
																		// naive
						// optimization
						mVeilCorners[Consts.QPANE_0][INDEX_CORNER_TR],
						mVeilCorners[Consts.QPANE_0][INDEX_CORNER_BL],
						mVeilCorners[Consts.QPANE_0][INDEX_CORNER_BR], null,
						null, null, null, mVeilFillShadows[Consts.QPANE_0],
						mVeilDropShadows[Consts.QPANE_0], null, sliceTime,
						GlowEffect.TYPE_NONE, null, FadeEffect.TYPE_NONE, null);

				// log(ArrayOps.arrayToString(field)) ;
			}

			// now blit the veil. Use order: blit FULL, blit VOLATILE_Q0 at the
			// right offset.
			canvas.save();
			if (mDrawSettings.configCanvas.clipRegion != null)
				canvas.clipRect(mDrawSettings.configCanvas.clipRegion,
						Region.Op.INTERSECT);

			if (mDrawSettings.getBehaviorIs_backgroundBlit()) {
				drawLayeredBackgroundAssets(canvas,
						mDrawSettings.configCanvas.region, sliceTime,
						mDrawSettings.configCanvas.background);
			}

			canvas.drawBitmap(mLastBitmap[BITMAP_FULL],
					mLastBitmapBounds[BITMAP_FULL],
					mLastBitmapBlitRect[BITMAP_FULL], null);

			if (mVeiled) {
                // offset is the distance LOWERED. Convert to distance above zero-mark.
                yOffset = Math.max(0, mDrawSettings.configCanvas.region.height() - veilOffset * mDrawSettings.getScale());
            } else {
                // offset is the distance RISEN.
                yOffset = veilOffset * mDrawSettings.getScale();
            }

			tempSrcRect.set(0, 0,
					mLastBitmapBounds[BITMAP_SEPTUPLE_Q0_VOLATILE].width(),
					mLastBitmapBounds[BITMAP_SEPTUPLE_Q0_VOLATILE].height());
			tempDstRect.set(mDrawSettings.configCanvas.region.left,
					mDrawSettings.configCanvas.region.top - yOffset,
					mLastBitmapBlitRect[BITMAP_FULL].width()
							+ mDrawSettings.configCanvas.region.left,
					Math.round(upscaleFactor * mLastBitmapBounds[BITMAP_SEPTUPLE_Q0_VOLATILE].height())
							+ mDrawSettings.configCanvas.region.top - yOffset);

			canvas.drawBitmap(mLastBitmap[BITMAP_SEPTUPLE_Q0_VOLATILE],
					tempSrcRect, tempDstRect, null);

			/*
			 * canvas.drawBitmap(mLastBitmap[BITMAP_Q0_VOLATILE],
			 * mDrawSettings.configCanvas.region.left,
			 * mDrawSettings.configCanvas.region.top - yOffset, null);
			 */
			canvas.restore();

			break;

		case DrawSettings.BLIT_FULL:
			boolean doubleHeightOffset = mLastBitmapBounds[BITMAP_FULL]
					.height() > mDrawSettings.height;
			boolean contentAtBottom = doubleHeightOffset
					&& !mDrawSettings.getBehaviorIs_displacement();
			int dropShadowPixels = this.boundDropShadowHeight(mVeilSettings);
			int dropShadowBlitPixels = mDrawSettings.getBlit() == DrawSettings.BLIT_FULL ? dropShadowPixels
					: dropShadowPixels * 2;
			if (redrawVeil) {
                mLastBitmapCanvas[BITMAP_FULL].save();
				if (contentAtBottom) {
					mLastBitmapCanvas[BITMAP_FULL].clipRect(0, 0,
							mLastBitmapBounds[BITMAP_FULL].width(),
							mLastBitmapBounds[BITMAP_FULL].height() / 2
									+ dropShadowPixels, Region.Op.INTERSECT);
				} else {
					mLastBitmapCanvas[BITMAP_FULL].clipRect(0,
							mLastBitmapBounds[BITMAP_FULL].height() / 2,
							mLastBitmapBounds[BITMAP_FULL].width(),
							mLastBitmapBounds[BITMAP_FULL].height(),
							Region.Op.INTERSECT);
				}
				mLastBitmapCanvas[BITMAP_FULL].drawPaint(clearPaint);

				byte[][][] field = mVeilSlice.getBlockfieldStable();

				if (doubleHeightOffset) {
					// This blit style gives us a double-sized bitmap to work
					// with.
					// The veiled content is either at the top or the bottom,
					// depending on whether we're using displacement.
					if (contentAtBottom)
						alignmentOffset.y -= mDrawSettings.height;
					else
						alignmentOffset.y += mDrawSettings.height;

					log("drawing veil at alignment offset " + alignmentOffset.toString());

					// Draw the veil.
					drawBlockFieldQPaneAtAlignmentOffset(
							mVeilSettings,
							mLastBitmapCanvas[BITMAP_FULL],
							field,
							mConfigRangeVeil,
							Consts.QPANE_0,
							-1,
							alignmentOffset,
							-1,
							mVeilSettings.alpha_lockedFill,
							255,
							mVeilSettings.alpha_lockedTop,
							mVeilSettings.alpha_lockedBorder,
							mVeilCorners[Consts.QPANE_0][INDEX_CORNER_TL], // no
																			// naive
							// optimization
							mVeilCorners[Consts.QPANE_0][INDEX_CORNER_TR],
							mVeilCorners[Consts.QPANE_0][INDEX_CORNER_BL],
							mVeilCorners[Consts.QPANE_0][INDEX_CORNER_BR],
							null, null, null, null,
							mVeilFillShadows[Consts.QPANE_0],
							mVeilDropShadows[Consts.QPANE_0], null, sliceTime,
							GlowEffect.TYPE_NONE, null, FadeEffect.TYPE_NONE,
							null);

					if (contentAtBottom)
						alignmentOffset.y += mDrawSettings.height;
					else
						alignmentOffset.y -= mDrawSettings.height;
				} else {
					// single-height bitmap. Draw to cover.
					// Draw the veil.
					drawBlockFieldQPaneAtAlignmentOffset(
							mVeilSettings,
							mLastBitmapCanvas[BITMAP_FULL],
							field,
							mConfigRangeVeil,
							Consts.QPANE_0,
							-1,
							alignmentOffset,
							-1,
							mVeilSettings.alpha_lockedFill,
							255,
							mVeilSettings.alpha_lockedTop,
							mVeilSettings.alpha_lockedBorder,
							mVeilCorners[Consts.QPANE_0][INDEX_CORNER_TL], // no
																			// naive
							// optimization
							mVeilCorners[Consts.QPANE_0][INDEX_CORNER_TR],
							mVeilCorners[Consts.QPANE_0][INDEX_CORNER_BL],
							mVeilCorners[Consts.QPANE_0][INDEX_CORNER_BR],
							null, null, null, null,
							mVeilFillShadows[Consts.QPANE_0],
							mVeilDropShadows[Consts.QPANE_0], null, sliceTime,
							GlowEffect.TYPE_NONE, null, FadeEffect.TYPE_NONE,
							null);
				}
                mLastBitmapCanvas[BITMAP_FULL].restore();
			}

			// now blit the veil. Use order: blit bottom-half of full
			// (omitting the top 'dropShadowHeight' pixels), then blit the
			// top-half (including the bottom 'dropShadowHeight' pixels).
			canvas.save();
			if (mDrawSettings.configCanvas.clipRegion != null)
				canvas.clipRect(mDrawSettings.configCanvas.clipRegion,
						Region.Op.INTERSECT);
			canvas.drawPaint(clearPaint);

			if (doubleHeightOffset) {

				if (mDrawSettings.getBehaviorIs_backgroundBlit()) {
					drawLayeredBackgroundAssets(canvas,
							mDrawSettings.configCanvas.region, sliceTime,
							mDrawSettings.configCanvas.background);
				}
				if (contentAtBottom) {
					tempSrcRect.set(0, mLastBitmapBounds[BITMAP_FULL].height() / 2 + dropShadowPixels,
							mLastBitmapBounds[BITMAP_FULL].width(),
							mLastBitmapBounds[BITMAP_FULL].height());
					tempDstRect.set(mDrawSettings.configCanvas.region.left,
							mDrawSettings.configCanvas.region.top
									+ dropShadowBlitPixels,
							mDrawSettings.configCanvas.region.right,
							mDrawSettings.configCanvas.region.bottom);
				} else {
					tempSrcRect.set(0, 0,
							mLastBitmapBounds[BITMAP_FULL].width(),
							mLastBitmapBounds[BITMAP_FULL].height() / 2);
					tempDstRect.set(mDrawSettings.configCanvas.region.left,
							mDrawSettings.configCanvas.region.top,
							mDrawSettings.configCanvas.region.right,
							mDrawSettings.configCanvas.region.bottom);
				}

				canvas.drawBitmap(mLastBitmap[BITMAP_FULL], tempSrcRect,
						tempDstRect, null);

				if (mVeiled) {
				    // offset is the distance LOWERED. Convert to
                    // distance above zero-mark.
                    yOffset = Math.max(0, mDrawSettings.configCanvas.region.height() - veilOffset * mDrawSettings.getScale());
                } else {
                    // offset is the distance RISEN.
                    yOffset = veilOffset * mDrawSettings.getScale();
                }

				if (contentAtBottom) {
					tempSrcRect.set(0, 0,
							mVeilSettings.size_blockWidth * (mVeilSettings.COLS - 1),
							mVeilSettings.height);

					tempDstRect.set(mDrawSettings.configCanvas.region.left,
							mDrawSettings.configCanvas.region.top,
							mDrawSettings.configCanvas.region.right,
							mDrawSettings.configCanvas.region.bottom
									+ dropShadowBlitPixels);
					tempDstRect.offset(0, -yOffset);
				} else {
					tempSrcRect.set(0,
							mLastBitmapBounds[BITMAP_FULL].height() / 2,
							mVeilSettings.size_blockWidth * (mVeilSettings.COLS - 1) ,
                            mLastBitmapBounds[BITMAP_FULL].height() / 2 + mVeilSettings.height);

					tempDstRect.set(mDrawSettings.configCanvas.region.left,
							mDrawSettings.configCanvas.region.top,
							mDrawSettings.configCanvas.region.right,
							mDrawSettings.configCanvas.region.bottom);
					tempDstRect.offset(0, -yOffset);
				}

				canvas.drawBitmap(mLastBitmap[BITMAP_FULL], tempSrcRect,
						tempDstRect, null);
			} else {
				// just do the full bitmap.

				if (mDrawSettings.getBehaviorIs_backgroundBlit()) {
					drawLayeredBackgroundAssets(canvas,
							mDrawSettings.configCanvas.region, sliceTime,
							mDrawSettings.configCanvas.background);
				}

				canvas.drawBitmap(mLastBitmap[BITMAP_FULL],
						mLastBitmapBounds[BITMAP_FULL],
						mLastBitmapBlitRect[BITMAP_FULL], null);
			}

			canvas.restore();
			break;

		case DrawSettings.BLIT_NONE:
			break;
		// we perform no veiling here.
		}

		// un-offset our alignment offset to compensate for differently
		// sized veils.
		if (mVeilSettings.width > mDrawSettings.width)
			alignmentOffset.x += (mVeilSettings.width - mDrawSettings.width) / 2;

	}

	/**
	 * Given the current slice and slice time, returns whether there are
	 * lingering and unresolved effects from some other slice -- which should be
	 * fully resolved before we advance to the next slice.
	 * 
	 * @param slice
	 * @return
	 */
	private boolean shouldHoldToDrawLingeringEffects(GameBlocksSlice slice,
			BlockDrawerSliceTime sliceTime) {

		// A most basic -- and incorrect -- implementation of this
		// method would merely check for non-expired Effects in our lists.
		// A slightly more sophisticated (but still incorrect) implementation
		// would make sure that those effects have some visual representation
		// when drawn to screen.

		// We should only hold the current slice to draw lingering effects to
		// previous slices if:

		// 1. We intentionally transitioned away from the slice which generated
		// the effects. Our policy: keep Effects slice-relative until
		// we are ready to change slices, then switch to "unpaused relative."
		// Therefore, if Slice-relative effects exist, we did not smoothly
		// transition and should not hold the current slice.
		// 2. The slice provided is consistent. "Consistent" can mean all kinds
		// of things. Here, we note that the GameView (necessarily) denotes
		// POSSIBLE inconsistency when a game is Synchronized. This is not
		// what we are referring to. We mean that the slice BREAKS SEQUENCE.
		// Breaking sequence means effects are immediately truncated.
		// 3. Our DrawSettings allows us to hold the specified slice type while
		// lingering effects are drawn. By default, no effects are "lingered:"
		// they are completely drawn within their creating slice. Other draw
		// settings have different policies.
		// 4. We only "hold" slices that have not advanced.
		
		// Never hold for "stable stutter."
		if ( mDrawSettings.drawAnimations == DrawSettings.DRAW_ANIMATIONS_STABLE_STUTTER ) {
			return false ;
		}

		// If we don't HAVE any effects, we shouldn't hold for them.
		if (mLastEffectsGlow.size() == 0 && mLastEffectsSound.size() == 0
				&& mLastEffectsFade.size() == 0) {
			// log( 
			// "shouldHoldToDrawLingeringEffects no hold: no effects") ;
			return false;
		}

		// Don't break the sequence!
		if (mNextSliceBreaksSequence) {
			// log( 
			// "shouldHoldToDrawLingeringEffects no hold: breaks sequence") ;
			return false;
		}

		// If we only draw effects in-slice, we stick around here.
		if (mDrawSettings.drawEffects == DrawSettings.DRAW_EFFECTS_IN_SLICE) {
			// log( 
			// "shouldHoldToDrawLingeringEffects no hold: draw in slice") ;
			return false ;
		}
		if (mDrawSettings.drawEffects == DrawSettings.DRAW_EFFECTS_THROUGH_SLICE) {
			int blocksState = slice.getBlocksState();
			// advance through fallChunks -- assuming we don't have any box
			// fades.
			// We don't want to have to deal with fading through falling!
			if (blocksState == GameBlocksSlice.BLOCKS_CHUNKS_FALLING
					&& mLastEffectsFade.size() == 0
			/*
			 * && ( slice.getFallDistancesMax() <= 0 ) &&
			 * !slice.getChunksArePieceComponents()
			 */) {
				// log( 
				// "shouldHoldToDrawLingeringEffects no hold: falling w/out fades")
				// ;
				return false;
			}
			// advance through pieceFalling
			if (blocksState == GameBlocksSlice.BLOCKS_PIECE_FALLING) {
				// log( 
				// "shouldHoldToDrawLingeringEffects no hold: piece falling") ;
				return false;
			}
			// advance through stable
			if (blocksState == GameBlocksSlice.BLOCKS_STABLE) {
				// log( 
				// "shouldHoldToDrawLingeringEffects no hold: stable") ;
				return false;
			}

			// Advance through metamorphosis
			if (blocksState == GameBlocksSlice.BLOCKS_METAMORPHOSIZING) {
				// log( 
				// "shouldHoldToDrawLingeringEffects no hold: metamorphosis") ;
				return false;
			}

			// Advance through PUSH UP, but ONLY if we aren't animating
			// "pushes": we want to keep going if we are animating a row
			// transfer,
			// since this doesn't move anything up or down. Glows still need to
			// be adjusted, though...
			if (blocksState == GameBlocksSlice.BLOCKS_PUSHING_ROWS
					&& slice.getNumRowsPushedDown() < 0
					&& slice.getNumRowsPushedUp() <= 0) {
				return false;
			}
		}
		// TODO: If we are in THROUGH_SLICE, check whether the new slice is a
		// type
		// we hold or a type we continue animating.

		// If the current slice was advanced already, it no longer makes since
		// to hold it.
		if (sliceTime.getSliceAdvanced()) {
			// log( 
			// "shouldHoldToDrawLingeringEffects no hold: slice has advanced") ;
			return false;
		}

		// log("shouldHoldToDrawLingeringEffects HOLD") ;
		return true;
	}

	private void drawTouchedCoveredTestToCanvas(Canvas canvas) {

		// step 1: draw 'touched but now covered' area, with
		// stable CYAN, volatile GREEN (for brighter 'stable')
		// use 1/2 alpha.
        canvas.save();

        reset(tempPath);
        op(tempPath, this.mLastBitmapTouchedPath[BITMAP_REGION_Q0_STABLE], Path.Op.UNION);
        op(tempPath, this.mLastBitmapTouchedPath[BITMAP_REGION_Q1_STABLE], Path.Op.UNION);
        op(tempPath, this.mLastBitmapTouchedPath[BITMAP_REGION_3D_STABLE], Path.Op.UNION);
        canvas.clipPath(tempPath);

        reset(tempPath);
        op(tempPath, this.mLastBitmapCoveredPath[BITMAP_REGION_Q0_STABLE], Path.Op.UNION);
        op(tempPath, this.mLastBitmapCoveredPath[BITMAP_REGION_Q1_STABLE], Path.Op.UNION);
        op(tempPath, this.mLastBitmapCoveredPath[BITMAP_REGION_3D_STABLE], Path.Op.UNION);
        canvas.clipPath(tempPath, Region.Op.DIFFERENCE);

		canvas.drawColor(ColorOp.setAlphaForColor(128, Color.CYAN));
		canvas.restore();

		canvas.save();
		reset(tempPath);
		op(tempPath, this.mLastBitmapTouchedPath[BITMAP_REGION_Q0_VOLATILE], Path.Op.UNION);
        op(tempPath, this.mLastBitmapTouchedPath[BITMAP_REGION_Q1_VOLATILE], Path.Op.UNION);
        op(tempPath, this.mLastBitmapTouchedPath[BITMAP_REGION_3D_VOLATILE], Path.Op.UNION);
        canvas.clipPath(tempPath);

        reset(tempPath);
        op(tempPath, this.mLastBitmapCoveredPath[BITMAP_REGION_Q0_VOLATILE], Path.Op.UNION);
        op(tempPath, this.mLastBitmapCoveredPath[BITMAP_REGION_Q1_VOLATILE], Path.Op.UNION);
        op(tempPath, this.mLastBitmapCoveredPath[BITMAP_REGION_3D_VOLATILE], Path.Op.UNION);
        canvas.clipPath(tempPath, Region.Op.DIFFERENCE);

		canvas.drawColor(ColorOp.setAlphaForColor(128, Color.GREEN));
		canvas.restore();

		// step 2: draw 'covered' area, with stable MAGENTA, volatile RED
		// (for brighter 'stable'
        canvas.save();
        reset(tempPath);
        op(tempPath, this.mLastBitmapCoveredPath[BITMAP_REGION_Q0_STABLE], Path.Op.UNION);
        op(tempPath, this.mLastBitmapCoveredPath[BITMAP_REGION_Q1_STABLE], Path.Op.UNION);
        op(tempPath, this.mLastBitmapCoveredPath[BITMAP_REGION_3D_STABLE], Path.Op.UNION);
        canvas.clipPath(tempPath);
		canvas.drawColor(ColorOp.setAlphaForColor(128, Color.MAGENTA));
		canvas.restore();

		canvas.save();
        reset(tempPath);
        op(tempPath, this.mLastBitmapCoveredPath[BITMAP_REGION_Q0_VOLATILE], Path.Op.UNION);
        op(tempPath, this.mLastBitmapCoveredPath[BITMAP_REGION_Q1_VOLATILE], Path.Op.UNION);
        op(tempPath, this.mLastBitmapCoveredPath[BITMAP_REGION_3D_VOLATILE], Path.Op.UNION);
        canvas.clipPath(tempPath);
		canvas.drawColor(ColorOp.setAlphaForColor(128, Color.RED));
		canvas.restore();
	}

	private void drawStableWithLastSlice(Canvas canvas, QuantroSoundPool pool,
			GameBlocksSlice slice, BlockDrawerSliceTime sliceTime,
			BlockDrawerConfigCanvas configCanvas, int blitAlpha) {

		drawStableWithLastSlice(canvas, pool, slice, sliceTime, configCanvas,
				DrawStableFieldType.STABLE, blitAlpha);

	}

	private void drawStableWithLastSlice(Canvas canvas, QuantroSoundPool pool,
			GameBlocksSlice slice, BlockDrawerSliceTime sliceTime,
			BlockDrawerConfigCanvas configCanvas,
			DrawStableFieldType stableField,
			int blitAlpha) {

		if (configCanvas == null && mNextSliceNeedsExplicitConfigCanvas)
			configCanvas = mDrawSettings.configCanvas;

		tick();
		// Our "efficient" draw function. We draw to mLastBitmapCanvas, then
		// draw mLastBitmap to the canvas provided.

		boolean backgroundChanged = backgroundLayerChanged(mLastSliceTime,
				sliceTime);
		boolean fieldChanged = false;
		boolean sliceStateChanged = slice.getBlocksState() != mLastSlice
				.getBlocksState();

		if (sliceStateChanged
				&& GlobalTestSettings.BLOCK_DRAWER_LOG_SLICE_STATE)
			log("now drawing stable");

		tick();
		fieldChanged = mNextSliceBreaksSequence || !mLastBitmapIsStableSlice;
		fieldChanged = fieldChanged
				|| mLastBitmapStableField != stableField ;
		
		// The setting for 'field' is used throughout.  Don't remove this.
		byte [][][] field = null ;
		byte [][][] lastField = null ;
		switch( stableField ) {
		case MINIMUM_PROFILE:
			field = slice.getBlockfieldMinimumProfile() ;
			lastField = mLastSlice.getBlockfieldMinimumProfile() ;
			break ;
		case PUSHING_PRE:
		case INITIAL:
			field = slice.getBlockfieldInitial() ;
			lastField = mLastSlice.getBlockfieldInitial() ;
			break ;
		case PUSHING_POST:
		case STABLE:
		default:
			field = slice.getBlockfieldStable() ;
			lastField = mLastSlice.getBlockfieldStable() ;
			break ;
		}
		fieldChanged = fieldChanged
				|| ( mNextSlicePossiblyInconsistent && !ArrayOps.areEqual( field, lastField ) ) ;
		fieldChanged = fieldChanged || mLastBitmapDifferentDisplacement ;

		if (fieldChanged)
			mProfileBehavior = BlockDrawer.INDEX_PROFILE_SLICE_STABLE_BEHAVIOR_FIELD_CHANGED;
		else
			mProfileBehavior = BlockDrawer.INDEX_PROFILE_SLICE_STABLE_BEHAVIOR_NOTHING_CHANGED;
		mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_CHECK_EQUALITY] += tock();

		// shadows and corners must be recalculated if not stable.
		tick();
		if (fieldChanged) {
			byte[][][][] corners = mLastCorners_byField_byPaneCorner
					.get(INDEX_FIELD_STABLE);
			short[][][] shadows = mLastFillShadowSets_byField_byPane
					.get(INDEX_FIELD_STABLE);
			short[][][][] drop = mLastDropShadowSets_byField_byPane_byUniqueColor
					.get(INDEX_FIELD_STABLE);
			setShadowsAndCorners(mDrawSettings, field, mConfigRangeStandard,
					shadows, drop, corners);

			byte[][][][] qoCorners = this.mLastQOConnectedCorners_byField_byPaneCorner
					.get(INDEX_FIELD_STABLE);
			short[][][] qoSets = this.mLastQOConnectedSets_byField_byPane
					.get(INDEX_FIELD_STABLE);
			setQOConnectionAndCorners(mDrawSettings, field,
					mConfigRangeStandard, qoSets, qoCorners);
		}
		mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_SET_SHADOWS_AND_CORNERS] += tock();

		// Determine our clip. Clip the full visible area (BOTTOM half of the
		// canvas!) if
		// the field changed. Clip the before-and-after areas for piece and
		// ghosts if the
		// piece changed. If neither, don't bother with the clip. This is also a
		// good time
		// to determine our offset.
		int height = mDrawSettings.height;
		int blitHeight = mDrawSettings.configCanvas.region.height();
		boolean doubleBitmapWithOffset = mLastBitmap != null
				&& mDrawSettings.drawAnimations >= DrawSettings.DRAW_ANIMATIONS_STABLE_STUTTER
				&& mDrawSettings.getBlit() != DrawSettings.BLIT_SEPTUPLE
				&& !mDrawSettings.getBehaviorIs_displacement();
		// for clipping, we need to extend the clip by a certain distance
		// from each altered block. This lets us draw and re-draw our drop
		// shadow,
		// which extends slightly beyond the reach of each block.
		int extendByPixels = Math.max(boundDropShadowHeight(mDrawSettings),
				boundDropShadowWidth(mDrawSettings));

		// log("doubleBitmap " + doubleBitmap + ", height " + height +
		// ", bitmap height " + mLastBitmap.getHeight()) ;

		if (fieldChanged || alignmentOffsetSet || sliceStateChanged
				|| mLastBitmapVeiled) {
			setAlignmentOffset( field, clipOffset );
			if (doubleBitmapWithOffset)
				clipOffset.y += height;
		}

		// Set Stable touched / covered clips.
		if (fieldChanged
				|| mLastBitmapVeiled
				|| mLastBitmapDifferentDisplacement
				|| (sliceStateChanged && mDrawSettings.getBlit() != DrawSettings.BLIT_SEPTUPLE)) {
			
			switch( stableField ) {
			case MINIMUM_PROFILE:
				drawStableMinimumProfileWithLastSlice_helperClipCoveredStable(
						slice, clipOffset);
				drawStableMinimumProfileWithLastSlice_helperClipTouchedStable(
						slice, clipOffset, extendByPixels);
				break ;
				
			case PUSHING_PRE:
			case INITIAL:
				drawStableInitialWithLastSlice_helperClipCoveredStable(slice,
						clipOffset);
				drawStableInitialWithLastSlice_helperClipTouchedStable(slice,
						clipOffset, extendByPixels, true);
				break ;
				
			case PUSHING_POST:
			case STABLE:
			default:
				drawStableWithLastSlice_helperClipCoveredStable(slice,
						clipOffset);
				drawStableWithLastSlice_helperClipTouchedStable(slice,
						clipOffset, extendByPixels, true);
				break ;
			}
			
			drawStableWithBlockfield_helperClipCoveredVolatileEmpty() ;
			drawStableWithBlockfield_helperClipTouchedVolatileEmpty() ;
		}

		// //////////////////////////////////////////////////////////////////////
		// VEIL INSTRUCTIONS: If we're veiled, we possibly skip this entire
		// section
		// UNLESS this is our first attempt or something in the slice has
		// changed.
		// The setup below (among other effects) sets mLastBitmap[BITMAP_FULL]
		// to
		// the on-screen representation of the blockField.

		if (!this.willDrawVeilPixels(sliceTime) || !mLastBitmapVeiled
				|| fieldChanged || sliceStateChanged) {
			// If using BLIT_FULL, we set offsets to match the mLast, clip
			// according
			// to changes, draw to mLastBitmap and finally blit to the canvas.
			// If
			// using BLIT_NONE, we set offset to match the canvas, clip UNION
			// the
			// pulses (assuming an appropriate clip is already in place), and
			// draw
			// directly to the canvas.
			switch (mDrawSettings.getBlit()) {
			case DrawSettings.BLIT_SEPTUPLE:
				// set offsets
				if (fieldChanged || alignmentOffsetSet || sliceStateChanged
						|| mLastBitmapVeiled) {
					setAlignmentOffset( field, alignmentOffset );
					canvasAlignmentOffset.takeVals(alignmentOffset);

					alignmentOffsetSet = false;
				}

				canvasTranslationOffset.x = 0;
				canvasTranslationOffset.y = 0;
				// clip
				boolean havePulseQ0 = false;
				boolean havePulseQ1 = false;
				boolean havePulse3D = false;
				tick();
				reset(mLastBitmapClipPath);
				if (fieldChanged || mLastBitmapVeiled) {
					unionRect(mLastBitmapClipPath[BITMAP_FULL], 0, 0,
							mLastBitmapBounds[BITMAP_FULL].width(),
							mLastBitmapBounds[BITMAP_FULL].height(),
							Path.Direction.CW);
					unionRect(mLastBitmapClipPath[BITMAP_SEPTUPLE_Q0_STABLE], 0, 0,
							mLastBitmapBounds[BITMAP_SEPTUPLE_Q0_STABLE].width(),
							mLastBitmapBounds[BITMAP_SEPTUPLE_Q0_STABLE].height(),
                            Path.Direction.CW);
					unionRect(mLastBitmapClipPath[BITMAP_SEPTUPLE_Q1_STABLE], 0, 0,
							mLastBitmapBounds[BITMAP_SEPTUPLE_Q1_STABLE].width(),
							mLastBitmapBounds[BITMAP_SEPTUPLE_Q0_STABLE].height(),
                            Path.Direction.CW);
					unionRect(mLastBitmapClipPath[BITMAP_SEPTUPLE_3D_STABLE], 0, 0,
							mLastBitmapBounds[BITMAP_SEPTUPLE_3D_STABLE].width(),
							mLastBitmapBounds[BITMAP_SEPTUPLE_Q0_STABLE].height(),
                            Path.Direction.CW);
				}

				// Clip "pulse" behavior pieces.
				if (animationSettings != null) {
				    reset(clipPath);
					havePulseQ0 = clipPulseFill(
							clipPath,
							field, Consts.QPANE_0, 0,
							alignmentOffset);
					if (havePulseQ0) {
						op(mLastBitmapClipPath[BITMAP_SEPTUPLE_Q0_STABLE], clipPath, Path.Op.UNION);
						op(mLastBitmapClipPath[BITMAP_FULL], clipPath, Path.Op.UNION);
					}
					reset(clipPath);
					havePulseQ1 = clipPulseFill(
							clipPath,
							field, Consts.QPANE_1, 0,
							alignmentOffset);
					if (havePulseQ1) {
						op(mLastBitmapClipPath[BITMAP_SEPTUPLE_Q1_STABLE], clipPath, Path.Op.UNION);
						op(mLastBitmapClipPath[BITMAP_FULL], clipPath, Path.Op.UNION);
					}
					reset(clipPath);
					havePulse3D = clipPulseFill(
							clipPath,
							field, Consts.QPANE_3D, 0,
							alignmentOffset);
					if (havePulse3D) {
						op(mLastBitmapClipPath[BITMAP_SEPTUPLE_3D_STABLE], clipPath, Path.Op.UNION);
						op(mLastBitmapClipPath[BITMAP_FULL], clipPath, Path.Op.UNION);
					}
				}
				// GlowEffects
				if (mDrawSettings.drawEffects == DrawSettings.DRAW_EFFECTS_THROUGH_SLICE
						&& mLastEffectsGlow != null) {
					int numGlows = mLastEffectsGlow.size() ;
					for (int i = 0; i < numGlows; i++) {
						GlowEffect glowEffect = mLastEffectsGlow.get(i);
						// clip this glow IF 1: it is a lock glow, 2: it has
						// started,
						// and 3: it has not been playing for long enough to
						// fade.
						if (glowEffect.active(sliceTime)
								|| glowEffect.active(mLastSliceTime)) {
							this.clipGlowEffect(mLastBitmapClipPath[BITMAP_FULL],
									glowEffect, 0, alignmentOffset);
						}
					}
				}
				// FadeEffects
				if (mDrawSettings.drawEffects == DrawSettings.DRAW_EFFECTS_THROUGH_SLICE
						&& mLastEffectsFade != null) {
					int numFades = mLastEffectsFade.size() ;
					for (int i = 0; i < numFades; i++) {
						FadeEffect fadeEffect = mLastEffectsFade.get(i);
						if (fadeEffect.active(sliceTime)
								|| fadeEffect.active(mLastSliceTime)) {
							switch (fadeEffect.type()) {
							case FadeEffect.TYPE_BOX:
								// drawn in 3D layer.
								reset(clipPath);
								boolean haveClip = clipPulseFill(
										clipPath,
										fadeEffect.directQOrientationsAccess(),
										Consts.QPANE_3D, 0, alignmentOffset);
								if (haveClip) {
									op(mLastBitmapClipPath[BITMAP_SEPTUPLE_3D_STABLE], clipPath, Path.Op.UNION);
									op(mLastBitmapClipPath[BITMAP_FULL], clipPath, Path.Op.UNION);
									havePulse3D = havePulse3D || haveClip;
								}
								break;
							}
						}
					}
				}
                if (configCanvas != null && configCanvas.background != null) {
                    // fully draw the BITMAP_FULL canvas
                    reset(mLastBitmapClipPath[BITMAP_FULL]);
                    unionRect(mLastBitmapClipPath[BITMAP_FULL], 0, 0,
                            mLastBitmap[BITMAP_FULL].getWidth(),
                            mLastBitmap[BITMAP_FULL].getHeight(),
                            Path.Direction.CW);
                }
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_CLIP] += tock();

                // All draw and blit operations performed under this clip; restored after blitting
                for (int i = 0; i < mLastBitmapCanvas.length; i++) {
                    mLastBitmapCanvas[i].save();
                    mLastBitmapCanvas[i].clipPath(mLastBitmapClipPath[i]);
                }

				// draw
				tick();
				// We have set canvasTransationOffset, mLastCorners and shadow
				// sets, and
				// calculated the clip. That's all we need for this method.
				if (fieldChanged || havePulseQ0 || mLastBitmapVeiled
						|| configCanvas != null)
					drawStableToCanvas_withSlice(
							mDrawSettings,
							Consts.QPANE_0,
							mLastBitmapCanvas[BITMAP_SEPTUPLE_Q0_STABLE],
							alignmentOffset,
							slice,
							sliceTime,
							mConfigRangeStandard,
							stableField, null,
							BlockDrawerConfigCanvas.Background.CLEAR, 0, true);
				if (fieldChanged || havePulseQ1 || mLastBitmapVeiled
						|| configCanvas != null)
					drawStableToCanvas_withSlice(
							mDrawSettings,
							Consts.QPANE_1,
							mLastBitmapCanvas[BITMAP_SEPTUPLE_Q1_STABLE],
							alignmentOffset,
							slice,
							sliceTime,
							mConfigRangeStandard,
							stableField, null,
							BlockDrawerConfigCanvas.Background.CLEAR, 0, true);
				if (fieldChanged || havePulse3D || mLastBitmapVeiled
						|| configCanvas != null)
					drawStableToCanvas_withSlice(
							mDrawSettings,
							Consts.QPANE_3D,
							mLastBitmapCanvas[BITMAP_SEPTUPLE_3D_STABLE],
							alignmentOffset,
							slice,
							sliceTime,
							mConfigRangeStandard,
							stableField, null,
							BlockDrawerConfigCanvas.Background.CLEAR, 0, true);
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW] += tock();

				// blit
				tick();
				// set blit rectangles
				setCanvasDestinationRect(
						mLastBitmapBlitRect[BITMAP_FULL],
						mLastBitmapBounds[BITMAP_FULL],
						mDrawSettings.configCanvas.region,
						-((int) Math.round(slice.getDisplacement()
								* mDrawSettings.size_blockHeight))
							+ mDrawSettings.displacementSafeMarginOffsetBlit);
				mLastBitmapBlitRect[BITMAP_SEPTUPLE_Q0_STABLE].set(0, 0,
						mLastBitmapBounds[BITMAP_FULL].width(),
						mLastBitmapBounds[BITMAP_FULL].height());
				mLastBitmapBlitRect[BITMAP_SEPTUPLE_Q1_STABLE].set(0, 0,
						mLastBitmapBounds[BITMAP_FULL].width(),
						mLastBitmapBounds[BITMAP_FULL].height());
				mLastBitmapBlitRect[BITMAP_SEPTUPLE_3D_STABLE].set(0, 0,
						mLastBitmapBounds[BITMAP_FULL].width(),
						mLastBitmapBounds[BITMAP_FULL].height());

				// start with the background. This call places appropriate
				// background content on FULL, including black backgrounds for blocks with transparent
                // fill that should not display the background.
				septupleBlitDrawBackgroundStableOnly(sliceTime, configCanvas);
				// blit q1, blit 3d, blit q0.
				septupleBlitStableOnly(alignmentOffset, slice.getPieceType(), sliceTime);

				// now done with internal bitmap clips; restore
                for (int i = 0; i < mLastBitmapCanvas.length; i++) {
                    mLastBitmapCanvas[i].restore();
                }

				// Copy the result to canvas.
				// blit alpha might be less than 255.
				blitPaintWithAlpha.setAlpha(blitAlpha);
				if (configCanvas == null
						|| configCanvas.equals(mDrawSettings.configCanvas)) {
					canvas.save();
					if (mDrawSettings.configCanvas.clipRegion != null)
						canvas.clipRect(mDrawSettings.configCanvas.clipRegion,
								Region.Op.INTERSECT);

					if (mDrawSettings.getBehaviorIs_backgroundBlit()) {
						drawLayeredBackgroundAssets(canvas,
								mDrawSettings.configCanvas.region, sliceTime,
								mDrawSettings.configCanvas.background);
					}

					canvas.drawBitmap(mLastBitmap[BITMAP_FULL],
							mLastBitmapBounds[BITMAP_FULL],
							mLastBitmapBlitRect[BITMAP_FULL],
							blitPaintWithAlpha);
					canvas.restore();
				} else {
					tempSrcRect.set(mLastBitmapBounds[BITMAP_FULL]);
					tempSrcRect.bottom = tempSrcRect.top + mDrawSettings.height;
					drawBitmapToCanvasWithConfig(canvas,
							mLastBitmap[BITMAP_FULL], tempSrcRect, slice,
							configCanvas, blitPaintWithAlpha);
				}
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_BLIT] += tock();

				// that's it
				break;

			case DrawSettings.BLIT_FULL:
				// set offsets
				if (fieldChanged || alignmentOffsetSet) {
					setAlignmentOffset(
							field, alignmentOffset);
					if (doubleBitmapWithOffset)
						alignmentOffset.y += height;

					alignmentOffsetSet = false;
				}

				canvasTranslationOffset.x = 0;
				canvasTranslationOffset.y = 0;

				// clip
				boolean havePulse = false;
				tick();
				reset(mLastBitmapClipPath[BITMAP_FULL]);
				if (fieldChanged || mBackgroundBitmapClipOrBlitIsBlitting
						|| mLastBitmapVeiled || configCanvas != null
						|| backgroundChanged) {
					if (doubleBitmapWithOffset) {
						unionRect(mLastBitmapClipPath[BITMAP_FULL], 0, height,
                                mLastBitmapBounds[BITMAP_FULL].width(),
                                height * 2,
                                Path.Direction.CW);
					} else {
						// clip with extra space below, so we have room to draw
						// displacement rows.
						float extra = mDrawSettings.getBehaviorIs_displacement()
								? mDrawSettings.size_blockHeight * 3
								: 0 ;
                        unionRect(mLastBitmapClipPath[BITMAP_FULL], 0, 0,
                                mLastBitmapBounds[BITMAP_FULL].width(),
                                mLastBitmapBounds[BITMAP_FULL].height() + extra,
                                Path.Direction.CW);
					}
				}

				// Clip glows - if any are left over from previous slices.
				boolean haveGlows = false;
				if (mDrawSettings.drawEffects == DrawSettings.DRAW_EFFECTS_THROUGH_SLICE
						&& mLastEffectsGlow != null) {
					int numGlows = mLastEffectsGlow.size() ;
					for (int i = 0; i < numGlows; i++) {
						GlowEffect glowEffect = mLastEffectsGlow.get(i);
						if (glowEffect.active(sliceTime)
								|| glowEffect.active(mLastSliceTime)) {
							haveGlows = true;
							clipGlowEffect(mLastBitmapClipPath[BITMAP_FULL],
									glowEffect, 0, alignmentOffset);
						}
					}
				}
				// FadeEffects
				if (mDrawSettings.drawEffects == DrawSettings.DRAW_EFFECTS_THROUGH_SLICE
						&& mLastEffectsFade != null) {
					int numFades = mLastEffectsFade.size() ;
					for (int i = 0; i < numFades; i++) {
						FadeEffect fadeEffect = mLastEffectsFade.get(i);
						if (fadeEffect.active(sliceTime)
								|| fadeEffect.active(mLastSliceTime)) {
							switch (fadeEffect.type()) {
							case FadeEffect.TYPE_BOX:
								// drawn in 3D layer.
								boolean haveClip = clipPulseFill(
										mLastBitmapClipPath[BITMAP_FULL],
										fadeEffect.directQOrientationsAccess(),
										Consts.QPANE_3D, 0, alignmentOffset);
								havePulse = havePulse || haveClip;
								break;
							}
						}
					}
				}

				// Clip "pulse" behavior pieces.
				if (animationSettings != null) {
					havePulse = clipPulseFill(
							mLastBitmapClipPath[BITMAP_FULL],
							field, 0, alignmentOffset);
				}

				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_CLIP] += tock();

				if (GlobalTestSettings.BLOCK_DRAWER_SHOW_COVERED_AND_TOUCHING_REGIONS) {
                    reset(mLastBitmapClipPath[BITMAP_FULL]);
					unionRect(mLastBitmapClipPath[BITMAP_FULL], 0, 0,
							Integer.MAX_VALUE, Integer.MAX_VALUE,
							Path.Direction.CW);
				}

				// draw
				tick();
				mLastBitmapCanvas[BITMAP_FULL].save();
				mLastBitmapCanvas[BITMAP_FULL].clipPath(mLastBitmapClipPath[BITMAP_FULL]);
				// We have set canvasTransationOffset, mLastCorners and shadow
				// sets, and
				// calculated the clip. That's all we need for this method.
				if (fieldChanged
						|| havePulse
						|| haveGlows
						|| configCanvas != null
						|| (backgroundChanged && !mDrawSettings
								.getBehaviorIs_backgroundBlit())) {

					BlockDrawerConfigCanvas.Background backgroundDefault = mDrawSettings
							.getBehaviorIs_backgroundBlit() ? BlockDrawerConfigCanvas.Background.CLEAR
							: BlockDrawerConfigCanvas.Background.DEFAULT;

					drawStableToCanvas_withSlice(
							mDrawSettings,
							Consts.QPANE_ALL,
							mLastBitmapCanvas[BITMAP_FULL],
							alignmentOffset,
							slice,
							sliceTime,
							mConfigRangeStandard,
							stableField,
							mBackgroundBitmapOffset,
							configCanvas != null ? configCanvas.background
									: backgroundDefault, 0, true);
				}
				mLastBitmapCanvas[BITMAP_FULL].restore();
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW] += tock();

				if (GlobalTestSettings.BLOCK_DRAWER_SHOW_COVERED_AND_TOUCHING_REGIONS)
					drawTouchedCoveredTestToCanvas(mLastBitmapCanvas[BITMAP_FULL]);

				// blit
				tick();

				if (mDrawSettings.getBehaviorIs_displacement()) {
					setCanvasDestinationRect(
							mLastBitmapBlitRect[BITMAP_FULL],
							mLastBitmapBounds[BITMAP_FULL],
							mDrawSettings.configCanvas.region,
							-((int) Math.round(slice.getDisplacement()
									* mDrawSettings.size_blockHeight))
								+ mDrawSettings.displacementSafeMarginOffsetBlit);
				} else {
					mLastBitmapBlitRect[BITMAP_FULL]
							.set(mDrawSettings.configCanvas.region.left,
									mDrawSettings.configCanvas.region.top
											- (doubleBitmapWithOffset ? blitHeight
													: 0),
									mDrawSettings.configCanvas.region.right,
									mDrawSettings.configCanvas.region.top
											+ blitHeight);
				}

				if (configCanvas == null
						|| configCanvas.equals(mDrawSettings.configCanvas)) {
					canvas.save();
					if (mDrawSettings.configCanvas.clipRegion != null)
						canvas.clipRect(mDrawSettings.configCanvas.clipRegion,
								Region.Op.INTERSECT);

					if (mDrawSettings.getBehaviorIs_backgroundBlit()) {
						drawLayeredBackgroundAssets(canvas,
								mDrawSettings.configCanvas.region, sliceTime,
								mDrawSettings.configCanvas.background);
					}

					blitPaintWithAlpha.setAlpha(blitAlpha);
					canvas.drawBitmap(mLastBitmap[BITMAP_FULL],
							mLastBitmapBounds[BITMAP_FULL],
							mLastBitmapBlitRect[BITMAP_FULL],
							blitPaintWithAlpha);
					canvas.restore();
				} else {
					// our content is available in mLastBitmap. However,
					// depending on
					// our background settings and config canvas settings, this
					// might fail.
					// throw an exception so we know this is unacceptable.
					blitPaintWithAlpha.setAlpha(blitAlpha);
					tempSrcRect.set(mLastBitmapBounds[BITMAP_FULL]);
					tempSrcRect.bottom = tempSrcRect.top + height;
					if (doubleBitmapWithOffset)
						tempSrcRect.offset(0, height);
					drawBitmapToCanvasWithConfig(canvas,
							mLastBitmap[BITMAP_FULL], tempSrcRect, slice,
							configCanvas, blitPaintWithAlpha);
				}
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_BLIT] += tock();

				// that's it
				break;

			case DrawSettings.BLIT_NONE:
				// set offsets to true canvas
				setAlignmentOffset(
						field, alignmentOffset);
				alignmentOffsetSet = true;
				setCanvasTranslationOffset(canvas);
				int displacement = 0;
				if (mDrawSettings.getBehaviorIs_displacement()) {
					displacement = -((int) Math.round(slice.getDisplacement()
							* mDrawSettings.size_blockHeight));
					alignmentOffset.y += displacement;
				}

				// We don't bother clipping; we assume that has been done
				// for us.

				// draw to the canvas
				tick();
				// We have set canvasTransationOffset, mLastCorners and shadow
				// sets, and
				// calculated the clip. That's all we need for this method.
				canvas.save();
				if (mDrawSettings.configCanvas.clipRegion != null) {
					log("clipping configCanvas clipRegion") ;
					canvas.clipRect(mDrawSettings.configCanvas.clipRegion,
							Region.Op.INTERSECT);
				}
				drawStableToCanvas_withSlice(
						mDrawSettings,
						Consts.QPANE_ALL,
						canvas,
						alignmentOffset,
						slice,
						sliceTime,
						mConfigRangeStandard,
						stableField,
						mBackgroundBitmapOffset,
						BlockDrawerConfigCanvas.Background.DEFAULT,
						displacement, true);
				canvas.restore();
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW] += tock();

				if (GlobalTestSettings.BLOCK_DRAWER_SHOW_COVERED_AND_TOUCHING_REGIONS)
					drawTouchedCoveredTestToCanvas(canvas);

				// that's it; no blitting
				break;

			default:
				throw new IllegalStateException("Blit setting "
						+ mDrawSettings.getBlit() + " confuses and infuriates us");
			}

			mLastBitmapVeiled = false;
		}

		// //////////////////////////////////////////////////////////////////////
		// VEIL INSTRUCTIONS: At this point, mLastBitmap[BITMAP_FULL] is the
		// content to be drawn under the veil. Draw the veil over it.

		if (veilOnScreen(sliceTime)
				&& (configCanvas == null || configCanvas
						.equals(mDrawSettings.configCanvas))) {
			drawBitmapFullVeiledToCanvas(canvas, sliceTime, sliceStateChanged
					|| fieldChanged || !mLastBitmapVeiled);
			// only force a redraw if content changed, otherwise use our cached
			// veil.
			mLastBitmapVeiled = true;
		}

		// We have drawn. Update metadata.
		if (fieldChanged)
			mLastSlice.takeVals(slice);

		mLastBitmapIsStableSlice = true;
		mLastBitmapIsStableSliceIgnoringEffects = true;
		mLastBitmapIsStableSliceReadyToAdvanceEffects = true;
		this.mLastBitmapStableField = stableField;
		mNextSliceNeedsExplicitConfigCanvas = false;
		mNextSliceBreaksSequence = false;
		mNextSlicePossiblyInconsistent = false;

		mBackgroundBitmapClipOrBlitIsBlitting = false; // having drawn stable,
														// we prefer clipping.

		mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_TOTAL] += tock();
		mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_NUMBER]++;

		// SOUNDS! Play sounds according to what happened.
		playSounds(sliceTime, pool);

		sliceTime.setLastDrawn();
		clearExpiredEffects(sliceTime);

		if (mLastSliceTime != null && sliceTime != null)
			mLastSliceTime.takeVals(sliceTime);
	}

	private void drawStableWithLastSlice_helperClipCoveredStable(
			GameBlocksSlice slice, Offset offset) {
		drawStableWithBlockfield_helperClipCoveredStable(
				slice.getBlockfieldStable(), offset);
	}
	
	private void drawStableInitialWithLastSlice_helperClipCoveredStable(
			GameBlocksSlice slice, Offset offset) {
		drawStableWithBlockfield_helperClipCoveredStable(
				slice.getBlockfieldInitial(), offset);
	}

	private void drawStableWithLastSlice_helperClipTouchedStable(
			GameBlocksSlice slice, Offset offset, int extendByPixels,
			boolean includeDisplacementRowsIfAvailable) {

		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q0_STABLE]);
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_3D_STABLE]);
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q1_STABLE]);

		drawStableWithBlockfield_helperClipTouchedStable(
				slice.getBlockfieldStable(), mConfigRangeStandard, offset,
				extendByPixels, true);

		if (includeDisplacementRowsIfAvailable
				&& mDrawSettings.getBehaviorIs_displacement()) {
			clipDisplacementOffset.takeVals(offset);
			clipDisplacementOffset.offsetXY(0, mDrawSettings.ROWS
					* mDrawSettings.size_blockHeight);
			drawStableWithBlockfield_helperClipTouchedStable(
					slice.getDisplacementBlockfield(), mConfigRangeDisplaced,
					clipDisplacementOffset, extendByPixels, false);
		}
	}
	
	private void drawStableInitialWithLastSlice_helperClipTouchedStable(
			GameBlocksSlice slice, Offset offset, int extendByPixels,
			boolean includeDisplacementRowsIfAvailable) {

		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q0_STABLE]);
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_3D_STABLE]);
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q1_STABLE]);

		drawStableWithBlockfield_helperClipTouchedStable(
				slice.getBlockfieldInitial(), mConfigRangeStandard, offset,
				extendByPixels, true);

		if (includeDisplacementRowsIfAvailable
				&& mDrawSettings.getBehaviorIs_displacement()) {
			clipDisplacementOffset.takeVals(offset);
			clipDisplacementOffset.offsetXY(0, mDrawSettings.ROWS
					* mDrawSettings.size_blockHeight);
			drawStableWithBlockfield_helperClipTouchedStable(
					slice.getDisplacementBlockfield(), mConfigRangeDisplaced,
					clipDisplacementOffset, extendByPixels, false);
		}
	}

	private void drawStableMinimumProfileWithLastSlice_helperClipCoveredStable(
			GameBlocksSlice slice, Offset offset) {
		drawStableWithBlockfield_helperClipCoveredStable(
				slice.getBlockfieldMinimumProfile(), offset);
	}

	private void drawStableMinimumProfileWithLastSlice_helperClipTouchedStable(
			GameBlocksSlice slice, Offset offset, int extendByPixels) {

		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q0_STABLE]);
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_3D_STABLE]);
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q1_STABLE]);

		drawStableWithBlockfield_helperClipTouchedStable(
				slice.getBlockfieldMinimumProfile(), mConfigRangeStandard,
				offset, extendByPixels, true);
	}

	private void drawStableWithBlockfield_helperClipCoveredStable(
			byte[][][] blockfield, Offset offset) {

		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_Q0_STABLE]);
		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_3D_STABLE]);
		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_Q1_STABLE]);

		clipCoveredPath(mLastBitmapCoveredPath[BITMAP_REGION_Q0_STABLE],
				blockfield, Consts.QPANE_0, 0, offset);
		// skip 3D
		clipCoveredPath(mLastBitmapCoveredPath[BITMAP_REGION_Q1_STABLE],
				blockfield, Consts.QPANE_1, 0, offset);
	}

	private void drawStableWithBlockfield_helperClipTouchedStable(
			byte[][][] blockfield, BlockDrawerConfigRange configRange,
			Offset offset, int extendByPixels, boolean includeRowNegativeOne) {

		clipTouchedPath(mLastBitmapTouchedPath[BITMAP_REGION_Q0_STABLE],
				blockfield, configRange, Consts.QPANE_0, offset, extendByPixels);
		clipTouchedPath(mLastBitmapTouchedPath[BITMAP_REGION_Q1_STABLE],
				blockfield, configRange, Consts.QPANE_1, offset, extendByPixels);
		clipTouchedPath(mLastBitmapTouchedPath[BITMAP_REGION_3D_STABLE],
				blockfield, configRange, Consts.QPANE_3D, offset,
				extendByPixels);

		if (includeRowNegativeOne) {
			clipFullWidthRowNegativeOne(
					mLastBitmapTouchedPath[BITMAP_REGION_Q0_STABLE], 0,
					mDrawSettings.width, Consts.QPANE_0, offset, extendByPixels);
			clipFullWidthRowNegativeOne(
					mLastBitmapTouchedPath[BITMAP_REGION_Q1_STABLE], 0,
					mDrawSettings.width, Consts.QPANE_1, offset, extendByPixels);
		}
	}
	
	
	private void drawStableWithBlockfield_helperClipCoveredVolatileEmpty() {
		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_Q0_VOLATILE]);
		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_3D_VOLATILE]);
		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_Q1_VOLATILE]);
	}
	
	private void drawStableWithBlockfield_helperClipTouchedVolatileEmpty() {
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q0_VOLATILE]);
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_3D_VOLATILE]);
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q1_VOLATILE]);
	}
	

	/**
	 * Primarily intended as a helper for drawStableWithLastSlice. Provide a
	 * canvas, a draw offset, a GameBlocksSlice to draw and the current time
	 * (for pulses).
	 * 
	 * PRECONDITIONS: The provided canvas has been clipped appropriately. When
	 * drawing efficiently (i.e. to mLastBitmapCanvas, this clip should cover
	 * only those blocks which have changed; when drawing directly to the
	 * OS-provided canvas, a clip has likely already been applied; redraw
	 * everything.
	 * 
	 * 'canvasTransation' has been set in advance, according to whether the
	 * provided canvas includes any transation.
	 * 
	 * mLastCorners_ and mLastInnerShadowSets have been configured.
	 * 
	 * POSTCONDITIONS: The stable block slice has been drawn to the canvas.
	 * 
	 * If drawn with Consts.QPANE_ALL, includes glows as well.
	 */
	private void drawStableToCanvas_withSlice(DrawSettings drawSettings,
			int qPane, Canvas canvas, Offset offset, GameBlocksSlice slice,
			BlockDrawerSliceTime sliceTime, BlockDrawerConfigRange configRange,
			DrawStableFieldType type, Offset offsetBackground,
			BlockDrawerConfigCanvas.Background configCanvasBackground,
			int blockCoveredYOffset, boolean includeDisplacementRowsIfAvailable) {

		if (configRange == null) {
			configRange = tempConfigRange;
			configRange.set(drawSettings.displayedRows, drawSettings.COLS);
		}

		long currentTime = sliceTime == null ? 0 : sliceTime.getUnpaused();

		float alphaScale_fillPulse = animationSettings == null ? 0
				: animationSettings.pulseAlpha(
						drawSettings.alphaScale_lockedFillPulse, currentTime);
		float alphaScale_boxPulse = animationSettings == null ? 0
				: animationSettings.pulseAlpha(
						drawSettings.alphaScale_lockedBoxPulse, currentTime);

		byte[][][] field;
		int field_index;
		switch (type) {
		case INITIAL:
			field = slice.getBlockfieldInitial() ;
			field_index = INDEX_FIELD_STABLE;
			break ;
		case MINIMUM_PROFILE:
			field = slice.getBlockfieldMinimumProfile();
			field_index = INDEX_FIELD_STABLE;
			break;
		case PUSHING_PRE:
			field = slice.getPushingRowsPreBlockfield();
			field_index = INDEX_FIELD_PUSHING_PRE;
			break;
		case PUSHING_POST:
			field = slice.getPushingRowsPostBlockfield();
			field_index = INDEX_FIELD_PUSHING;
			break;
		case STABLE:
		default:
			field = slice.getBlockfieldStable();
			field_index = INDEX_FIELD_STABLE;
			break;
		}

		byte[][][][] corners = mLastCorners_byField_byPaneCorner
				.get(field_index);
		short[][][] shadows = mLastFillShadowSets_byField_byPane
				.get(field_index);
		short[][][][] drop = mLastDropShadowSets_byField_byPane_byUniqueColor
				.get(field_index);

		byte[][][][] qo_corners = mLastQOConnectedCorners_byField_byPaneCorner
				.get(field_index);
		short[][][] qo_sets = mLastQOConnectedSets_byField_byPane
				.get(field_index);
		
		byte[][][][] displacement_corners = mLastCorners_byField_byPaneCorner.get(INDEX_FIELD_DISPLACEMENT) ;

		int pieceType = slice.getPieceType();

		// Drop shadows: Because there is only 1 blockfield to consider
		// (stable), we can safely
		// draw the drop shadows as part of our normal style.

		// draw background: happens in 2 different steps. If we draw 'all,' we
		// fill
		// now. Otherwise, if BLOCK_FILL, we draw twice - first to set the
		// background
		// color, second to draw the fills themselves.

		int backAlpha = qPane == Consts.QPANE_ALL ? 255 : 0;
		fullBlitDrawBackground(drawSettings, canvas, offsetBackground,
				sliceTime, configCanvasBackground, backAlpha, backAlpha,
				blockCoveredYOffset) ;

		boolean drawQ1 = qPane == Consts.QPANE_ALL || qPane == Consts.QPANE_1;
		boolean drawQ0 = qPane == Consts.QPANE_ALL || qPane == Consts.QPANE_0;
		boolean draw3d = qPane == Consts.QPANE_ALL || qPane == Consts.QPANE_3D;
		boolean drawGlows = qPane == Consts.QPANE_ALL && sliceTime != null;

		if (includeDisplacementRowsIfAvailable
				&& drawSettings.getBehaviorIs_displacement()) {
			drawDisplacementOffset.takeVals(offset);
			drawDisplacementOffset.offsetXY(0,
					drawSettings.ROWS * drawSettings.size_blockHeight);
		}

		// draw to last bitmap canvas
		if (drawSettings.drawQ1 && drawQ1) {
			// PANE 1: displacement.
			if (includeDisplacementRowsIfAvailable
					&& drawSettings.getBehaviorIs_displacement()) {
				drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
						drawSettings.alpha_displacementBorder > 0 ? STYLE_FILL_AND_BORDER : STYLE_FILL,
						canvas, slice.getDisplacementBlockfield(),
						mConfigRangeDisplaced, Consts.QPANE_1, pieceType,
						drawDisplacementOffset,
						drawSettings.alpha_displacementFill, 0, 0, 0, drawSettings.alpha_displacementBorder, 0, 0,
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_TL],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_TR],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_BL],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_BR],
						null, null, sliceTime,
						GlowEffect.TYPE_NONE, true, null);
			}

			// PANE 1: draw row neg 1
			if (drawSettings.behavior_border == DrawSettings.BEHAVIOR_BORDER_ROW_NEGATIVE_ONE)
				drawRowNegativeOneToCanvas(drawSettings, canvas,
						Consts.QPANE_1,
						drawSettings.alpha_rowNegativeOneBorder, offset);
			// PANE 1: field
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, field,
					configRange, Consts.QPANE_1, pieceType, offset, -1,
					drawSettings.alpha_lockedFill, alphaScale_fillPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					corners[Consts.QPANE_1][INDEX_CORNER_TL],
					corners[Consts.QPANE_1][INDEX_CORNER_TR],
					corners[Consts.QPANE_1][INDEX_CORNER_BL],
					corners[Consts.QPANE_1][INDEX_CORNER_BR],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_TL],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_TR],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_BL],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_BR],
					shadows[Consts.QPANE_1], drop[Consts.QPANE_1],
					qo_sets[Consts.QPANE_1], sliceTime,
					drawGlows ? GlowEffect.TYPE_ANY : GlowEffect.TYPE_NONE,
					drawGlows ? mLastEffectsGlow : null, FadeEffect.TYPE_NONE,
					null);
		}

		if (drawSettings.draw3D && draw3d) {
			// PANE 3D: field
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, field,
					configRange, Consts.QPANE_3D, pieceType, offset, -1,
					drawSettings.alpha_lockedFill, alphaScale_boxPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					corners[Consts.QPANE_0][INDEX_CORNER_TL],
					corners[Consts.QPANE_0][INDEX_CORNER_TR],
					corners[Consts.QPANE_0][INDEX_CORNER_BL],
					corners[Consts.QPANE_0][INDEX_CORNER_BR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BR], null, null,
					qo_sets[Consts.QPANE_0], sliceTime, GlowEffect.TYPE_NONE,
					null, FadeEffect.TYPE_BOX, mLastEffectsFade);
		}

		// draw to last bitmap canvas
		if (drawSettings.drawQ0 && drawQ0) {
			// PANE 0: displacement.
			if (includeDisplacementRowsIfAvailable
					&& drawSettings.getBehaviorIs_displacement()) {
				drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
						(drawSettings.alpha_displacementBorder > 0 ? STYLE_FILL_AND_BORDER : STYLE_FILL),
						canvas, slice.getDisplacementBlockfield(),
						mConfigRangeDisplaced, Consts.QPANE_0, pieceType,
						drawDisplacementOffset,
						drawSettings.alpha_displacementFill, 0, 0, 0, drawSettings.alpha_displacementBorder, 0, 0,
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_TL],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_TR],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_BL],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_BR],
						null, null, sliceTime,
						GlowEffect.TYPE_NONE, true, null);
			}

			// PANE 0: draw row neg 1.
			if (drawSettings.behavior_border == DrawSettings.BEHAVIOR_BORDER_ROW_NEGATIVE_ONE)
				drawRowNegativeOneToCanvas(drawSettings, canvas,
						Consts.QPANE_0,
						drawSettings.alpha_rowNegativeOneBorder, offset);
			// PANE 1: field
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, field,
					configRange, Consts.QPANE_0, pieceType, offset, -1,
					drawSettings.alpha_lockedFill, alphaScale_fillPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					corners[Consts.QPANE_0][INDEX_CORNER_TL],
					corners[Consts.QPANE_0][INDEX_CORNER_TR],
					corners[Consts.QPANE_0][INDEX_CORNER_BL],
					corners[Consts.QPANE_0][INDEX_CORNER_BR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BR],
					shadows[Consts.QPANE_0], drop[Consts.QPANE_0],
					qo_sets[Consts.QPANE_0], sliceTime,
					drawGlows ? GlowEffect.TYPE_ANY : GlowEffect.TYPE_NONE,
					drawGlows ? mLastEffectsGlow : null, FadeEffect.TYPE_NONE,
					null);
		}
	}

	private void drawPieceFallingInBlockFieldWithLastSlice(Canvas canvas,
			QuantroSoundPool pool, GameBlocksSlice slice,
			BlockDrawerSliceTime sliceTime, BlockDrawerConfigCanvas configCanvas) {

		if (configCanvas == null && mNextSliceNeedsExplicitConfigCanvas)
			configCanvas = mDrawSettings.configCanvas;

		tick(); // nest 0

		// Our "efficient" draw function. We draw to mLastBitmapCanvas, then
		// draw mLastBitmap to the canvas provided.

		boolean backgroundChanged = backgroundLayerChanged(mLastSliceTime,
				sliceTime);
		boolean fieldChanged = false;
		boolean pieceChanged = false;
		boolean stateChanged = mLastSlice.getBlocksState() != slice
				.getBlocksState();

		if (stateChanged && GlobalTestSettings.BLOCK_DRAWER_LOG_SLICE_STATE)
			log("now drawing piece falling");

		// Next: determine what changed. If the field changed (including
		// if the last slice was a different state) or the piece.
		tick(); // nest 1
		fieldChanged = mNextSliceBreaksSequence;
		fieldChanged = fieldChanged
				|| (mLastSlice.getBlocksState() != GameBlocksSlice.BLOCKS_PIECE_FALLING && ((mNextSlicePossiblyInconsistent && !ArrayOps
						.areEqual(mLastSlice.getBlockfieldStable(),
								slice.getPieceFallingBlockfield())) || !mLastBitmapIsStableSlice))
				|| (mLastSlice.getBlocksState() == GameBlocksSlice.BLOCKS_PIECE_FALLING && (mNextSlicePossiblyInconsistent && !ArrayOps
						.areEqual(mLastSlice.getPieceFallingBlockfield(),
								slice.getPieceFallingBlockfield()))) ;
		fieldChanged = fieldChanged || mLastBitmapDifferentDisplacement ;

		pieceChanged = fieldChanged
				|| mLastSlice.getBlocksState() != GameBlocksSlice.BLOCKS_PIECE_FALLING
				|| !ArrayOps.areEqual(mLastSlice.getPieceFallingPiece(),
						slice.getPieceFallingPiece());
		if (fieldChanged)
			mProfileBehavior = BlockDrawer.INDEX_PROFILE_SLICE_PIECE_BEHAVIOR_FIELD_CHANGED;
		else if (pieceChanged)
			mProfileBehavior = BlockDrawer.INDEX_PROFILE_SLICE_PIECE_BEHAVIOR_PIECE_CHANGED;
		else
			mProfileBehavior = BlockDrawer.INDEX_PROFILE_SLICE_PIECE_BEHAVIOR_NOTHING_CHANGED;
		mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_CHECK_EQUALITY] += tock();
		// \nest 1

		// Determine shadow sets and corners, if necessary.
		// for drop shadows, note that the "stable" slice contains both the
		// field and
		// the falling piece.
		tick(); // nest 1
		if (fieldChanged) {
			byte[][][] field = slice.getPieceFallingBlockfield();
			byte[][][][] corners = mLastCorners_byField_byPaneCorner
					.get(INDEX_FIELD_PIECE_FIELD);
			short[][][] shadows = mLastFillShadowSets_byField_byPane
					.get(INDEX_FIELD_PIECE_FIELD);
			short[][][][] drop = mLastDropShadowSets_byField_byPane_byUniqueColor
					.get(INDEX_FIELD_PIECE_FIELD);
			setShadowsAndCorners(mDrawSettings, field, mConfigRangeStandard,
					shadows, drop, corners);

			byte[][][][] qoCorners = this.mLastQOConnectedCorners_byField_byPaneCorner
					.get(INDEX_FIELD_PIECE_FIELD);
			short[][][] qoSets = this.mLastQOConnectedSets_byField_byPane
					.get(INDEX_FIELD_PIECE_FIELD);
			setQOConnectionAndCorners(mDrawSettings, field,
					mConfigRangeStandard, qoSets, qoCorners);
		}
		if (pieceChanged) {
			byte[][][] field = slice.getPieceFallingPiece();
			byte[][][][] corners = mLastCorners_byField_byPaneCorner
					.get(INDEX_FIELD_PIECE_PIECE);
			short[][][] shadows = mLastFillShadowSets_byField_byPane
					.get(INDEX_FIELD_PIECE_PIECE);
			short[][][][] drop = mLastDropShadowSets_byField_byPane_byUniqueColor
					.get(INDEX_FIELD_PIECE_PIECE);
			setShadowsAndCorners(mDrawSettings, field, mConfigRangeStandard,
					shadows, drop, corners);

			byte[][][][] qoCorners = this.mLastQOConnectedCorners_byField_byPaneCorner
					.get(INDEX_FIELD_PIECE_PIECE);
			short[][][] qoSets = this.mLastQOConnectedSets_byField_byPane
					.get(INDEX_FIELD_PIECE_PIECE);
			setQOConnectionAndCorners(mDrawSettings, field,
					mConfigRangeStandard, qoSets, qoCorners);

			for (int i = 0; i < slice.getNumPieceGhosts(); i++) {
				field = slice.getPieceFallingGhosts()[i
						+ slice.getFirstPieceGhosts()];
				corners = mLastCorners_byField_byPaneCorner
						.get(INDEX_FIELD_PIECE_FIRST_GHOST + i);
				// used for 3D and a small set of skins only
				setShadowsAndCorners(mDrawSettings, field, mConfigRangeStandard,
						null, null, corners);

				qoCorners = mLastQOConnectedCorners_byField_byPaneCorner
						.get(INDEX_FIELD_PIECE_FIRST_GHOST + i);
				qoSets = mLastQOConnectedSets_byField_byPane
						.get(INDEX_FIELD_PIECE_FIRST_GHOST + i);
				setQOConnectionAndCorners(mDrawSettings, field,
						mConfigRangeStandard, qoSets, qoCorners);
			}

			// set the piece mask.
			for (int qp = 0; qp < 2; qp++) {
			    reset(mPieceMask_byQPane[qp]);
				for (int row = 0; row < mDrawSettings.displayedRows; row++) {
					int r = row + mDrawSettings.blockFieldOuterBuffer;
					int top_y = mDrawSettings.getBlockYPosition(qp, row);
					for (int col = 0; col < mDrawSettings.COLS; col++) {
						int c = col + mDrawSettings.blockFieldOuterBuffer;
						int left_x = mDrawSettings.getBlockXPosition(qp, col);
						if (slice.getPieceFallingPiece()[qp][r][c] != QOrientations.NO) {
                            unionRect(mPieceMask_byQPane[qp], left_x, top_y,
                                    left_x + mDrawSettings.size_blockWidth,
                                    top_y + mDrawSettings.size_blockHeight,
                                    Path.Direction.CW);
                        }
					}
				}
			}
		}
		if (fieldChanged || pieceChanged) {
			byte[][][] field = slice.getBlockfieldStable();
			short[][][][] drop = mLastDropShadowSets_byField_byPane_byUniqueColor
					.get(INDEX_FIELD_PIECE_STABLE_DROP_SHADOWS);
			setShadowsAndCorners(mDrawSettings, field, mConfigRangeStandard,
					null, drop, null);
		}
		mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_SET_SHADOWS_AND_CORNERS] += tock();
		// \nest 1

		int height = mDrawSettings.height;
		int blitHeight = mDrawSettings.configCanvas.region.height();
		boolean doubleBitmapOffset = mLastBitmap != null
				&& mDrawSettings.drawAnimations >= DrawSettings.DRAW_ANIMATIONS_STABLE_STUTTER
				&& mDrawSettings.getBlit() != DrawSettings.BLIT_SEPTUPLE
				&& !mDrawSettings.getBehaviorIs_displacement();

		// for clipping, we need to extend the clip by a certain distance
		// from each altered block. This lets us draw and re-draw our drop
		// shadow,
		// which extends slightly beyond the reach of each block.
		int extendByPixels = Math.max(boundDropShadowHeight(mDrawSettings),
				boundDropShadowWidth(mDrawSettings));

		if (fieldChanged || pieceChanged || stateChanged || alignmentOffsetSet) {
			setAlignmentOffset(slice.getBlockfieldStable(), clipOffset);
			if (doubleBitmapOffset)
				clipOffset.y += height;
		}

		// Clip the covered / touched area.
		if (fieldChanged
				|| mLastBitmapVeiled
				|| mLastBitmapDifferentDisplacement
				|| (stateChanged && mDrawSettings.getBlit() != DrawSettings.BLIT_SEPTUPLE)) {
			// Clip the covered content in stable (we need it to draw
			// the piece w/o overlapping drop shadows)
			drawPieceFallingToCanvasWithSlice_helperClipCoveredStable(slice,
					clipOffset);
			drawPieceFallingToCanvasWithSlice_helperClipCoveredVolatile(slice,
					clipOffset);
			// Clip the touched content in stable and volatile (volatile
			// is UNIONed
			// for the piece and all ghosts).
			drawPieceFallingToCanvasWithSlice_helperClipTouchedStable(slice,
					clipOffset, extendByPixels, true);
			drawPieceFallingToCanvasWithSlice_helperClipTouchedVolatile(slice,
					clipOffset, extendByPixels);
		} else if (stateChanged) {
			// Stable regions are OK; regen VOLATILE coverage and
			// touchage.
			drawPieceFallingToCanvasWithSlice_helperClipCoveredVolatile(slice,
					clipOffset);
			drawPieceFallingToCanvasWithSlice_helperClipTouchedVolatile(slice,
					clipOffset, extendByPixels);
		} else if (pieceChanged) {
			// Also clip coverage and touches for the volatile blocks
			// (they have changed also).
			drawPieceFallingToCanvasWithSlice_helperClipCoveredVolatile(slice,
					clipOffset);
			drawPieceFallingToCanvasWithSlice_helperClipTouchedVolatile(slice,
					clipOffset, extendByPixels);
		}

		// //////////////////////////////////////////////////////////////////////
		// VEIL INSTRUCTIONS: If we're veiled, we possibly skip this entire
		// section
		// UNLESS this is our first attempt or something in the slice has
		// changed.
		// The setup below (among other effects) sets mLastBitmap[BITMAP_FULL]
		// to
		// the on-screen representation of the blockField, including ghost
		// piece(s).

		if (!this.willDrawVeilPixels(sliceTime) || !mLastBitmapVeiled
				|| fieldChanged || stateChanged || pieceChanged) {
			// If using BLIT_FULL, we set offsets to match the mLast, clip
			// according
			// to changes, draw to mLastBitmap and finally blit to the canvas.
			// If
			// using BLIT_NONE, we set offset to match the canvas, clip UNION
			// the
			// pulses (assuming an appropriate clip is already in place), and
			// draw
			// directly to the canvas.
			switch (mDrawSettings.getBlit()) {
			case DrawSettings.BLIT_SEPTUPLE:
				// set offsets
				if (fieldChanged || alignmentOffsetSet || stateChanged) {
					setAlignmentOffset(slice.getBlockfieldStable(),
							alignmentOffset);
					canvasAlignmentOffset.takeVals(alignmentOffset);

					alignmentOffsetSet = false;
				}
				canvasTranslationOffset.x = 0;
				canvasTranslationOffset.y = 0;

				// clip
				tick(); // nest 1
                reset(mLastBitmapClipPath);
				if (fieldChanged || mLastBitmapVeiled) {
                    // log("drawPiece... fieldChanged") ;
					// We need to draw-clip EVERYTHING, both stable and
					// volatile.
					for (int i = 0; i < mLastBitmap.length; i++) {
					    unionRect(mLastBitmapClipPath[i], 0, 0,
                                mLastBitmapBounds[i].width(),
                                mLastBitmapBounds[i].height(),
                                Path.Direction.CW);
                    }
				} else if (stateChanged) {
				    // we want from stable to this. We wish to redraw all
					// VOLATILE layers from scratch.
					// However, we note that the STABLE layer remains unchanged.
					// TODO: clip only the content in BITMAP_FULL?
					unionRect(mLastBitmapClipPath[BITMAP_FULL], 0, 0,
							mLastBitmapBounds[BITMAP_FULL].width(),
							mLastBitmapBounds[BITMAP_FULL].height(),
                            Path.Direction.CW);
					unionRect(mLastBitmapClipPath[BITMAP_SEPTUPLE_Q0_VOLATILE], 0, 0, 
                            mLastBitmapBounds[BITMAP_SEPTUPLE_Q0_VOLATILE].width(),
							mLastBitmapBounds[BITMAP_SEPTUPLE_Q0_VOLATILE].height(),
                            Path.Direction.CW);
					unionRect(mLastBitmapClipPath[BITMAP_SEPTUPLE_Q1_VOLATILE], 0,0, 
                            mLastBitmapBounds[BITMAP_SEPTUPLE_Q1_VOLATILE].width(),
							mLastBitmapBounds[BITMAP_SEPTUPLE_Q1_VOLATILE].height(),
                            Path.Direction.CW);
					unionRect(mLastBitmapClipPath[BITMAP_SEPTUPLE_3D_VOLATILE], 0,0,
                            mLastBitmapBounds[BITMAP_SEPTUPLE_3D_VOLATILE].width(),
							mLastBitmapBounds[BITMAP_SEPTUPLE_3D_VOLATILE].height(),
                            Path.Direction.CW);
				} else if (pieceChanged) {
					// log("drawPiece... pieceChanged") ;
					// the stable field are completely unchanged, but the piece
					// altered. Clip
					// to redraw the piece and its ghosts.
					for (int qp = 0; qp < 3; qp++) {
						int qPane, BMAP;
						if (qp == 0) {
							qPane = Consts.QPANE_0;
							BMAP = BITMAP_SEPTUPLE_Q0_VOLATILE;
						} else if (qp == 1) {
							qPane = Consts.QPANE_1;
							BMAP = BITMAP_SEPTUPLE_Q1_VOLATILE;
						} else {
							qPane = Consts.QPANE_3D;
							BMAP = BITMAP_SEPTUPLE_3D_VOLATILE;
						}
						reset(clipPath);
						this.clipConservativeDifference(clipPath,
								mLastSlice.getPieceFallingPiece(),
								slice.getPieceFallingPiece(), qPane, 0,
								alignmentOffset, extendByPixels);
						op(mLastBitmapClipPath[BITMAP_FULL], clipPath, Path.Op.UNION);
						op(mLastBitmapClipPath[BMAP], clipPath, Path.Op.UNION);
                        int numGhosts = Math.max(slice.getNumPieceGhosts(),
                                mLastSlice.getNumPieceGhosts());
						for (int i = 0; i < numGhosts; i++) {
							// Note: using a "reserve piece" will sometimes activate pieceChanged
							// but not fieldChanged. That reserve piece may have a different number
							// of ghosts.
							reset(clipPath);
							if (i < mLastSlice.getNumPieceGhosts()
									&& i < slice.getNumPieceGhosts())
								this.clipConservativeDifference(
										clipPath,
										slice.getPieceFallingGhosts()[i + slice.getFirstPieceGhosts()],
										mLastSlice.getPieceFallingGhosts()[i + mLastSlice.getFirstPieceGhosts()],
										qPane, 0, alignmentOffset, 0);
							else if (i < slice.getNumPieceGhosts())
								this.clipContentUnion(
										clipPath,
										slice.getPieceFallingGhosts()[i + slice.getFirstPieceGhosts()],
										qPane, 0, alignmentOffset, 0);
							else if (i < mLastSlice.getNumPieceGhosts())
								this.clipContentUnion(
										clipPath,
										mLastSlice.getPieceFallingGhosts()[i + mLastSlice.getFirstPieceGhosts()],
										qPane, 0, alignmentOffset, 0);

							op(mLastBitmapClipPath[BMAP], clipPath, Path.Op.UNION);
							op(mLastBitmapClipPath[BITMAP_FULL], clipPath, Path.Op.UNION);
						}
					}
				}

				// Clip "pulse" behavior pieces and stable blocks.
				boolean pulseChangedQ0Stable = false;
				boolean pulseChangedQ1Stable = false;
				boolean pulseChanged3DStable = false;
				boolean pulseChangedQ0Volatile = false;
				boolean pulseChangedQ1Volatile = false;
				boolean pulseChanged3DVolatile = false;

				if (animationSettings != null) {
					for (int qp = 0; qp < 3; qp++) {
						int qPane, BITMAP_STABLE, BITMAP_VOLATILE;
						if (qp == 0) {
							qPane = Consts.QPANE_0;
							BITMAP_STABLE = BITMAP_SEPTUPLE_Q0_STABLE;
							BITMAP_VOLATILE = BITMAP_SEPTUPLE_Q0_VOLATILE;
						} else if (qp == 1) {
							qPane = Consts.QPANE_1;
							BITMAP_STABLE = BITMAP_SEPTUPLE_Q1_STABLE;
							BITMAP_VOLATILE = BITMAP_SEPTUPLE_Q1_VOLATILE;
						} else {
							qPane = Consts.QPANE_3D;
							BITMAP_STABLE = BITMAP_SEPTUPLE_3D_STABLE;
							BITMAP_VOLATILE = BITMAP_SEPTUPLE_3D_VOLATILE;
						}

						reset(clipPath);
						boolean changed = clipPulseFill(clipPath,
								slice.getPieceFallingBlockfield(), qPane, 0,
								alignmentOffset);
						if (qp == 0)
							pulseChangedQ0Stable = changed;
						else if (qp == 1)
							pulseChangedQ1Stable = changed;
						else
							pulseChanged3DStable = changed;

						op(mLastBitmapClipPath[BITMAP_STABLE], clipPath, Path.Op.UNION);
						op(mLastBitmapClipPath[BITMAP_FULL], clipPath, Path.Op.UNION);

						reset(clipPath);
						changed = clipPulseFill(clipPath,
								slice.getPieceFallingPiece(), qPane, 0,
								alignmentOffset);
						if (qp == 0)
							pulseChangedQ0Volatile = changed;
						else if (qp == 1)
							pulseChangedQ1Volatile = changed;
						else
							pulseChanged3DVolatile = changed;

						op(mLastBitmapClipPath[BITMAP_VOLATILE], clipPath, Path.Op.UNION);
						op(mLastBitmapClipPath[BITMAP_FULL], clipPath, Path.Op.UNION);
					}
				}

				// clip glows
				int numGlows = mLastEffectsGlow.size() ;
				for (int i = 0; i < numGlows; i++) {
					GlowEffect glowEffect = mLastEffectsGlow.get(i);
					// clip this glow IF 1: it is a lock glow, 2: it has
					// started,
					// and 3: it has not been playing for long enough to fade.
					if (glowEffect.active(sliceTime)
							|| glowEffect.active(mLastSliceTime)) {
						this.clipGlowEffect(mLastBitmapClipPath[BITMAP_FULL],
								glowEffect, 0, alignmentOffset);
					}
				}
				// FadeEffects
				if (mDrawSettings.drawEffects == DrawSettings.DRAW_EFFECTS_THROUGH_SLICE
						&& mLastEffectsFade != null) {
					int numFades = mLastEffectsFade.size() ;
					for (int i = 0; i < numFades; i++) {
						FadeEffect fadeEffect = mLastEffectsFade.get(i);
						if (fadeEffect.active(sliceTime) || fadeEffect.active(mLastSliceTime)) {
							switch (fadeEffect.type()) {
							case FadeEffect.TYPE_BOX:
								// drawn in 3D layer.
								boolean haveClip = clipPulseFill(
										clipPath,
										fadeEffect.directQOrientationsAccess(),
										Consts.QPANE_3D, 0, alignmentOffset);
								if (haveClip) {
									op(mLastBitmapClipPath[BITMAP_SEPTUPLE_3D_STABLE], clipPath, Path.Op.UNION);
									op(mLastBitmapClipPath[BITMAP_FULL], clipPath, Path.Op.UNION);
									pulseChanged3DStable = pulseChanged3DStable || haveClip;
								}
								break;
							}
						}
					}
				}

				// draw the entire full bitmap if the background is changing or custom
                if ((configCanvas != null && configCanvas.background != null)
                        || backgroundLayerChanged(mLastSliceTime, sliceTime)) {
                    reset(mLastBitmapClipPath[BITMAP_FULL]);
                    unionRect(mLastBitmapClipPath[BITMAP_FULL], 0, 0,
                            mLastBitmap[BITMAP_FULL].getWidth(),
                            mLastBitmap[BITMAP_FULL].getHeight(),
                            Path.Direction.CW);
                }

				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_CLIP] += tock();
				// \nest 1

                // All draw and blit operations performed under this clip; restored after blitting
                for (int i = 0; i < mLastBitmapCanvas.length; i++) {
                    mLastBitmapCanvas[i].save();
                    mLastBitmapCanvas[i].clipPath(mLastBitmapClipPath[i]);
                }

				// draw
				tick(); // nest 1
				if (pulseChangedQ0Stable || fieldChanged || mLastBitmapVeiled)
					this.drawPieceFallingToCanvasWithSlice_helperDrawStableField(
							mDrawSettings, Consts.QPANE_0,
							mLastBitmapCanvas[BITMAP_SEPTUPLE_Q0_STABLE],
							alignmentOffset, slice, sliceTime, null, true);
				if (pulseChangedQ1Stable || fieldChanged || mLastBitmapVeiled)
					this.drawPieceFallingToCanvasWithSlice_helperDrawStableField(
							mDrawSettings, Consts.QPANE_1,
							mLastBitmapCanvas[BITMAP_SEPTUPLE_Q1_STABLE],
							alignmentOffset, slice, sliceTime, null, true);
				if (pulseChanged3DStable || fieldChanged || mLastBitmapVeiled)
					this.drawPieceFallingToCanvasWithSlice_helperDrawStableField(
							mDrawSettings, Consts.QPANE_3D,
							mLastBitmapCanvas[BITMAP_SEPTUPLE_3D_STABLE],
							alignmentOffset, slice, sliceTime, null, true);
				if (pulseChangedQ0Volatile || pieceChanged || fieldChanged
						|| stateChanged || mLastBitmapVeiled)
					this.drawPieceFallingToCanvasWithSlice_helperDrawPiece(
							mDrawSettings, Consts.QPANE_0,
							mLastBitmapCanvas[BITMAP_SEPTUPLE_Q0_VOLATILE],
							alignmentOffset, slice, sliceTime, null);
				if (pulseChangedQ1Volatile || pieceChanged || fieldChanged
						|| stateChanged || mLastBitmapVeiled)
					this.drawPieceFallingToCanvasWithSlice_helperDrawPiece(
							mDrawSettings, Consts.QPANE_1,
							mLastBitmapCanvas[BITMAP_SEPTUPLE_Q1_VOLATILE],
							alignmentOffset, slice, sliceTime, null);
				if (pulseChanged3DVolatile || pieceChanged || fieldChanged
						|| stateChanged || mLastBitmapVeiled)
					this.drawPieceFallingToCanvasWithSlice_helperDrawPiece(
							mDrawSettings, Consts.QPANE_3D,
							mLastBitmapCanvas[BITMAP_SEPTUPLE_3D_VOLATILE],
							alignmentOffset, slice, sliceTime, null);
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW] += tock();
				// \nest 1
				
				

				// blit
				tick();

				// canvas translation offset?
				setCanvasDestinationRect(
						mLastBitmapBlitRect[BITMAP_FULL],
						mLastBitmapBounds[BITMAP_FULL],
						mDrawSettings.configCanvas.region,
						-((int) Math.round(slice.getDisplacement()
								* mDrawSettings.size_blockHeight))
							+ mDrawSettings.displacementSafeMarginOffsetBlit);
				
				for (int i = 0; i < 7; i++) {
					if (i != BITMAP_FULL) {
                        mLastBitmapBlitRect[i].set(0, 0,
                                mLastBitmapBounds[i].width(),
                                mLastBitmapBounds[i].height());
                    }
					// align with 0, 0 in FULL. Some of these layers are taller
					// than FULL.
				}
				// Draw the background. This call obeys background behavior,
				// including leaving transparent pixels for BLIT behavior.
				septupleBlitDrawBackground(sliceTime, configCanvas);
				// Septuple Blit!
				septupleBlit(alignmentOffset, slice.getPieceType(), sliceTime);

                // now done with internal bitmap clips; restore
                for (int i = 0; i < mLastBitmapCanvas.length; i++) {
                    mLastBitmapCanvas[i].restore();
                }

				// blit to the main canvas
				if (configCanvas == null || configCanvas.equals(mDrawSettings.configCanvas)) {
					canvas.save();

					if (mDrawSettings.configCanvas.clipRegion != null) {
                        canvas.clipRect(mDrawSettings.configCanvas.clipRegion, Region.Op.INTERSECT);
                    }

					if (mDrawSettings.getBehaviorIs_backgroundBlit()) {
						drawLayeredBackgroundAssets(canvas,
								mDrawSettings.configCanvas.region, sliceTime,
								mDrawSettings.configCanvas.background);
					}

					canvas.drawBitmap(mLastBitmap[BITMAP_FULL],
							mLastBitmapBounds[BITMAP_FULL],
							mLastBitmapBlitRect[BITMAP_FULL], null);
					canvas.restore();
				} else {
					tempSrcRect.set(mLastBitmapBounds[BITMAP_FULL]);
					tempSrcRect.bottom = tempSrcRect.top + mDrawSettings.height;
					drawBitmapToCanvasWithConfig(canvas,
							mLastBitmap[BITMAP_FULL], tempSrcRect, slice,
							configCanvas, null);
				}

				// timer
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_BLIT] += tock();

				// that's it
				break;

			case DrawSettings.BLIT_FULL:
				// Set offsets
				canvasTranslationOffset.x = 0;
				canvasTranslationOffset.y = 0;
				if (fieldChanged || pieceChanged || stateChanged
						|| alignmentOffsetSet) {
					setAlignmentOffset(slice.getBlockfieldStable(),
							alignmentOffset);
					if (doubleBitmapOffset)
						alignmentOffset.y += height;
					alignmentOffsetSet = false;
				}

				// clip
				tick(); // nest 1
                reset(mLastBitmapClipPath[BITMAP_FULL]);
				if (fieldChanged
						|| mBackgroundBitmapClipOrBlitIsBlitting
						|| mLastBitmapVeiled
						|| configCanvas != null
						|| (backgroundChanged && !mDrawSettings
								.getBehaviorIs_backgroundBlit())) {
					// HACK HACK HACK:
					// This call is necessary because we haven't implemented an
					// "efficient" version for other
					// draw methods yet. Note that piece borders can very easily
					// change without the actual
					// value at a location changing.
					if (doubleBitmapOffset) {
						unionRect(mLastBitmapClipPath[BITMAP_FULL], 0, height,
								mLastBitmapBounds[BITMAP_FULL].width(),
								height * 2, Path.Direction.CW);
					} else {
						log("draw piece falling : clip with extra margin below") ;
						// clip with extra space below, so we have room to draw
						// displacement rows.
						float extra = mDrawSettings.getBehaviorIs_displacement()
								? mDrawSettings.size_blockHeight * 3
								: 0 ;
                        unionRect(mLastBitmapClipPath[BITMAP_FULL], 0, 0,
                                mLastBitmapBounds[BITMAP_FULL].width(),
                                mLastBitmapBounds[BITMAP_FULL].height() + extra,
                                Path.Direction.CW);
					}
				} else if (stateChanged) {

					// we went from stable to this. Clip the piece and ghost(s),
					// clip conservative
					// difference for the blockfield (vs stable).
					this.clipConservativeDifference(
							mLastBitmapClipPath[BITMAP_FULL],
							mLastSlice.getBlockfieldStable(),
							slice.getPieceFallingBlockfield(), 0,
							alignmentOffset, extendByPixels);
					this.clipContentUnion(mLastBitmapClipPath[BITMAP_FULL],
							slice.getPieceFallingPiece(), alignmentOffset,
							extendByPixels);
					for (int i = 0; i < slice.getNumPieceGhosts(); i++) {
						this.clipContentUnion(
								mLastBitmapClipPath[BITMAP_FULL],
								slice.getPieceFallingGhosts()[i
										+ slice.getFirstPieceGhosts()],
								alignmentOffset, extendByPixels);
					}
				} else if (pieceChanged) {
					this.clipConservativeDifference(
							mLastBitmapClipPath[BITMAP_FULL],
							mLastSlice.getPieceFallingPiece(),
							slice.getPieceFallingPiece(), 0, alignmentOffset,
							extendByPixels);
					int numGhosts = Math.max(slice.getNumPieceGhosts(),
							mLastSlice.getNumPieceGhosts());
					for (int i = 0; i < numGhosts; i++) {
						// Note: using a "reserve piece" will sometimes activate
						// pieceChanged
						// but not fieldChanged. That reserve piece may have a
						// different number
						// of ghosts.
						if (i < mLastSlice.getNumPieceGhosts()
								&& i < slice.getNumPieceGhosts())
							this.clipConservativeDifference(
									mLastBitmapClipPath[BITMAP_FULL],
									slice.getPieceFallingGhosts()[i
											+ slice.getFirstPieceGhosts()],
									mLastSlice.getPieceFallingGhosts()[i
											+ mLastSlice.getFirstPieceGhosts()],
									0, alignmentOffset, 0);
						else if (i < slice.getNumPieceGhosts())
							this.clipContentUnion(
									mLastBitmapClipPath[BITMAP_FULL],
									slice.getPieceFallingGhosts()[i
											+ slice.getFirstPieceGhosts()],
									alignmentOffset, 0);
						else if (i < mLastSlice.getNumPieceGhosts())
							this.clipContentUnion(
									mLastBitmapClipPath[BITMAP_FULL],
									mLastSlice.getPieceFallingGhosts()[i
											+ mLastSlice.getFirstPieceGhosts()],
									alignmentOffset, 0);
					}
				}

				// Clip "pulse" behavior pieces.
				boolean pulseChanged = false;
				if (animationSettings != null) {
					pulseChanged = clipPulseFill(
							mLastBitmapClipPath[BITMAP_FULL],
							slice.getPieceFallingBlockfield(), 0,
							alignmentOffset)
							|| pulseChanged;
					pulseChanged = clipPulseFill(
							mLastBitmapClipPath[BITMAP_FULL],
							slice.getPieceFallingPiece(), 0, alignmentOffset)
							|| pulseChanged;
				}

				// Clip glows - if any are left over from previous slices.
				boolean haveGlows = false;
				if (mDrawSettings.drawEffects == DrawSettings.DRAW_EFFECTS_THROUGH_SLICE
						&& mLastEffectsGlow != null) {
					numGlows = mLastEffectsGlow.size() ;
					for (int i = 0; i < numGlows; i++) {
						GlowEffect glowEffect = mLastEffectsGlow.get(i);
						if (glowEffect.active(sliceTime)
								|| glowEffect.active(mLastSliceTime)) {
							haveGlows = true;
							clipGlowEffect(mLastBitmapClipPath[BITMAP_FULL],
									glowEffect, 0, alignmentOffset);
						}
					}
				}
				// FadeEffects
				if (mDrawSettings.drawEffects == DrawSettings.DRAW_EFFECTS_THROUGH_SLICE
						&& mLastEffectsFade != null) {
					int numFades = mLastEffectsFade.size() ;
					for (int i = 0; i < numFades; i++) {
						FadeEffect fadeEffect = mLastEffectsFade.get(i);
						if (fadeEffect.active(sliceTime)
								|| fadeEffect.active(mLastSliceTime)) {
							switch (fadeEffect.type()) {
							case FadeEffect.TYPE_BOX:
								// drawn in 3D layer.
								boolean haveClip = clipPulseFill(
										mLastBitmapClipPath[BITMAP_FULL],
										fadeEffect.directQOrientationsAccess(),
										Consts.QPANE_3D, 0, alignmentOffset);
								pulseChanged = pulseChanged || haveClip;
								break;
							}
						}
					}
				}

				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_CLIP] += tock();
				// \nest 1

				if (GlobalTestSettings.BLOCK_DRAWER_SHOW_COVERED_AND_TOUCHING_REGIONS) {
				    reset(mLastBitmapClipPath[BITMAP_FULL]);
                    unionRect(mLastBitmapClipPath[BITMAP_FULL], 0, 0,
                            Integer.MAX_VALUE, Integer.MAX_VALUE,
                            Path.Direction.CW);
                }

				// draw
				tick(); // nest 1
                mLastBitmapCanvas[BITMAP_FULL].save();
                mLastBitmapCanvas[BITMAP_FULL].clipPath(mLastBitmapClipPath[BITMAP_FULL]);
				// We have set canvasTranslationOffset and our shadow and
				// corners sets;
				// that's all we need for this call.
				if (pulseChanged
						|| pieceChanged
						|| fieldChanged
						|| (backgroundChanged && !mDrawSettings
								.getBehaviorIs_backgroundBlit())
						|| stateChanged
						|| mLastBitmapVeiled
						|| haveGlows
						|| configCanvas != null
						|| GlobalTestSettings.BLOCK_DRAWER_SHOW_COVERED_AND_TOUCHING_REGIONS) {

					BlockDrawerConfigCanvas.Background backgroundDefault = mDrawSettings
							.getBehaviorIs_backgroundBlit() ? BlockDrawerConfigCanvas.Background.CLEAR
							: BlockDrawerConfigCanvas.Background.DEFAULT;

					drawPieceFallingToCanvas_withSlice(mDrawSettings,
							mLastBitmapCanvas[BITMAP_FULL], alignmentOffset,
							slice, sliceTime, mBackgroundBitmapOffset,
							configCanvas != null ? configCanvas.background
									: backgroundDefault, 0, true);
				}
                if (GlobalTestSettings.BLOCK_DRAWER_SHOW_COVERED_AND_TOUCHING_REGIONS) {
                    drawTouchedCoveredTestToCanvas(mLastBitmapCanvas[BITMAP_FULL]);
                }
                mLastBitmapCanvas[BITMAP_FULL].restore();
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW] += tock();
				// \nest 1


				// blit
				tick(); // nest 1
				if (mDrawSettings.getBehaviorIs_displacement()) {
					setCanvasDestinationRect(
							mLastBitmapBlitRect[BITMAP_FULL],
							mLastBitmapBounds[BITMAP_FULL],
							mDrawSettings.configCanvas.region,
							-((int) Math.round(slice.getDisplacement()
									* mDrawSettings.size_blockHeight))
								+ mDrawSettings.displacementSafeMarginOffsetBlit);
				} else {
					mLastBitmapBlitRect[BITMAP_FULL].set(
							mDrawSettings.configCanvas.region.left,
							mDrawSettings.configCanvas.region.top
									- (doubleBitmapOffset ? blitHeight : 0),
							mDrawSettings.configCanvas.region.right,
							mDrawSettings.configCanvas.region.top + blitHeight);
				}

				if (configCanvas == null
						|| configCanvas.equals(mDrawSettings.configCanvas)) {
					canvas.save();
					if (mDrawSettings.configCanvas.clipRegion != null)
						canvas.clipRect(mDrawSettings.configCanvas.clipRegion,
								Region.Op.INTERSECT);

					if (mDrawSettings.getBehaviorIs_backgroundBlit()) {
						drawLayeredBackgroundAssets(canvas,
								mDrawSettings.configCanvas.region, sliceTime,
								mDrawSettings.configCanvas.background);
					}

					canvas.drawBitmap(mLastBitmap[BITMAP_FULL],
							mLastBitmapBounds[BITMAP_FULL],
							mLastBitmapBlitRect[BITMAP_FULL], blitPaint);
					canvas.restore();
				} else {
					// our content is available in mLastBitmap. However,
					// depending on
					// our background settings and config canvas settings, this
					// might fail.
					// throw an exception so we know this is unacceptable.
					tempSrcRect.set(mLastBitmapBounds[BITMAP_FULL]);
					tempSrcRect.bottom = tempSrcRect.top + height;
					if (doubleBitmapOffset)
						tempSrcRect.offset(0, height);
					drawBitmapToCanvasWithConfig(canvas,
							mLastBitmap[BITMAP_FULL], tempSrcRect, slice,
							configCanvas, blitPaint);
				}
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_BLIT] += tock();
				// \nest 1

				// done
				break;

			case DrawSettings.BLIT_NONE:
				// set offsets according to true canvas.
				setCanvasTranslationOffset(canvas);
				setAlignmentOffset(slice.getBlockfieldStable(), alignmentOffset);
				int displacement = 0;
				if (mDrawSettings.getBehaviorIs_displacement()) {
					displacement = -((int) Math.round(slice.getDisplacement()
							* mDrawSettings.size_blockHeight));
					alignmentOffset.y += displacement;
				}

				alignmentOffsetSet = true;

				// for now, we assume we don't actually need to
				// clip anything, and we'll be re-drawing the whole shebang.

				// draw
				tick(); // nest 1
				// We have set canvasTranslationOffset and our shadow and
				// corners sets;
				// that's all we need for this call.
				canvas.save();
				if (mDrawSettings.configCanvas.clipRegion != null)
					canvas.clipRect(mDrawSettings.configCanvas.clipRegion,
							Region.Op.INTERSECT);
				drawPieceFallingToCanvas_withSlice(mDrawSettings, canvas,
						alignmentOffset, slice, sliceTime,
						mBackgroundBitmapOffset,
						BlockDrawerConfigCanvas.Background.DEFAULT,
						displacement, true);
				canvas.restore();
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW] += tock();
				// \nest 1

				if (GlobalTestSettings.BLOCK_DRAWER_SHOW_COVERED_AND_TOUCHING_REGIONS)
					drawTouchedCoveredTestToCanvas(canvas);

				// no blitting; we done
				break;

			default:
				throw new IllegalStateException("Blit setting "
						+ mDrawSettings.getBlit() + " confuses and infuriates us");
			}

			mLastBitmapVeiled = false;
		}

		if (veilOnScreen(sliceTime)
				&& (configCanvas == null || configCanvas
						.equals(mDrawSettings.configCanvas))) {
			drawBitmapFullVeiledToCanvas(canvas, sliceTime, stateChanged
					|| fieldChanged || pieceChanged || !mLastBitmapVeiled);
			// only force a redraw if content changed, otherwise use our cached
			// veil.
			mLastBitmapVeiled = true;
		}

		// We have drawn to mLastBitmap. Copy the slice and blit.
		if (fieldChanged || pieceChanged)
			mLastSlice.takeVals(slice);
		mLastBitmapIsStableSlice = false;		// never stable -- we draw a ghost, and a disconnected piece.
		mLastBitmapIsStableSliceIgnoringEffects = false;
		mLastBitmapIsStableSliceReadyToAdvanceEffects = false;
		mNextSliceNeedsExplicitConfigCanvas = false;
		mNextSliceBreaksSequence = false;
		mNextSlicePossiblyInconsistent = false;

		mBackgroundBitmapClipOrBlitIsBlitting = false; // having drawn this, we
														// prefer clipping.

		mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_TOTAL] += tock();
		mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_NUMBER]++;
		// \nest 0

		// SOUNDS! Play sounds according to what happened.
		playSounds(sliceTime, pool);

		sliceTime.setLastDrawn();
		clearExpiredEffects(sliceTime);

		if (mLastSliceTime != null && sliceTime != null)
			mLastSliceTime.takeVals(sliceTime);
	}

	private void drawPieceFallingToCanvasWithSlice_helperClipCoveredStable(
			GameBlocksSlice slice, Offset offset) {

		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_Q0_STABLE]);
		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_3D_STABLE]);
		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_Q1_STABLE]);

		clipCoveredPath(mLastBitmapCoveredPath[BITMAP_REGION_Q0_STABLE],
				slice.getPieceFallingBlockfield(), Consts.QPANE_0, 0, offset);
		// nothing for 3D.
		clipCoveredPath(mLastBitmapCoveredPath[BITMAP_REGION_Q1_STABLE],
				slice.getPieceFallingBlockfield(), Consts.QPANE_1, 0, offset);
	}

	private void drawPieceFallingToCanvasWithSlice_helperClipCoveredVolatile(
			GameBlocksSlice slice, Offset offset) {

		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_Q0_VOLATILE]);
		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_3D_VOLATILE]);
		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_Q1_VOLATILE]);

		clipCoveredPath(mLastBitmapCoveredPath[BITMAP_REGION_Q0_VOLATILE],
				slice.getPieceFallingPiece(), Consts.QPANE_0, 0, offset);
		// nothing for 3d
		clipCoveredPath(mLastBitmapCoveredPath[BITMAP_REGION_Q1_VOLATILE],
				slice.getPieceFallingPiece(), Consts.QPANE_1, 0, offset);

	}

	private void drawPieceFallingToCanvasWithSlice_helperClipTouchedStable(
			GameBlocksSlice slice, Offset offset, int extendByPixels,
			boolean includeDisplacementRowsIfAvailable) {

		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q0_STABLE]);
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_3D_STABLE]);
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q1_STABLE]);

		clipTouchedPath(mLastBitmapTouchedPath[BITMAP_REGION_Q0_STABLE],
				slice.getPieceFallingBlockfield(), mConfigRangeStandard,
				Consts.QPANE_0, offset, extendByPixels);
		clipTouchedPath(mLastBitmapTouchedPath[BITMAP_REGION_Q1_STABLE],
				slice.getPieceFallingBlockfield(), mConfigRangeStandard,
				Consts.QPANE_1, offset, extendByPixels);
		clipTouchedPath(mLastBitmapTouchedPath[BITMAP_REGION_3D_STABLE],
				slice.getPieceFallingBlockfield(), mConfigRangeStandard,
				Consts.QPANE_3D, offset, extendByPixels);

		// clip row negative 1
		clipFullWidthRowNegativeOne(
				mLastBitmapTouchedPath[BITMAP_REGION_Q0_STABLE], 0,
				mDrawSettings.width, Consts.QPANE_0, offset, extendByPixels);
		clipFullWidthRowNegativeOne(
				mLastBitmapTouchedPath[BITMAP_REGION_Q1_STABLE], 0,
				mDrawSettings.width, Consts.QPANE_1, offset, extendByPixels);

		if (includeDisplacementRowsIfAvailable
				&& mDrawSettings.getBehaviorIs_displacement()) {
			clipDisplacementOffset.takeVals(offset);
			clipDisplacementOffset.offsetXY(0, mDrawSettings.ROWS
					* mDrawSettings.size_blockHeight);

			clipTouchedPath(
					mLastBitmapTouchedPath[BITMAP_REGION_Q0_STABLE],
					slice.getDisplacementBlockfield(), mConfigRangeDisplaced,
					Consts.QPANE_0, clipDisplacementOffset, extendByPixels);
			clipTouchedPath(
					mLastBitmapTouchedPath[BITMAP_REGION_Q1_STABLE],
					slice.getDisplacementBlockfield(), mConfigRangeDisplaced,
					Consts.QPANE_1, clipDisplacementOffset, extendByPixels);
			clipTouchedPath(
					mLastBitmapTouchedPath[BITMAP_REGION_3D_STABLE],
					slice.getDisplacementBlockfield(), mConfigRangeDisplaced,
					Consts.QPANE_3D, clipDisplacementOffset, extendByPixels);
		}
	}

	private void drawPieceFallingToCanvasWithSlice_helperClipTouchedVolatile(
			GameBlocksSlice slice, Offset offset, int extendByPixels) {

		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q0_VOLATILE]);
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_3D_VOLATILE]);
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q1_VOLATILE]);

		BlockDrawerConfigRange configRange = tempConfigRange;
		configRange.set(mConfigRangeStandard);

		clipTouchedPath(mLastBitmapTouchedPath[BITMAP_REGION_Q0_VOLATILE],
				slice.getPieceFallingPiece(), configRange, Consts.QPANE_0,
				offset, extendByPixels);
		clipTouchedPath(mLastBitmapTouchedPath[BITMAP_REGION_Q1_VOLATILE],
				slice.getPieceFallingPiece(), configRange, Consts.QPANE_1,
				offset, extendByPixels);
		clipTouchedPath(mLastBitmapTouchedPath[BITMAP_REGION_3D_VOLATILE],
				slice.getPieceFallingPiece(), configRange, Consts.QPANE_3D,
				offset, extendByPixels);
		int numGhosts = slice.getNumPieceGhosts();
		for (int i = 0; i < numGhosts; i++) {
			clipTouchedPath(
					mLastBitmapTouchedPath[BITMAP_REGION_Q0_VOLATILE],
					slice.getPieceFallingGhosts()[i
							+ slice.getFirstPieceGhosts()], configRange,
					Consts.QPANE_0, offset, 0);
			clipTouchedPath(
					mLastBitmapTouchedPath[BITMAP_REGION_Q1_VOLATILE],
					slice.getPieceFallingGhosts()[i
							+ slice.getFirstPieceGhosts()], configRange,
					Consts.QPANE_1, offset, 0);
			clipTouchedPath(
					mLastBitmapTouchedPath[BITMAP_REGION_3D_VOLATILE],
					slice.getPieceFallingGhosts()[i
							+ slice.getFirstPieceGhosts()], configRange,
					Consts.QPANE_3D, offset, 0);
		}
	}

	private void drawPieceFallingToCanvas_withSlice(DrawSettings drawSettings,
			Canvas canvas, Offset offset, GameBlocksSlice slice,
			BlockDrawerSliceTime sliceTime, Offset offsetBackground,
			BlockDrawerConfigCanvas.Background configCanvasBackground,
			int blockCoveredYOffset, boolean includeDisplacementRowsIfAvailable) {

		drawPieceFallingToCanvas_withSlice(drawSettings, Consts.QPANE_ALL,
				canvas, offset, slice, sliceTime, offsetBackground,
				configCanvasBackground, blockCoveredYOffset,
				includeDisplacementRowsIfAvailable);
	}

	/**
	 * Primarily intended as a helper for drawPieceFallingWithLastSlice. Provide
	 * a canvas, a draw offset, a GameBlocksSlice to draw and the current time
	 * (for pulses).
	 * 
	 * PRECONDITIONS: The provided canvas has been clipped appropriately. When
	 * drawing efficiently (i.e. to mLastBitmapCanvas, this clip should cover
	 * only those blocks which have changed; when drawing directly to the
	 * OS-provided canvas, a clip has likely already been applied; redraw
	 * everything.
	 * 
	 * 'canvasTransation' has been set in advance, according to whether the
	 * provided canvas includes any transation.
	 * 
	 * mLastCorners_ and mLastInnerShadowSets have been configured.
	 * 
	 * POSTCONDITIONS: The falling piece slice has been drawn to the canvas.
	 */
	private void drawPieceFallingToCanvas_withSlice(DrawSettings drawSettings,
			int qPane, Canvas canvas, Offset offset, GameBlocksSlice slice,
			BlockDrawerSliceTime sliceTime, Offset offsetBackground,
			BlockDrawerConfigCanvas.Background configCanvasBackground,
			int blockCoveredYOffset, boolean includeDisplacementRowsIfAvailable) {

		BlockDrawerConfigRange configRange = tempConfigRange;
		configRange.set(drawSettings.displayedRows, drawSettings.COLS);

		// draw background
		// draw background: happens in 2 different steps. If we draw 'all,' we
		// fill
		// now. Otherwise, if BLOCK_FILL, we draw twice - first to set the
		// background
		// color, second to draw the fills themselves.
		// canvas.drawColor(Color.BLACK);
		fullBlitDrawBackground(drawSettings, canvas, offsetBackground,
				sliceTime, configCanvasBackground, 255, 255,
				blockCoveredYOffset);

		long currentTime = sliceTime.getUnpaused();

		float alphaScale_lockedFillPulse = animationSettings == null ? 0
				: animationSettings.pulseAlpha(
						drawSettings.alphaScale_lockedFillPulse, currentTime);
		float alphaScale_pieceFillPulse = animationSettings == null ? 0
				: animationSettings.pulseAlpha(
						drawSettings.alphaScale_pieceFillPulse, currentTime);
		float alphaScale_lockedBoxPulse = animationSettings == null ? 0
				: animationSettings.pulseAlpha(
						drawSettings.alphaScale_lockedBoxPulse, currentTime);
		float alphaScale_pieceBoxPulse = animationSettings == null ? 0
				: animationSettings.pulseAlpha(
						drawSettings.alphaScale_pieceBoxPulse, currentTime);

		float ghostAlphaMult = (float) drawSettings.alpha_ghostFill
				/ (float) drawSettings.alpha_lockedFill;
		if (ghostAlphaMult == Float.POSITIVE_INFINITY)
			ghostAlphaMult = 1.0f;

		boolean drawQ0 = qPane == Consts.QPANE_ALL || qPane == Consts.QPANE_0;
		boolean drawQ1 = qPane == Consts.QPANE_ALL || qPane == Consts.QPANE_1;
		boolean draw3D = qPane == Consts.QPANE_ALL || qPane == Consts.QPANE_3D;

		byte[][][] field;
		byte[][][][] corners;
		short[][][] shadows;
		short[][][][] drop;

		byte[][][][] qo_corners;
		short[][][] qo_sets;

		byte[][][][] piece_corners;
		
		byte[][][][] displacement_corners = mLastCorners_byField_byPaneCorner.get(INDEX_FIELD_DISPLACEMENT) ;

		int pieceType = slice.getPieceType();

		if (includeDisplacementRowsIfAvailable
				&& drawSettings.getBehaviorIs_displacement()) {
			drawDisplacementOffset.takeVals(offset);
			drawDisplacementOffset.offsetXY(0,
					drawSettings.ROWS * drawSettings.size_blockHeight);
		}

		// draw to last bitmap canvas
		if (drawSettings.drawQ1 && drawQ1) {
			// PANE 1: displacement.
			if (includeDisplacementRowsIfAvailable
					&& drawSettings.getBehaviorIs_displacement()) {
				drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
						(drawSettings.alpha_displacementBorder > 0 ? STYLE_FILL_AND_BORDER : STYLE_FILL),
						canvas, slice.getDisplacementBlockfield(),
						mConfigRangeDisplaced, Consts.QPANE_1, pieceType,
						drawDisplacementOffset,
						drawSettings.alpha_displacementFill, 0, 0, 0, drawSettings.alpha_displacementBorder, 0, 0,
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_TL],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_TR],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_BL],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_BR],
						null, null, sliceTime,
						GlowEffect.TYPE_NONE, true, null);
			}

			// PANE 1: draw ghost components
			mPieceMask_byQPane[Consts.QPANE_1].offset(offset.x, offset.y);
			canvas.save();
			canvas.clipPath(mPieceMask_byQPane[Consts.QPANE_1], Region.Op.DIFFERENCE);
			for (int i = 0; i < slice.getNumPieceGhosts(); i++) {
				field = slice.getPieceFallingGhosts()[i
						+ slice.getFirstPieceGhosts()];
				corners = mLastCorners_byField_byPaneCorner
						.get(INDEX_FIELD_PIECE_FIRST_GHOST + i) ;
				drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
						drawSettings.alpha_ghostBorder > 0 ? STYLE_FILL_WITHOUT_BOX_AND_TOP_AND_BORDER : STYLE_FILL_WITHOUT_BOX_AND_TOP,
						canvas, field,
						configRange, Consts.QPANE_1, pieceType, offset,
						drawSettings.alpha_ghostFill,
						drawSettings.alpha_ghostFill,
						drawSettings.alpha_ghostTop, ghostAlphaMult,
						drawSettings.alpha_ghostBorder,
						255, 255, // 255 to spot errors: should not be drawn.
						corners[Consts.QPANE_1][INDEX_CORNER_TL],
						corners[Consts.QPANE_1][INDEX_CORNER_TR],
						corners[Consts.QPANE_1][INDEX_CORNER_BL],
						corners[Consts.QPANE_1][INDEX_CORNER_BR],
						null, null, sliceTime,
						GlowEffect.TYPE_NONE, true, null);
			}
			canvas.restore();
			mPieceMask_byQPane[Consts.QPANE_1].offset(-offset.x, -offset.y);

			// PANE 1: draw row neg 1
			if (drawSettings.behavior_border == DrawSettings.BEHAVIOR_BORDER_ROW_NEGATIVE_ONE)
				drawRowNegativeOneToCanvas(drawSettings, canvas,
						Consts.QPANE_1,
						drawSettings.alpha_rowNegativeOneBorder, offset);
			// PANE 1: drop shadow
			field = slice.getBlockfieldStable();
			drop = mLastDropShadowSets_byField_byPane_byUniqueColor
					.get(INDEX_FIELD_PIECE_STABLE_DROP_SHADOWS);
			drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
					STYLE_DROP_SHADOW, canvas, field, configRange,
					Consts.QPANE_1, pieceType, offset, 255, 255, 255, 255, 255,
					255, 255,
					null, // drop shadow has no fills...
					null, null, null, null, drop[Consts.QPANE_1], sliceTime,
					GlowEffect.TYPE_NONE, null);
			// PANE 1: field
			field = slice.getPieceFallingBlockfield();
			corners = mLastCorners_byField_byPaneCorner
					.get(INDEX_FIELD_PIECE_FIELD);
			shadows = mLastFillShadowSets_byField_byPane
					.get(INDEX_FIELD_PIECE_FIELD);
			qo_corners = mLastQOConnectedCorners_byField_byPaneCorner
					.get(INDEX_FIELD_PIECE_FIELD);
			qo_sets = this.mLastQOConnectedSets_byField_byPane
					.get(INDEX_FIELD_PIECE_FIELD);
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, field,
					configRange, Consts.QPANE_1, pieceType, offset, -1,
					drawSettings.alpha_lockedFill, alphaScale_lockedFillPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					corners[Consts.QPANE_1][INDEX_CORNER_TL],
					corners[Consts.QPANE_1][INDEX_CORNER_TR],
					corners[Consts.QPANE_1][INDEX_CORNER_BL],
					corners[Consts.QPANE_1][INDEX_CORNER_BR],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_TL],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_TR],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_BL],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_BR],
					shadows[Consts.QPANE_1], null, qo_sets[Consts.QPANE_1],
					sliceTime, GlowEffect.TYPE_NONE, null,
					FadeEffect.TYPE_NONE, null);
			// PANE 1: piece
			field = slice.getPieceFallingPiece();
			corners = mLastCorners_byField_byPaneCorner
					.get(INDEX_FIELD_PIECE_PIECE);
			shadows = mLastFillShadowSets_byField_byPane
					.get(INDEX_FIELD_PIECE_PIECE);
			qo_corners = mLastQOConnectedCorners_byField_byPaneCorner
					.get(INDEX_FIELD_PIECE_PIECE);
			qo_sets = this.mLastQOConnectedSets_byField_byPane
					.get(INDEX_FIELD_PIECE_PIECE);
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, field,
					configRange, Consts.QPANE_1, pieceType, offset, -1,
					drawSettings.alpha_pieceFill, alphaScale_pieceFillPulse,
					drawSettings.alpha_pieceTop,
					drawSettings.alpha_pieceBorder,
					corners[Consts.QPANE_1][INDEX_CORNER_TL],
					corners[Consts.QPANE_1][INDEX_CORNER_TR],
					corners[Consts.QPANE_1][INDEX_CORNER_BL],
					corners[Consts.QPANE_1][INDEX_CORNER_BR],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_TL],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_TR],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_BL],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_BR],
					shadows[Consts.QPANE_1], null, qo_sets[Consts.QPANE_1],
					sliceTime, GlowEffect.TYPE_NONE, null,
					FadeEffect.TYPE_NONE, null);
			// PANE 1: Glows
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, null,
					configRange, Consts.QPANE_1, pieceType, offset, -1, 255,
					255,
					255,
					255, // spot errors with this
					null, null, null, null, null, null, null, null, null, null,
					null, sliceTime, GlowEffect.TYPE_ANY, mLastEffectsGlow,
					FadeEffect.TYPE_NONE, null);
		}

		if (drawSettings.draw3D && draw3D) {
			// PANE 3D: draw ghost components
			for (int i = 0; i < slice.getNumPieceGhosts(); i++) {
				field = slice.getPieceFallingGhosts()[i
						+ slice.getFirstPieceGhosts()];
				corners = mLastCorners_byField_byPaneCorner
						.get(INDEX_FIELD_PIECE_FIRST_GHOST + i);
				qo_corners = mLastQOConnectedCorners_byField_byPaneCorner
						.get(INDEX_FIELD_PIECE_FIRST_GHOST + i);
				qo_sets = mLastQOConnectedSets_byField_byPane
						.get(INDEX_FIELD_PIECE_FIRST_GHOST + i);
				piece_corners = mLastQOConnectedCorners_byField_byPaneCorner
						.get(INDEX_FIELD_PIECE_PIECE);
				drawBlockFieldQPane3DAtAlignmentOffset(drawSettings, canvas,
						field, slice.getPieceFallingPiece(), configRange,
						offset, corners[Consts.QPANE_0][INDEX_CORNER_TL],
						corners[Consts.QPANE_0][INDEX_CORNER_TR],
						corners[Consts.QPANE_0][INDEX_CORNER_BL],
						corners[Consts.QPANE_0][INDEX_CORNER_BR],
						qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
						qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
						qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
						qo_corners[Consts.QPANE_0][INDEX_CORNER_BR],
						piece_corners[Consts.QPANE_0][INDEX_CORNER_TL],
						piece_corners[Consts.QPANE_0][INDEX_CORNER_TR],
						piece_corners[Consts.QPANE_0][INDEX_CORNER_BL],
						piece_corners[Consts.QPANE_0][INDEX_CORNER_BR],
						qo_sets[Consts.QPANE_0], drawSettings.alpha_ghostTop,
						drawSettings.alpha_ghostFill,
						0.5f * drawSettings.alpha_ghostFill / 255.0f, 0, false,
						sliceTime, FadeEffect.TYPE_NONE, null);
			}
			// PANE 3D: field
			field = slice.getPieceFallingBlockfield();
			corners = mLastCorners_byField_byPaneCorner
					.get(INDEX_FIELD_PIECE_FIELD);
			shadows = mLastFillShadowSets_byField_byPane
					.get(INDEX_FIELD_PIECE_FIELD);
			qo_corners = mLastQOConnectedCorners_byField_byPaneCorner
					.get(INDEX_FIELD_PIECE_FIELD);
			qo_sets = this.mLastQOConnectedSets_byField_byPane
					.get(INDEX_FIELD_PIECE_FIELD);
			drawBlockFieldQPaneAtAlignmentOffset(
					drawSettings,
					canvas,
					field,
					configRange,
					Consts.QPANE_3D,
					pieceType,
					offset,
					-1,
					drawSettings.alpha_lockedFill,
					alphaScale_lockedBoxPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					corners[Consts.QPANE_0][INDEX_CORNER_TL], // can't naively
																// optimize
					// 3D fills...
					corners[Consts.QPANE_0][INDEX_CORNER_TR],
					corners[Consts.QPANE_0][INDEX_CORNER_BL],
					corners[Consts.QPANE_0][INDEX_CORNER_BR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BR], null, null,
					qo_sets[Consts.QPANE_0], sliceTime, GlowEffect.TYPE_NONE,
					null, FadeEffect.TYPE_BOX, mLastEffectsFade);
			// PANE 3D: piece
			field = slice.getPieceFallingPiece();
			corners = mLastCorners_byField_byPaneCorner
					.get(INDEX_FIELD_PIECE_PIECE);
			shadows = mLastFillShadowSets_byField_byPane
					.get(INDEX_FIELD_PIECE_PIECE);
			qo_corners = mLastQOConnectedCorners_byField_byPaneCorner
					.get(INDEX_FIELD_PIECE_PIECE);
			qo_sets = this.mLastQOConnectedSets_byField_byPane
					.get(INDEX_FIELD_PIECE_PIECE);
			drawBlockFieldQPaneAtAlignmentOffset(
					drawSettings,
					canvas,
					field,
					configRange,
					Consts.QPANE_3D,
					pieceType,
					offset,
					-1,
					drawSettings.alpha_lockedFill,
					alphaScale_pieceBoxPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					corners[Consts.QPANE_0][INDEX_CORNER_TL], // can't naively
																// optimize
					// 3D fills...
					corners[Consts.QPANE_0][INDEX_CORNER_TR],
					corners[Consts.QPANE_0][INDEX_CORNER_BL],
					corners[Consts.QPANE_0][INDEX_CORNER_BR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BR], null, null,
					qo_sets[Consts.QPANE_0], sliceTime, GlowEffect.TYPE_NONE,
					null, FadeEffect.TYPE_NONE, null);
		}

		// draw to last bitmap canvas
		if (drawSettings.drawQ0 && drawQ0) {
			// PANE 0: displacement.
			if (includeDisplacementRowsIfAvailable
					&& drawSettings.getBehaviorIs_displacement()) {
				drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
						(drawSettings.alpha_displacementBorder > 0 ? STYLE_FILL_AND_BORDER : STYLE_FILL),
						canvas, slice.getDisplacementBlockfield(),
						mConfigRangeDisplaced, Consts.QPANE_0, pieceType,
						drawDisplacementOffset,
						drawSettings.alpha_displacementFill, 0, 0, 0, drawSettings.alpha_displacementBorder, 0, 0,
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_TL],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_TR],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_BL],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_BR],
						null, null, sliceTime,
						GlowEffect.TYPE_NONE, true, null);
			}
			// PANE 0: draw ghost components
			mPieceMask_byQPane[Consts.QPANE_0].offset(offset.x, offset.y);
			canvas.save();
			canvas.clipPath(mPieceMask_byQPane[Consts.QPANE_0], Region.Op.DIFFERENCE);
			for (int i = 0; i < slice.getNumPieceGhosts(); i++) {
				field = slice.getPieceFallingGhosts()[i
						+ slice.getFirstPieceGhosts()];
				corners = mLastCorners_byField_byPaneCorner
						.get(INDEX_FIELD_PIECE_FIRST_GHOST + i) ;
				drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
						drawSettings.alpha_ghostBorder > 0 ? STYLE_FILL_WITHOUT_BOX_AND_TOP_AND_BORDER : STYLE_FILL_WITHOUT_BOX_AND_TOP,
						canvas, field,
						configRange, Consts.QPANE_0, pieceType, offset,
						drawSettings.alpha_ghostFill,
						drawSettings.alpha_ghostFill,
						drawSettings.alpha_ghostTop, ghostAlphaMult,
						drawSettings.alpha_ghostBorder,
						255, 255, // 255 to spot errors: should not be drawn.
						corners[Consts.QPANE_0][INDEX_CORNER_TL],
						corners[Consts.QPANE_0][INDEX_CORNER_TR],
						corners[Consts.QPANE_0][INDEX_CORNER_BL],
						corners[Consts.QPANE_0][INDEX_CORNER_BR],
						null, null, sliceTime,
						GlowEffect.TYPE_NONE, true, null);
			}
			canvas.restore();
			mPieceMask_byQPane[Consts.QPANE_0].offset(-offset.x, -offset.y);

			// PANE 0: draw row neg 1.
			if (drawSettings.behavior_border == DrawSettings.BEHAVIOR_BORDER_ROW_NEGATIVE_ONE)
				drawRowNegativeOneToCanvas(drawSettings, canvas,
						Consts.QPANE_0,
						drawSettings.alpha_rowNegativeOneBorder, offset);
			// PANE 0: drop shadow
			field = slice.getBlockfieldStable();
			drop = mLastDropShadowSets_byField_byPane_byUniqueColor
					.get(INDEX_FIELD_PIECE_STABLE_DROP_SHADOWS);
			drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
					STYLE_DROP_SHADOW, canvas, field, configRange,
					Consts.QPANE_0, pieceType, offset, 255, 255, 255, 255, 255,
					255, 255, null, null, null, null, null,
					drop[Consts.QPANE_0], sliceTime, GlowEffect.TYPE_NONE, null);
			// PANE 0: field
			field = slice.getPieceFallingBlockfield();
			corners = mLastCorners_byField_byPaneCorner
					.get(INDEX_FIELD_PIECE_FIELD);
			shadows = mLastFillShadowSets_byField_byPane
					.get(INDEX_FIELD_PIECE_FIELD);
			qo_corners = mLastQOConnectedCorners_byField_byPaneCorner
					.get(INDEX_FIELD_PIECE_FIELD);
			qo_sets = this.mLastQOConnectedSets_byField_byPane
					.get(INDEX_FIELD_PIECE_FIELD);
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, field,
					configRange, Consts.QPANE_0, pieceType, offset, -1,
					drawSettings.alpha_lockedFill, alphaScale_lockedFillPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					corners[Consts.QPANE_0][INDEX_CORNER_TL],
					corners[Consts.QPANE_0][INDEX_CORNER_TR],
					corners[Consts.QPANE_0][INDEX_CORNER_BL],
					corners[Consts.QPANE_0][INDEX_CORNER_BR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BR],
					shadows[Consts.QPANE_0], null, qo_sets[Consts.QPANE_0],
					sliceTime, GlowEffect.TYPE_NONE, null,
					FadeEffect.TYPE_NONE, null);
			// PANE 0: piece
			field = slice.getPieceFallingPiece();
			corners = mLastCorners_byField_byPaneCorner
					.get(INDEX_FIELD_PIECE_PIECE);
			shadows = mLastFillShadowSets_byField_byPane
					.get(INDEX_FIELD_PIECE_PIECE);
			qo_corners = mLastQOConnectedCorners_byField_byPaneCorner
					.get(INDEX_FIELD_PIECE_PIECE);
			qo_sets = this.mLastQOConnectedSets_byField_byPane
					.get(INDEX_FIELD_PIECE_PIECE);
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, field,
					configRange, Consts.QPANE_0, pieceType, offset, -1,
					drawSettings.alpha_pieceFill, alphaScale_pieceFillPulse,
					drawSettings.alpha_pieceTop,
					drawSettings.alpha_pieceBorder,
					corners[Consts.QPANE_0][INDEX_CORNER_TL],
					corners[Consts.QPANE_0][INDEX_CORNER_TR],
					corners[Consts.QPANE_0][INDEX_CORNER_BL],
					corners[Consts.QPANE_0][INDEX_CORNER_BR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BR],
					shadows[Consts.QPANE_0], null, qo_sets[Consts.QPANE_0],
					sliceTime, GlowEffect.TYPE_NONE, null,
					FadeEffect.TYPE_NONE, null);
			// PANE 0: Glows
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, null,
					configRange, Consts.QPANE_0, pieceType, offset, -1, 255,
					255,
					255,
					255, // spot errors with this
					null, null, null, null, null, null, null, null, null, null,
					null, sliceTime, GlowEffect.TYPE_ANY, mLastEffectsGlow,
					FadeEffect.TYPE_NONE, null);
		}
	}

	/**
	 * Primarily intended as a helper for drawPieceFallingWithLastSlice. Provide
	 * a canvas, a draw offset, a GameBlocksSlice to draw and the current time
	 * (for pulses).
	 * 
	 * PRECONDITIONS: The provided canvas has been clipped appropriately. When
	 * drawing efficiently (i.e. to mLastBitmapCanvas, this clip should cover
	 * only those blocks which have changed; when drawing directly to the
	 * OS-provided canvas, a clip has likely already been applied; redraw
	 * everything.
	 * 
	 * 'canvasTransation' has been set in advance, according to whether the
	 * provided canvas includes any transation.
	 * 
	 * mLastCorners_ and mLastInnerShadowSets have been configured.
	 * 
	 * POSTCONDITIONS: The falling piece slice has been drawn to the canvas.
	 */
	private void drawPieceFallingToCanvasWithSlice_helperDrawStableField(
			DrawSettings drawSettings, int qPane, Canvas canvas, Offset offset,
			GameBlocksSlice slice, BlockDrawerSliceTime sliceTime,
			Offset offsetBackground, boolean includeDisplacementRowsIfAvailable) {

		BlockDrawerConfigRange configRange = tempConfigRange;
		configRange.set(drawSettings.displayedRows, drawSettings.COLS);

		drawBackgroundBehaviorToCanvas(drawSettings, canvas, null, sliceTime,
				BlockDrawerConfigCanvas.Background.CLEAR);

		long currentTime = sliceTime.getUnpaused();

		float alphaScale_fillPulse = animationSettings == null ? 0
				: animationSettings.pulseAlpha(
						drawSettings.alphaScale_lockedFillPulse, currentTime);
		float alphaScale_boxPulse = animationSettings == null ? 0
				: animationSettings.pulseAlpha(
						drawSettings.alphaScale_lockedBoxPulse, currentTime);

		// a note on naive fill optimization: it is "naive" in the sense that it
		// functions only if:
		// 1. the QPane on which it is used is the first to be drawn
		// 2. the block background used is drawSettings.paint_background_piece
		// 3. this background is fully opaque.
		// (PENDING: we currently alter the paint's opacity freely while
		// assuming
		// alpha 255 is standard, making this hard to determine).
		// Hence, we cannot naively optimize ghost fills, for example.

		boolean drawQ0 = qPane == Consts.QPANE_ALL || qPane == Consts.QPANE_0;
		boolean drawQ1 = qPane == Consts.QPANE_ALL || qPane == Consts.QPANE_1;
		boolean draw3D = qPane == Consts.QPANE_ALL || qPane == Consts.QPANE_3D;

		byte[][][] field;
		byte[][][][] corners;
		short[][][] shadows;
		short[][][][] drop;

		byte[][][][] qo_corners;
		short[][][] qo_sets;
		int pieceType = slice.getPieceType();
		
		byte[][][][] displacement_corners = mLastCorners_byField_byPaneCorner.get(INDEX_FIELD_DISPLACEMENT) ;

		if (includeDisplacementRowsIfAvailable
				&& drawSettings.getBehaviorIs_displacement()) {
			drawDisplacementOffset.takeVals(offset);
			drawDisplacementOffset.offsetXY(0,
					drawSettings.ROWS * drawSettings.size_blockHeight);
		}

		// draw to last bitmap canvas
		if (drawSettings.drawQ1 && drawQ1) {
			// PANE 1: displacement.
			if (includeDisplacementRowsIfAvailable
					&& drawSettings.getBehaviorIs_displacement()) {
				drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
						(drawSettings.alpha_displacementBorder > 0 ? STYLE_FILL_AND_BORDER : STYLE_FILL),
						canvas, slice.getDisplacementBlockfield(),
						mConfigRangeDisplaced, Consts.QPANE_1, pieceType,
						drawDisplacementOffset,
						drawSettings.alpha_displacementFill, 0, 0, 0, drawSettings.alpha_displacementBorder, 0, 0,
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_TL],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_TR],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_BL],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_BR],
						null, null, sliceTime,
						GlowEffect.TYPE_NONE, true, null);
			}
			// PANE 1: draw row neg 1
			if (drawSettings.behavior_border == DrawSettings.BEHAVIOR_BORDER_ROW_NEGATIVE_ONE)
				drawRowNegativeOneToCanvas(drawSettings, canvas,
						Consts.QPANE_1,
						drawSettings.alpha_rowNegativeOneBorder, offset);
			// PANE 1: field
			field = slice.getPieceFallingBlockfield();
			corners = mLastCorners_byField_byPaneCorner
					.get(INDEX_FIELD_PIECE_FIELD);
			shadows = mLastFillShadowSets_byField_byPane
					.get(INDEX_FIELD_PIECE_FIELD);
			drop = mLastDropShadowSets_byField_byPane_byUniqueColor
					.get(INDEX_FIELD_PIECE_FIELD);
			qo_corners = mLastQOConnectedCorners_byField_byPaneCorner
					.get(INDEX_FIELD_PIECE_FIELD);
			qo_sets = mLastQOConnectedSets_byField_byPane
					.get(INDEX_FIELD_PIECE_FIELD);

			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, field,
					configRange, Consts.QPANE_1, pieceType, offset, -1,
					drawSettings.alpha_lockedFill, alphaScale_fillPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					corners[Consts.QPANE_1][INDEX_CORNER_TL],
					corners[Consts.QPANE_1][INDEX_CORNER_TR],
					corners[Consts.QPANE_1][INDEX_CORNER_BL],
					corners[Consts.QPANE_1][INDEX_CORNER_BR],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_TL],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_TR],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_BL],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_BR],
					shadows[Consts.QPANE_1], drop[Consts.QPANE_1],
					qo_sets[Consts.QPANE_1], sliceTime, GlowEffect.TYPE_NONE,
					null, FadeEffect.TYPE_NONE, null);
		}

		if (drawSettings.draw3D && draw3D) {
			// PANE 3D: field
			field = slice.getPieceFallingBlockfield();
			corners = mLastCorners_byField_byPaneCorner
					.get(INDEX_FIELD_PIECE_FIELD);
			qo_corners = mLastQOConnectedCorners_byField_byPaneCorner
					.get(INDEX_FIELD_PIECE_FIELD);
			qo_sets = mLastQOConnectedSets_byField_byPane
					.get(INDEX_FIELD_PIECE_FIELD);
			drawBlockFieldQPaneAtAlignmentOffset(
					drawSettings,
					canvas,
					field,
					configRange,
					Consts.QPANE_3D,
					pieceType,
					offset,
					-1,
					drawSettings.alpha_lockedFill,
					alphaScale_boxPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					corners[Consts.QPANE_0][INDEX_CORNER_TL], // can't naively
																// optimize
					// 3D fills...
					corners[Consts.QPANE_0][INDEX_CORNER_TR],
					corners[Consts.QPANE_0][INDEX_CORNER_BL],
					corners[Consts.QPANE_0][INDEX_CORNER_BR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BR], null, null,
					qo_sets[Consts.QPANE_0], sliceTime, GlowEffect.TYPE_NONE,
					null, FadeEffect.TYPE_BOX, mLastEffectsFade);
		}

		// draw to last bitmap canvas. Note: we also need to draw the
		// "block fill" background
		// for Q0 when we are drawing to Q1.
		if (drawSettings.drawQ0 && drawQ0) {
			// PANE 1: displacement.
			if (includeDisplacementRowsIfAvailable
					&& drawSettings.getBehaviorIs_displacement()) {
				drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
						(drawSettings.alpha_displacementBorder > 0 ? STYLE_FILL_AND_BORDER : STYLE_FILL),
						canvas, slice.getDisplacementBlockfield(),
						mConfigRangeDisplaced, Consts.QPANE_0, pieceType,
						drawDisplacementOffset,
						drawSettings.alpha_displacementFill, 0, 0, 0, drawSettings.alpha_displacementBorder, 0, 0,
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_TL],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_TR],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_BL],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_BR],
						null, null, sliceTime,
						GlowEffect.TYPE_NONE, true, null);
			}
			// PANE 0: draw row neg 1.
			if (drawSettings.behavior_border == DrawSettings.BEHAVIOR_BORDER_ROW_NEGATIVE_ONE)
				drawRowNegativeOneToCanvas(drawSettings, canvas,
						Consts.QPANE_0,
						drawSettings.alpha_rowNegativeOneBorder, offset);
			// PANE 0: field
			field = slice.getPieceFallingBlockfield();
			corners = mLastCorners_byField_byPaneCorner
					.get(INDEX_FIELD_PIECE_FIELD);
			shadows = mLastFillShadowSets_byField_byPane
					.get(INDEX_FIELD_PIECE_FIELD);
			drop = mLastDropShadowSets_byField_byPane_byUniqueColor
					.get(INDEX_FIELD_PIECE_FIELD);
			qo_corners = mLastQOConnectedCorners_byField_byPaneCorner
					.get(INDEX_FIELD_PIECE_FIELD);
			qo_sets = mLastQOConnectedSets_byField_byPane
					.get(INDEX_FIELD_PIECE_FIELD);

			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, field,
					configRange, Consts.QPANE_0, pieceType, offset, -1,
					drawSettings.alpha_lockedFill, alphaScale_fillPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					corners[Consts.QPANE_0][INDEX_CORNER_TL],
					corners[Consts.QPANE_0][INDEX_CORNER_TR],
					corners[Consts.QPANE_0][INDEX_CORNER_BL],
					corners[Consts.QPANE_0][INDEX_CORNER_BR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BR],
					shadows[Consts.QPANE_0], drop[Consts.QPANE_0],
					qo_sets[Consts.QPANE_0], sliceTime, GlowEffect.TYPE_NONE,
					null, FadeEffect.TYPE_NONE, null);
		}
	}

	/**
	 * Primarily intended as a helper for drawPieceFallingWithLastSlice. Provide
	 * a canvas, a draw offset, a GameBlocksSlice to draw and the current time
	 * (for pulses).
	 * 
	 * PRECONDITIONS: The provided canvas has been clipped appropriately. When
	 * drawing efficiently (i.e. to mLastBitmapCanvas, this clip should cover
	 * only those blocks which have changed; when drawing directly to the
	 * OS-provided canvas, a clip has likely already been applied; redraw
	 * everything.
	 * 
	 * 'canvasTransation' has been set in advance, according to whether the
	 * provided canvas includes any transation.
	 * 
	 * mLastCorners_ and mLastInnerShadowSets have been configured.
	 * 
	 * POSTCONDITIONS: The falling piece slice has been drawn to the canvas.
	 */
	private void drawPieceFallingToCanvasWithSlice_helperDrawPiece(
			DrawSettings drawSettings, int qPane, Canvas canvas, Offset offset,
			GameBlocksSlice slice, BlockDrawerSliceTime sliceTime,
			Offset offsetBackground) {

		BlockDrawerConfigRange configRange = tempConfigRange;
		configRange.set(drawSettings.displayedRows, drawSettings.COLS);

		// draw background
		// draw background: happens in 2 different steps. If we draw 'all,' we
		// fill
		// now. Otherwise, if BLOCK_FILL, we draw twice - first to set the
		// background
		// color, second to draw the fills themselves.
		drawBackgroundBehaviorToCanvas(drawSettings, canvas, null, sliceTime,
				BlockDrawerConfigCanvas.Background.CLEAR);

		// canvas.drawColor( qPane == Consts.QPANE_0 ? 0xffff00ff : 0xff00ffff )
		// ;

		// TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST
		// mLastBitmapCanvas.drawColor( new Random().nextBoolean() ?
		// Color.MAGENTA : Color.YELLOW) ;

		long currentTime = sliceTime.getUnpaused();

		float alphaScale_fillPulse = animationSettings == null ? 0
				: animationSettings.pulseAlpha(
						drawSettings.alphaScale_pieceFillPulse, currentTime);
		float alphaScale_boxPulse = animationSettings == null ? 0
				: animationSettings.pulseAlpha(
						drawSettings.alphaScale_pieceBoxPulse, currentTime);

		float ghostAlphaMult = (float) drawSettings.alpha_ghostFill
				/ (float) drawSettings.alpha_lockedFill;
		if (ghostAlphaMult == Float.POSITIVE_INFINITY)
			ghostAlphaMult = 1.0f;

		// a note on naive fill optimization: it is "naive" in the sense that it
		// functions only if:
		// 1. the QPane on which it is used is the first to be drawn
		// 2. the block background used is drawSettings.paint_background_piece
		// 3. this background is fully opaque.
		// (PENDING: we currently alter the paint's opacity freely while
		// assuming
		// alpha 255 is standard, making this hard to determine).
		// Hence, we cannot naively optimize ghost fills, for example.

		boolean drawQ0 = qPane == Consts.QPANE_ALL || qPane == Consts.QPANE_0;
		boolean drawQ1 = qPane == Consts.QPANE_ALL || qPane == Consts.QPANE_1;
		boolean draw3D = qPane == Consts.QPANE_ALL || qPane == Consts.QPANE_3D;

		byte[][][] field;
		byte[][][][] corners;
		short[][][] shadows;
		short[][][][] drop;

		byte[][][][] qo_corners;
		short[][][] qo_sets;

		byte[][][][] piece_corners;

		int pieceType = slice.getPieceType();

		// draw to last bitmap canvas
		if (drawSettings.drawQ1 && drawQ1) {
			// PANE 1: draw ghost components
			mPieceMask_byQPane[Consts.QPANE_1].offset(offset.x, offset.y);
			canvas.save();
			canvas.clipPath(mPieceMask_byQPane[Consts.QPANE_1], Region.Op.DIFFERENCE);
			for (int i = 0; i < slice.getNumPieceGhosts(); i++) {
				field = slice.getPieceFallingGhosts()[i
						+ slice.getFirstPieceGhosts()];
				corners = mLastCorners_byField_byPaneCorner
						.get(INDEX_FIELD_PIECE_FIRST_GHOST + i) ;
				drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
						drawSettings.alpha_ghostBorder > 0 ? STYLE_FILL_WITHOUT_BOX_AND_TOP_AND_BORDER : STYLE_FILL_WITHOUT_BOX_AND_TOP,
						canvas, field,
						configRange, Consts.QPANE_1, pieceType, offset,
						drawSettings.alpha_ghostFill,
						drawSettings.alpha_ghostFill,
						drawSettings.alpha_ghostTop, ghostAlphaMult,
						drawSettings.alpha_ghostBorder,
						255, 255, // 255 to spot errors: should not be drawn.
						corners[Consts.QPANE_1][INDEX_CORNER_TL],
						corners[Consts.QPANE_1][INDEX_CORNER_TR],
						corners[Consts.QPANE_1][INDEX_CORNER_BL],
						corners[Consts.QPANE_1][INDEX_CORNER_BR],
						null, null, sliceTime,
						GlowEffect.TYPE_NONE, true, null);
			}
			canvas.restore();
			mPieceMask_byQPane[Consts.QPANE_1].offset(-offset.x, -offset.y);
			// PANE 1: piece
			field = slice.getPieceFallingPiece();
			corners = mLastCorners_byField_byPaneCorner
					.get(INDEX_FIELD_PIECE_PIECE);
			shadows = mLastFillShadowSets_byField_byPane
					.get(INDEX_FIELD_PIECE_PIECE);
			drop = mLastDropShadowSets_byField_byPane_byUniqueColor
					.get(INDEX_FIELD_PIECE_PIECE);
			qo_corners = mLastQOConnectedCorners_byField_byPaneCorner
					.get(INDEX_FIELD_PIECE_PIECE);
			qo_sets = mLastQOConnectedSets_byField_byPane
					.get(INDEX_FIELD_PIECE_PIECE);

			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, field,
					configRange, Consts.QPANE_1, pieceType, offset, -1,
					drawSettings.alpha_pieceFill, alphaScale_fillPulse,
					drawSettings.alpha_pieceTop,
					drawSettings.alpha_pieceBorder,
					corners[Consts.QPANE_1][INDEX_CORNER_TL],
					corners[Consts.QPANE_1][INDEX_CORNER_TR],
					corners[Consts.QPANE_1][INDEX_CORNER_BL],
					corners[Consts.QPANE_1][INDEX_CORNER_BR],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_TL],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_TR],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_BL],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_BR],
					shadows[Consts.QPANE_1], drop[Consts.QPANE_1],
					qo_sets[Consts.QPANE_1], sliceTime, GlowEffect.TYPE_NONE,
					null, FadeEffect.TYPE_NONE, null);
		}

		if (drawSettings.draw3D && draw3D) {
			// PANE 3D: draw ghost components
			for (int i = 0; i < slice.getNumPieceGhosts(); i++) {
				field = slice.getPieceFallingGhosts()[i
						+ slice.getFirstPieceGhosts()];
				corners = mLastCorners_byField_byPaneCorner
						.get(INDEX_FIELD_PIECE_FIRST_GHOST + i);
				qo_corners = mLastQOConnectedCorners_byField_byPaneCorner
						.get(INDEX_FIELD_PIECE_FIRST_GHOST + i);
				qo_sets = mLastQOConnectedSets_byField_byPane
						.get(INDEX_FIELD_PIECE_FIRST_GHOST + i);
				piece_corners = mLastQOConnectedCorners_byField_byPaneCorner
						.get(INDEX_FIELD_PIECE_PIECE);
				drawBlockFieldQPane3DAtAlignmentOffset(drawSettings, canvas,
						field, slice.getPieceFallingPiece(), configRange,
						offset, corners[Consts.QPANE_0][INDEX_CORNER_TL],
						corners[Consts.QPANE_0][INDEX_CORNER_TR],
						corners[Consts.QPANE_0][INDEX_CORNER_BL],
						corners[Consts.QPANE_0][INDEX_CORNER_BR],
						qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
						qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
						qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
						qo_corners[Consts.QPANE_0][INDEX_CORNER_BR],
						piece_corners[Consts.QPANE_0][INDEX_CORNER_TL],
						piece_corners[Consts.QPANE_0][INDEX_CORNER_TR],
						piece_corners[Consts.QPANE_0][INDEX_CORNER_BL],
						piece_corners[Consts.QPANE_0][INDEX_CORNER_BR],
						qo_sets[Consts.QPANE_0], drawSettings.alpha_ghostTop,
						drawSettings.alpha_ghostFill,
						0.5f * drawSettings.alpha_ghostFill / 255.0f, 0, false,
						sliceTime, FadeEffect.TYPE_NONE, null);
			}
			// PANE 3D: piece
			field = slice.getPieceFallingPiece();
			corners = mLastCorners_byField_byPaneCorner
					.get(INDEX_FIELD_PIECE_PIECE);
			shadows = mLastFillShadowSets_byField_byPane
					.get(INDEX_FIELD_PIECE_PIECE);
			qo_corners = mLastQOConnectedCorners_byField_byPaneCorner
					.get(INDEX_FIELD_PIECE_PIECE);
			qo_sets = mLastQOConnectedSets_byField_byPane
					.get(INDEX_FIELD_PIECE_PIECE);

			drawBlockFieldQPaneAtAlignmentOffset(
					drawSettings,
					canvas,
					field,
					configRange,
					Consts.QPANE_3D,
					pieceType,
					offset,
					-1,
					drawSettings.alpha_lockedFill,
					alphaScale_boxPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					corners[Consts.QPANE_0][INDEX_CORNER_TL], // can't naively
																// optimize
					// 3D fills...
					corners[Consts.QPANE_0][INDEX_CORNER_TR],
					corners[Consts.QPANE_0][INDEX_CORNER_BL],
					corners[Consts.QPANE_0][INDEX_CORNER_BR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BR], null, null,
					qo_sets[Consts.QPANE_0], sliceTime, GlowEffect.TYPE_NONE,
					null, FadeEffect.TYPE_NONE, null);
		}

		// draw to last bitmap canvas
		if (drawSettings.drawQ0 && drawQ0) {
			// PANE 0: draw ghost components
			mPieceMask_byQPane[Consts.QPANE_0].offset(offset.x, offset.y);
			canvas.save();
			canvas.clipPath(mPieceMask_byQPane[Consts.QPANE_0], Region.Op.DIFFERENCE);
			for (int i = 0; i < slice.getNumPieceGhosts(); i++) {
				field = slice.getPieceFallingGhosts()[i
						+ slice.getFirstPieceGhosts()];
				corners = mLastCorners_byField_byPaneCorner
						.get(INDEX_FIELD_PIECE_FIRST_GHOST + i) ;
				drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
						drawSettings.alpha_ghostBorder > 0 ? STYLE_FILL_WITHOUT_BOX_AND_TOP_AND_BORDER : STYLE_FILL_WITHOUT_BOX_AND_TOP,
						canvas, field,
						configRange, Consts.QPANE_0, pieceType, offset,
						drawSettings.alpha_ghostFill,
						drawSettings.alpha_ghostFill,
						drawSettings.alpha_ghostTop, ghostAlphaMult,
						drawSettings.alpha_ghostBorder,
						255, 255, // 255 to spot errors: should not be drawn.
						corners[Consts.QPANE_0][INDEX_CORNER_TL],
						corners[Consts.QPANE_0][INDEX_CORNER_TR],
						corners[Consts.QPANE_0][INDEX_CORNER_BL],
						corners[Consts.QPANE_0][INDEX_CORNER_BR],
						null, null, sliceTime,
						GlowEffect.TYPE_NONE, true, null);
			}
			canvas.restore();
			mPieceMask_byQPane[Consts.QPANE_0].offset(-offset.x, -offset.y);
			// PANE 0: piece
			field = slice.getPieceFallingPiece();
			corners = mLastCorners_byField_byPaneCorner
					.get(INDEX_FIELD_PIECE_PIECE);
			shadows = mLastFillShadowSets_byField_byPane
					.get(INDEX_FIELD_PIECE_PIECE);
			drop = mLastDropShadowSets_byField_byPane_byUniqueColor
					.get(INDEX_FIELD_PIECE_PIECE);
			qo_corners = mLastQOConnectedCorners_byField_byPaneCorner
					.get(INDEX_FIELD_PIECE_PIECE);
			qo_sets = mLastQOConnectedSets_byField_byPane
					.get(INDEX_FIELD_PIECE_PIECE);

			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, field,
					configRange, Consts.QPANE_0, pieceType, offset, -1,
					drawSettings.alpha_pieceFill, alphaScale_fillPulse,
					drawSettings.alpha_pieceTop,
					drawSettings.alpha_pieceBorder,
					corners[Consts.QPANE_0][INDEX_CORNER_TL],
					corners[Consts.QPANE_0][INDEX_CORNER_TR],
					corners[Consts.QPANE_0][INDEX_CORNER_BL],
					corners[Consts.QPANE_0][INDEX_CORNER_BR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BR],
					shadows[Consts.QPANE_0], drop[Consts.QPANE_0],
					qo_sets[Consts.QPANE_0], sliceTime, GlowEffect.TYPE_NONE,
					null, FadeEffect.TYPE_NONE, null);
		}
	}

	private void drawChunksFallingWithLastSlice(Canvas canvas,
			QuantroSoundPool pool, GameBlocksSlice slice,
			BlockDrawerSliceTime sliceTime, BlockDrawerConfigCanvas configCanvas) {

		if (configCanvas == null && mNextSliceNeedsExplicitConfigCanvas)
			configCanvas = mDrawSettings.configCanvas;

		tick();

		// Our "efficient" draw method for falling chunks. We draw to
		// mLastBitmapCanvas, then
		// draw mLastBitmap to the canvas provided.

		boolean backgroundChanged = backgroundLayerChanged(mLastSliceTime,
				sliceTime);
		boolean unlockedThisSlice = false;
		boolean unlocking = false;
		boolean riseAndFade = false;

		boolean fieldChanged = false; // should we redraw the entire thing?
		boolean chunkTransition = false; // has at least 1 chunk transitioned
											// from "falling" to "locked" in the
											// last tick?

		boolean fallZeroDistance = slice.getChunksArePieceComponents();
		// if the chunks are piece components, we DO want to force pieces
		// "resting"
		// to explicitly fall for at least 1 millisecond. This delays any
		// impressive
		// "glow" effect until after as much as possible is pre-computed.
		// However,
		// if not, then waiting for a fall time of 0 causes visual bugs - e.g.,
		// chunks which are "unlocked" by a Flash piece but have nowhere to fall
		// - and will immediately re-lock without any glow effect - appear
		// temporarily
		// separate, with their own border.

		tick();
		boolean sliceStateChanged = mLastSlice.getBlocksState() != slice
				.getBlocksState() || !sliceTime.hasBeenDrawnEver();

		if (sliceStateChanged
				&& GlobalTestSettings.BLOCK_DRAWER_LOG_SLICE_STATE)
			log("now drawing chunks falling");

		int qo = PieceCatalog.getQCombination(slice.getPieceType());
		riseAndFade = slice.getChunksArePieceComponents()
				&& slice.getNumChunks() > 1
				&& qo >= 0
				&& qo < QOrientations.NUM
				&& mDrawSettings.behavior_qo_falling_chunk[PieceCatalog
						.getQCombination(slice.getPieceType())] == DrawSettings.BEHAVIOR_QO_FALLING_CHUNK_PIECE_TYPE_PIECE_COMPONENT_RISE_AND_FADE;
		int maxRiseFadeHeight = Integer.MAX_VALUE;
		for (int i = slice.getFirstChunk() + 1; i < slice.getNumChunks()
				+ slice.getFirstChunk(); i++) {
			maxRiseFadeHeight = Math.min(
					maxRiseFadeHeight,
					heightAvailableToRise(
							slice.getBlockfields()[slice.getFirstChunk()],
							slice.getChunks()[i], slice.getFallDistances()[i],
							0));
		}
		long unlockingTime = timeToDrawUnlock(slice); // 0 if no columns to
														// unlock
		long fallingTime = Math.max(0, sliceTime.getSlice() - unlockingTime);
		float blocksFallen = fallingTime <= 0 ? 0 : animationSettings
				.distanceFallen(fallingTime);
		float blocksRisen = fallingTime <= 0 ? 0 : animationSettings
				.riseFadeDistanceRisen(fallingTime, maxRiseFadeHeight);

		if (riseAndFade)
			blocksFallen = 0;
		else
			blocksRisen = 0;

		unlocking = unlockingTime > sliceTime.getSlice();

		unlockedThisSlice = !unlocking
				&& unlockingTime > 0
				&& (sliceStateChanged || sliceTime.getLastDrawnSlice() < unlockingTime);
		boolean chunkJustLanded = false;
		int lastLandedChunk = -1;
		if (!riseAndFade) {
			for (int i = slice.getFirstChunk(); i < slice.getFirstChunk()
					+ slice.getNumChunks(); i++) {

				// Special case reasoning. Initially, we assume a piece lands
				// the MOMENT it touches down.
				// However, this led to animation hiccups due to the first frame
				// (timeSpentAnimiting = 0)
				// taking longer to render than the rest, so we changed this to
				// the moment when its fall
				// distance EXCEEDS the the total needed (rather than >=). This
				// fixed the 1st frame hiccup,
				// since animations were delayed until after the first frame
				// rendered.
				// However, it introduced a strange visual bug in high-framerate
				// phones, where pieces after
				// the first appear to land but don't animate for a frame
				// (caused by the distance fallen
				// exactly matching the distance required).
				//
				// To accomodate these two problems, we use special-case
				// reasoning: a chunk with fall distance
				// 0 must have fallen for at least 1 millisecond to land, but
				// all other chunks will land
				// the moment they exactly reach the ground.
				int d = slice.getFallDistances()[i];
				if (d < 0
						|| ((fallingTime > animationSettings.fall_timeToFallDistance[d] || ((d > 0 || (d == 0 && !fallZeroDistance)) && fallingTime >= animationSettings.fall_timeToFallDistance[d])))) {
					lastLandedChunk = i;
					if ((d == 0 && fallingTime
							- (sliceTime.timeSinceLastSliceDraw()) <= animationSettings.fall_timeToFallDistance[d])
							|| ((d > 0 || (d == 0 && !fallZeroDistance)) && fallingTime
									- (sliceTime.timeSinceLastSliceDraw()) < animationSettings.fall_timeToFallDistance[d])) {
						chunkJustLanded = true;
						break;
					}
				}
			}
		} else {
			for (int i = slice.getFirstChunk(); i < slice.getFirstChunk()
					+ slice.getNumChunks(); i++) {
				int d = slice.getFallDistances()[i];
				if (d < 0) {
					lastLandedChunk = i;
					if (fallingTime - (sliceTime.timeSinceLastSliceDraw()) <= animationSettings.fall_timeToFallDistance[0])
						chunkJustLanded = true;
				}
			}
		}

		// Calculate whether we're done animating...
		boolean doneMoving = false;
		if (riseAndFade)
			doneMoving = animationSettings.riseFadeTotalTime(1, 0,
					maxRiseFadeHeight) < fallingTime;
		else
			doneMoving = slice.getNumChunks() <= 1
					|| fallingTime > animationSettings.fall_timeToFallDistance[slice
							.getFallDistances()[slice.getNumChunks()
							+ slice.getFirstChunk() - 1]];

		// if ( sliceStateChanged ) {
		// log("in drawChunksFallingWithLastSlice") ;
		// log("has " + slice.getNumChunks() + " chunks starting at " +
		// slice.getFirstChunk()) ;
		// log("last landed chunk is " + lastLandedChunk) ;
		// for ( int i = slice.getFirstChunk(); i < slice.getNumChunks() +
		// slice.getFirstChunk(); i++ )
		// log("chunk " + i + " has fall distance " +
		// slice.getFallDistances()[i] ) ;
		// }

		// field change? in an effort to push this method out the door, we apply
		// a field change
		// when we start on this slice, w/o regard to whether we have a
		// previously stable match.
		fieldChanged = mNextSliceBreaksSequence;
		fieldChanged = fieldChanged
				|| mLastSlice.getBlocksState() != GameBlocksSlice.BLOCKS_CHUNKS_FALLING
				|| !sliceTime.hasBeenDrawnEver();
		fieldChanged = fieldChanged || mLastBitmapDifferentDisplacement ;

		boolean startedUnlocking = unlocking && sliceStateChanged
				|| fieldChanged || !sliceTime.hasBeenDrawnEver();

		// 'chunkTransition' is true if different chunks were attached last time
		// than
		// this time. It is only set to 'true' if 'unlocking' is false. It
		// supersets
		// 'unlockedThisSlice;' we assume that moment includes a change in which
		// chunks
		// are attached. Naturally, it also supersets 'fieldChanged.'
		chunkTransition = fieldChanged || unlockedThisSlice;
		if (!unlocking) {
			// chunk transition if:
			// at our current time spent animating, chunk X has landed,
			// but at our LAST time spent animating, chunk X had not yet landed.
			long lastFallingTime = sliceTime.hasBeenDrawnEver() ? sliceTime
					.getLastDrawnSlice() - unlockingTime : 0;
			float lastBlocksFallen = lastFallingTime > 0 ? animationSettings
					.distanceFallen(lastFallingTime) : 0;
			for (int i = slice.getFirstChunk(); i < slice.getFirstChunk()
					+ slice.getNumChunks(); i++) {
				int dist = slice.getFallDistances()[i];
				if ((dist == 0 && blocksFallen > dist && lastBlocksFallen <= dist)
						|| ((dist > 0 || (dist == 0 && !fallZeroDistance))
								&& blocksFallen >= dist && lastBlocksFallen < dist)) {
				    log("drawing falling chunks. chunk " + i + " dist " + dist + " blocks fallen " + blocksFallen + " lastBlocksFallen " + lastBlocksFallen);
					chunkTransition = true;
					break;
				}
			}
		}
		
		 // log("drawing falling chunks.  fieldChanged:" + fieldChanged +
		 // ", chunkTransition:" + chunkTransition + ", unlocking:" + unlocking
		 // + ", unlockingTime:" + unlockingTime + ", fallingTime:" + fallingTime
		 // + ", blocksFallen:" + blocksFallen + ", unlockedThisSlice:" +
		 // unlockedThisSlice) ;

		if (fieldChanged)
			mProfileBehavior = INDEX_PROFILE_SLICE_FALLING_BEHAVIOR_FIELD_CHANGED;
		else if (chunkTransition)
			mProfileBehavior = INDEX_PROFILE_SLICE_FALLING_BEHAVIOR_CHUNK_TRANSITION;
		else if (unlocking)
			mProfileBehavior = INDEX_PROFILE_SLICE_FALLING_BEHAVIOR_UNLOCKING;
		else
			mProfileBehavior = INDEX_PROFILE_SLICE_FALLING_BEHAVIOR_CHUNK_FALLING;
		mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_CHECK_EQUALITY] += tock();

		// calculate riseFallDirection metadata.
		if ((mDrawSettings.getBlit() != DrawSettings.BLIT_SEPTUPLE)
				&& !mDrawSettings.getBehaviorIs_displacement()
				&& (fieldChanged || sliceStateChanged || !sliceTime
						.hasBeenDrawnEver())) {
			mLastBitmapChunksFalling_drawFallDirectionChangeChunk = 0;
			mLastBitmapChunksFalling_drawFallDirectionChangeDistance = 0;
			mLastBitmapChunksFalling_drawFallDirectionChangeClipped = false;
			mLastBitmapChunksFalling_drawFallDirectionChangeChunkFallDistance = 0;

			if (!riseAndFade) {
				// examine chunks / blocks locked. naively count blocks, and
				// switch
				// when there are more blocks "on the ground" than "in the air."
				// This may happen right away. For faster computation, we start
				// at
				// the end and decrement. Set everything as it is upon the last
				// chunk landing.

				// Set this value to {0, ..., numChunks}. It indicates the
				// "switch point"
				// between raising the ground and falling the chunks; at 0, the
				// switch
				// point happens BEFORE chunk 0 lands. That is, for 'i', we
				// raise
				// the ground up to the point where 'i' is the first falling
				// chunk,
				// and 'i - 1' is lastLandedChunk.
				//
				// We prefer moving the smaller set of blocks. Thus, if 'i' is
				// the first
				// chunk number which, when it is the first falling, results in
				// more on the
				// ground than in the air, we use ChangeChunk <- i.
				//
				// for 'numChunks', this never happens, and there are always
				// more in the
				// air. Unlikely! For '0', this happens immediately, and there
				// are always
				// more on the ground. Most common case!
				mLastBitmapChunksFalling_drawFallDirectionChangeChunk = 0;
				int inTheAir = 0;
				int onTheGround;
				// as this chunk lands, there are 0 in the air, the specified
				// number on the ground.
				for (int i = slice.getNumChunks() - 1; i >= 0; i--) {
					int chunkNum = i + slice.getFirstChunk();

					// imagine 'chunkNum' is the last falling chunk. At this
					// time, there are
					// (prev. total) + <size of chunkNum> in the air, and
					// (blockfields[chunkNum-1]) on the ground.
					//
					// We guarantee that for i+1, there are more on the ground.
					// We need to
					// check whether the same is true for i. If yes, continue
					// looping.
					// If no, set ChangeChunk to i+1, as it is the first chunk
					// where
					// there are more on the ground.
					//
					// Finally, as a special case, when i == 0 we compare
					// against blockfield 0.
					// By our usage assumptions (empty chunk 0, fall distance
					// -1).

					onTheGround = countNonEmptyBlocks(
							slice.getBlockfields()[i == 0 ? chunkNum
									: chunkNum - 1], 0);
					inTheAir += countNonEmptyBlocks(
							slice.getChunks()[chunkNum], 0);
					// when this chunk is the first the air, this is the number
					// on the air and in the ground.
					// If onTheGround < inTheAir, then we switch AFTER this
					// chunk lands.

					// if there are more in the air NOW
					if (onTheGround < inTheAir) {
						mLastBitmapChunksFalling_drawFallDirectionChangeChunk = i
								+ 1 + slice.getFirstChunk();
						mLastBitmapChunksFalling_drawFallDirectionChangeChunkFallDistance = slice
								.getFallDistances()[mLastBitmapChunksFalling_drawFallDirectionChangeChunk - 1];
						break;
					}
				}
			}
			// log("lastLandedChunk: " + lastLandedChunk +
			// " mLastBitmapChunksFalling_drawFallDirectionChangeChunk " +
			// mLastBitmapChunksFalling_drawFallDirectionChangeChunk) ;
		}

		// update mLastBitmapChunksFalling_drawFallDirectionChangeDistance.
		// We set it to the CURRENT distance fallen, IF we are actually falling
		// (not riseAndFade). Recall that we have set ChangeChunk to the
		// first chunk such that, if it is the first falling chunk, we
		// transition
		// to falling from groundRising. Thus we set groundRising = true if
		// the first falling chunk is < ChangeChunk.
		//
		// 6/13: NOTE: in testing the BACKGROUND_CLIP_IMAGE setting, we must
		// disable
		// rising ground optimization. mLastBitmapCanvas should remain
		// stationary forever;
		// if it changed position we need to COMPLETELY redraw the background,
		// losing any
		// clip benefits we may have gained.
		boolean groundRising = false;
		if ((mDrawSettings.getBlit() != DrawSettings.BLIT_SEPTUPLE)
				&& (!unlocking && !riseAndFade && !mDrawSettings
						.getBehaviorIs_displacement())) {
			if (lastLandedChunk + 1 < mLastBitmapChunksFalling_drawFallDirectionChangeChunk) {
				groundRising = true;
				mLastBitmapChunksFalling_drawFallDirectionChangeDistance = Math
						.round(blocksFallen
								* mDrawSettings.size_blockHeight);
			}

			if (mLastBitmapChunksFalling_animationsFinished && !fieldChanged) {
				groundRising = false;
				mLastBitmapChunksFalling_drawFallDirectionChangeDistance = 0;
				fieldChanged = true; // redraw everything
			}
		}

		// When falling, SEPTUPLE BLIT has some special considerations to make.
		// We handle the
		// VOLATILE bitmaps (representing falling chunks) in two ways. VOLATILE
		// bitmaps hold
		// all chunks currently falling at the time they were last refreshed
		// (more detail later).
		// Upon refresh, we draw all of these chunks at their current "falling"
		// positions, BUT
		// with a vertical offset that puts the lowest nonzero row among them at
		// "row 0 position."
		// We draw these chunks by blitting using a vertical offset which slides
		// the volatile
		// bitmaps downward. When this vertical offset would put the volalite
		// bitmap below the stable
		// ones (even by a 1 pixel offset), we refresh and re-align.
		//
		// Important things to note: when transitioning between chunks, make a
		// note of the "lowest
		// chunk row" among those still falling. This is used to re-align if
		// necessary.
		// We also need to keep track of the "lowest chunk row" used at the time
		// of re-alignment,
		// but that can be stored when re-alignment occurs. Finally, we need to
		// track the
		// vertical offset in use as it changes over time. This is equivalent
		// to:
		// ( blocksFallen - lowestChunkRow ) * size_blockHeight.
		// If this value is > 0 (and there are any chunks left unlanded) it is
		// time to re-align.
		// Again, we re-iterate that "lowestChunkRow" is NOT necessarily the
		// chunk which
		// has the shortest distance to fall, nor is it the chunk which lands
		// the lowest!
		// Consider:
		//
		// Falling from 6 to 0 NO: lands lowest but is currently not the lowest
		// Falling from 3 to 1 YES: is the lowest chunk.
		// Falling from 5 to 4 NO: shortest distance to fall but currently not
		// the lowest
		//
		// As a reminder, chunks are locked at the TERMINAL (post-fall)
		// positions. Aggregated
		// chunks are locked at their position HAVING FALLEN THE SPECIFIED
		// DISTANCE.
		//
		// In short, the information needed to calculate every time a chunk
		// transition occurs:
		//
		// mChunksFallingLowestRowChunk <-- the currently falling chunk which
		// has the lowest row (ties can be broken arbitrarily)
		// mChunksFallingLowestRow <-- the row number AT ITS ORIGINAL POSITION
		// of the bottom row of the chunk specified.
		// mChunksFallingHighestRowChunk <-- the currently falling cunk which
		// has the HIGHEST row (ties can be broken arbitrarily)
		// mChunksFallingHighestRow <-- the row number AT ITS ORIGINAL POSITION
		// of the highest row of the chunk specified.
		//
		// Later on (when drawing) we also set the following:

		// mChunksFallingLowestRowChunk_atLastVolatileAlignment
		// mChunksFallingLowestRow_atLastVolatileAlignment
		// mChunksFallingHighestRowChunk_atLastVolatileAlignment
		// mChunksFallingHighestRow_atLastVolatileAlignment
		//
		// We know it is time to re-align when
		// ( blocksFallen - mChunksFallingLowestRow_atLastVolatileAlignment ) *
		// size_blockHeight > 0
		// as it indicates that 1. the lowest chunk has slipped off the bottom
		// of the screen
		// (probably it was already locked!) and 2. more importantly, any chunks
		// above have not
		// yet been drawn.
		//
		// Note: re-alignment is skipped IFF
		// ( mChunksFallingHighestRow_atLastVolatileAlignment -
		// mChunksFallingLowestRow_atLastVolatileAlignment ) < displayedRows,
		// as it means that all falling chunks were completely drawn within the
		// Volatile bitmap and it does not
		// need re-alignment, and can instead continue to fall through.
		// log("fieldChanged: " + fieldChanged + " sliceStateChanged " +
		// sliceStateChanged + " chunkTransition " + chunkTransition +
		// " blit status " + mDrawSettings.getBlit() ) ;
		if ((fieldChanged || sliceStateChanged || chunkTransition)
				&& mDrawSettings.getBlit() == DrawSettings.BLIT_SEPTUPLE) {
			// find the lowest / highest rows.
			// lastLandedChunk is an actual chunk index.
			mChunksFallingLowestRow = Integer.MAX_VALUE / 10;
			mChunksFallingHighestRow = Integer.MIN_VALUE / 10;
			int firstChunkToCheck = riseAndFade ? 1 : lastLandedChunk + 1;
			for (int i = firstChunkToCheck; i < slice.getNumChunks()
					+ slice.getFirstChunk(); i++) {
				// chunks are locked at their terminal positions - we want their
				// ORIGINAL positions,
				// so remember to offset by fallDistance!

				// log("AlignmentCheck: checking chunk " + i +
				// " with fall distance " + slice.getFallDistances()[i] ) ;

				int lowestRow = Integer.MAX_VALUE;
				for (int row = mDrawSettings.blockFieldOuterBuffer; row < mDrawSettings.ROWS
						+ mDrawSettings.blockFieldOuterBuffer
						&& lowestRow == Integer.MAX_VALUE; row++) {
					for (int col = mDrawSettings.blockFieldOuterBuffer; col < mDrawSettings.COLS
							+ mDrawSettings.blockFieldOuterBuffer
							&& lowestRow == Integer.MAX_VALUE; col++) {
						for (int qp = 0; qp < 2; qp++) {
							if (slice.getChunks()[i][qp][row][col] != QOrientations.NO) {
								lowestRow = row
										- mDrawSettings.blockFieldOuterBuffer;
								break;
							}
						}
					}
				}

				if (lowestRow == Integer.MAX_VALUE)
					continue; // no blocks here that will ever be drawn - it
								// does not land within our view.

				int highestRow = Integer.MIN_VALUE;
				for (int row = mDrawSettings.ROWS
						+ mDrawSettings.blockFieldOuterBuffer - 1; row >= mDrawSettings.blockFieldOuterBuffer
						&& highestRow == Integer.MIN_VALUE; row--) {
					for (int col = mDrawSettings.blockFieldOuterBuffer; col < mDrawSettings.COLS
							+ mDrawSettings.blockFieldOuterBuffer
							&& highestRow == Integer.MIN_VALUE; col++) {
						for (int qp = 0; qp < 2; qp++) {
							if (slice.getChunks()[i][qp][row][col] != QOrientations.NO) {
								highestRow = row
										- mDrawSettings.blockFieldOuterBuffer;
								break;
							}
						}
					}
				}

				// do these beat our records? (offset to their ORIGINAL heights,
				// not destination heights)
				lowestRow += slice.getFallDistances()[i];
				highestRow += slice.getFallDistances()[i];
				if (lowestRow < mChunksFallingLowestRow) {
					mChunksFallingLowestRow = lowestRow;
					mChunksFallingLowestRowChunk = i;
				}
				if (highestRow > mChunksFallingHighestRow) {
					mChunksFallingHighestRow = highestRow;
					mChunksFallingHighestRowChunk = i;
				}
			}
			// log("recalced lowest/highest; now have lowest " +
			// mChunksFallingLowestRow + " to " + mChunksFallingHighestRow) ;
		}

		// determine if re-alignment is needed.
		boolean volatileNeedsAlignment = (fieldChanged || sliceStateChanged)
				&& mChunksFallingLowestRow <= mChunksFallingHighestRow;
		if (!volatileNeedsAlignment && chunkTransition
				&& mChunksFallingLowestRow <= mChunksFallingHighestRow) {
			// we MIGHT need realignment after a chunk transition. As mentioned
			// above, this happens when
			// ( blocksFallen - mChunksFallingLowestRow_atLastVolatileAlignment
			// ) * size_blockHeight > 0
			// IF there are any chunks which would be drawn beyond the top of
			// the window.
			// We err on the side of caution for this.
			if ((blocksFallen - mChunksFallingLowestRow_atLastVolatileAlignment)
					* mDrawSettings.size_blockHeight > 0) {
				// the number of rows in existence at the time volatile was last
				// aligned
				// is mChunksFallingHighestRow_atLastVolatileAlignment -
				// mChunksFallingLowestRow_atLastVolatileAlignment.
				// If this is >= displayedRows - 1, there is a danger that we
				// need a redraw.
				if (mChunksFallingHighestRow_atLastVolatileAlignment
						- mChunksFallingLowestRow_atLastVolatileAlignment >= mDrawSettings.displayedRows - 1) {
					volatileNeedsAlignment = true;
				}
			}
		}

		// Align, my child! This is step 1. Step 2 happens in clip / draw code.
		if (volatileNeedsAlignment) {
			mChunksFallingLowestRow_atLastVolatileAlignment = mChunksFallingLowestRow;
			mChunksFallingLowestRowChunk_atLastVolatileAlignment = mChunksFallingLowestRowChunk;
			mChunksFallingHighestRow_atLastVolatileAlignment = mChunksFallingHighestRow;
			mChunksFallingHighestRowChunk_atLastVolatileAlignment = mChunksFallingHighestRowChunk;
		}

		// Here's where we calculate shadows, corners and glows.
		// Shadows and corners need to be recalculated every time the field
		// composition changes (including chunks attaching to each other).
		// This happens when chunkTransition or fieldChanged. We keep two sets
		// of shadows / corners: one indicating the "locked" and stationary
		// blocks, and another giving the blocks which have yet to lock in
		// place. Important note: although we can safely draw the fill/top
		// areas of a "combined" field giving all falling pieces, we need
		// to compute shadows and corners independently: since some chunks may
		// become unlocked from others, and thus fall different distances
		// despite
		// appearing connected, we need to ensure they have a border and a
		// shadow.
		// However, because these piece don't actually overlap, we can store the
		// calculated border-and-shadow information in one structure and draw
		// it in a single pass.
		if ((chunkTransition || fieldChanged || sliceStateChanged)
				&& mDrawSettings.getBlit() != DrawSettings.BLIT_SEPTUPLE) {

			tick();

			byte[][][] field;
			byte[][][][] corners;
			short[][][] shadows;
			short[][][][] drop;

			// determine which chunks have landed (could be none, if we're still
			// unlocking). Set FIELD corners and shadows to those that have
			// locked,
			// and CHUNKS to those which have not. Remember the note above about
			// corners between different chunks!
			int firstFalling = lastLandedChunk + 1;
			/*
			 * for ( firstFalling = slice.getFirstChunk() + 1; firstFalling <
			 * slice.getNumChunks() + slice.getFirstChunk(); firstFalling++ ) {
			 * if ( riseAndFade || blocksFallen <=
			 * slice.getFallDistances()[firstFalling] ) break ; }
			 */

			// set extended to be extended by
			// mLastBitmapChunksFalling_drawFallDirectionChangeChunkFallDistance
			mConfigRangeExtended
					.set(mDrawSettings.displayedRows
							+ mLastBitmapChunksFalling_drawFallDirectionChangeChunkFallDistance,
							mDrawSettings.COLS);

			// log("blocksFallen:" + blocksFallen + ", firstFalling:" +
			// firstFalling + " numChunks:" + slice.getNumChunks() +
			// " firstChunk:" + slice.getFirstChunk() ) ;
			// the field we use is firstFalling-1.
			field = slice.getBlockfields()[firstFalling - 1];
			corners = mLastCorners_byField_byPaneCorner
					.get(INDEX_FIELD_FALLING_FIELD);
			shadows = mLastFillShadowSets_byField_byPane
					.get(INDEX_FIELD_FALLING_FIELD);
			drop = mLastDropShadowSets_byField_byPane_byUniqueColor
					.get(INDEX_FIELD_FALLING_FIELD);
			setShadowsAndCorners(mDrawSettings, field, mConfigRangeExtended,
					shadows, drop, corners);

			byte[][][][] qoCorners = this.mLastQOConnectedCorners_byField_byPaneCorner
					.get(INDEX_FIELD_FALLING_FIELD);
			short[][][] qoSets = this.mLastQOConnectedSets_byField_byPane
					.get(INDEX_FIELD_FALLING_FIELD);
			setQOConnectionAndCorners(mDrawSettings, field,
					mConfigRangeExtended, qoSets, qoCorners);

			// here's where we store shadows and corners. Note that
			// there will not be any collisions between different chunks,
			// IF we process them all at the same height. Use the 'landing'
			// height of the first falling block.

			// finally, a note on "unlocking:" for most blits we will be drawing
			// it in one pass,
			// using "pre" for fills and FIELD_FALLING_FIELD for corners and
			// shadows. Thus, we
			// need even the falling block
			// corner and shadow information in the FIELD sets, not just the
			// CHUNK sets (this is to
			// allow a single-pass draw).
			// However, for SEPTUPLE_BLIT, we use the same segregated draws as
			// before.
			if (!unlocking || mDrawSettings.getBlit() == DrawSettings.BLIT_SEPTUPLE) {
				corners = mLastCorners_byField_byPaneCorner
						.get(INDEX_FIELD_FALLING_CHUNKS);
				shadows = mLastFillShadowSets_byField_byPane
						.get(INDEX_FIELD_FALLING_CHUNKS);
				drop = mLastDropShadowSets_byField_byPane_byUniqueColor
						.get(INDEX_FIELD_FALLING_CHUNKS);
				qoCorners = mLastQOConnectedCorners_byField_byPaneCorner
						.get(INDEX_FIELD_FALLING_CHUNKS);
				qoSets = mLastQOConnectedSets_byField_byPane
						.get(INDEX_FIELD_FALLING_CHUNKS);
				for (int qp = 0; qp < 2; qp++)
					for (int i = 0; i < 4; i++) {
						ArrayOps.fill(corners[qp][i], (byte) -1);
						ArrayOps.fill(qoCorners[qp][i], (byte) -1);
					}
				ArrayOps.fill(shadows, SHADOW_SET_INDEX_NONE);
				ArrayOps.fill(drop, SHADOW_SET_INDEX_NONE);
				ArrayOps.fill(qoSets, SHADOW_SET_INDEX_NONE);
			}

			if (firstFalling <= slice.getNumChunks() + slice.getFirstChunk()) {
				int relativeFallDistance = unlocking ? 0 : slice
						.getFallDistances()[firstFalling];
				byte[][][][] tempCorners = mLastCorners_byField_byPaneCorner
						.get(INDEX_FIELD_FALLING_WORKING_SPACE);
				short[][][] tempShadows = mLastFillShadowSets_byField_byPane
						.get(INDEX_FIELD_FALLING_WORKING_SPACE);
				byte[][][][] tempQOCorners = mLastQOConnectedCorners_byField_byPaneCorner
						.get(INDEX_FIELD_FALLING_WORKING_SPACE);
				short[][][] tempQOSets = mLastQOConnectedSets_byField_byPane
						.get(INDEX_FIELD_FALLING_WORKING_SPACE);

				for (int i = firstFalling; i < slice.getNumChunks()
						+ slice.getFirstChunk(); i++) {
					field = slice.getChunks()[i];
					// shadows and corners for this chunk?
					setShadowsAndCorners(mDrawSettings, field,
							mConfigRangeExtended, tempShadows, null,
							tempCorners);
					setQOConnectionAndCorners(mDrawSettings, field,
							mConfigRangeExtended, tempQOSets, tempQOCorners);
					// shadows and corners are set at the chunk's ultimate
					// position.
					// set them to match the first falling chunk's ultimate
					// position
					int offset = slice.getFallDistances()[i]
							- relativeFallDistance;
					// place them this many rows higher.
					for (int qp = 0; qp < 2; qp++) {
						int R = Math
								.min(tempCorners[0][0].length,
										mDrawSettings.displayedRows
												- offset
												+ mDrawSettings.blockFieldOuterBuffer
												* 2
												+ mLastBitmapChunksFalling_drawFallDirectionChangeChunkFallDistance);
						for (int r = 0; r < R; r++) {
							for (int c = 0; c < mDrawSettings.COLS
									+ mDrawSettings.blockFieldOuterBuffer * 2; c++) {
								for (int corner = 0; corner < 4; corner++) {
									if (tempCorners[qp][corner][r][c] != -1)
										corners[qp][corner][r + offset][c] = tempCorners[qp][corner][r][c];
									if (tempQOCorners[qp][corner][r][c] != -1)
										qoCorners[qp][corner][r + offset][c] = tempQOCorners[qp][corner][r][c];
								}
								if (tempShadows[qp][r][c] != SHADOW_SET_INDEX_NONE)
									shadows[qp][r + offset][c] = tempShadows[qp][r][c];
								if (tempQOSets[qp][r][c] != SHADOW_SET_INDEX_NONE)
									qoSets[qp][r + offset][c] = tempQOSets[qp][r][c];
							}
						}
					}
				}

				// we would like drop shadows positioned at the same offset as
				// our corners and such - the firstFalling chunk's
				// ultimate position. Luckily, they are already in that
				// position, in firstFallingChunk's aggregated chunk.
				field = slice.getChunksAggregated()[firstFalling];
				drop = mLastDropShadowSets_byField_byPane_byUniqueColor
						.get(INDEX_FIELD_FALLING_CHUNKS);
				setShadowsAndCorners(mDrawSettings, field,
						mConfigRangeExtended, null, drop, null);
			}

			mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_SET_SHADOWS_AND_CORNERS] += tock();
		} else if ((chunkTransition || fieldChanged || sliceStateChanged)
				&& mDrawSettings.getBlit() == DrawSettings.BLIT_SEPTUPLE) {
			tick();

			// set extended to be extended by
			// mLastBitmapChunksFalling_drawFallDirectionChangeChunkFallDistance
			mConfigRangeExtended
					.set(mDrawSettings.displayedRows
							+ mLastBitmapChunksFalling_drawFallDirectionChangeChunkFallDistance,
							mDrawSettings.COLS);

			byte[][][] field;
			byte[][][][] corners;
			short[][][] shadows;
			short[][][][] drop;

			// determine which chunks have landed (could be none, if we're still
			// unlocking). Set FIELD corners and shadows to those that have
			// locked,
			// and CHUNKS to those which have not. Remember the note above about
			// corners between different chunks!
			int firstFalling = lastLandedChunk + 1;
			/*
			 * for ( firstFalling = slice.getFirstChunk() + 1; firstFalling <
			 * slice.getNumChunks() + slice.getFirstChunk(); firstFalling++ ) {
			 * if ( riseAndFade || blocksFallen <=
			 * slice.getFallDistances()[firstFalling] ) break ; }
			 */

			// log("blocksFallen:" + blocksFallen + ", firstFalling:" +
			// firstFalling + " numChunks:" + slice.getNumChunks() +
			// " firstChunk:" + slice.getFirstChunk() ) ;
			// the field we use is firstFalling-1.
			field = slice.getBlockfields()[firstFalling - 1];
			corners = mLastCorners_byField_byPaneCorner
					.get(INDEX_FIELD_FALLING_FIELD);
			shadows = mLastFillShadowSets_byField_byPane
					.get(INDEX_FIELD_FALLING_FIELD);
			drop = mLastDropShadowSets_byField_byPane_byUniqueColor
					.get(INDEX_FIELD_FALLING_FIELD);
			setShadowsAndCorners(mDrawSettings, field, mConfigRangeStandard,
					shadows, drop, corners);

			byte[][][][] qoCorners = this.mLastQOConnectedCorners_byField_byPaneCorner
					.get(INDEX_FIELD_FALLING_FIELD);
			short[][][] qoSets = this.mLastQOConnectedSets_byField_byPane
					.get(INDEX_FIELD_FALLING_FIELD);
			setQOConnectionAndCorners(mDrawSettings, field,
					mConfigRangeExtended, qoSets, qoCorners);

			// here's where we store shadows and corners. Note that
			// there will not be any collisions between different chunks,
			// IF we process them all at the same height. Use the 'landing'
			// height of the first falling block.

			// BTW, why give SEPTUPLE special treatment? Because of the way it
			// renders falling
			// and unlocking chunks. In particular, we need to collect corner
			// and shadow information
			// about each chunk and store it at its AGGREGATED (NOT pre-fall!)
			// height.
			corners = mLastCorners_byField_byPaneCorner
					.get(INDEX_FIELD_FALLING_CHUNKS);
			shadows = mLastFillShadowSets_byField_byPane
					.get(INDEX_FIELD_FALLING_CHUNKS);
			qoCorners = mLastQOConnectedCorners_byField_byPaneCorner
					.get(INDEX_FIELD_FALLING_CHUNKS);
			qoSets = mLastQOConnectedSets_byField_byPane
					.get(INDEX_FIELD_FALLING_CHUNKS);
			for (int qp = 0; qp < 2; qp++)
				for (int i = 0; i < 4; i++) {
					ArrayOps.fill(corners[qp][i], (byte) -1);
					ArrayOps.fill(qoCorners[qp][i], (byte) -1);
				}
			ArrayOps.fill(shadows, SHADOW_SET_INDEX_NONE);
			ArrayOps.fill(qoSets, SHADOW_SET_INDEX_NONE);

			// shadows/corners get set with a unique number of extra rows.
			tempConfigRange.set(
					mDrawSettings.displayedRows
							+ Math.max(0,
									mChunksFallingHighestRowChunk_atLastVolatileAlignment
											- mDrawSettings.displayedRows),
					mDrawSettings.COLS);

			if (firstFalling <= slice.getNumChunks() + slice.getFirstChunk()) {
				int relativeFallDistance = slice.getFallDistances()[firstFalling];
				byte[][][][] tempCorners = mLastCorners_byField_byPaneCorner
						.get(INDEX_FIELD_FALLING_WORKING_SPACE);
				short[][][] tempShadows = mLastFillShadowSets_byField_byPane
						.get(INDEX_FIELD_FALLING_WORKING_SPACE);
				byte[][][][] tempQOCorners = this.mLastQOConnectedCorners_byField_byPaneCorner
						.get(INDEX_FIELD_FALLING_WORKING_SPACE);
				short[][][] tempQOSets = this.mLastQOConnectedSets_byField_byPane
						.get(INDEX_FIELD_FALLING_WORKING_SPACE);
				for (int i = firstFalling; i < slice.getNumChunks()
						+ slice.getFirstChunk(); i++) {
					field = slice.getChunks()[i];

					// shadows and corners for this chunk?
					setShadowsAndCorners(mDrawSettings, field, tempConfigRange,
							tempShadows, null, tempCorners);
					setQOConnectionAndCorners(mDrawSettings, field,
							mConfigRangeExtended, tempQOSets, tempQOCorners);

					// shadows and corners are set at the chunk's ultimate
					// position.
					// set them to match the first falling chunk's ultimate
					// position
					int offset = slice.getFallDistances()[i]
							- relativeFallDistance;
					// place them this many rows higher.
					for (int qp = 0; qp < 2; qp++) {
						int R = Math
								.min(tempCorners[0][0].length,
										mDrawSettings.displayedRows
												- offset
												+ mDrawSettings.blockFieldOuterBuffer
												* 2
												+ mLastBitmapChunksFalling_drawFallDirectionChangeChunkFallDistance);
						for (int r = 0; r < R; r++) {
							for (int c = 0; c < mDrawSettings.COLS
									+ mDrawSettings.blockFieldOuterBuffer * 2; c++) {
								for (int corner = 0; corner < 4; corner++) {
									if (tempCorners[qp][corner][r][c] != -1)
										corners[qp][corner][r + offset][c] = tempCorners[qp][corner][r][c];
									if (tempQOCorners[qp][corner][r][c] != -1)
										qoCorners[qp][corner][r + offset][c] = tempQOCorners[qp][corner][r][c];
								}
								if (tempShadows[qp][r][c] != SHADOW_SET_INDEX_NONE)
									shadows[qp][r + offset][c] = tempShadows[qp][r][c];
								if (tempQOSets[qp][r][c] != SHADOW_SET_INDEX_NONE)
									qoSets[qp][r + offset][c] = tempQOSets[qp][r][c];
							}
						}
					}
				}

				// we would like drop shadows positioned at the same offset as
				// our corners and such - the firstFalling chunk's
				// ultimate position. Luckily, they are already in that
				// position, in firstFallingChunk's aggregated chunk.
				field = slice.getChunksAggregated()[firstFalling];
				drop = mLastDropShadowSets_byField_byPane_byUniqueColor
						.get(INDEX_FIELD_FALLING_CHUNKS);
				setShadowsAndCorners(mDrawSettings, field, tempConfigRange,
						null, drop, null);
			}

			mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_SET_SHADOWS_AND_CORNERS] += tock();
		}

		// okay, we have corners and shadows. Now calculate glows. There are two
		// basic sets of
		// glows: those used for column unlocks and those for piece locks.
		// Remember, we only
		// need to calculate this once!

		// We store the "unlock" glows at index 0, and the fall-and-lock glows
		// at 1 + the difference
		// between the chunk index and the first chunk.
		if (fieldChanged || sliceStateChanged) {
			tick();
			long unlockGlowDuration = 0;
			for (int i = 0; i < mDrawSettings.glow_alphaPeakNormalized[Consts.GLOW_UNLOCK].length; i++) {
				unlockGlowDuration = Math
						.max(unlockGlowDuration,
								animationSettings
										.unlockColumnGlowTotalTime(
												0,
												mDrawSettings.glow_alphaPeakNormalized[Consts.GLOW_UNLOCK][i],
												0));
			}
			long lockGlowDuration = 0;
			for (int i = 0; i < mDrawSettings.glow_alphaPeakNormalized[Consts.GLOW_LOCK].length; i++) {
				lockGlowDuration = Math
						.max(lockGlowDuration,
								animationSettings
										.lockGlowTimeToFinish(
												0,
												mDrawSettings.glow_alphaPeakNormalized[Consts.GLOW_LOCK][i],
												0));
			}

			boolean hasUnlockGlows = false;
			for (int qp = 0; qp < 2; qp++) {
				// get the unlock glows for index 0.
				if ((qp == 0 && mDrawSettings.drawQ0)
						|| (qp == 1 && mDrawSettings.drawQ1)) {
					int numUnlockGlows = addColumnUnlockGlows(mDrawSettings,
							slice.getBlockfields(), slice.getChunks(),
							slice.getFallDistances(), qp,
							slice.getFirstChunk(), slice.getNumChunks(),
							slice.getUnlockedColumns(),
							slice.getNumUnlockedColumns(), mLastEffectsGlow, 0,
							unlockGlowDuration,
							PieceCatalog.getQCombination(slice.getPieceType()),
							0);
					hasUnlockGlows = hasUnlockGlows || numUnlockGlows > 0;
				}
			}
			if (hasUnlockGlows)
				mLastEffectsSound.addColumnUnlocked(
						BlockDrawerSliceTime.RelativeTo.SLICE, 0,
						slice.getPieceType());

			// now get the piece locking chunks. Important note: our flood
			// operation will sometimes
			// produce 0 glows (e.g., with UL blocks). This is fine; we just
			// won't animate anything
			// for them. However, some chunks may or may not glow for a
			// reason independent of
			// their block content: for example, a fall of 0 will produce a
			// glow IF the chunks are
			// piece components; otherwise, there will be no glow.
			if (!riseAndFade) {
				for (int i = 0; i < slice.getNumChunks(); i++) {
					byte chunk[][][] = slice.getChunks()[i
							+ slice.getFirstChunk()];
					byte field[][][] = slice.getBlockfields()[i
							+ slice.getFirstChunk()];
					int dist = slice.getFallDistances()[i
							+ slice.getFirstChunk()];
					if (dist > 0
							|| (dist == 0 && slice
									.getChunksArePieceComponents())) {

						long timeLanded = unlockingTime
								+ animationSettings.fall_timeToFallDistance[slice
										.getFallDistances()[i
										+ slice.getFirstChunk()]];

						boolean hasLockGlows = false;
						for (int qp = 0; qp < 2; qp++) {
							if ((qp == 0 && mDrawSettings.drawQ0)
									|| (qp == 1 && mDrawSettings.drawQ1)) {
								int numLockGlows = addLockGlows(mDrawSettings,
										chunk, field, qp,
										!slice.getChunksArePieceComponents(),
										mLastEffectsGlow,
										Math.max(1, timeLanded),
										lockGlowDuration, 0);
								hasLockGlows = hasLockGlows || numLockGlows > 0;
							}
						}

						if (hasLockGlows)
							mLastEffectsSound.addLock(
									BlockDrawerSliceTime.RelativeTo.SLICE, timeLanded,
									slice.getPieceType(),
									slice.getChunksArePieceComponents(), 0); // TODO:
																				// Put
																				// in
																				// actual
																				// QCombination.
						else
							mLastEffectsSound.addLand(
									BlockDrawerSliceTime.RelativeTo.SLICE, timeLanded,
									slice.getPieceType(),
									slice.getChunksArePieceComponents(), 0); // TODO:
																				// Put
																				// in
																				// actual
																				// QCombination.
					}
				}
			} else {
				mLastEffectsSound.addRiseAndFade(
						BlockDrawerSliceTime.RelativeTo.SLICE, 0,
						slice.getPieceType());
			}

			mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_SET_EFFECTS] += tock();
		}

		int height = mDrawSettings.height;
		int blitHeight = mDrawSettings.configCanvas.region.height();
		boolean doneLocking = false;
		boolean doubleBitmapOffset = mLastBitmap != null
				&& mDrawSettings.drawAnimations >= DrawSettings.DRAW_ANIMATIONS_STABLE_STUTTER
				&& mDrawSettings.getBlit() != DrawSettings.BLIT_SEPTUPLE
				&& !mDrawSettings.getBehaviorIs_displacement();

		// for clipping, we need to extend the clip by a certain distance
		// from each altered block. This lets us draw and re-draw our drop
		// shadow,
		// which extends slightly beyond the reach of each block.
		int extendByPixels = Math.max(boundDropShadowHeight(mDrawSettings),
				boundDropShadowWidth(mDrawSettings));

		long fallingTimeLast = sliceTime.hasBeenDrawnEver() ? sliceTime
				.getLastDrawnSlice() - unlockingTime : 0;
		float blocksFallenLast = fallingTimeLast <= 0 ? 0 : animationSettings
				.distanceFallen(fallingTimeLast);
		float blocksRisenLast = fallingTimeLast <= 0 ? 0 : animationSettings
				.riseFadeDistanceRisen(fallingTimeLast, maxRiseFadeHeight);
		if (sliceStateChanged) {
			blocksFallenLast = 0;
			blocksRisenLast = 0;
		}

		int pixelsFallen = Math.round(blocksFallen
				* mDrawSettings.size_blockHeight);
		int pixelsFallenLast = Math.round(blocksFallenLast
				* mDrawSettings.size_blockHeight);
		int pixelsRisen = Math.round(blocksRisen
				* mDrawSettings.size_blockHeight);
		int pixelsRisenLast = Math.round(blocksRisenLast
				* mDrawSettings.size_blockHeight);

		int firstChunk = lastLandedChunk + 1;

		// SET ALIGNMENT AND CLIP TOUCHED / COVERED AREAS. If the actual region
		// changed, we need to reset the region. Otherwise, we MIGHT need to
		// offset
		// the regions up or down, depending on our draw style.
		// One final note: for FULL, this can leave the stable region
		// offset from the ground, so be careful of that.
		if (fieldChanged || sliceStateChanged || startedUnlocking
				|| mLastBitmapVeiled || mLastBitmapDifferentDisplacement|| chunkTransition) {

			setAlignmentOffset(slice.getBlockfieldStable(), clipOffset);
			if (doubleBitmapOffset)
				clipOffset.y += height;

			int stableYExtra = 0, volatileYExtra = 0;
			switch (mDrawSettings.getBlit()) {
			case DrawSettings.BLIT_SEPTUPLE:
				stableYExtra = 0;
				volatileYExtra = mDrawSettings.size_blockHeight
						* (mChunksFallingLowestRow_atLastVolatileAlignment - (firstChunk < slice
								.getNumChunks() + slice.getFirstChunk() ? slice
								.getFallDistances()[firstChunk] : 0));
				break;

			case DrawSettings.BLIT_FULL:
			case DrawSettings.BLIT_NONE:
				// NOTE: Full and QuarterSize actual have more complex behavior:
				// e.g.,
				// they might rise the stable area if 'groundRising' is true. We
				// perform
				// the adjustment later.
				stableYExtra = 0;
				if (riseAndFade) {
					volatileYExtra = 0;
				} else {
					volatileYExtra = -slice.getFallDistances()[firstChunk]
							* mDrawSettings.size_blockHeight;
				}
				break;
			}

			// Clip Touched & Stable
			if (fieldChanged || sliceStateChanged || startedUnlocking
					|| mLastBitmapVeiled) {
				// Clip covered and touched content in stable (volatile will
				// be handled in volatileNeedsAlignment)
				drawChunksFallingWithLastSlice_helperClipCoveredStable(slice,
						clipOffset, lastLandedChunk, stableYExtra);
				drawChunksFallingWithLastSlice_helperClipTouchedStable(slice,
						clipOffset, lastLandedChunk, stableYExtra,
						extendByPixels, true);
			}

			if (chunkTransition) {
				// we also need a coverage / touching update.
				drawChunksFallingWithLastSlice_helperClipCoveredStable(slice,
						clipOffset, lastLandedChunk, stableYExtra);
				drawChunksFallingWithLastSlice_helperClipTouchedStable(slice,
						clipOffset, lastLandedChunk, stableYExtra,
						extendByPixels, true);
				drawChunksFallingWithLastSlice_helperClipCoveredVolatile(slice,
						clipOffset, lastLandedChunk, volatileYExtra);
				drawChunksFallingWithLastSlice_helperClipTouchedVolatile(slice,
						clipOffset, lastLandedChunk, volatileYExtra,
						extendByPixels);
			}
		}

		int regionStableYExtra, regionVolatileYExtra;

		if (!this.willDrawVeilPixels(sliceTime) || !mLastBitmapVeiled
				|| fieldChanged || sliceStateChanged
				|| !sliceTime.hasBeenDrawnAtThisSliceTime()) {
			// If using BLIT_FULL, we set offsets to match the mLast, clip
			// according
			// to changes, draw to mLastBitmap and finally blit to the canvas.
			// If
			// using BLIT_NONE, we set offset to match the canvas, clip UNION
			// the
			// pulses (assuming an appropriate clip is already in place), and
			// draw
			// directly to the canvas.
			switch (mDrawSettings.getBlit()) {
			case DrawSettings.BLIT_SEPTUPLE:
				// set offsets
				canvasTranslationOffset.x = 0;
				canvasTranslationOffset.y = 0;

				if (fieldChanged || alignmentOffsetSet || sliceStateChanged) {
					setAlignmentOffset(slice.getBlockfieldStable(), clipOffset);
					canvasAlignmentOffset.takeVals(alignmentOffset);

					alignmentOffsetSet = false;
				}

				// offsets?
				int volatileOffset = -(int) Math
						.round((blocksFallen
								- mChunksFallingLowestRow_atLastVolatileAlignment - blocksRisen)
								* mDrawSettings.size_blockHeight);
				int volatileOffsetLast = -(int) Math
						.round((blocksFallenLast
								- mChunksFallingLowestRow_atLastVolatileAlignment + blocksRisenLast)
								* mDrawSettings.size_blockHeight);

				// clip
				tick(); // nest 1
				// We need to draw-clip EVERYTHING, both stable and volatile.
                reset(mLastBitmapClipPath);
				if (fieldChanged || sliceStateChanged || startedUnlocking
						|| mLastBitmapVeiled) {
					// we redraw the entire field (and chunks). Note that
					// 'volatileNeedsAlignment' is a
					// superset of this, so we are guaranteed to redraw our
					// volatile pieces.
					// We need to draw-clip EVERYTHING, both stable and
					// volatile.
					for (int i = 0; i < mLastBitmap.length; i++) {
                        unionRect(mLastBitmapClipPath[i], 0, 0,
                                mLastBitmapBounds[i].width(),
                                mLastBitmapBounds[i].height(),
                                Path.Direction.CW);
                    }

					mChunksFallingLastChunkHandled = 0;
				}

				if (volatileNeedsAlignment) {
					// redraw the ENTIRE volatile image, along with the full
					// bitmap.
                    reset(mLastBitmapClipPath[BITMAP_FULL]);
                    reset(mLastBitmapClipPath[BITMAP_SEPTUPLE_Q0_VOLATILE]);
                    reset(mLastBitmapClipPath[BITMAP_SEPTUPLE_Q1_VOLATILE]);
                    reset(mLastBitmapClipPath[BITMAP_SEPTUPLE_3D_VOLATILE]);

                    unionRect(mLastBitmapClipPath[BITMAP_FULL], 0, 0,
							mLastBitmapBounds[BITMAP_FULL].width(),
							mLastBitmapBounds[BITMAP_FULL].height(),
							Path.Direction.CW);
					unionRect(mLastBitmapClipPath[BITMAP_SEPTUPLE_Q0_VOLATILE], 0,0, 
                            mLastBitmapBounds[BITMAP_SEPTUPLE_Q0_VOLATILE].width(),
							mLastBitmapBounds[BITMAP_SEPTUPLE_Q0_VOLATILE].height(), 
                            Path.Direction.CW);
					unionRect(mLastBitmapClipPath[BITMAP_SEPTUPLE_Q1_VOLATILE], 0, 0, 
                            mLastBitmapBounds[BITMAP_SEPTUPLE_Q1_VOLATILE].width(),
							mLastBitmapBounds[BITMAP_SEPTUPLE_Q1_VOLATILE].height(), 
                            Path.Direction.CW);
					unionRect(mLastBitmapClipPath[BITMAP_SEPTUPLE_3D_VOLATILE], 0,0, 
                            mLastBitmapBounds[BITMAP_SEPTUPLE_3D_VOLATILE].width(),
							mLastBitmapBounds[BITMAP_SEPTUPLE_3D_VOLATILE].height(), 
                            Path.Direction.CW);
				}

				if (chunkTransition) {
					// log("chunkTransition.  firstChunk is " +
					// firstChunk ) ;
					for (int chunkNum = mChunksFallingLastChunkHandled + 1; chunkNum < firstChunk; chunkNum++) {
					    log("chunkTransition; clipping for chunkNum " + chunkNum + " which just locked");
						// a chunk transition that does NOT cause a
						// re-alignment. One of the chunks has just landed!
						// We clip the content of that chunk (extendBy in place,
						// of course) and then cover/touched the new area.
						for (int qp = 0; qp < 3; qp++) {
							int qPane, BMAP, BMAP_STABLE;
							if (qp == 0) {
								qPane = Consts.QPANE_0;
								BMAP = BITMAP_SEPTUPLE_Q0_VOLATILE;
								BMAP_STABLE = BITMAP_SEPTUPLE_Q0_STABLE;
							} else if (qp == 1) {
								qPane = Consts.QPANE_1;
								BMAP = BITMAP_SEPTUPLE_Q1_VOLATILE;
								BMAP_STABLE = BITMAP_SEPTUPLE_Q1_STABLE;
							} else {
								qPane = Consts.QPANE_3D;
								BMAP = BITMAP_SEPTUPLE_3D_VOLATILE;
								BMAP_STABLE = BITMAP_SEPTUPLE_3D_STABLE;
							}

							// Note: previously, we clipped the chunk and
							// applied that region to STABLE and FULL,
							// along with (translated) its previous location in
							// STABLE, FULL and VOLATILE. We
							// still handle its previous location as mentioned,
							// but this produced a visual bug
							// for its new location - although we draw the chunk
							// itself, we fail to update any
							// blocks which may be affected by the new chunk,
							// e.g. existing shadows and borders.
							// Instead, clip the conservative difference between
							// the old blockfield and the new one.
							reset(clipPath);
							this.clipConservativeDifference(clipPath,
									slice.getBlockfields()[chunkNum],
									slice.getBlockfields()[chunkNum - 1],
									qPane, 0, alignmentOffset, extendByPixels);
							op(mLastBitmapClipPath[BITMAP_FULL], clipPath, Path.Op.UNION);
							op(mLastBitmapClipPath[BMAP_STABLE], clipPath, Path.Op.UNION);

							// remember, we align to put
							// mChunksFallingLowestRow_atLastVolatileAlignment
							// at row position 0.
							// we do the offset in a bit.
							reset(clipPath);
							this.clipContentUnion(
									clipPath,
									slice.getChunks()[chunkNum],
									qPane,
									Math.max(
											0,
											mChunksFallingHighestRow_atLastVolatileAlignment
													- mDrawSettings.displayedRows), // extra
																					// rows?
									alignmentOffset, extendByPixels);

							// Clip its position in VOLATILE as well. Where is
							// it, exactly?
							// it was drawn such that
							// mChunksFallingLowestRow_atLastVolatileAlignment
							// had row position 0. Try offsetting upward
							// (negative) by the distance
							// this chunk has fallen, to put it at its starting
							// position, then offset
							// downward (positive) by
							// mChunksFallingLowestRow_atLastVolatileAlignment.
							int vChunkOffset = mDrawSettings
									.size_blockHeight
									* (mChunksFallingLowestRow_atLastVolatileAlignment - slice
											.getFallDistances()[chunkNum]);
							// log("chunkTransition.  firstChunk is " +
							// firstChunk-1 + ", vChunkOffset is " +
							// vChunkOffset) ;
							clipPath.offset(0, vChunkOffset);
							op(mLastBitmapClipPath[BMAP], clipPath, Path.Op.UNION);
							clipPath.offset(0, -vChunkOffset);
							// Finally, note that this chunk was drawn via
							// VOLATILE to the
							// appropriate location last tick. That location is
							// slightly above
							// its landed position by the difference between
							// blocksFallingLast
							// its total fall distance.
							vChunkOffset = (int) Math.round(mDrawSettings
									.size_blockHeight
									* (blocksFallenLast - slice
											.getFallDistances()[chunkNum]));
							clipPath.offset(0, vChunkOffset);
							op(mLastBitmapClipPath[BITMAP_FULL], clipPath, Path.Op.UNION);
						}
					}

					mChunksFallingLastChunkHandled = firstChunk - 1;
				}

				// Now for general, every tick updates. If last offset and this
				// offset differ, clip the conservative
				// difference in FULL (we do NOT need to clip the difference in
				// VOLATILE - if its contents changed
				// and must be redrawn, that clip has already occurred).
				if (volatileOffset != volatileOffsetLast
						&& firstChunk < slice.getNumChunks()
								+ slice.getFirstChunk() && !riseAndFade) {
					tempOffset.takeVals(alignmentOffset);
					tempOffset2.takeVals(alignmentOffset);

					// What height these offsets? Well, aggregatedChunks[X] are
					// represented having fallen fallDistances[X]. We need to
					// move
					// it back up by the difference between that number and its
					// "blocksFallen"
					// number.

					tempOffset.y -= Math
							.round((slice.getFallDistances()[firstChunk] - blocksFallenLast)
									* mDrawSettings.size_blockHeight);
					tempOffset2.y -= Math
							.round((slice.getFallDistances()[firstChunk] - blocksFallen)
									* mDrawSettings.size_blockHeight);
					reset(clipPath);
					clipConservativeDifference(clipPath,
							slice.getChunksAggregated()[firstChunk],
							slice.getChunksAggregated()[firstChunk], Math.max(
									0,
									mChunksFallingHighestRow_atLastVolatileAlignment
											- mDrawSettings.displayedRows), // extra
																			// rows
							tempOffset, tempOffset2, extendByPixels);
					op(mLastBitmapClipPath[BITMAP_FULL], clipPath, Path.Op.UNION);
					// yup.
					// Log.d( TAG, "offset by " + tempOffset +
					// " compared to last at " + tempOffset2 + " has bounds " +
					// clipPath.getBounds() ) ;
				}

				if (firstChunk < slice.getNumChunks() + slice.getFirstChunk()
						&& riseAndFade) {
					tempOffset.takeVals(alignmentOffset);
					tempOffset2.takeVals(alignmentOffset);
					tempOffset.y -= Math
							.round((slice.getFallDistances()[firstChunk] + blocksRisenLast)
									* mDrawSettings.size_blockHeight);
					tempOffset2.y -= Math
							.round((slice.getFallDistances()[firstChunk] + blocksRisen)
									* mDrawSettings.size_blockHeight);

					// Clip the entire chunk at its current position and its
					// last position.
					this.clipContentUnion(mLastBitmapClipPath[BITMAP_FULL],
							slice.getChunks()[firstChunk], tempOffset,
							extendByPixels);
					this.clipContentUnion(mLastBitmapClipPath[BITMAP_FULL],
							slice.getChunks()[firstChunk], tempOffset2,
							extendByPixels);
				}

				// we also clip all pulsing blocks, both in stable and volatile.
				reset(clipPath);
				boolean pulseQ0Stable = clipPulseFill(clipPath,
						slice.getBlockfields()[firstChunk - 1], Consts.QPANE_0,
						0, alignmentOffset);
				op(mLastBitmapClipPath[BITMAP_SEPTUPLE_Q0_STABLE], clipPath, Path.Op.UNION);
				op(mLastBitmapClipPath[BITMAP_FULL], clipPath, Path.Op.UNION);

				reset(clipPath);
				boolean pulseQ1Stable = clipPulseFill(clipPath,
						slice.getBlockfields()[firstChunk - 1], Consts.QPANE_1,
						0, alignmentOffset);
				op(mLastBitmapClipPath[BITMAP_SEPTUPLE_Q1_STABLE], clipPath, Path.Op.UNION);
				op(mLastBitmapClipPath[BITMAP_FULL], clipPath, Path.Op.UNION);

				reset(clipPath);
				boolean pulse3DStable = clipPulseFill(clipPath,
						slice.getBlockfields()[firstChunk - 1],
						Consts.QPANE_3D, 0, alignmentOffset);
				op(mLastBitmapClipPath[BITMAP_SEPTUPLE_3D_STABLE], clipPath, Path.Op.UNION);
				op(mLastBitmapClipPath[BITMAP_FULL], clipPath, Path.Op.UNION);

				boolean pulseQ0Volatile = false;
				boolean pulseQ1Volatile = false;
				boolean pulse3DVolatile = false;

				if (firstChunk < slice.getNumChunks() + slice.getFirstChunk()) {
					reset(clipPath);
					pulseQ0Volatile = clipPulseFill(clipPath,
							slice.getChunksAggregated()[firstChunk],
							Consts.QPANE_0, Math.max(0,
									mChunksFallingHighestRow_atLastVolatileAlignment
											- mDrawSettings.displayedRows),
							alignmentOffset);
					// offset this to clip FULL (by the current height of this
					// aggregated chunk set)
					int diff = -(int) Math
							.round((slice.getFallDistances()[firstChunk] - blocksFallen)
									* mDrawSettings.size_blockHeight);
					clipPath.offset(0, diff);
					op(mLastBitmapClipPath[BITMAP_FULL], clipPath, Path.Op.UNION);
					clipPath.offset(0, -diff);
					// the difference between "landing position" and
					// "volatile position"
					// is blockHeight times the lowest aligned row. Lower by
					// that amount.
					int vChunkOffset = mDrawSettings.size_blockHeight
							* (mChunksFallingLowestRow_atLastVolatileAlignment - slice
									.getFallDistances()[firstChunk]);
					clipPath.offset(0, vChunkOffset);
					op(mLastBitmapClipPath[BITMAP_SEPTUPLE_Q0_VOLATILE], clipPath, Path.Op.UNION);

					reset(clipPath);
					pulseQ1Volatile = clipPulseFill(clipPath,
							slice.getChunksAggregated()[firstChunk],
							Consts.QPANE_1, Math.max(0,
									mChunksFallingHighestRow_atLastVolatileAlignment
											- mDrawSettings.displayedRows),
							alignmentOffset);
					// offset this to clip FULL (by the current height of this
					// aggregated chunk set)
					diff = -(int) Math
							.round((slice.getFallDistances()[firstChunk] - blocksFallen)
									* mDrawSettings.size_blockHeight);
					clipPath.offset(0, diff);
					op(mLastBitmapClipPath[BITMAP_FULL], clipPath, Path.Op.UNION);
					clipPath.offset(0, -diff);
					// the difference between "landing position" and
					// "volatile position"
					// is blockHeight times the lowest aligned row. Lower by
					// that amount.
					clipPath.offset(0, vChunkOffset);
					op(mLastBitmapClipPath[BITMAP_SEPTUPLE_Q1_VOLATILE], clipPath, Path.Op.UNION);

					reset(clipPath);
					pulse3DVolatile = clipPulseFill(clipPath,
							slice.getChunksAggregated()[firstChunk],
							Consts.QPANE_3D, Math.max(0,
									mChunksFallingHighestRow_atLastVolatileAlignment
											- mDrawSettings.displayedRows),
							alignmentOffset);
					// offset this to clip FULL (by the current height of this
					// aggregated chunk set)
					diff = -(int) Math
							.round((slice.getFallDistances()[firstChunk] - blocksFallen)
									* mDrawSettings.size_blockHeight);
					clipPath.offset(0, diff);
					op(mLastBitmapClipPath[BITMAP_FULL], clipPath, Path.Op.UNION);
					clipPath.offset(0, -diff);
					// the difference between "landing position" and
					// "volatile position"
					// is blockHeight times the lowest aligned row. Lower by
					// that amount.
					clipPath.offset(0, vChunkOffset);
					op(mLastBitmapClipPath[BITMAP_SEPTUPLE_3D_VOLATILE], clipPath, Path.Op.UNION);
				}

				// Lastly, because we draw glows directly to the FULL bitmap, we
				// clip them there and nowhere else.
				// we have clipped all altered blocks. Time to clip glows, if we
				// have any.
				// Unlocking is easy - clip the whole column.
				if (unlocking) {
					for (int i = 0; i < slice.getNumUnlockedColumns(); i++) {
						Offset o = slice.getUnlockedColumns().get(i);
						tempRectF.left = mDrawSettings.getBlockXPosition(-1,
								o.x - 1);
                        tempRectF.right = mDrawSettings.getBlockXPosition(
								-1, o.x + 2);
                        tempRectF.bottom = mDrawSettings.getBlockYPosition(
								-1, o.y - 1);
                        tempRectF.top = mDrawSettings.getBlockYPosition(-1,
								mDrawSettings.displayedRows);
                        tempRectF.offset(alignmentOffset.x, alignmentOffset.y);
						unionRect(mLastBitmapClipPath[BITMAP_FULL], tempRectF, Path.Direction.CW);
					}
				} else {
					// lock glows. Iterate through chunks, drawing the glows for
					// each if still going.
					// Find the length of the glow animation, so we can tell
					// whether
					// each is finished.
					long timeToLockGlow = 0;
					for (int i = 0; i < mDrawSettings.glow_alphaPeakNormalized[Consts.GLOW_LOCK].length; i++) {
						timeToLockGlow = Math
								.max(timeToLockGlow,
										animationSettings
												.lockGlowTimeToFinish(
														0,
														mDrawSettings.glow_alphaPeakNormalized[Consts.GLOW_LOCK][i],
														0));
					}
				}
				int numGlows = mLastEffectsGlow.size() ;
				for (int i = 0; i < numGlows; i++) {
					GlowEffect glowEffect = mLastEffectsGlow.get(i);
					// clip this glow IF 1: it is a lock glow, 2: it has
					// started,
					// and 3: it has not been playing for long enough to fade.
					if (glowEffect.active(sliceTime)
							|| glowEffect.active(mLastSliceTime)) {
						this.clipGlowEffect(mLastBitmapClipPath[BITMAP_FULL],
								glowEffect, 0, alignmentOffset);
					}
				}
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_CLIP] += tock();
				// \nest 1

				// time to draw.
				tick();
				for (int i = 0; i < mLastBitmapCanvas.length; i++) {
                    mLastBitmapCanvas[i].save();
                    mLastBitmapCanvas[i].clipPath(mLastBitmapClipPath[i]);
                }
				if (fieldChanged || chunkTransition || pulseQ0Stable)
					drawChunksFallingWithLastSlice_helperDrawBlockfield(
							mDrawSettings, Consts.QPANE_0,
							mLastBitmapCanvas[BITMAP_SEPTUPLE_Q0_STABLE],
							alignmentOffset, slice, firstChunk - 1, sliceTime,
							true);
				if (fieldChanged || chunkTransition || pulseQ1Stable)
					drawChunksFallingWithLastSlice_helperDrawBlockfield(
							mDrawSettings, Consts.QPANE_1,
							mLastBitmapCanvas[BITMAP_SEPTUPLE_Q1_STABLE],
							alignmentOffset, slice, firstChunk - 1, sliceTime,
							true);
				if (fieldChanged || chunkTransition || pulse3DStable)
					drawChunksFallingWithLastSlice_helperDrawBlockfield(
							mDrawSettings, Consts.QPANE_3D,
							mLastBitmapCanvas[BITMAP_SEPTUPLE_3D_STABLE],
							alignmentOffset, slice, firstChunk - 1, sliceTime,
							true);
				if (fieldChanged || chunkTransition || pulseQ0Volatile)
					drawChunksFallingWithLastSlice_helperDrawAggregatedChunks(
							mDrawSettings, Consts.QPANE_0,
							mLastBitmapCanvas[BITMAP_SEPTUPLE_Q0_VOLATILE],
							alignmentOffset, slice, firstChunk - 1, sliceTime);
				if (fieldChanged || chunkTransition || pulseQ1Volatile)
					drawChunksFallingWithLastSlice_helperDrawAggregatedChunks(
							mDrawSettings, Consts.QPANE_1,
							mLastBitmapCanvas[BITMAP_SEPTUPLE_Q1_VOLATILE],
							alignmentOffset, slice, firstChunk - 1, sliceTime);
				if (fieldChanged || chunkTransition || pulse3DVolatile)
					drawChunksFallingWithLastSlice_helperDrawAggregatedChunks(
							mDrawSettings, Consts.QPANE_3D,
							mLastBitmapCanvas[BITMAP_SEPTUPLE_3D_VOLATILE],
							alignmentOffset, slice, firstChunk - 1, sliceTime);
                for (int i = 0; i < mLastBitmapCanvas.length; i++) {
                    mLastBitmapCanvas[i].restore();
                }
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW] += tock();

				// time to blit. Blit is where our three operation modes differ
				// - we blit
				// volatile in different places (with different opacities!) and
				// with
				// different glow array sets.
				tick();
				// canvas translation offset?
				setCanvasDestinationRect(
						mLastBitmapBlitRect[BITMAP_FULL],
						mLastBitmapBounds[BITMAP_FULL],
						mDrawSettings.configCanvas.region,
						-((int) Math.round(slice.getDisplacement()
								* mDrawSettings.size_blockHeight))
							+ mDrawSettings.displacementSafeMarginOffsetBlit);
				mLastBitmapBlitRect[BITMAP_SEPTUPLE_Q0_STABLE].set(0, 0,
						mLastBitmapBounds[BITMAP_SEPTUPLE_Q0_STABLE].width(),
						mLastBitmapBounds[BITMAP_SEPTUPLE_Q0_STABLE].height());
				mLastBitmapBlitRect[BITMAP_SEPTUPLE_Q1_STABLE].set(0, 0,
						mLastBitmapBounds[BITMAP_SEPTUPLE_Q1_STABLE].width(),
						mLastBitmapBounds[BITMAP_SEPTUPLE_Q1_STABLE].height());
				mLastBitmapBlitRect[BITMAP_SEPTUPLE_3D_STABLE].set(0, 0,
						mLastBitmapBounds[BITMAP_SEPTUPLE_3D_STABLE].width(),
						mLastBitmapBounds[BITMAP_SEPTUPLE_3D_STABLE].height());
				mLastBitmapBlitRect[BITMAP_SEPTUPLE_Q0_VOLATILE].set(0,
						-volatileOffset,
						mLastBitmapBounds[BITMAP_SEPTUPLE_Q0_VOLATILE].width(),
						mLastBitmapBounds[BITMAP_SEPTUPLE_Q0_VOLATILE].height()
								- volatileOffset);
				mLastBitmapBlitRect[BITMAP_SEPTUPLE_Q1_VOLATILE].set(0,
						-volatileOffset,
						mLastBitmapBounds[BITMAP_SEPTUPLE_Q1_VOLATILE].width(),
						mLastBitmapBounds[BITMAP_SEPTUPLE_Q1_VOLATILE].height()
								- volatileOffset);
				mLastBitmapBlitRect[BITMAP_SEPTUPLE_3D_VOLATILE].set(0,
						-volatileOffset,
						mLastBitmapBounds[BITMAP_SEPTUPLE_3D_VOLATILE].width(),
						mLastBitmapBounds[BITMAP_SEPTUPLE_3D_VOLATILE].height()
								- volatileOffset);

				// log("chunks: volatile offset by " + volatileOffset) ;

				// Draw the background. This call obeys background behavior,
				// including BLIT (for which it draws nothing).
				int volatileBlitAlpha = riseAndFade ? animationSettings
						.riseFadeAlpha(255, 0, fallingTime) : 255;
				septupleBlitDrawBackground(sliceTime, configCanvas, 255,
						volatileBlitAlpha);

				// Settings for Septuple Blit...
				int pieceType = slice.getPieceType();

				// Septuple Blit!
				boolean doneGlowing = septupleBlit(255, volatileBlitAlpha,
						alignmentOffset, pieceType, sliceTime);

				// blit to the main canvas
				if (configCanvas == null
						|| configCanvas.equals(mDrawSettings.configCanvas)) {
					canvas.save();
					if (mDrawSettings.configCanvas.clipRegion != null)
						canvas.clipRect(mDrawSettings.configCanvas.clipRegion,
								Region.Op.INTERSECT);

					if (mDrawSettings.behavior_background == DrawSettings.BEHAVIOR_BACKGROUND_BLIT_IMAGE) {
						drawLayeredBackgroundAssets(canvas,
								mDrawSettings.configCanvas.region, sliceTime,
								mDrawSettings.configCanvas.background);
					}

					canvas.drawBitmap(mLastBitmap[BITMAP_FULL],
							mLastBitmapBounds[BITMAP_FULL],
							mLastBitmapBlitRect[BITMAP_FULL], null);
					canvas.restore();
				} else {
					tempSrcRect.set(mLastBitmapBounds[BITMAP_FULL]);
					tempSrcRect.bottom = tempSrcRect.top + mDrawSettings.height;
					drawBitmapToCanvasWithConfig(canvas,
							mLastBitmap[BITMAP_FULL], tempSrcRect, slice,
							configCanvas, null);
				}

				// timer
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_BLIT] += tock();

				doneLocking = doneGlowing && doneMoving;

				// that's it
				break;

			case DrawSettings.BLIT_FULL:
				// set offsets
				canvasTranslationOffset.x = 0;
				canvasTranslationOffset.y = 0;
				setAlignmentOffset(slice.getBlockfieldStable(), alignmentOffset);
				alignmentOffsetSet = true;
				if (doubleBitmapOffset)
					alignmentOffset.y += height;
				// raise the ground up...
				alignmentOffset.y -= mLastBitmapChunksFalling_drawFallDirectionChangeDistance;

				// clip
				tick();
				// We first clip the blocks which have changed, then clip the
				// glows. Separating
				// things this way makes it a little easier to consider.
				reset(mLastBitmapClipPath[BITMAP_FULL]);
				if (fieldChanged
						|| (mBackgroundBitmapClipOrBlitIsBlitting != groundRising)
						|| mLastBitmapVeiled
						|| configCanvas != null
						|| (backgroundChanged && !mDrawSettings
								.getBehaviorIs_backgroundBlit())) {

					if (doubleBitmapOffset) {
						int yTop = height
								- mLastBitmapChunksFalling_drawFallDirectionChangeDistance;
						unionRect(mLastBitmapClipPath[BITMAP_FULL], 0, yTop,
								mLastBitmapBounds[BITMAP_FULL].width(), yTop
										+ height, Path.Direction.CW);
					} else {
						// clip with extra space below, so we have room to draw
						// displacement rows.
						float extra = mDrawSettings.getBehaviorIs_displacement()
								? mDrawSettings.size_blockHeight * 3
								: 0 ;
						unionRect(mLastBitmapClipPath[BITMAP_FULL], 0, 0,
								mLastBitmapBounds[BITMAP_FULL].width(),
								mLastBitmapBounds[BITMAP_FULL].height() + extra,
								Path.Direction.CW);
					}
				} else if (groundRising) {
					// only true if the ground is currently rising - e.g.,
					// unlocking == false
					// chunk transition requires clipping the affected area of
					// the blockfield.
					// we do that automatically.

					// ground is rising: we draw at the current offset, and
					// everything should
					// be positioned appropriately (draw methods automatically
					// adjust chunk
					// height, which would constitute moving them down to
					// compensate for the
					// offset up).

					// However, clipping might be a bit complicated. Note that
					// we do NOT clip
					// the falling chunks, as we expect them to be always and
					// forever identical.
					// We clip instead the conservative difference between
					// current blockfield
					// at current offset and "last tick blockfield" (may or may
					// not be the same)
					// at last tick offset, and union that with any glows
					// current in progress.
					// Note that glow clips occur whether or not the ground is
					// rising, so we
					// do them in another section - for now, just do the
					// blockfield differences.
					tempOffset.takeVals(alignmentOffset);
					// ground is drawn at this offset, unchanged.

					tempOffset.y += (mLastBitmapChunksFalling_drawFallDirectionChangeDistance - mDrawSettings
							.size_blockHeight * blocksFallenLast);

					int chunkNum = slice.getFirstChunk() + lastLandedChunk;
					this.clipConservativeDifference(
							mLastBitmapClipPath[BITMAP_FULL],
							slice.getBlockfields()[chunkNum],
							slice.getBlockfields()[chunkNum
									- (chunkTransition
											&& lastLandedChunk > slice
													.getFirstChunk() ? 1 : 0)],
							0, alignmentOffset, tempOffset, extendByPixels);

					// quick note: raising the ground leaves a "trail" of
					// bottom-row bitmaps behind. Clip these
					// out? Set tempOffset to the previous offset.
					int left = 0, right = mLastBitmapBounds[BITMAP_FULL]
							.width();
					for (int qp = 0; qp < 2; qp++) {
						clipFullWidthRowNegativeOne(
								mLastBitmapClipPath[BITMAP_FULL], left, right,
								qp, alignmentOffset, extendByPixels);
						clipFullWidthRowNegativeOne(
								mLastBitmapClipPath[BITMAP_FULL], left, right,
								qp, tempOffset, extendByPixels);
					}

					if (!mLastBitmapChunksFalling_drawFallDirectionChangeClipped) {
						int rowsGroundRising = mLastBitmapChunksFalling_drawFallDirectionChangeChunk == slice
								.getFirstChunk() ? 0
								: mLastBitmapChunksFalling_drawFallDirectionChangeChunkFallDistance;
						// log("chunk number " + chunkNum +
						// ", blocks fallen " + blocksFallen +
						// " alignmentOffset:(" + alignmentOffset.x + "," +
						// alignmentOffset.y + "), tempOffset:(" + tempOffset.x
						// + "," + tempOffset.y + ")") ;
						// log("rows ground rising " + rowsGroundRising)
						// ;
						// log("chunk? " +
						// mLastBitmapChunksFalling_drawFallDirectionChangeChunk
						// ) ;
						// we need to draw a certain number of "extra" rows
						// right away
						unionRect(mLastBitmapClipPath[BITMAP_FULL], 0, height
								- mDrawSettings.size_blockHeight
								* rowsGroundRising,
								mLastBitmapBounds[BITMAP_FULL].width(), height,
								Path.Direction.CW);
						mLastBitmapChunksFalling_drawFallDirectionChangeClipped = true;
					}

					// now just needs glows
				} else if (!unlocking) {
					// The ground is NOT rising, and we are NOT unlocking -
					// chunks are falling from the sky.
					// We need to iterate through the chunks. If any landed in
					// the last tick, we need to
					// conservative-difference the blockfield (at
					// mLastBitmapChunksFalling_drawFallDirectionChangeDistance,
					// which has not changed since the last time it was drawn).
					// Regardless, we also need
					// to conservative-difference every falling chunk (including
					// any that landed this tick)
					// against its previous position. Chunks which had already
					// landed last tick don't need
					// to be clipped; if they are glowing, we do that below.
					// Finally, riseAndFade chunks
					// are treated identically to 'falling' chunks, just with a
					// different offset in a
					// different direction.

					// One last note: although we probably have a "risen ground"
					// offset in the form of
					// mLastBitmapChunksFalling_drawFallDirectionChangeDistance,
					// this is compensated
					// for by merely applying the normal chunk fall distance to
					// alignmentOffset.
					// Convince yourself this is the case before continuing,
					// because most of our
					// clip and draw methodology relies on this.
					for (int i = 0; i < slice.getNumChunks(); i++) {
						int chunkNum = i + slice.getFirstChunk();
						int dist = slice.getFallDistances()[chunkNum];
						// note: a chunk that is currently falling, and one that
						// is currently rising/fading,
						// can be treated nearly identically - we just clip to
						// different offsets.
						if ((!riseAndFade && dist > 0 && dist > blocksFallen)
								|| (riseAndFade && dist >= 0)) {
							// this chunk is in-motion. Determine current and
							// previous offsets
							// (use tempOffset, tempOffset2) and clip the
							// conservative difference.
							// For riseAndFade == <true/false>, only the offsets
							// are different.
							// Recall that the height at which chunk blocks are
							// represented is
							// their LANDED HEIGHT; we want to offset UPWARD by
							// that amount,
							// then downward by the distance fallen (upward by
							// risen, resp.)
							tempOffset.takeVals(alignmentOffset);
							tempOffset2.takeVals(alignmentOffset);
							if (riseAndFade) {
								// rising upward at a ~constant rate
								float heightOffset = -slice.getFallDistances()[chunkNum]
										- blocksRisen;
								float heightOffsetLast = -slice
										.getFallDistances()[chunkNum]
										- blocksRisenLast;
								// offsets are in blocks, convert to pixels
								tempOffset.y += Math.round(heightOffset
										* mDrawSettings.size_blockHeight);
								tempOffset2.y += Math.round(heightOffsetLast
										* mDrawSettings.size_blockHeight);
							} else {
								// falling downward at an accelerating rate
								float heightOffset = -slice.getFallDistances()[chunkNum]
										+ blocksFallen;

								float heightOffsetLast = -slice
										.getFallDistances()[chunkNum]
										+ blocksFallenLast;
								// offsets are in blocks, convert to pixels
								tempOffset.y += Math.round(heightOffset
										* mDrawSettings.size_blockHeight);
								tempOffset2.y += Math.round(heightOffsetLast
										* mDrawSettings.size_blockHeight);
							}
							byte[][][] chunkField = slice.getChunks()[chunkNum];
							if (!riseAndFade)
								this.clipConservativeDifference(
										mLastBitmapClipPath[BITMAP_FULL],
										chunkField, chunkField, 0, tempOffset,
										tempOffset2, extendByPixels);
							// riseAndFade: we want to fade even if they
							// completely overlap, so...
							else {
								this.clipContentUnion(
										mLastBitmapClipPath[BITMAP_FULL],
										chunkField, tempOffset, extendByPixels);
								this.clipContentUnion(
										mLastBitmapClipPath[BITMAP_FULL],
										chunkField, tempOffset2, extendByPixels);
							}
							// SANITY CHECK: check whether this clip method is
							// the
							// problem by clipping the content union instead.
							// this.clipContentUnion(mLastBitmapCanvas,
							// chunkField, tempOffset) ;
							// this.clipContentUnion(mLastBitmapCanvas,
							// chunkField, tempOffset2) ;
							// log("chunk number " + chunkNum + " dist "
							// + dist + ", blocks fallen " + blocksFallen +
							// " alignmentOffset:(" + alignmentOffset.x + "," +
							// alignmentOffset.y + "), tempOffset:(" +
							// tempOffset.x + "," + tempOffset.y +
							// "), tempOffset2:(" + tempOffset2.x + "," +
							// tempOffset2.y + ")") ;
						} else if (!riseAndFade && i > 0) {
							// chunks are falling, but this one has landed.
							// Important: glows are clipped
							// LATER. Our main concern here is to determine
							// whether we need to clip
							// BLOCKS - basically, the blockfield may have
							// changed (or have its borders
							// change) since the last tick. Basically, we only
							// clip this chunk if
							// it had NOT landed last chunk, but HAS landed this
							// one. We clip the previous
							// content of the chunk at the previous position,
							// then the conservative
							// difference between the blockfields (before and
							// after landing).
							int fallDist = slice.getFallDistances()[chunkNum];
							if (fallDist < 0
									|| ((fallingTime > animationSettings.fall_timeToFallDistance[fallDist] || ((fallDist > 0 || (fallDist == 0 && !fallZeroDistance)) && fallingTime >= animationSettings.fall_timeToFallDistance[fallDist])))) {
								// this chunk just landed. First clip the
								// previous chunk position...
								float heightOffset = -slice.getFallDistances()[chunkNum]
										+ blocksFallenLast;
								tempOffset.takeVals(alignmentOffset);
								tempOffset.y += Math.round(heightOffset
										* mDrawSettings.size_blockHeight);
								this.clipContentUnion(
										mLastBitmapClipPath[BITMAP_FULL],
										slice.getChunks()[chunkNum],
										tempOffset, extendByPixels);
								// ...now clip the conservative difference
								// between blockfields.
								// We can safely decrement chunkNum by 1 since
								// the first tick will
								// use fieldChanged, this chunk has spent at
								// least 1 tick falling
								// before landing and thus is not chunk 0.
								this.clipConservativeDifference(
										mLastBitmapClipPath[BITMAP_FULL],
										slice.getBlockfields()[chunkNum],
										slice.getBlockfields()[chunkNum - 1],
										0, alignmentOffset, extendByPixels);
							}
						}
					}
				}

				// we have clipped all altered blocks. Time to clip glows, if we
				// have any.
				// Unlocking is easy - clip the whole column.
				if (unlocking) {
					for (int i = 0; i < slice.getNumUnlockedColumns(); i++) {
						Offset o = slice.getUnlockedColumns().get(i);
                        tempRectF.left = mDrawSettings.getBlockXPosition(-1,
								o.x - 1);
                        tempRectF.right = mDrawSettings.getBlockXPosition(
								-1, o.x + 2);
                        tempRectF.bottom = mDrawSettings.getBlockYPosition(
								-1, o.y - 1);
                        tempRectF.top = mDrawSettings.getBlockYPosition(-1,
								mDrawSettings.displayedRows);
                        tempRectF.offset(alignmentOffset.x,
								alignmentOffset.y);
						unionRect(mLastBitmapClipPath[BITMAP_FULL], tempRectF, Path.Direction.CW);
					}
				} else {
					// lock glows. Iterate through chunks, drawing the glows for
					// each if still going.
					// Find the length of the glow animation, so we can tell
					// whether
					// each is finished.
					long timeToLockGlow = 0;
					for (int i = 0; i < mDrawSettings.glow_alphaPeakNormalized[Consts.GLOW_LOCK].length; i++) {
						timeToLockGlow = Math
								.max(timeToLockGlow,
										animationSettings
												.lockGlowTimeToFinish(
														0,
														mDrawSettings.glow_alphaPeakNormalized[Consts.GLOW_LOCK][i],
														0));
					}
					numGlows = mLastEffectsGlow.size() ;
					for (int i = 0; i < numGlows; i++) {
						GlowEffect glowEffect = mLastEffectsGlow.get(i);
						// clip this glow IF 1: it is a lock glow, 2: it has
						// started,
						// and 3: it has not been playing for long enough to
						// fade.
						if (glowEffect.active(sliceTime)
								|| glowEffect.active(mLastSliceTime)) {
							this.clipGlowEffect(mLastBitmapClipPath[BITMAP_FULL],
									glowEffect, 0, alignmentOffset);
						}
					}
				}
				// Clip "pulse" behavior pieces. We have already completely
				// clipped any
				// block or glow changes, so this might be unnecessary, but just
				// in case...
				if (animationSettings != null) {
					if (unlocking) {
						clipPulseFill(mLastBitmapClipPath[BITMAP_FULL],
								slice.getChunksFallingPreBlockfield(), 0,
								alignmentOffset);
					} else {
						if (!groundRising) {
							for (int i = 0; i < slice.getNumChunks(); i++) {
								// we have already clipped the entirety of the
								// chunks. Just clip pulsing blocks in the first
								// "resting" blockfield.
								int chunkIndex = i + slice.getFirstChunk();
								if (slice.getFallDistances()[chunkIndex] > blocksFallen
										|| (fallZeroDistance
												&& slice.getFallDistances()[chunkIndex] == 0 && blocksFallen == 0)) {
									// indexing at 0-1 will never happen,
									// because the fall distance
									// for it is -1, always less than
									// blocksFallen.
									clipPulseFill(
											mLastBitmapClipPath[BITMAP_FULL],
											slice.getBlockfields()[chunkIndex - 1],
											0, alignmentOffset);
									break;
								}
							}
						} else {
							// we have already clipped the entirety of the stuff
							// on the ground. Clip pulsing
							// blocks which are falling. Can do this at the last
							// aggregated chunk.
							for (int i = 0; i < slice.getNumChunks(); i++) {
								// we have already clipped the entirety of the
								// chunks. Just clip pulsing blocks in the first
								// "resting" blockfield.
								int chunkIndex = i + slice.getFirstChunk();
								if (slice.getFallDistances()[chunkIndex] > blocksFallen
										|| (fallZeroDistance
												&& slice.getFallDistances()[chunkIndex] == 0 && blocksFallen == 0)) {

									tempOffset.takeVals(alignmentOffset);
									float distanceLeftToFall = slice
											.getFallDistances()[chunkIndex]
											- blocksFallen;
									tempOffset.y = alignmentOffset.y
											- Math.round(mDrawSettings
													.size_blockHeight
													* distanceLeftToFall);

									clipPulseFill(
											mLastBitmapClipPath[BITMAP_FULL],
											slice.getChunks()[chunkIndex], 0,
											tempOffset);
								}
							}
						}
					}
				}
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_CLIP] += tock();

				// Adjust our regions. We calculate regions with STABLE set at
				// the bottom,
				// and VOLATILE set with the firstChunk at its
				// "just about to fall" position.
				// We will adjust back down at the end of this method.

				regionStableYExtra = 0;
				regionVolatileYExtra = 0;
				if (riseAndFade) {
					// volatile is currently at its "starting" position; rise it
					// up.
					regionVolatileYExtra = -pixelsRisen;
				} else {
					// might be raising the ground, might not.
					// the distance from bottom to stable is
					// minimum of pixelsFallen,
					// mLastBitmapChunksFalling_drawFallDirectionChangeDistance
					// the positive offset for volatile is
					// maximum of (0, pixelsFallen -
					// mLastBitmapChunksFalling_drawFallDirectionChangeDistance
					// )
					regionStableYExtra = Math
							.max(-pixelsFallen,
									-mLastBitmapChunksFalling_drawFallDirectionChangeDistance);
					regionVolatileYExtra = Math
							.max(0,
									pixelsFallen
											- mLastBitmapChunksFalling_drawFallDirectionChangeDistance);
				}

				mLastBitmapCoveredPath[BITMAP_REGION_FULL_STABLE].offset(
						0, regionStableYExtra);
				mLastBitmapTouchedPath[BITMAP_REGION_FULL_STABLE].offset(
						0, regionStableYExtra);
				mLastBitmapCoveredPath[BITMAP_REGION_FULL_VOLATILE]
						.offset(0, regionVolatileYExtra);
				mLastBitmapTouchedPath[BITMAP_REGION_FULL_VOLATILE]
						.offset(0, regionVolatileYExtra);

				if (GlobalTestSettings.BLOCK_DRAWER_SHOW_COVERED_AND_TOUCHING_REGIONS) {
				    reset(mLastBitmapClipPath[BITMAP_FULL]);
                    unionRect(mLastBitmapClipPath[BITMAP_FULL], 0, 0,
                            Integer.MAX_VALUE, Integer.MAX_VALUE,
                            Path.Direction.CW);
                }

				// draw
				tick();

				mLastBitmapCanvas[BITMAP_FULL].save();
				mLastBitmapCanvas[BITMAP_FULL].clipPath(mLastBitmapClipPath[BITMAP_FULL]);

				BlockDrawerConfigCanvas.Background backgroundDefault = mDrawSettings
						.getBehaviorIs_backgroundBlit() ? BlockDrawerConfigCanvas.Background.CLEAR
						: BlockDrawerConfigCanvas.Background.DEFAULT;

				if (unlocking) {
					// unlock glows!
					drawChunksFallingWithLastSlice_helperDrawUnlockGlows(
							mDrawSettings, mLastBitmapCanvas[BITMAP_FULL],
							alignmentOffset, slice, sliceTime,
							mBackgroundBitmapOffset,
							configCanvas != null ? configCanvas.background
									: backgroundDefault, 0, true);
				} else if (!riseAndFade) {
					tempOffset.takeVals(mBackgroundBitmapOffset);
					tempOffset.y -= mLastBitmapChunksFalling_drawFallDirectionChangeDistance;
					int extraRows = Math.min(
							mLastBitmapChunksFalling_drawFallDirectionChangeChunk == slice.getFirstChunk()
									? 0
									: slice.getFallDistances()[mLastBitmapChunksFalling_drawFallDirectionChangeChunk - 1],
							mDrawSettings.ROWS - mDrawSettings.displayedRows);
					doneLocking = drawChunksFallingWithLastSlice_helperDrawFallingChunks(
							mDrawSettings,
							mLastBitmapCanvas[BITMAP_FULL],
							alignmentOffset,
							slice,
							sliceTime,
							fallingTime,
							blocksFallen,
							lastLandedChunk,
							extraRows,
							tempOffset,
							(configCanvas != null && !groundRising) ? configCanvas.background
									: (groundRising ? BlockDrawerConfigCanvas.Background.CLEAR
											: backgroundDefault), 0, true);
				} else {
					doneLocking = drawChunksFallingWithLastSlice_helperDrawRisingFadingChunks(
							mDrawSettings, mLastBitmapCanvas[BITMAP_FULL],
							alignmentOffset, slice, sliceTime, fallingTime,
							blocksRisen, mBackgroundBitmapOffset,
							configCanvas != null ? configCanvas.background
									: backgroundDefault, 0, true);
				}

                if (GlobalTestSettings.BLOCK_DRAWER_SHOW_COVERED_AND_TOUCHING_REGIONS)
                    drawTouchedCoveredTestToCanvas(mLastBitmapCanvas[BITMAP_FULL]);

				mLastBitmapCanvas[BITMAP_FULL].restore();
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW] += tock();



				// blit
				tick();

				if (mDrawSettings.getBehaviorIs_displacement()) {
					setCanvasDestinationRect(
							mLastBitmapBlitRect[BITMAP_FULL],
							mLastBitmapBounds[BITMAP_FULL],
							mDrawSettings.configCanvas.region,
							-((int) Math.round(slice.getDisplacement()
									* mDrawSettings.size_blockHeight))
								+ mDrawSettings.displacementSafeMarginOffsetBlit);
				} else {
					mLastBitmapBlitRect[BITMAP_FULL].set(
							mDrawSettings.configCanvas.region.left,
							mDrawSettings.configCanvas.region.top
									- (doubleBitmapOffset ? blitHeight : 0),
							mDrawSettings.configCanvas.region.right,
							mDrawSettings.configCanvas.region.top + blitHeight);

					// blitting is slightly complicated due to the rising
					// ground. We
					// compensate by lowering the blit rectangle an equal amount
					// for
					// full blit, double that amount for 1/4 blit.
					mLastBitmapBlitRect[BITMAP_FULL]
							.offset(0, mLastBitmapChunksFalling_drawFallDirectionChangeDistance * mDrawSettings.getScale());
				}

				if (configCanvas == null
						|| configCanvas.equals(mDrawSettings.configCanvas)) {
					canvas.save();
					if (mDrawSettings.configCanvas.clipRegion != null)
						canvas.clipRect(mDrawSettings.configCanvas.clipRegion,
								Region.Op.INTERSECT);
					/*
					 * if (mBackgroundBitmap != null &&
					 * mDrawSettings.behavior_background ==
					 * DrawSettings.BEHAVIOR_BACKGROUND_CLIP_OR_BLIT_IMAGE &&
					 * groundRising) { canvas.drawBitmap(mBackgroundBitmap,
					 * mBackgroundBitmapDrawableRect,
					 * mDrawSettings.configCanvas.region, backgroundBlitPaint);
					 * }
					 */
					if ((mDrawSettings.behavior_background == DrawSettings.BEHAVIOR_BACKGROUND_CLIP_OR_BLIT_IMAGE && groundRising)
							|| mDrawSettings.getBehaviorIs_backgroundBlit()) {
						drawLayeredBackgroundAssets(canvas,
								mDrawSettings.configCanvas.region, sliceTime,
								mDrawSettings.configCanvas.background);
					}
					canvas.drawBitmap(mLastBitmap[BITMAP_FULL],
							mLastBitmapBounds[BITMAP_FULL],
							mLastBitmapBlitRect[BITMAP_FULL], blitPaint);
					canvas.restore();
				} else {
					// our content is available in mLastBitmap. However,
					// depending on
					// our background settings and config canvas settings, this
					// might fail.
					// throw an exception so we know this is unacceptable.
					tempSrcRect.set(mLastBitmapBounds[BITMAP_FULL]);
					tempSrcRect.bottom = tempSrcRect.top + height;
					if (doubleBitmapOffset)
						tempSrcRect.offset(0, height);
					tempSrcRect
							.offset(0,
									-mLastBitmapChunksFalling_drawFallDirectionChangeDistance);
					drawBitmapToCanvasWithConfig(canvas,
							mLastBitmap[BITMAP_FULL], tempSrcRect, slice,
							configCanvas, blitPaint);
				}

				// un-translate the region offsets.
				mLastBitmapCoveredPath[BITMAP_REGION_FULL_STABLE].offset(
						0, -regionStableYExtra);
				mLastBitmapTouchedPath[BITMAP_REGION_FULL_STABLE].offset(
						0, -regionStableYExtra);
				mLastBitmapCoveredPath[BITMAP_REGION_FULL_VOLATILE]
						.offset(0, -regionVolatileYExtra);
				mLastBitmapTouchedPath[BITMAP_REGION_FULL_VOLATILE]
						.offset(0, -regionVolatileYExtra);

				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_BLIT] += tock();

				// done
				break;

			case DrawSettings.BLIT_NONE:
				// set offsets according to canvas
				setAlignmentOffset(slice.getBlockfieldStable(), alignmentOffset);
				int displacement = 0;
				if (mDrawSettings.getBehaviorIs_displacement()) {
					displacement = -((int) Math.round(slice.getDisplacement()
							* mDrawSettings.size_blockHeight));
					alignmentOffset.y += displacement;
				}
				alignmentOffsetSet = true;
				setCanvasTranslationOffset(canvas);

				// Adjust our regions. We calculate regions with STABLE set at
				// the bottom,
				// and VOLATILE set with the firstChunk at its
				// "just about to fall" position.
				// We will adjust back down at the end of this method.

				regionStableYExtra = 0;
				regionVolatileYExtra = 0;
				if (riseAndFade) {
					// volatile is currently at its "starting" position; rise it
					// up.
					regionVolatileYExtra = -pixelsRisen;
				} else {
					regionVolatileYExtra = pixelsFallen;
				}

				mLastBitmapCoveredPath[BITMAP_REGION_FULL_STABLE].offset(
						0, regionStableYExtra);
				mLastBitmapTouchedPath[BITMAP_REGION_FULL_STABLE].offset(
						0, regionStableYExtra);
				mLastBitmapCoveredPath[BITMAP_REGION_FULL_VOLATILE]
						.offset(0, regionVolatileYExtra);
				mLastBitmapTouchedPath[BITMAP_REGION_FULL_VOLATILE]
						.offset(0, regionVolatileYExtra);

				// we do not clip, assuming that has been done for us.

				// Draw now dood
				tick();
				canvas.save();
				if (mDrawSettings.configCanvas.clipRegion != null)
					canvas.clipRect(mDrawSettings.configCanvas.clipRegion,
							Region.Op.INTERSECT);
				if (unlocking) {
					// unlock glows!
					drawChunksFallingWithLastSlice_helperDrawUnlockGlows(
							mDrawSettings, canvas, alignmentOffset, slice,
							sliceTime, mBackgroundBitmapOffset,
							BlockDrawerConfigCanvas.Background.DEFAULT,
							displacement, true);
				} else if (!riseAndFade) {
					doneLocking = drawChunksFallingWithLastSlice_helperDrawFallingChunks(
							mDrawSettings, canvas, alignmentOffset, slice,
							sliceTime, fallingTime, blocksFallen,
							lastLandedChunk, 0, mBackgroundBitmapOffset,
							BlockDrawerConfigCanvas.Background.DEFAULT,
							displacement, true);
				} else {
					doneLocking = drawChunksFallingWithLastSlice_helperDrawRisingFadingChunks(
							mDrawSettings, canvas, alignmentOffset, slice,
							sliceTime, fallingTime, blocksRisen,
							mBackgroundBitmapOffset,
							BlockDrawerConfigCanvas.Background.DEFAULT,
							displacement, true);
				}
				canvas.restore();

				if (GlobalTestSettings.BLOCK_DRAWER_SHOW_COVERED_AND_TOUCHING_REGIONS)
					drawTouchedCoveredTestToCanvas(canvas);

				// un-translate region.
				mLastBitmapCoveredPath[BITMAP_REGION_FULL_STABLE].offset(
						0, -regionStableYExtra);
				mLastBitmapTouchedPath[BITMAP_REGION_FULL_STABLE].offset(
						0, -regionStableYExtra);
				mLastBitmapCoveredPath[BITMAP_REGION_FULL_VOLATILE]
						.offset(0, -regionVolatileYExtra);
				mLastBitmapTouchedPath[BITMAP_REGION_FULL_VOLATILE]
						.offset(0, -regionVolatileYExtra);

				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW] += tock();

				// No need to blit; we put it on the canvas.
				break;

			default:
				throw new IllegalStateException("Blit setting "
						+ mDrawSettings.getBlit() + " confuses and infuriates us");
			}

			mLastBitmapVeiled = false;
		}

		// //////////////////////////////////////////////////////////////////////
		// VEIL INSTRUCTIONS: At this point, mLastBitmap[BITMAP_FULL] is the
		// content to be drawn under the veil. Draw the veil over it.

		if (veilOnScreen(sliceTime)
				&& (configCanvas == null || configCanvas
						.equals(mDrawSettings.configCanvas))) {
			drawBitmapFullVeiledToCanvas(canvas, sliceTime,
					sliceStateChanged || fieldChanged || !mLastBitmapVeiled
							|| !sliceTime.hasBeenDrawnAtThisSliceTime());
			// only force a redraw if content changed, otherwise use our cached
			// veil.
			mLastBitmapVeiled = true;
		}

		// We have drawn to mLastBitmap[BITMAP_FULL]. Copy the slice and blit.
		if (fieldChanged)
			mLastSlice.takeVals(slice);
		// we have drawn the stable slice if we're done unlocking
		// and enough time has passed for the last chunk to land and complete
		// its
		// lock animation. Note: if the ground has risen AT ALL, and we are done
		// locking, then the next slice will always be inconsistent.

		mNextSliceNeedsExplicitConfigCanvas = false;
		mNextSliceBreaksSequence = false;
		mNextSlicePossiblyInconsistent = false;
		mLastBitmapIsStableSlice = mLastBitmapChunksFalling_animationsFinished
				&& doneLocking;
		mLastBitmapIsStableSliceIgnoringEffects = doneMoving;
		mLastBitmapIsStableSliceReadyToAdvanceEffects = doneMoving;
		if (mLastBitmapIsStableSliceReadyToAdvanceEffects
				&& mDrawSettings.drawEffects == DrawSettings.DRAW_EFFECTS_THROUGH_SLICE) {
			// log( 
			// "drawChunksFalling: converting effects to unpaused relative.") ;
			convertEffectsToUnpausedRelative(sliceTime);
		}
		mLastBitmapChunksFalling_animationsFinished = doneLocking;

		mBackgroundBitmapClipOrBlitIsBlitting = mDrawSettings.behavior_background == DrawSettings.BEHAVIOR_BACKGROUND_CLIP_OR_BLIT_IMAGE
				&& groundRising;

		// SOUNDS! Play sounds according to what happened.
		playSounds(sliceTime, pool);

		sliceTime.setLastDrawn();
		clearExpiredEffects(sliceTime);

		mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_TOTAL] += tock();
		mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_NUMBER]++;

		if (mLastSliceTime != null && sliceTime != null)
			mLastSliceTime.takeVals(sliceTime);
	}

	private void drawChunksFallingWithLastSlice_helperClipCoveredStable(
			GameBlocksSlice slice, Offset offset, int lastLanded, int yOffset) {

		tempOffset.takeVals(offset);
		tempOffset.y += yOffset;

		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_Q0_STABLE]);
		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_3D_STABLE]);
		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_Q1_STABLE]);

		clipCoveredPath(mLastBitmapCoveredPath[BITMAP_REGION_Q0_STABLE],
				slice.getBlockfields()[lastLanded], Consts.QPANE_0, 0,
				tempOffset);
		// nothing for 3D.
		clipCoveredPath(mLastBitmapCoveredPath[BITMAP_REGION_Q1_STABLE],
				slice.getBlockfields()[lastLanded], Consts.QPANE_1, 0,
				tempOffset);
	}

	private void drawChunksFallingWithLastSlice_helperClipCoveredVolatile(
			GameBlocksSlice slice, Offset offset, int lastLanded, int yOffset) {
		tempOffset.takeVals(offset);
		tempOffset.y += yOffset;

		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_Q0_VOLATILE]);
		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_3D_VOLATILE]);
		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_Q1_VOLATILE]);

		if (lastLanded + 1 < slice.getNumChunks() + slice.getFirstChunk()) {
			clipCoveredPath(
					mLastBitmapCoveredPath[BITMAP_REGION_Q0_VOLATILE],
					slice.getChunksAggregated()[lastLanded + 1],
					Consts.QPANE_0, 0, tempOffset);
			// nothing for 3D
			clipCoveredPath(
					mLastBitmapCoveredPath[BITMAP_REGION_Q1_VOLATILE],
					slice.getChunksAggregated()[lastLanded + 1],
					Consts.QPANE_1, 0, tempOffset);
		}
	}

	private void drawChunksFallingWithLastSlice_helperClipTouchedStable(
			GameBlocksSlice slice, Offset offset, int lastLanded, int yOffset,
			int extendByPixels, boolean includeDisplacementRowsIfAvailable) {
		tempOffset.takeVals(offset);
		tempOffset.y += yOffset;

		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q0_STABLE]);
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_3D_STABLE]);
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q1_STABLE]);

		clipTouchedPath(mLastBitmapTouchedPath[BITMAP_REGION_Q0_STABLE],
				slice.getBlockfields()[lastLanded], mConfigRangeStandard,
				Consts.QPANE_0, tempOffset, extendByPixels);
		clipTouchedPath(mLastBitmapTouchedPath[BITMAP_REGION_Q1_STABLE],
				slice.getBlockfields()[lastLanded], mConfigRangeStandard,
				Consts.QPANE_1, tempOffset, extendByPixels);
		clipTouchedPath(mLastBitmapTouchedPath[BITMAP_REGION_3D_STABLE],
				slice.getBlockfields()[lastLanded], mConfigRangeStandard,
				Consts.QPANE_3D, tempOffset, extendByPixels);

		// clip row negative 1
		clipFullWidthRowNegativeOne(
				mLastBitmapTouchedPath[BITMAP_REGION_Q0_STABLE], 0,
				mDrawSettings.width, Consts.QPANE_0, tempOffset, extendByPixels);
		clipFullWidthRowNegativeOne(
				mLastBitmapTouchedPath[BITMAP_REGION_Q1_STABLE], 0,
				mDrawSettings.width, Consts.QPANE_1, tempOffset, extendByPixels);

		if (includeDisplacementRowsIfAvailable
				&& mDrawSettings.getBehaviorIs_displacement()) {
			clipDisplacementOffset.takeVals(offset);
			clipDisplacementOffset.offsetXY(0, mDrawSettings.ROWS
					* mDrawSettings.size_blockHeight);
			clipTouchedPath(
					mLastBitmapTouchedPath[BITMAP_REGION_Q0_STABLE],
					slice.getDisplacementBlockfield(), mConfigRangeDisplaced,
					Consts.QPANE_0, clipDisplacementOffset, extendByPixels);
			clipTouchedPath(
					mLastBitmapTouchedPath[BITMAP_REGION_Q1_STABLE],
					slice.getDisplacementBlockfield(), mConfigRangeDisplaced,
					Consts.QPANE_1, clipDisplacementOffset, extendByPixels);
			clipTouchedPath(
					mLastBitmapTouchedPath[BITMAP_REGION_3D_STABLE],
					slice.getDisplacementBlockfield(), mConfigRangeDisplaced,
					Consts.QPANE_3D, clipDisplacementOffset, extendByPixels);
		}
	}

	private void drawChunksFallingWithLastSlice_helperClipTouchedVolatile(
			GameBlocksSlice slice, Offset offset, int lastLanded, int yOffset,
			int extendByPixels) {
		tempOffset.takeVals(offset);
		tempOffset.y += yOffset;

		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q0_VOLATILE]);
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_3D_VOLATILE]);
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q1_VOLATILE]);

		BlockDrawerConfigRange configRange = tempConfigRange;
		configRange.set(mConfigRangeStandard);

		if (lastLanded + 1 < slice.getNumChunks() + slice.getFirstChunk()) {
			clipTouchedPath(
					mLastBitmapTouchedPath[BITMAP_REGION_Q0_VOLATILE],
					slice.getChunksAggregated()[lastLanded + 1], configRange,
					Consts.QPANE_0, tempOffset, extendByPixels);
			clipTouchedPath(
					mLastBitmapTouchedPath[BITMAP_REGION_Q1_VOLATILE],
					slice.getChunksAggregated()[lastLanded + 1], configRange,
					Consts.QPANE_1, tempOffset, extendByPixels);
			clipTouchedPath(
					mLastBitmapTouchedPath[BITMAP_REGION_3D_VOLATILE],
					slice.getChunksAggregated()[lastLanded + 1], configRange,
					Consts.QPANE_3D, tempOffset, extendByPixels);
		}
	}

	private void drawChunksFallingWithLastSlice_helperDrawBlockfield(
			DrawSettings drawSettings, int qPane, Canvas canvas, Offset offset,
			GameBlocksSlice slice, int lastLandedChunk,
			BlockDrawerSliceTime sliceTime,
			boolean includeDisplacementRowsIfAvailable) {

		BlockDrawerConfigRange configRange = tempConfigRange;
		configRange.set(drawSettings.displayedRows, drawSettings.COLS);

		long currentTime = sliceTime.getUnpaused();

		float alphaScale_fillPulse = animationSettings == null ? 0
				: animationSettings.pulseAlpha(
						drawSettings.alphaScale_lockedFillPulse, currentTime);
		float alphaScale_boxPulse = animationSettings == null ? 0
				: animationSettings.pulseAlpha(
						drawSettings.alphaScale_lockedBoxPulse, currentTime);

		canvas.drawColor(0xffff00ff);

		// set canvas translation
		canvasTranslationOffset.x = canvasTranslationOffset.y = 0;

		int pieceType = slice.getPieceType();
		byte[][][] field = slice.getBlockfields()[lastLandedChunk];

		byte[][][][] field_corners = mLastCorners_byField_byPaneCorner
				.get(INDEX_FIELD_FALLING_FIELD);
		short[][][] field_shadows = mLastFillShadowSets_byField_byPane
				.get(INDEX_FIELD_FALLING_FIELD);
		short[][][][] field_drop = mLastDropShadowSets_byField_byPane_byUniqueColor
				.get(INDEX_FIELD_FALLING_FIELD);

		byte[][][][] field_qo_corners = mLastQOConnectedCorners_byField_byPaneCorner
				.get(INDEX_FIELD_FALLING_FIELD);
		short[][][] field_qo_sets = mLastQOConnectedSets_byField_byPane
				.get(INDEX_FIELD_FALLING_FIELD);
		
		byte[][][][] displacement_corners = mLastCorners_byField_byPaneCorner.get(INDEX_FIELD_DISPLACEMENT) ;
		// clear the canvas
		drawBackgroundBehaviorToCanvas(drawSettings, canvas, null, sliceTime,
				BlockDrawerConfigCanvas.Background.CLEAR);

		boolean drawQ0 = qPane == Consts.QPANE_ALL || qPane == Consts.QPANE_0;
		boolean drawQ1 = qPane == Consts.QPANE_ALL || qPane == Consts.QPANE_1;
		boolean draw3D = qPane == Consts.QPANE_ALL || qPane == Consts.QPANE_3D;

		if (includeDisplacementRowsIfAvailable
				&& drawSettings.getBehaviorIs_displacement()) {
			drawDisplacementOffset.takeVals(offset);
			drawDisplacementOffset.offsetXY(0,
					drawSettings.ROWS * drawSettings.size_blockHeight);
		}

		// draw to last bitmap canvas
		if (drawSettings.drawQ1 && drawQ1) {
			// PANE 1: displacement.
			if (includeDisplacementRowsIfAvailable
					&& drawSettings.getBehaviorIs_displacement()) {
				drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
						(drawSettings.alpha_displacementBorder > 0 ? STYLE_FILL_AND_BORDER : STYLE_FILL),
						canvas, slice.getDisplacementBlockfield(),
						mConfigRangeDisplaced, Consts.QPANE_1, pieceType,
						drawDisplacementOffset,
						drawSettings.alpha_displacementFill, 0, 0, 0, drawSettings.alpha_displacementBorder, 0, 0,
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_TL],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_TR],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_BL],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_BR],
						null, null, sliceTime,
						GlowEffect.TYPE_NONE, true, null);
			}
			// PANE 1: draw row neg 1
			if (drawSettings.behavior_border == DrawSettings.BEHAVIOR_BORDER_ROW_NEGATIVE_ONE)
				drawRowNegativeOneToCanvas(drawSettings, canvas,
						Consts.QPANE_1,
						drawSettings.alpha_rowNegativeOneBorder, offset);
			// PANE 1: field
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, field,
					configRange, Consts.QPANE_1, pieceType, offset, -1,
					drawSettings.alpha_lockedFill, alphaScale_fillPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					field_corners[Consts.QPANE_1][INDEX_CORNER_TL],
					field_corners[Consts.QPANE_1][INDEX_CORNER_TR],
					field_corners[Consts.QPANE_1][INDEX_CORNER_BL],
					field_corners[Consts.QPANE_1][INDEX_CORNER_BR],
					field_qo_corners[Consts.QPANE_1][INDEX_CORNER_TL],
					field_qo_corners[Consts.QPANE_1][INDEX_CORNER_TR],
					field_qo_corners[Consts.QPANE_1][INDEX_CORNER_BL],
					field_qo_corners[Consts.QPANE_1][INDEX_CORNER_BR],
					field_shadows[Consts.QPANE_1], field_drop[Consts.QPANE_1],
					field_qo_sets[Consts.QPANE_1], sliceTime,
					GlowEffect.TYPE_NONE, null, FadeEffect.TYPE_NONE, null);
		}

		if (drawSettings.draw3D && draw3D) {
			// PANE 3D: field
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, field,
					configRange, Consts.QPANE_3D, pieceType, offset, -1,
					drawSettings.alpha_lockedFill, alphaScale_boxPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					field_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					field_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					field_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					field_corners[Consts.QPANE_0][INDEX_CORNER_BR],
					field_qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					field_qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					field_qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					field_qo_corners[Consts.QPANE_0][INDEX_CORNER_BR],
					field_shadows[Consts.QPANE_0], field_drop[Consts.QPANE_0],
					field_qo_sets[Consts.QPANE_0], sliceTime,
					GlowEffect.TYPE_NONE, null, FadeEffect.TYPE_NONE, null);
		}

		// draw to last bitmap canvas
		if (drawSettings.drawQ0 && drawQ0) {
			// PANE 1: displacement.
			if (includeDisplacementRowsIfAvailable
					&& drawSettings.getBehaviorIs_displacement()) {
				drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
						(drawSettings.alpha_displacementBorder > 0 ? STYLE_FILL_AND_BORDER : STYLE_FILL),
						canvas, slice.getDisplacementBlockfield(),
						mConfigRangeDisplaced, Consts.QPANE_0, pieceType,
						drawDisplacementOffset,
						drawSettings.alpha_displacementFill, 0, 0, 0, drawSettings.alpha_displacementBorder, 0, 0,
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_TL],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_TR],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_BL],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_BR],
						null, null, sliceTime,
						GlowEffect.TYPE_NONE, true, null);
			}
			// PANE 0: draw row neg 1
			if (drawSettings.behavior_border == DrawSettings.BEHAVIOR_BORDER_ROW_NEGATIVE_ONE)
				drawRowNegativeOneToCanvas(drawSettings, canvas,
						Consts.QPANE_0,
						drawSettings.alpha_rowNegativeOneBorder, offset);
			// PANE 0: field
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, field,
					configRange, Consts.QPANE_0, pieceType, offset, -1,
					drawSettings.alpha_lockedFill, alphaScale_fillPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					field_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					field_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					field_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					field_corners[Consts.QPANE_0][INDEX_CORNER_BR],
					field_qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					field_qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					field_qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					field_qo_corners[Consts.QPANE_0][INDEX_CORNER_BR],
					field_shadows[Consts.QPANE_0], field_drop[Consts.QPANE_0],
					field_qo_sets[Consts.QPANE_0], sliceTime,
					GlowEffect.TYPE_NONE, null, FadeEffect.TYPE_NONE, null);
		}
	}

	private void drawChunksFallingWithLastSlice_helperDrawAggregatedChunks(
			DrawSettings drawSettings, int qPane, Canvas canvas, Offset offset,
			GameBlocksSlice slice, int lastLandedChunk,
			BlockDrawerSliceTime sliceTime) {

		long currentTime = sliceTime.getUnpaused();

		float alphaScale_fillPulse = animationSettings == null ? 0
				: animationSettings.pulseAlpha(
						drawSettings.alphaScale_lockedFillPulse, currentTime);
		float alphaScale_boxPulse = animationSettings == null ? 0
				: animationSettings.pulseAlpha(
						drawSettings.alphaScale_lockedBoxPulse, currentTime);

		// log( 
		// "drawChunksFallingWithLastSlice_helperDrawAggregatedChunks has offset "
		// + offset ) ;

		// set canvas translation
		canvasTranslationOffset.x = canvasTranslationOffset.y = 0;

		drawBackgroundBehaviorToCanvas(drawSettings, canvas, null, sliceTime,
				BlockDrawerConfigCanvas.Background.CLEAR);

		// canvas.drawColor(0xff00ffff) ;

		int firstFalling = lastLandedChunk + 1;
        if (firstFalling >= slice.getNumChunks() + slice.getFirstChunk()) {
            return;
        }

		int pieceType = slice.getPieceType();
		byte[][][] chunks = slice.getChunksAggregated()[firstFalling];

		byte[][][][] chunk_corners = mLastCorners_byField_byPaneCorner
				.get(INDEX_FIELD_FALLING_CHUNKS);
		short[][][] chunk_shadows = mLastFillShadowSets_byField_byPane
				.get(INDEX_FIELD_FALLING_CHUNKS);
		short[][][][] chunk_drop = mLastDropShadowSets_byField_byPane_byUniqueColor
				.get(INDEX_FIELD_FALLING_CHUNKS);

		byte[][][][] chunk_qo_corners = mLastQOConnectedCorners_byField_byPaneCorner
				.get(INDEX_FIELD_FALLING_CHUNKS);
		short[][][] chunk_qo_sets = mLastQOConnectedSets_byField_byPane
				.get(INDEX_FIELD_FALLING_CHUNKS);

		boolean drawQ0 = qPane == Consts.QPANE_ALL || qPane == Consts.QPANE_0;
		boolean drawQ1 = qPane == Consts.QPANE_ALL || qPane == Consts.QPANE_1;
		boolean draw3D = qPane == Consts.QPANE_ALL || qPane == Consts.QPANE_3D;

		int extraRows = Math.min(
				mChunksFallingLowestRow_atLastVolatileAlignment,
				drawSettings.ROWS - drawSettings.displayedRows);

		BlockDrawerConfigRange configRange = tempConfigRange;
		configRange.set(drawSettings.displayedRows + extraRows,
				drawSettings.COLS);

		// Adjust our offset. We want to draw
		// mChunksFallingLowestRow_atLastVolatileAlignment aligned with position
		// (row) 0.
		// However, the aggregated chunks we draw are positioned having fallen
		// slice.getFallDistances()[lastLandedChunk+1]. We need to adjust them
		// by a certain number
		// of blocks upward or downward.
		int blocksToLower = mChunksFallingLowestRow_atLastVolatileAlignment
				- slice.getFallDistances()[firstFalling];
		o.takeVals(offset);
		o.y += blocksToLower * drawSettings.size_blockHeight;

		// draw to last bitmap canvas
		if (drawSettings.drawQ1 && drawQ1) {
			// PANE 1: chunks
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, chunks,
					configRange, Consts.QPANE_1, pieceType, o, -1,
					drawSettings.alpha_lockedFill, alphaScale_fillPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					chunk_corners[Consts.QPANE_1][INDEX_CORNER_TL],
					chunk_corners[Consts.QPANE_1][INDEX_CORNER_TR],
					chunk_corners[Consts.QPANE_1][INDEX_CORNER_BL],
					chunk_corners[Consts.QPANE_1][INDEX_CORNER_BR],
					chunk_qo_corners[Consts.QPANE_1][INDEX_CORNER_TL],
					chunk_qo_corners[Consts.QPANE_1][INDEX_CORNER_TR],
					chunk_qo_corners[Consts.QPANE_1][INDEX_CORNER_BL],
					chunk_qo_corners[Consts.QPANE_1][INDEX_CORNER_BR],
					chunk_shadows[Consts.QPANE_1], chunk_drop[Consts.QPANE_1],
					chunk_qo_sets[Consts.QPANE_1], sliceTime,
					GlowEffect.TYPE_NONE, null, FadeEffect.TYPE_NONE, null);
		}

		if (drawSettings.draw3D && draw3D) {
			// PANE 3D: chunks
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, chunks,
					configRange, Consts.QPANE_3D, pieceType, o, -1,
					drawSettings.alpha_lockedFill, alphaScale_boxPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					chunk_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					chunk_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					chunk_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					chunk_corners[Consts.QPANE_0][INDEX_CORNER_BR],
					chunk_qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					chunk_qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					chunk_qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					chunk_qo_corners[Consts.QPANE_0][INDEX_CORNER_BR],
					chunk_shadows[Consts.QPANE_0], chunk_drop[Consts.QPANE_0],
					chunk_qo_sets[Consts.QPANE_0], sliceTime,
					GlowEffect.TYPE_NONE, null, FadeEffect.TYPE_NONE, null);
		}

		// draw to last bitmap canvas
		if (drawSettings.drawQ0 && drawQ0) {
            // Log.d("DEBUG GHOST", "drawing aggregated chunk " + firstFalling + " num " + slice.getNumChunks() + " first " + slice.getFirstChunk());
			// PANE 0: chunks
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, chunks,
					configRange, Consts.QPANE_0, pieceType, o, -1,
					drawSettings.alpha_lockedFill, alphaScale_fillPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					chunk_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					chunk_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					chunk_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					chunk_corners[Consts.QPANE_0][INDEX_CORNER_BR],
					chunk_qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					chunk_qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					chunk_qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					chunk_qo_corners[Consts.QPANE_0][INDEX_CORNER_BR],
					chunk_shadows[Consts.QPANE_0], chunk_drop[Consts.QPANE_0],
					chunk_qo_sets[Consts.QPANE_1], sliceTime,
					GlowEffect.TYPE_NONE, null, FadeEffect.TYPE_NONE, null);
		}

	}

	private void drawChunksFallingWithLastSlice_helperDrawUnlockGlows(
			DrawSettings drawSettings, Canvas canvas, Offset offset,
			GameBlocksSlice slice, BlockDrawerSliceTime sliceTime,
			Offset offsetBackground,
			BlockDrawerConfigCanvas.Background configCanvasBackground,
			int blockCoveredYOffset, boolean includeDisplacementRowsIfAvailable) {

		BlockDrawerConfigRange configRange = tempConfigRange;
		configRange.set(drawSettings.displayedRows, drawSettings.COLS);

		long currentTime = sliceTime.getUnpaused();

		float alphaScale_fillPulse = animationSettings == null ? 0
				: animationSettings.pulseAlpha(
						drawSettings.alphaScale_lockedFillPulse, currentTime);
		float alphaScale_boxPulse = animationSettings == null ? 0
				: animationSettings.pulseAlpha(
						drawSettings.alphaScale_lockedBoxPulse, currentTime);

		// set canvas translation
		canvasTranslationOffset.x = canvasTranslationOffset.y = 0;

		int pieceType = slice.getPieceType();
		byte[][][] field = slice.getChunksFallingPreBlockfield();
		byte[][][][] corners = mLastCorners_byField_byPaneCorner
				.get(INDEX_FIELD_FALLING_FIELD);
		short[][][] shadows = mLastFillShadowSets_byField_byPane
				.get(INDEX_FIELD_FALLING_FIELD);
		short[][][][] drop = mLastDropShadowSets_byField_byPane_byUniqueColor
				.get(INDEX_FIELD_FALLING_FIELD);

		byte[][][][] qo_corners = mLastQOConnectedCorners_byField_byPaneCorner
				.get(INDEX_FIELD_FALLING_FIELD);
		short[][][] qo_sets = mLastQOConnectedSets_byField_byPane
				.get(INDEX_FIELD_FALLING_FIELD);
		
		byte[][][][] displacement_corners = mLastCorners_byField_byPaneCorner.get(INDEX_FIELD_DISPLACEMENT) ;

		// draw background
		fullBlitDrawBackground(drawSettings, canvas, offsetBackground,
				sliceTime, configCanvasBackground, 255, 255,
				blockCoveredYOffset);

		// set canvas translation
		canvasTranslationOffset.x = canvasTranslationOffset.y = 0;

		if (includeDisplacementRowsIfAvailable
				&& drawSettings.getBehaviorIs_displacement()) {
			drawDisplacementOffset.takeVals(offset);
			drawDisplacementOffset.offsetXY(0,
					drawSettings.ROWS * drawSettings.size_blockHeight);
		}

		// draw to last bitmap canvas
		if (drawSettings.drawQ1) {
			// PANE 1: displacement.
			if (includeDisplacementRowsIfAvailable
					&& drawSettings.getBehaviorIs_displacement()) {
				drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
						(drawSettings.alpha_displacementBorder > 0 ? STYLE_FILL_AND_BORDER : STYLE_FILL),
						canvas, slice.getDisplacementBlockfield(),
						mConfigRangeDisplaced, Consts.QPANE_1, pieceType,
						drawDisplacementOffset,
						drawSettings.alpha_displacementFill, 0, 0, 0, drawSettings.alpha_displacementBorder, 0, 0,
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_TL],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_TR],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_BL],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_BR],
						null, null, sliceTime,
						GlowEffect.TYPE_NONE, true, null);
			}
			// PANE 1: draw row neg 1
			if (drawSettings.behavior_border == DrawSettings.BEHAVIOR_BORDER_ROW_NEGATIVE_ONE)
				drawRowNegativeOneToCanvas(drawSettings, canvas,
						Consts.QPANE_1,
						drawSettings.alpha_rowNegativeOneBorder, offset);
			// PANE 1: field and glows.
			// We can do this is one pass! We draw the fills according to
			// 'pre blockfield', and the shadows / corners according to
			// those set in mLastSlice*. They have been configured to
			// correctly
			// represent the chunks in their top (pre-fall) position, which
			// corresponds to their preBlockfield fill positions. Finally,
			// we have placed the glows relevant to unlocking at '0' so they
			// can be included in the same pass.
			// Easy peasy lemon squeezy.
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas,
					slice.getChunksFallingPreBlockfield(), configRange,
					Consts.QPANE_1, pieceType, offset, -1,
					drawSettings.alpha_lockedFill, alphaScale_fillPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					corners[Consts.QPANE_1][INDEX_CORNER_TL],
					corners[Consts.QPANE_1][INDEX_CORNER_TR],
					corners[Consts.QPANE_1][INDEX_CORNER_BL],
					corners[Consts.QPANE_1][INDEX_CORNER_BR],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_TL],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_TR],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_BL],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_BR],
					shadows[Consts.QPANE_1], drop[Consts.QPANE_1],
					qo_sets[Consts.QPANE_1], sliceTime, GlowEffect.TYPE_ANY,
					mLastEffectsGlow, FadeEffect.TYPE_NONE, null);
		}

		if (drawSettings.draw3D) {
			// PANE 3D: draw the field
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, field,
					configRange, Consts.QPANE_3D, pieceType, offset, -1,
					drawSettings.alpha_lockedFill, alphaScale_boxPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					corners[Consts.QPANE_0][INDEX_CORNER_TL],
					corners[Consts.QPANE_0][INDEX_CORNER_TR],
					corners[Consts.QPANE_0][INDEX_CORNER_BL],
					corners[Consts.QPANE_0][INDEX_CORNER_BR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BR], null, null,
					qo_sets[Consts.QPANE_0], sliceTime, GlowEffect.TYPE_NONE,
					null, FadeEffect.TYPE_NONE, null);
		}

		// draw to last bitmap canvas
		if (drawSettings.drawQ0) {
			// PANE 0: displacement.
			if (includeDisplacementRowsIfAvailable
					&& drawSettings.getBehaviorIs_displacement()) {
				drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
						(drawSettings.alpha_displacementBorder > 0 ? STYLE_FILL_AND_BORDER : STYLE_FILL),
						canvas, slice.getDisplacementBlockfield(),
						mConfigRangeDisplaced, Consts.QPANE_0, pieceType,
						drawDisplacementOffset,
						drawSettings.alpha_displacementFill, 0, 0, 0, drawSettings.alpha_displacementBorder, 0, 0,
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_TL],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_TR],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_BL],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_BR],
						null, null, sliceTime,
						GlowEffect.TYPE_NONE, true, null);
			}
			// PANE 0: draw row neg 1
			if (drawSettings.behavior_border == DrawSettings.BEHAVIOR_BORDER_ROW_NEGATIVE_ONE)
				drawRowNegativeOneToCanvas(drawSettings, canvas,
						Consts.QPANE_0,
						drawSettings.alpha_rowNegativeOneBorder, offset);
			// PANE 0: field and glows.
			// We can do this is one pass! We draw the fills according to
			// 'pre blockfield', and the shadows / corners according to
			// those set in mLastSlice*. They have been configured to
			// correctly
			// represent the chunks in their top (pre-fall) position, which
			// corresponds to their preBlockfield fill positions. Finally,
			// we have placed the glows relevant to unlocking at '0' so they
			// can be included in the same pass.
			// Easy peasy lemon squeezy!
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas,
					slice.getChunksFallingPreBlockfield(), configRange,
					Consts.QPANE_0, pieceType, offset, -1,
					drawSettings.alpha_lockedFill, alphaScale_fillPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					corners[Consts.QPANE_0][INDEX_CORNER_TL],
					corners[Consts.QPANE_0][INDEX_CORNER_TR],
					corners[Consts.QPANE_0][INDEX_CORNER_BL],
					corners[Consts.QPANE_0][INDEX_CORNER_BR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BR],
					shadows[Consts.QPANE_0], drop[Consts.QPANE_0],
					qo_sets[Consts.QPANE_0], sliceTime, GlowEffect.TYPE_ANY,
					mLastEffectsGlow, FadeEffect.TYPE_NONE, null);
		}
	}

	private boolean drawChunksFallingWithLastSlice_helperDrawFallingChunks(
			DrawSettings drawSettings, Canvas canvas, Offset offset,
			GameBlocksSlice slice, BlockDrawerSliceTime sliceTime,
			long timeSpentFalling, float blocksFallen, int lastLandedChunk,
			int extraRows, Offset offsetBackground,
			BlockDrawerConfigCanvas.Background configCanvasBackground,
			int blockCoveredYOffset, boolean includeDisplacementRowsIfAvailable) {

		BlockDrawerConfigRange configRange = tempConfigRange;
		configRange.set(
				drawSettings.displayedRows + extraRows,
				drawSettings.COLS);

		long currentTime = sliceTime.getUnpaused();

		float alphaScale_fillPulse = animationSettings == null ? 0
				: animationSettings.pulseAlpha(
						drawSettings.alphaScale_lockedFillPulse, currentTime);
		float alphaScale_boxPulse = animationSettings == null ? 0
				: animationSettings.pulseAlpha(
						drawSettings.alphaScale_lockedBoxPulse, currentTime);

		// set canvas translation
		canvasTranslationOffset.x = canvasTranslationOffset.y = 0;

		// find 'first falling', the first chunk which is still in the air at
		// this time,
		// and also 'first animating', the chunk which is animating its "lock"
		// glow.
		int firstFalling = lastLandedChunk + 1;
		boolean hasFalling = firstFalling - slice.getFirstChunk() < slice
				.getNumChunks();
		long timeToAnimateLock = 0;
		for (int i = 0; i < drawSettings.glow_alphaPeakNormalized[Consts.GLOW_LOCK].length; i++) {
			timeToAnimateLock = Math
					.max(timeToAnimateLock,
							animationSettings
									.lockGlowTimeToFinish(
											0,
											drawSettings.glow_alphaPeakNormalized[Consts.GLOW_LOCK][i],
											0));
		}

		int pieceType = slice.getPieceType();
		byte[][][] field = slice.getBlockfields()[firstFalling - 1];
		byte[][][] chunks = hasFalling ? slice.getChunksAggregated()[firstFalling]
				: null;

		byte[][][][] field_corners = mLastCorners_byField_byPaneCorner
				.get(INDEX_FIELD_FALLING_FIELD);
		short[][][] field_shadows = mLastFillShadowSets_byField_byPane
				.get(INDEX_FIELD_FALLING_FIELD);
		short[][][][] field_drop = mLastDropShadowSets_byField_byPane_byUniqueColor
				.get(INDEX_FIELD_FALLING_FIELD);
		byte[][][][] field_qo_corners = mLastQOConnectedCorners_byField_byPaneCorner
				.get(INDEX_FIELD_FALLING_FIELD);
		short[][][] field_qo_sets = mLastQOConnectedSets_byField_byPane
				.get(INDEX_FIELD_FALLING_FIELD);

		byte[][][][] chunk_corners = mLastCorners_byField_byPaneCorner
				.get(INDEX_FIELD_FALLING_CHUNKS);
		short[][][] chunk_shadows = mLastFillShadowSets_byField_byPane
				.get(INDEX_FIELD_FALLING_CHUNKS);
		short[][][][] chunk_drop = mLastDropShadowSets_byField_byPane_byUniqueColor
				.get(INDEX_FIELD_FALLING_CHUNKS);
		byte[][][][] chunk_qo_corners = mLastQOConnectedCorners_byField_byPaneCorner
				.get(INDEX_FIELD_FALLING_CHUNKS);
		short[][][] chunk_qo_sets = mLastQOConnectedSets_byField_byPane
				.get(INDEX_FIELD_FALLING_CHUNKS);
		
		byte[][][][] displacement_corners = mLastCorners_byField_byPaneCorner.get(INDEX_FIELD_DISPLACEMENT) ;

		ArrayList<short[][]> glows;
		ArrayList<Integer> glowQOs;

		o.takeVals(offset);

		// what to draw! Whelp, first we draw the chunks that are currently
		// falling. Their fill contents can be determined by iterating from
		// firstFalling
		// to the last chunk; their corners and shadows are stored in
		// INDEX_FIELD_FALLING_CHUNK.
		// draw all falling chunks first. Then draw the stationary blocks, at
		// firstFalling-1.
		// Finally, draw all the glows starting at firstAnimating all the way to
		// firstFalling-1.

		// TODO: If drawing FILL and TOP takes up too much of our time, it might
		// be
		// worth modifying GameBlocksSlice to store "chunks still in motion"
		// explicitly
		// in their own arrays (indexed by fallDistance), so that the fill and
		// top layer
		// can be drawn in a single pass.

		// draw background
		fullBlitDrawBackground(drawSettings, canvas, offsetBackground,
				sliceTime, configCanvasBackground, 255, 255,
				blockCoveredYOffset);

		// set canvas translation
		canvasTranslationOffset.x = canvasTranslationOffset.y = 0;

		float distanceLeftToFall = slice.getFallDistances()[firstFalling]
				- blocksFallen;
		o.y = offset.y
				- Math.round(drawSettings.size_blockHeight
						* distanceLeftToFall);

		if (includeDisplacementRowsIfAvailable
				&& drawSettings.getBehaviorIs_displacement()) {
			// displaced from the floor, NOT the chunks.
			drawDisplacementOffset.takeVals(offset);
			drawDisplacementOffset.offsetXY(0,
					drawSettings.ROWS * drawSettings.size_blockHeight);
		}

		// draw to last bitmap canvas
		if (drawSettings.drawQ1) {
			// PANE 1: displacement.
			if (includeDisplacementRowsIfAvailable
					&& drawSettings.getBehaviorIs_displacement()) {
				drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
						(drawSettings.alpha_displacementBorder > 0 ? STYLE_FILL_AND_BORDER : STYLE_FILL),
						canvas, slice.getDisplacementBlockfield(),
						mConfigRangeDisplaced, Consts.QPANE_1, pieceType,
						drawDisplacementOffset,
						drawSettings.alpha_displacementFill, 0, 0, 0, drawSettings.alpha_displacementBorder, 0, 0,
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_TL],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_TR],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_BL],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_BR],
						null, null, sliceTime,
						GlowEffect.TYPE_NONE, true, null);
			}
			// PANE 1: draw row neg 1
			if (drawSettings.behavior_border == DrawSettings.BEHAVIOR_BORDER_ROW_NEGATIVE_ONE)
				drawRowNegativeOneToCanvas(drawSettings, canvas,
						Consts.QPANE_1,
						drawSettings.alpha_rowNegativeOneBorder, offset);
			// PANE 1: chunk drop shadow, field drop shadow
			drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
					STYLE_DROP_SHADOW, canvas, chunks, configRange,
					Consts.QPANE_1, pieceType, o, 255, 255, 255, 255, 255, 255,
					255, null, null, null, null, null,
					chunk_drop[Consts.QPANE_1], sliceTime,
					GlowEffect.TYPE_NONE, null);
			drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
					STYLE_DROP_SHADOW, canvas, field, configRange,
					Consts.QPANE_1, pieceType, offset, 255, 255, 255, 255, 255,
					255, 255, null, null, null, null, null,
					field_drop[Consts.QPANE_1], sliceTime,
					GlowEffect.TYPE_NONE, null);
			// PANE 1: chunks
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, chunks,
					configRange, Consts.QPANE_1, pieceType, o, -1,
					drawSettings.alpha_lockedFill, alphaScale_fillPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					chunk_corners[Consts.QPANE_1][INDEX_CORNER_TL],
					chunk_corners[Consts.QPANE_1][INDEX_CORNER_TR],
					chunk_corners[Consts.QPANE_1][INDEX_CORNER_BL],
					chunk_corners[Consts.QPANE_1][INDEX_CORNER_BR],
					chunk_qo_corners[Consts.QPANE_1][INDEX_CORNER_TL],
					chunk_qo_corners[Consts.QPANE_1][INDEX_CORNER_TR],
					chunk_qo_corners[Consts.QPANE_1][INDEX_CORNER_BL],
					chunk_qo_corners[Consts.QPANE_1][INDEX_CORNER_BR],
					chunk_shadows[Consts.QPANE_1], null,
					chunk_qo_sets[Consts.QPANE_1], sliceTime,
					GlowEffect.TYPE_NONE, null, FadeEffect.TYPE_NONE, null);
			// PANE 1: field
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, field,
					configRange, Consts.QPANE_1, pieceType, offset, -1,
					drawSettings.alpha_lockedFill, alphaScale_fillPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					field_corners[Consts.QPANE_1][INDEX_CORNER_TL],
					field_corners[Consts.QPANE_1][INDEX_CORNER_TR],
					field_corners[Consts.QPANE_1][INDEX_CORNER_BL],
					field_corners[Consts.QPANE_1][INDEX_CORNER_BR],
					field_qo_corners[Consts.QPANE_1][INDEX_CORNER_TL],
					field_qo_corners[Consts.QPANE_1][INDEX_CORNER_TR],
					field_qo_corners[Consts.QPANE_1][INDEX_CORNER_BL],
					field_qo_corners[Consts.QPANE_1][INDEX_CORNER_BR],
					field_shadows[Consts.QPANE_1], null,
					field_qo_sets[Consts.QPANE_1], sliceTime,
					GlowEffect.TYPE_NONE, null, FadeEffect.TYPE_NONE, null);
			// PANE 1: glows
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, null,
					configRange, Consts.QPANE_1, pieceType, offset, -1, 255,
					255,
					255,
					255, // spot errors with this
					null, null, null, null, null, null, null, null, null, null,
					null, sliceTime, GlowEffect.TYPE_ANY, mLastEffectsGlow,
					FadeEffect.TYPE_NONE, null);
		}

		if (drawSettings.draw3D) {
			// PANE 3D: chunks
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, chunks,
					configRange, Consts.QPANE_3D, pieceType, o, -1,
					drawSettings.alpha_lockedFill, alphaScale_boxPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					chunk_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					chunk_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					chunk_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					chunk_corners[Consts.QPANE_0][INDEX_CORNER_BR],
					chunk_qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					chunk_qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					chunk_qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					chunk_qo_corners[Consts.QPANE_0][INDEX_CORNER_BR],
					chunk_shadows[Consts.QPANE_0], null,
					chunk_qo_sets[Consts.QPANE_0], sliceTime,
					GlowEffect.TYPE_NONE, null, FadeEffect.TYPE_NONE, null);
			// PANE 3D: field
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, field,
					configRange, Consts.QPANE_3D, pieceType, offset, -1,
					drawSettings.alpha_lockedFill, alphaScale_boxPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					field_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					field_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					field_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					field_corners[Consts.QPANE_0][INDEX_CORNER_BR],
					field_qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					field_qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					field_qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					field_qo_corners[Consts.QPANE_0][INDEX_CORNER_BR],
					field_shadows[Consts.QPANE_1], null,
					field_qo_sets[Consts.QPANE_0], sliceTime,
					GlowEffect.TYPE_NONE, null, FadeEffect.TYPE_NONE, null);
		}

		// draw to last bitmap canvas
		if (drawSettings.drawQ0) {
			// PANE 0: displacement.
			if (includeDisplacementRowsIfAvailable
					&& drawSettings.getBehaviorIs_displacement()) {
				drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
						(drawSettings.alpha_displacementBorder > 0 ? STYLE_FILL_AND_BORDER : STYLE_FILL),
						canvas, slice.getDisplacementBlockfield(),
						mConfigRangeDisplaced, Consts.QPANE_0, pieceType,
						drawDisplacementOffset,
						drawSettings.alpha_displacementFill, 0, 0, 0, drawSettings.alpha_displacementBorder, 0, 0,
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_TL],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_TR],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_BL],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_BR],
						null, null, sliceTime,
						GlowEffect.TYPE_NONE, true, null);
			}
			// PANE 0: draw row neg 1
			if (drawSettings.behavior_border == DrawSettings.BEHAVIOR_BORDER_ROW_NEGATIVE_ONE)
				drawRowNegativeOneToCanvas(drawSettings, canvas,
						Consts.QPANE_0,
						drawSettings.alpha_rowNegativeOneBorder, offset);
			// PANE 0: chunk drop shadow, field drop shadow
			drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
					STYLE_DROP_SHADOW, canvas, chunks, configRange,
					Consts.QPANE_0, pieceType, o, 255, 255, 255, 255, 255, 255,
					255, null, null, null, null, null,
					chunk_drop[Consts.QPANE_0], sliceTime,
					GlowEffect.TYPE_NONE, null);
			drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
					STYLE_DROP_SHADOW, canvas, field, configRange,
					Consts.QPANE_0, pieceType, offset, 255, 255, 255, 255, 255,
					255, 255, null, null, null, null, null,
					field_drop[Consts.QPANE_0], sliceTime,
					GlowEffect.TYPE_NONE, null);
			// PANE 0: chunks
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, chunks,
					configRange, Consts.QPANE_0, pieceType, o, -1,
					drawSettings.alpha_lockedFill, alphaScale_fillPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					chunk_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					chunk_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					chunk_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					chunk_corners[Consts.QPANE_0][INDEX_CORNER_BR],
					chunk_qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					chunk_qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					chunk_qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					chunk_qo_corners[Consts.QPANE_0][INDEX_CORNER_BR],
					chunk_shadows[Consts.QPANE_0], null,
					chunk_qo_sets[Consts.QPANE_0], sliceTime,
					GlowEffect.TYPE_NONE, null, FadeEffect.TYPE_NONE, null);
			// PANE 0: field
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, field,
					configRange, Consts.QPANE_0, pieceType, offset, -1,
					drawSettings.alpha_lockedFill, alphaScale_fillPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					field_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					field_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					field_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					field_corners[Consts.QPANE_0][INDEX_CORNER_BR],
					field_qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					field_qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					field_qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					field_qo_corners[Consts.QPANE_0][INDEX_CORNER_BR],
					field_shadows[Consts.QPANE_0], null,
					field_qo_sets[Consts.QPANE_0], sliceTime,
					GlowEffect.TYPE_NONE, null, FadeEffect.TYPE_NONE, null);
			// PANE 0: glows
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, null,
					configRange, Consts.QPANE_0, pieceType, offset, -1, 255,
					255,
					255,
					255, // spot errors with this
					null, null, null, null, null, null, null, null, null, null,
					null, sliceTime, GlowEffect.TYPE_ANY, mLastEffectsGlow,
					FadeEffect.TYPE_NONE, null);
		}

		if (hasFalling)
			return false;
		int numGlows = mLastEffectsGlow.size() ;
		for (int i = 0; i < numGlows; i++) {
			GlowEffect glowEffect = mLastEffectsGlow.get(i);
			if (glowEffect.isType(GlowEffect.TYPE_LOCK)
					&& glowEffect.timeSinceStarted(sliceTime) < timeToAnimateLock)
				return false;
		}

		return true;
	}

	private boolean drawChunksFallingWithLastSlice_helperDrawRisingFadingChunks(
			DrawSettings drawSettings, Canvas canvas, Offset offset,
			GameBlocksSlice slice, BlockDrawerSliceTime sliceTime,
			long timeSpentRising, float blocksRisen, Offset offsetBackground,
			BlockDrawerConfigCanvas.Background configCanvasBackground,
			int blockCoveredYOffset, boolean includeDisplacementRowsIfAvailable) {

		BlockDrawerConfigRange configRange = tempConfigRange;
		configRange.set(drawSettings.displayedRows, drawSettings.COLS);

		long currentTime = sliceTime.getUnpaused();

		float alphaScale_fillPulse = animationSettings == null ? 0
				: animationSettings.pulseAlpha(
						drawSettings.alphaScale_lockedFillPulse, currentTime);
		float alphaScale_boxPulse = animationSettings == null ? 0
				: animationSettings.pulseAlpha(
						drawSettings.alphaScale_lockedBoxPulse, currentTime);

		float riseFadeAlphaMult = animationSettings.riseFadeAlpha(1.0f, 0.0f,
				timeSpentRising);
		int riseFadeBackgroundAlpha = Math.round(riseFadeAlphaMult * 255);

		// set canvas translation
		canvasTranslationOffset.x = canvasTranslationOffset.y = 0;

		// 'first rising' is always firstChunk + 1, if such a thing even exists.
		int firstRising = slice.getFirstChunk() + 1;
		byte[][][] chunks = firstRising < slice.getFirstChunk()
				+ slice.getNumChunks() ? slice.getChunksAggregated()[firstRising]
				: null;
		byte[][][] field = slice.getBlockfields()[firstRising - 1];

		int pieceType = slice.getPieceType();

		byte[][][][] field_corners = mLastCorners_byField_byPaneCorner
				.get(INDEX_FIELD_FALLING_FIELD);
		short[][][] field_shadows = mLastFillShadowSets_byField_byPane
				.get(INDEX_FIELD_FALLING_FIELD);
		short[][][][] field_drop = mLastDropShadowSets_byField_byPane_byUniqueColor
				.get(INDEX_FIELD_FALLING_FIELD);
		byte[][][][] field_qo_corners = mLastQOConnectedCorners_byField_byPaneCorner
				.get(INDEX_FIELD_FALLING_FIELD);
		short[][][] field_qo_sets = mLastQOConnectedSets_byField_byPane
				.get(INDEX_FIELD_FALLING_FIELD);

		byte[][][][] chunk_corners = mLastCorners_byField_byPaneCorner
				.get(INDEX_FIELD_FALLING_CHUNKS);
		short[][][] chunk_shadows = mLastFillShadowSets_byField_byPane
				.get(INDEX_FIELD_FALLING_CHUNKS);
		short[][][][] chunk_drop = mLastDropShadowSets_byField_byPane_byUniqueColor
				.get(INDEX_FIELD_FALLING_CHUNKS);
		byte[][][][] chunk_qo_corners = mLastQOConnectedCorners_byField_byPaneCorner
				.get(INDEX_FIELD_FALLING_FIELD);
		short[][][] chunk_qo_sets = mLastQOConnectedSets_byField_byPane
				.get(INDEX_FIELD_FALLING_FIELD);
		
		byte[][][][] displacement_corners = mLastCorners_byField_byPaneCorner.get(INDEX_FIELD_DISPLACEMENT) ;

		o.takeVals(offset);
		float distanceOffset = slice.getFallDistances()[firstRising]
				+ blocksRisen;
		o.y = offset.y
				- Math.round(drawSettings.size_blockHeight
						* distanceOffset);

		// what to draw! Whelp, first we draw the chunks that are currently
		// falling. Their fill contents can be determined by iterating from
		// firstFalling
		// to the last chunk; their corners and shadows are stored in
		// INDEX_FIELD_FALLING_CHUNK.
		// draw all falling chunks first. Then draw the stationary blocks, at
		// firstFalling-1.
		// Finally, draw all the glows starting at firstAnimating all the way to
		// firstFalling-1.

		// draw background
		// draw background: happens in 2 different steps. If we draw 'all,' we
		// fill
		// now. Otherwise, if BLOCK_FILL, we draw twice - first to set the
		// background
		// color, second to draw the fills themselves.
		fullBlitDrawBackground(drawSettings, canvas, offsetBackground,
				sliceTime, configCanvasBackground, 255,
				riseFadeBackgroundAlpha, blockCoveredYOffset);

		// set canvas translation
		canvasTranslationOffset.x = canvasTranslationOffset.y = 0;

		if (includeDisplacementRowsIfAvailable
				&& drawSettings.getBehaviorIs_displacement()) {
			drawDisplacementOffset.takeVals(o);
			drawDisplacementOffset.offsetXY(0,
					drawSettings.ROWS * drawSettings.size_blockHeight);
		}

		// draw to last bitmap canvas
		if (drawSettings.drawQ1) {
			// PANE 1: displacement.
			if (includeDisplacementRowsIfAvailable
					&& drawSettings.getBehaviorIs_displacement()) {
				drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
						(drawSettings.alpha_displacementBorder > 0 ? STYLE_FILL_AND_BORDER : STYLE_FILL),
						canvas, slice.getDisplacementBlockfield(),
						mConfigRangeDisplaced, Consts.QPANE_1, pieceType,
						drawDisplacementOffset,
						drawSettings.alpha_displacementFill, 0, 0, 0, drawSettings.alpha_displacementBorder, 0, 0,
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_TL],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_TR],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_BL],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_BR],
						null, null, sliceTime,
						GlowEffect.TYPE_NONE, true, null);
			}
			// PANE 1: draw row neg 1
			if (drawSettings.behavior_border == DrawSettings.BEHAVIOR_BORDER_ROW_NEGATIVE_ONE)
				drawRowNegativeOneToCanvas(drawSettings, canvas,
						Consts.QPANE_1,
						drawSettings.alpha_rowNegativeOneBorder, offset);
			// PANE 1: chunk drop shadow, field drop shadow
			this.drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
					STYLE_DROP_SHADOW, canvas, chunks, configRange,
					Consts.QPANE_1, pieceType, o, 255, 255, 255, 255, 255, 255,
					(int) (riseFadeAlphaMult * 255), null, null, null, null,
					null, chunk_drop[Consts.QPANE_1], sliceTime,
					GlowEffect.TYPE_NONE, null);
			this.drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
					STYLE_DROP_SHADOW, canvas, chunks, configRange,
					Consts.QPANE_1, pieceType, offset, 255, 255, 255, 255, 255,
					255, 255, null, null, null, null, null,
					field_drop[Consts.QPANE_1], sliceTime,
					GlowEffect.TYPE_NONE, null);
			// PANE 1: chunks. Explicitly draw a fading background.
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, chunks,
					configRange, Consts.QPANE_1, pieceType, o,
					riseFadeAlphaMult, drawSettings.alpha_lockedFill,
					alphaScale_fillPulse, drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					chunk_corners[Consts.QPANE_1][INDEX_CORNER_TL],
					chunk_corners[Consts.QPANE_1][INDEX_CORNER_TR],
					chunk_corners[Consts.QPANE_1][INDEX_CORNER_BL],
					chunk_corners[Consts.QPANE_1][INDEX_CORNER_BR],
					chunk_qo_corners[Consts.QPANE_1][INDEX_CORNER_TL],
					chunk_qo_corners[Consts.QPANE_1][INDEX_CORNER_TR],
					chunk_qo_corners[Consts.QPANE_1][INDEX_CORNER_BL],
					chunk_qo_corners[Consts.QPANE_1][INDEX_CORNER_BR],
					chunk_shadows[Consts.QPANE_1], null,
					chunk_qo_sets[Consts.QPANE_1], sliceTime,
					GlowEffect.TYPE_NONE, null, FadeEffect.TYPE_NONE, null);
			// PANE 1: field
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, field,
					configRange, Consts.QPANE_1, pieceType, offset, -1,
					drawSettings.alpha_lockedFill, alphaScale_fillPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					field_corners[Consts.QPANE_1][INDEX_CORNER_TL],
					field_corners[Consts.QPANE_1][INDEX_CORNER_TR],
					field_corners[Consts.QPANE_1][INDEX_CORNER_BL],
					field_corners[Consts.QPANE_1][INDEX_CORNER_BR],
					field_qo_corners[Consts.QPANE_1][INDEX_CORNER_TL],
					field_qo_corners[Consts.QPANE_1][INDEX_CORNER_TR],
					field_qo_corners[Consts.QPANE_1][INDEX_CORNER_BL],
					field_qo_corners[Consts.QPANE_1][INDEX_CORNER_BR],
					field_shadows[Consts.QPANE_1], null,
					field_qo_sets[Consts.QPANE_1], sliceTime,
					GlowEffect.TYPE_NONE, null, FadeEffect.TYPE_NONE, null);
			// PANE 1 has no glows
		}

		if (drawSettings.draw3D) {
			// PANE 3D: chunks
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, chunks,
					configRange, Consts.QPANE_3D, pieceType, o,
					riseFadeAlphaMult, drawSettings.alpha_lockedFill,
					alphaScale_boxPulse, drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					chunk_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					chunk_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					chunk_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					chunk_corners[Consts.QPANE_0][INDEX_CORNER_BR],
					chunk_qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					chunk_qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					chunk_qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					chunk_qo_corners[Consts.QPANE_0][INDEX_CORNER_BR],
					chunk_shadows[Consts.QPANE_0], null,
					chunk_qo_sets[Consts.QPANE_0], sliceTime,
					GlowEffect.TYPE_NONE, null, FadeEffect.TYPE_NONE, null);
			// PANE 3D: field
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, field,
					configRange, Consts.QPANE_3D, pieceType, offset, -1,
					drawSettings.alpha_lockedFill, alphaScale_boxPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					field_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					field_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					field_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					field_corners[Consts.QPANE_0][INDEX_CORNER_BR],
					field_qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					field_qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					field_qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					field_qo_corners[Consts.QPANE_0][INDEX_CORNER_BR],
					field_shadows[Consts.QPANE_0], null,
					field_qo_sets[Consts.QPANE_0], sliceTime,
					GlowEffect.TYPE_NONE, null, FadeEffect.TYPE_NONE, null);
		}

		// draw to last bitmap canvas
		if (drawSettings.drawQ0) {
			// PANE 0: displacement.
			if (includeDisplacementRowsIfAvailable
					&& drawSettings.getBehaviorIs_displacement()) {
				drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
						(drawSettings.alpha_displacementBorder > 0 ? STYLE_FILL_AND_BORDER : STYLE_FILL),
						canvas, slice.getDisplacementBlockfield(),
						mConfigRangeDisplaced, Consts.QPANE_0, pieceType,
						drawDisplacementOffset,
						drawSettings.alpha_displacementFill, 0, 0, 0, drawSettings.alpha_displacementBorder, 0, 0,
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_TL],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_TR],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_BL],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_BR],
						null, null, sliceTime,
						GlowEffect.TYPE_NONE, true, null);
			}
			// PANE 0: draw row neg 1
			if (drawSettings.behavior_border == DrawSettings.BEHAVIOR_BORDER_ROW_NEGATIVE_ONE)
				drawRowNegativeOneToCanvas(drawSettings, canvas,
						Consts.QPANE_0,
						drawSettings.alpha_rowNegativeOneBorder, offset);
			// PANE 0: chunk drop shadow, field drop shadow
			this.drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
					STYLE_DROP_SHADOW, canvas, chunks, configRange,
					Consts.QPANE_0, pieceType, o, 255, 255, 255, 255, 255, 255,
					(int) (riseFadeAlphaMult * 255), null, null, null, null,
					null, chunk_drop[Consts.QPANE_0], sliceTime,
					GlowEffect.TYPE_NONE, null);
			this.drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
					STYLE_DROP_SHADOW, canvas, chunks, configRange,
					Consts.QPANE_0, pieceType, offset, 255, 255, 255, 255, 255,
					255, 255, null, null, null, null, null,
					field_drop[Consts.QPANE_0], sliceTime,
					GlowEffect.TYPE_NONE, null);
			// PANE 0: chunks
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, chunks,
					configRange, Consts.QPANE_0, pieceType, o,
					riseFadeAlphaMult, drawSettings.alpha_lockedFill,
					alphaScale_fillPulse, drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					chunk_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					chunk_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					chunk_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					chunk_corners[Consts.QPANE_0][INDEX_CORNER_BR],
					chunk_qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					chunk_qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					chunk_qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					chunk_qo_corners[Consts.QPANE_0][INDEX_CORNER_BR],
					chunk_shadows[Consts.QPANE_0], null,
					chunk_qo_sets[Consts.QPANE_0], sliceTime,
					GlowEffect.TYPE_NONE, null, FadeEffect.TYPE_NONE, null);
			// PANE 0: field
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, field,
					configRange, Consts.QPANE_0, pieceType, offset, -1,
					drawSettings.alpha_lockedFill, alphaScale_fillPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					field_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					field_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					field_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					field_corners[Consts.QPANE_0][INDEX_CORNER_BR],
					field_qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					field_qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					field_qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					field_qo_corners[Consts.QPANE_0][INDEX_CORNER_BR],
					field_shadows[Consts.QPANE_0], null,
					field_qo_sets[Consts.QPANE_0], sliceTime,
					GlowEffect.TYPE_NONE, null, FadeEffect.TYPE_NONE, null);
			// PANE 0 has no glows
		}

		return riseFadeAlphaMult == 0;
	}

	private long timeToDrawUnlock(GameBlocksSlice slice) {
		if (slice.getNumUnlockedColumns() > 0) {
			if (mDrawSettings.drawEffects == DrawSettings.DRAW_EFFECTS_IN_SLICE)
				return animationSettings.unlockColumnGlowTotalTime(0, 1, 0);
			else
				return animationSettings.unlockColumnGlowExitPeakTime(0, 1, 0);
		}

		return 0;
	}

	private void drawRowsClearingWithLastSlice(Canvas canvas,
			QuantroSoundPool pool, GameBlocksSlice slice,
			BlockDrawerSliceTime sliceTime, BlockDrawerConfigCanvas configCanvas) {

		if (configCanvas == null && mNextSliceNeedsExplicitConfigCanvas)
			configCanvas = mDrawSettings.configCanvas;

		if (this.veilOnScreen(sliceTime))
			throw new IllegalStateException(
					"Can only display veil in Stable or Piece Falling");

		tick();

		// Our "efficient" draw function. We draw to
		// mLastBitmapCanvas[BITMAP_FULL], then
		// draw mLastBitmap to the canvas provided.

		boolean backgroundChanged = backgroundLayerChanged(mLastSliceTime, sliceTime);
		boolean fieldChanged = false; // a change in underlying field. Either
										// 'pre' is not 'stable', or the field
										// has changed since the last
		boolean fieldTransition = false; // a transition from emphasis to
											// "clearing." This requires
											// recomputing shadows and computing
											// glows.

		boolean emphasizing; // if 'true' we are still in the 'row emphasis'
								// phase of clearing; if false, the 'glow'
								// phase.
		boolean emphasizingLast;
		boolean drawingPreField;

		boolean firstTimeThisAnimation = false; // if 'emphasizing', this the
												// first time we've emphasized
												// this clear.

		byte[][][] pre_field = slice.getClearPreBlockfield();
		byte[][][] post_field = slice.getClearPostBlockfield();
		byte[][][] cleared_field = slice.getClearClearedBlocks();

		// The field has changed and requires a complete re-draw, or a very
		// careful clipping, if
		// ( the last tick was not clearing and not stable OR stable blockfield
		// doesn't match the current one )
		// OR ( the last tick was clearing, but the fields don't match the
		// provided slice ).

		tick();
		boolean sliceStateChanged = mLastSlice.getBlocksState() != slice
				.getBlocksState() || !sliceTime.hasBeenDrawnEver();

		if (sliceStateChanged
				&& GlobalTestSettings.BLOCK_DRAWER_LOG_SLICE_STATE)
			log( 
					"now drawing rows clearing with slice time "
							+ sliceTime.getSlice());

		emphasizing = !animationSettings.clearEmphFinished(
				mDrawSettings.alpha_lockedFill, mDrawSettings.alpha_emphFill,
				sliceTime.getSlice());
		emphasizingLast = !sliceStateChanged
				&& !animationSettings.clearEmphFinished(
						mDrawSettings.alpha_lockedFill,
						mDrawSettings.alpha_emphFill,
						sliceTime.getLastDrawnSlice());
		drawingPreField = emphasizing
				|| !animationSettings.clearEmphFinished(
						mDrawSettings.alpha_lockedFill,
						mDrawSettings.alpha_emphFill, sliceTime.getSlice())
				|| !animationSettings.clearGlowPeaked(
						0,
						1,
						0,
						sliceTime.getSlice()
								- animationSettings.clearEmphTotalTime(
										mDrawSettings.alpha_lockedFill,
										mDrawSettings.alpha_emphFill));

		fieldChanged = mNextSliceBreaksSequence;
		fieldChanged = fieldChanged
				|| (mLastSlice.getBlocksState() != GameBlocksSlice.BLOCKS_ROWS_CLEARING && (!mLastBitmapIsStableSlice || (mNextSlicePossiblyInconsistent && !ArrayOps
						.areEqual(mLastSlice.getBlockfieldStable(), pre_field))))
				|| (mLastSlice.getBlocksState() == GameBlocksSlice.BLOCKS_ROWS_CLEARING
						&& mNextSlicePossiblyInconsistent && (!ArrayOps
						.areEqual(mLastSlice.getClearPreBlockfield(), pre_field)
						|| !ArrayOps
								.areEqual(mLastSlice.getClearPostBlockfield(),
										post_field) || !ArrayOps.areEqual(
						mLastSlice.getClearClearedBlocks(), cleared_field))) ;
		fieldChanged = fieldChanged || mLastBitmapDifferentDisplacement ;
		// field transition if the field didn't change but our "emphasizing"
		// status did.
		// This indicates that we should recalculate shadows and corners but not
		// necessarily redraw
		// everything (we will clip
		// to include the clearing rows and their surroundings in any
		// circumstance).
		// BUG TEST: changing this to switch when clear glow peaks.
		fieldTransition = !fieldChanged
				&& drawingPreField == (animationSettings.clearEmphFinished(
						mDrawSettings.alpha_lockedFill,
						mDrawSettings.alpha_emphFill,
						sliceTime.getLastDrawnSlice()) && animationSettings
						.clearGlowPeaked(
								0,
								1,
								0,
								sliceTime.getLastDrawnSlice()
										- animationSettings.clearEmphTotalTime(
												mDrawSettings.alpha_lockedFill,
												mDrawSettings.alpha_emphFill)));

		if (emphasizing)
			firstTimeThisAnimation = sliceStateChanged || fieldChanged
					|| !sliceTime.hasBeenDrawnEver();
		else
			firstTimeThisAnimation = sliceStateChanged || fieldChanged
					|| !sliceTime.hasBeenDrawnEver() || emphasizingLast;

		if (fieldChanged)
			mProfileBehavior = BlockDrawer.INDEX_PROFILE_SLICE_CLEARING_BEHAVIOR_FIELD_CHANGED;
		else if (fieldTransition)
			mProfileBehavior = BlockDrawer.INDEX_PROFILE_SLICE_CLEARING_BEHAVIOR_FIELD_TRANSITION;
		else if (emphasizing)
			mProfileBehavior = BlockDrawer.INDEX_PROFILE_SLICE_CLEARING_BEHAVIOR_EMPHASIZING_ROWS;
		else
			mProfileBehavior = BlockDrawer.INDEX_PROFILE_SLICE_CLEARING_BEHAVIOR_GLOWING_ROWS;
		mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_CHECK_EQUALITY] += tock();

		// We recalculate shadows and corners if the field changed or
		// transitioned.
		// We calculate glows at the start of the animation, or if the field
		// changes.
		if (fieldChanged
				|| mLastSlice.getBlocksState() != GameBlocksSlice.BLOCKS_ROWS_CLEARING) {
			// recalc glows.
			tick();
			long clearEmphTotalTime = animationSettings.clearEmphTotalTime(
					mDrawSettings.alpha_lockedFill,
					mDrawSettings.alpha_emphFill);
			long clearGlowDuration = 0;
			for (int i = 0; i < mDrawSettings.glow_alphaPeakNormalized[Consts.GLOW_CLEAR].length; i++) {
				clearGlowDuration = Math
						.max(clearGlowDuration,
								animationSettings
										.clearGlowTimeToFinish(
												0,
												mDrawSettings.glow_alphaPeakNormalized[Consts.GLOW_CLEAR][i],
												0));
			}
			for (int qp = 0; qp < 2; qp++) {
				if ((qp == 0 && mDrawSettings.drawQ0)
						|| (qp == 1 && mDrawSettings.drawQ1)) {
					this.addClearGlows(mDrawSettings, slice.getClears(),
							slice.getMonochromeClears(), qp, mLastEffectsGlow,
							clearEmphTotalTime, clearGlowDuration, 0);
				}
			}
			// Sound Effects: clear emphasis (if there is one), and clear.
			drawRowsClearingWithLastSlice_helperAddSoundEffects(
					slice, BlockDrawerSliceTime.RelativeTo.SLICE, 0, clearEmphTotalTime, 0 ) ;

			mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_SET_EFFECTS] += tock();
		}
		if (fieldChanged || fieldTransition || sliceStateChanged) {
			// recalc shadows and corners
			tick();
			byte[][][] field = drawingPreField ? pre_field : post_field;
			// log("clearing: recalc corners and shadows.  pre_field: " +
			// drawingPreField) ;
			byte[][][][] corners = mLastCorners_byField_byPaneCorner
					.get(INDEX_FIELD_CLEARING);
			short[][][] shadows = mLastFillShadowSets_byField_byPane
					.get(INDEX_FIELD_CLEARING);
			short[][][][] drop = mLastDropShadowSets_byField_byPane_byUniqueColor
					.get(INDEX_FIELD_CLEARING);
			setShadowsAndCorners(mDrawSettings, field, mConfigRangeStandard,
					shadows, drop, corners);

			// only non-pulsing FILL and TOP are drawn in VOLATILE; STABLE
			// includes all
			// pulsing top and fill, as well as all 3D information.
			byte[][][][] qoCorners = this.mLastQOConnectedCorners_byField_byPaneCorner
					.get(INDEX_FIELD_CLEARING);
			short[][][] qoSets = this.mLastQOConnectedSets_byField_byPane
					.get(INDEX_FIELD_CLEARING);
			setQOConnectionAndCorners(mDrawSettings, field,
					mConfigRangeStandard, qoSets, qoCorners);

			mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_SET_SHADOWS_AND_CORNERS] += tock();
		}

		int height = mDrawSettings.height;
		int blitHeight = mDrawSettings.configCanvas.region.height();
		// for clipping, we need to extend the clip by a certain distance
		// from each altered block. This lets us draw and re-draw our drop
		// shadow,
		// which extends slightly beyond the reach of each block.
		int extendByPixels = Math.max(boundDropShadowHeight(mDrawSettings),
				boundDropShadowWidth(mDrawSettings));

		boolean doubleBitmapOffset = mLastBitmap != null
				&& mDrawSettings.drawAnimations >= DrawSettings.DRAW_ANIMATIONS_STABLE_STUTTER
				&& mDrawSettings.getBlit() != DrawSettings.BLIT_SEPTUPLE
				&& !mDrawSettings.getBehaviorIs_displacement();

		// ////
		// /////////////////////////////////////////////////////////////////
		// Set the Touched / Covered regions.

		setAlignmentOffset(slice.getBlockfieldStable(), clipOffset);
		if (doubleBitmapOffset)
			clipOffset.y += height;

		if (drawingPreField
				&& (fieldChanged || sliceStateChanged || firstTimeThisAnimation || mLastBitmapDifferentDisplacement)) {

			// log("clearing: preparing to PRE field") ;
			// for stable, we draw almost everything, clipping for
			// full-coverage.
			// Stable contains all the edges and shadows of the
			// "preBlockfield,"

			// generate coverage and touching. Coverage is according to
			// post-clear, while touched
			// is according to pre.
			drawRowsClearingWithLastSlice_helperClipCoveredStablePostClear(
					slice, clipOffset);
			drawRowsClearingWithLastSlice_helperClipTouchedStablePreClear(
					slice, clipOffset, extendByPixels, true);

			// generate coverage and touching. Volatile covers and
			// touches exactly the
			// cleared blocks.
			drawRowsClearingWithLastSlice_helperClipCoveredVolatile(slice,
					clipOffset);
			drawRowsClearingWithLastSlice_helperClipTouchedVolatile(slice,
					clipOffset, 0);
		}

		if (!drawingPreField
				&& (fieldTransition || fieldChanged || sliceStateChanged || firstTimeThisAnimation || mLastBitmapDifferentDisplacement)) {

			// generate coverage and touching - both post clear.
			drawRowsClearingWithLastSlice_helperClipCoveredStablePostClear(
					slice, clipOffset);
			drawRowsClearingWithLastSlice_helperClipTouchedStablePostClear(
					slice, clipOffset, extendByPixels, true);

			// VOLATILE: there is nothing to do. Set it empty (we don't
			// actually need to redraw).
			drawRowsClearingWithLastSlice_helperClipCoveredVolatileEmpty();
			drawRowsClearingWithLastSlice_helperClipTouchedVolatileEmpty();
		}

		if (!veilOnScreen(sliceTime) || !mLastBitmapVeiled || fieldChanged
				|| sliceStateChanged
				|| !sliceTime.hasBeenDrawnAtThisSliceTime()) {
			// If using BLIT_FULL, we set offsets to match the mLast, clip
			// according
			// to changes, draw to mLastBitmap and finally blit to the canvas.
			// If
			// using BLIT_NONE, we set offset to match the canvas, clip UNION
			// the
			// pulses (assuming an appropriate clip is already in place), and
			// draw
			// directly to the canvas.
			switch (mDrawSettings.getBlit()) {
			case DrawSettings.BLIT_SEPTUPLE:
				// set offsets
				if (fieldChanged || alignmentOffsetSet || sliceStateChanged) {
					setAlignmentOffset(slice.getBlockfieldStable(),
							alignmentOffset);
					canvasAlignmentOffset.takeVals(alignmentOffset);

					alignmentOffsetSet = false;
				}
				canvasTranslationOffset.x = 0;
				canvasTranslationOffset.y = 0;

				// clip!
				tick();
				reset(mLastBitmapClipPath);
				if (fieldChanged || mLastBitmapVeiled) {
					// clip everything.
					for (int i = 0; i < mLastBitmap.length; i++)
						unionRect(mLastBitmapClipPath[i], 0, 0,
								mLastBitmapBounds[i].width(),
								mLastBitmapBounds[i].height(),
								Path.Direction.CW);

					// touched and covered clips are adjusted below: if the
					// field changed,
				}

				if (drawingPreField
						&& (fieldChanged || sliceStateChanged || firstTimeThisAnimation)) {
					// log("septuple clearing: preparing to PRE field") ;
					// for stable, we draw almost everything, clipping for
					// full-coverage.
					// Stable contains all the edges and shadows of the
					// "preBlockfield,"
					// but the fill and top content of "post."
					// Note: if the field changed, we already clipped
					// everything, so we can
					// safely ignore that possibility.

					for (int qp = 0; qp < 3; qp++) {
						int qPane = 0, BMAP = 0;
						if (qp == 0) {
							qPane = Consts.QPANE_0;
							BMAP = BITMAP_SEPTUPLE_Q0_STABLE;
						} else if (qp == 1) {
							qPane = Consts.QPANE_1;
							BMAP = BITMAP_SEPTUPLE_Q1_STABLE;
						} else if (qp == 2) {
							qPane = Consts.QPANE_3D;
							BMAP = BITMAP_SEPTUPLE_3D_STABLE;
						}

						reset(clipPath);
						this.clipContentUnion(clipPath,
								slice.getClearPreBlockfield(), qPane, 0,
								alignmentOffset, extendByPixels);
						op(mLastBitmapClipPath[BITMAP_FULL], clipPath, Path.Op.UNION);
						op(mLastBitmapClipPath[BMAP], clipPath, Path.Op.UNION);
					}

					// for volatile, we draw ONLY AND EXACTLY the fill and top
					// content in the row(s) being cleared,
					// since this is what we are glowing to emphasize.
					for (int qp = 0; qp < 3; qp++) {
						int qPane = 0, BMAP = 0;
						if (qp == 0) {
							qPane = Consts.QPANE_0;
							BMAP = BITMAP_SEPTUPLE_Q0_VOLATILE;
						} else if (qp == 1) {
							qPane = Consts.QPANE_1;
							BMAP = BITMAP_SEPTUPLE_Q1_VOLATILE;
						} else if (qp == 2) {
							qPane = Consts.QPANE_3D;
							BMAP = BITMAP_SEPTUPLE_3D_VOLATILE;
						}

						reset(clipPath);
						this.clipContentUnion(clipPath,
								slice.getClearClearedBlocks(), qPane, 0,
								alignmentOffset, extendByPixels);
						op(mLastBitmapClipPath[BITMAP_FULL], clipPath, Path.Op.UNION);
						op(mLastBitmapClipPath[BMAP], clipPath, Path.Op.UNION);
					}
				}

				if (!drawingPreField
						&& (fieldTransition || fieldChanged
								|| sliceStateChanged || firstTimeThisAnimation)) {
					// log( 
					// "septuple clearing: switching to POST stable field") ;
					// our glow peaked; time to change from pre- to post-clear.
					// For stable, we need to redraw everything in the pre-clear
					// field; however,
					// this is only to erase content now cleared away, so its
					// touched and covered regions are smaller.
					for (int qp = 0; qp < 3; qp++) {
						int qPane = 0, BMAP = 0;
						if (qp == 0) {
							qPane = Consts.QPANE_0;
							BMAP = BITMAP_SEPTUPLE_Q0_STABLE;
						} else if (qp == 1) {
							qPane = Consts.QPANE_1;
							BMAP = BITMAP_SEPTUPLE_Q1_STABLE;
						} else if (qp == 2) {
							qPane = Consts.QPANE_3D;
							BMAP = BITMAP_SEPTUPLE_3D_STABLE;
						}

						reset(clipPath);
						this.clipContentUnion(clipPath,
								slice.getClearPreBlockfield(), qPane, 0,
								alignmentOffset, extendByPixels);
						op(mLastBitmapClipPath[BITMAP_FULL], clipPath, Path.Op.UNION);
						op(mLastBitmapClipPath[BMAP], clipPath, Path.Op.UNION);
					}
				}

				// clip "pulse" behavior. We only bother with this in stable.
				reset(clipPath);
				boolean pulseQ0 = this.clipPulseFill(clipPath,
						drawingPreField ? pre_field : post_field,
						Consts.QPANE_0, 0, alignmentOffset);
				op(mLastBitmapClipPath[BITMAP_FULL], clipPath, Path.Op.UNION);
				op(mLastBitmapClipPath[BITMAP_SEPTUPLE_Q0_STABLE], clipPath, Path.Op.UNION);

				reset(clipPath);
				boolean pulseQ1 = this.clipPulseFill(clipPath,
						drawingPreField ? pre_field : post_field,
						Consts.QPANE_1, 0, alignmentOffset);
				op(mLastBitmapClipPath[BITMAP_FULL], clipPath, Path.Op.UNION);
				op(mLastBitmapClipPath[BITMAP_SEPTUPLE_Q1_STABLE], clipPath, Path.Op.UNION);

				reset(clipPath);
				boolean pulse3D = this.clipPulseFill(clipPath,
						drawingPreField ? pre_field : post_field,
						Consts.QPANE_3D, 0, alignmentOffset);
				op(mLastBitmapClipPath[BITMAP_FULL], clipPath, Path.Op.UNION);
				op(mLastBitmapClipPath[BITMAP_SEPTUPLE_3D_STABLE], clipPath, Path.Op.UNION);

				// clear glow and emphasis are almost exactly the same area.
				if (emphasizing) {
					clipClearedRows(mLastBitmapClipPath[BITMAP_FULL],
							slice.getClears(), slice.getMonochromeClears(), 0,
							alignmentOffset, 0);
				}
				// Clip Glows
				int numGlows = mLastEffectsGlow.size() ;
				for (int i = 0; i < numGlows; i++) {
					GlowEffect glowEffect = mLastEffectsGlow.get(i);
					if (glowEffect.active(sliceTime)
							|| glowEffect.active(mLastSliceTime)) {
						this.clipGlowEffect(mLastBitmapClipPath[BITMAP_FULL],
								mLastEffectsGlow.get(i), 0, alignmentOffset);
					}
				}
                if ((configCanvas != null && configCanvas.background != null)
                        || backgroundLayerChanged(mLastSliceTime, sliceTime)) {
                    // fully draw the BITMAP_FULL canvas
                    reset(mLastBitmapClipPath[BITMAP_FULL]);
                    unionRect(mLastBitmapClipPath[BITMAP_FULL], 0, 0,
                            mLastBitmap[BITMAP_FULL].getWidth(),
                            mLastBitmap[BITMAP_FULL].getHeight(),
                            Path.Direction.CW);
                }
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_CLIP] += tock();

				int emphasisAlpha = animationSettings.clearEmphAlpha(
						mDrawSettings.alpha_lockedFill,
						mDrawSettings.alpha_emphFill, sliceTime.getSlice());

                // All draw and blit operations performed under this clip; restored after blitting
                for (int i = 0; i < mLastBitmapCanvas.length; i++) {
                    mLastBitmapCanvas[i].save();
                    mLastBitmapCanvas[i].clipPath(mLastBitmapClipPath[i]);
                }

				// draw
				tick();
				if (drawingPreField) {
					if (fieldChanged || sliceStateChanged
							|| firstTimeThisAnimation || pulseQ0)
						drawRowsClearingWithSlice_helperDrawStablePreClear(
								mDrawSettings, Consts.QPANE_0,
								mLastBitmapCanvas[BITMAP_SEPTUPLE_Q0_STABLE],
								alignmentOffset, emphasisAlpha, slice,
								sliceTime, true);
					if (fieldChanged || sliceStateChanged
							|| firstTimeThisAnimation || pulseQ1)
						drawRowsClearingWithSlice_helperDrawStablePreClear(
								mDrawSettings, Consts.QPANE_1,
								mLastBitmapCanvas[BITMAP_SEPTUPLE_Q1_STABLE],
								alignmentOffset, emphasisAlpha, slice,
								sliceTime, true);
					if (fieldChanged || sliceStateChanged
							|| firstTimeThisAnimation || pulse3D)
						drawRowsClearingWithSlice_helperDrawStablePreClear(
								mDrawSettings, Consts.QPANE_3D,
								mLastBitmapCanvas[BITMAP_SEPTUPLE_3D_STABLE],
								alignmentOffset, emphasisAlpha, slice,
								sliceTime, true);
					if (fieldChanged || sliceStateChanged
							|| firstTimeThisAnimation) {
						drawRowsClearingWithSlice_helperDrawVolatilePreClear(
								mDrawSettings, Consts.QPANE_0,
								mLastBitmapCanvas[BITMAP_SEPTUPLE_Q0_VOLATILE],
								alignmentOffset, slice, sliceTime);
						drawRowsClearingWithSlice_helperDrawVolatilePreClear(
								mDrawSettings, Consts.QPANE_1,
								mLastBitmapCanvas[BITMAP_SEPTUPLE_Q1_VOLATILE],
								alignmentOffset, slice, sliceTime);
						drawRowsClearingWithSlice_helperDrawVolatilePreClear(
								mDrawSettings, Consts.QPANE_3D,
								mLastBitmapCanvas[BITMAP_SEPTUPLE_3D_VOLATILE],
								alignmentOffset, slice, sliceTime);
					}
				} else {
					if (fieldChanged || sliceStateChanged
							|| firstTimeThisAnimation || fieldTransition
							|| pulseQ0)
						drawRowsClearingWithLastSlice_helperDrawStablePostClear(
								mDrawSettings, Consts.QPANE_0,
								mLastBitmapCanvas[BITMAP_SEPTUPLE_Q0_STABLE],
								alignmentOffset, slice, sliceTime, true);
					if (fieldChanged || sliceStateChanged
							|| firstTimeThisAnimation || fieldTransition
							|| pulseQ1)
						drawRowsClearingWithLastSlice_helperDrawStablePostClear(
								mDrawSettings, Consts.QPANE_1,
								mLastBitmapCanvas[BITMAP_SEPTUPLE_Q1_STABLE],
								alignmentOffset, slice, sliceTime, true);
					if (fieldChanged || sliceStateChanged
							|| firstTimeThisAnimation || fieldTransition
							|| pulse3D)
						drawRowsClearingWithLastSlice_helperDrawStablePostClear(
								mDrawSettings, Consts.QPANE_3D,
								mLastBitmapCanvas[BITMAP_SEPTUPLE_3D_STABLE],
								alignmentOffset, slice, sliceTime, true);
				}
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW] += tock();

				// blit
				tick();
				// canvas translation offset?
				setCanvasDestinationRect(
						mLastBitmapBlitRect[BITMAP_FULL],
						mLastBitmapBounds[BITMAP_FULL],
						mDrawSettings.configCanvas.region,
						-((int) Math.round(slice.getDisplacement()
								* mDrawSettings.size_blockHeight))
							+ mDrawSettings.displacementSafeMarginOffsetBlit);
				mLastBitmapBlitRect[BITMAP_SEPTUPLE_Q0_STABLE].set(0, 0,
						mLastBitmapBounds[BITMAP_SEPTUPLE_Q0_STABLE].width(),
						mLastBitmapBounds[BITMAP_SEPTUPLE_Q0_STABLE].height());
				mLastBitmapBlitRect[BITMAP_SEPTUPLE_Q1_STABLE].set(0, 0,
						mLastBitmapBounds[BITMAP_SEPTUPLE_Q1_STABLE].width(),
						mLastBitmapBounds[BITMAP_SEPTUPLE_Q1_STABLE].height());
				mLastBitmapBlitRect[BITMAP_SEPTUPLE_3D_STABLE].set(0, 0,
						mLastBitmapBounds[BITMAP_SEPTUPLE_3D_STABLE].width(),
						mLastBitmapBounds[BITMAP_SEPTUPLE_3D_STABLE].height());
				mLastBitmapBlitRect[BITMAP_SEPTUPLE_Q0_VOLATILE]
						.set(0, 0,
								mLastBitmapBounds[BITMAP_SEPTUPLE_Q0_VOLATILE]
										.width(),
								mLastBitmapBounds[BITMAP_SEPTUPLE_Q0_VOLATILE]
										.height());
				mLastBitmapBlitRect[BITMAP_SEPTUPLE_Q1_VOLATILE]
						.set(0, 0,
								mLastBitmapBounds[BITMAP_SEPTUPLE_Q1_VOLATILE]
										.width(),
								mLastBitmapBounds[BITMAP_SEPTUPLE_Q1_VOLATILE]
										.height());
				mLastBitmapBlitRect[BITMAP_SEPTUPLE_3D_VOLATILE]
						.set(0, 0,
								mLastBitmapBounds[BITMAP_SEPTUPLE_3D_VOLATILE]
										.width(),
								mLastBitmapBounds[BITMAP_SEPTUPLE_3D_VOLATILE]
										.height());

				// blitting behavior differs from most other modes, in which
				// STABLE is drawn
				// first, followed by a <Covered-by-Stable> clipped version of
				// VOLATILE.
				// Here, VOLATILE is drawn first (remember that if
				// drawingPostField, VOLATILE
				// has clipped-empty content), followed by STABLE which occludes
				// it.
				//
				// Volatile layers were drawn with only and exactly their fill
				// colors, at full alpha.
				// Those layers need to be blitted at the emphasis alpha.
				// This call obeys background behavior.
				septupleBlitDrawBackground(sliceTime, configCanvas);
				// Get parameters for our blit...
				int pieceType = slice.getPieceType();
				// Blit...
				boolean doneGlowing = septupleBlitStableOccludes(255,
						emphasisAlpha, alignmentOffset, pieceType, sliceTime);

                // now done with internal bitmap clips; restore
                for (int i = 0; i < mLastBitmapCanvas.length; i++) {
                    mLastBitmapCanvas[i].restore();
                }

				// blit to the main canvas
				if (configCanvas == null
						|| configCanvas.equals(mDrawSettings.configCanvas)) {
					canvas.save();
					if (mDrawSettings.configCanvas.clipRegion != null)
						canvas.clipRect(mDrawSettings.configCanvas.clipRegion,
								Region.Op.INTERSECT);

					if (mDrawSettings.behavior_background == DrawSettings.BEHAVIOR_BACKGROUND_BLIT_IMAGE) {
						drawLayeredBackgroundAssets(canvas,
								mDrawSettings.configCanvas.region, sliceTime,
								mDrawSettings.configCanvas.background);
					}

					canvas.drawBitmap(mLastBitmap[BITMAP_FULL],
							mLastBitmapBounds[BITMAP_FULL],
							mLastBitmapBlitRect[BITMAP_FULL], null);
					canvas.restore();
				} else {
					tempSrcRect.set(mLastBitmapBounds[BITMAP_FULL]);
					tempSrcRect.bottom = tempSrcRect.top + mDrawSettings.height;
					drawBitmapToCanvasWithConfig(canvas,
							mLastBitmap[BITMAP_FULL], tempSrcRect, slice,
							configCanvas, null);
				}

				// timer
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_BLIT] += tock();

				break;

			case DrawSettings.BLIT_FULL:
				// determine our offsets
				canvasTranslationOffset.x = 0;
				canvasTranslationOffset.y = 0;
				setAlignmentOffset(slice.getBlockfieldStable(), alignmentOffset);
				alignmentOffsetSet = true;
				if (doubleBitmapOffset)
					alignmentOffset.y += height;

				// clip!
				tick();
				reset(mLastBitmapClipPath[BITMAP_FULL]);
				if (fieldChanged || mBackgroundBitmapClipOrBlitIsBlitting
						|| mLastBitmapVeiled || configCanvas != null
						|| backgroundChanged) {
					// HACK HACK HACK:
					// This call is necessary because we haven't implemented an
					// "efficient" version for other
					// draw methods yet. Note that piece borders can very easily
					// change without the actual
					// value at a location changing.
					if (doubleBitmapOffset) {
					    unionRect(mLastBitmapClipPath[BITMAP_FULL], 0, height,
                                mLastBitmapBounds[BITMAP_FULL].width(),
                                height * 2,
                                Path.Direction.CW);
					} else {
						// clip with extra space below, so we have room to draw
						// displacement rows.
						float extra = mDrawSettings.getBehaviorIs_displacement()
								? mDrawSettings.size_blockHeight * 3
								: 0 ;
						unionRect(mLastBitmapClipPath[BITMAP_FULL], 0, 0,
                                mLastBitmapBounds[BITMAP_FULL].width(),
                                mLastBitmapBounds[BITMAP_FULL].height() + extra,
                                Path.Direction.CW);
					}
				} else if (fieldTransition) {
					// We don't have an efficient way to determine the changes
					// in borders yet. For now,
					// clip the whole thing.
                    unionRect(mLastBitmapClipPath[BITMAP_FULL], 0, height,
                            mLastBitmapBounds[BITMAP_FULL].width(), height * 2,
                            Path.Direction.CW);
				}
				// If we're emphasizing, clip only those rows; otherwise, clip
				// the glow areas
				// (which we assume include those rows, and more besides).
				if (emphasizing) {
					clipClearedRows(mLastBitmapClipPath[BITMAP_FULL],
							slice.getClears(), slice.getMonochromeClears(), 0,
							alignmentOffset, extendByPixels);
				}
				// Clip Glows
				numGlows = mLastEffectsGlow.size() ;
				for (int i = 0; i < numGlows; i++) {
					GlowEffect glowEffect = mLastEffectsGlow.get(i);
					if (glowEffect.active(sliceTime)
							|| glowEffect.active(mLastSliceTime)) {
						this.clipGlowEffect(mLastBitmapClipPath[BITMAP_FULL],
								glowEffect, 0, alignmentOffset);
					}
				}
				// Clip "pulse" behavior pieces.
				if (animationSettings != null) {
					clipPulseFill(mLastBitmapClipPath[BITMAP_FULL],
							drawingPreField ? pre_field : post_field, 0,
							alignmentOffset);
				}
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_CLIP] += tock();

				if (GlobalTestSettings.BLOCK_DRAWER_SHOW_COVERED_AND_TOUCHING_REGIONS) {
				    reset(mLastBitmapClipPath[BITMAP_FULL]);
                    unionRect(mLastBitmapClipPath[BITMAP_FULL], 0, 0,
                            Integer.MAX_VALUE, Integer.MAX_VALUE,
                            Path.Direction.CW);
                }

				// draw
				tick();
				mLastBitmapCanvas[BITMAP_FULL].save();
				mLastBitmapCanvas[BITMAP_FULL].clipPath(mLastBitmapClipPath[BITMAP_FULL]);
				// We have set the canvasTranslationOffset and all
				// shadow/corner/glow metadata
				BlockDrawerConfigCanvas.Background backgroundDefault = mDrawSettings
						.getBehaviorIs_backgroundBlit() ? BlockDrawerConfigCanvas.Background.CLEAR
						: BlockDrawerConfigCanvas.Background.DEFAULT;
				drawRowsClearingToCanvas_withSlice(mDrawSettings,
						mLastBitmapCanvas[BITMAP_FULL], alignmentOffset, slice,
						sliceTime, mBackgroundBitmapOffset,
						configCanvas != null ? configCanvas.background
								: backgroundDefault, 0, true);
				mLastBitmapCanvas[BITMAP_FULL].restore();
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW] += tock();

				if (GlobalTestSettings.BLOCK_DRAWER_SHOW_COVERED_AND_TOUCHING_REGIONS)
					drawTouchedCoveredTestToCanvas(mLastBitmapCanvas[BITMAP_FULL]);

				// blit
				tick();
				if (mDrawSettings.getBehaviorIs_displacement()) {
					setCanvasDestinationRect(
							mLastBitmapBlitRect[BITMAP_FULL],
							mLastBitmapBounds[BITMAP_FULL],
							mDrawSettings.configCanvas.region,
							-((int) Math.round(slice.getDisplacement()
									* mDrawSettings.size_blockHeight))
								+ mDrawSettings.displacementSafeMarginOffsetBlit);
				} else {
					mLastBitmapBlitRect[BITMAP_FULL].set(
							mDrawSettings.configCanvas.region.left,
							mDrawSettings.configCanvas.region.top
									- (doubleBitmapOffset ? blitHeight : 0),
							mDrawSettings.configCanvas.region.right,
							mDrawSettings.configCanvas.region.top + blitHeight);
				}

				if (configCanvas == null
						|| configCanvas.equals(mDrawSettings.configCanvas)) {
					canvas.save();
					if (mDrawSettings.configCanvas.clipRegion != null)
						canvas.clipRect(mDrawSettings.configCanvas.clipRegion,
								Region.Op.INTERSECT);

					if (mDrawSettings.getBehaviorIs_backgroundBlit()) {
						drawLayeredBackgroundAssets(canvas,
								mDrawSettings.configCanvas.region, sliceTime,
								mDrawSettings.configCanvas.background);
					}

					canvas.drawBitmap(mLastBitmap[BITMAP_FULL],
							mLastBitmapBounds[BITMAP_FULL],
							mLastBitmapBlitRect[BITMAP_FULL], blitPaint);
					canvas.restore();
				} else {
					// our content is available in mLastBitmap. However,
					// depending on
					// our background settings and config canvas settings, this
					// might fail.
					// throw an exception so we know this is unacceptable.
					tempSrcRect.set(mLastBitmapBounds[BITMAP_FULL]);
					tempSrcRect.bottom = tempSrcRect.top + height;
					if (doubleBitmapOffset)
						tempSrcRect.offset(0, height);
					drawBitmapToCanvasWithConfig(canvas,
							mLastBitmap[BITMAP_FULL], tempSrcRect, slice,
							configCanvas, blitPaint);
				}
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_BLIT] += tock();

				// done
				break;

			case DrawSettings.BLIT_NONE:
				// determine our true offset for the canvas
				setCanvasTranslationOffset(canvas);
				setAlignmentOffset(slice.getBlockfieldStable(), alignmentOffset);
				int displacement = 0;
				if (mDrawSettings.getBehaviorIs_displacement()) {
					displacement = -((int) Math.round(slice.getDisplacement()
							* mDrawSettings.size_blockHeight));
					alignmentOffset.y += displacement;
				}
				alignmentOffsetSet = true;

				// We don't clip, assuming that has been done for us.

				// draw to canvas!
				tick();
				// We have set the canvasTranslationOffset and all
				// shadow/corner/glow metadata
				canvas.save();
				if (mDrawSettings.configCanvas.clipRegion != null)
					canvas.clipRect(mDrawSettings.configCanvas.clipRegion,
							Region.Op.INTERSECT);
				drawRowsClearingToCanvas_withSlice(mDrawSettings, canvas,
						alignmentOffset, slice, sliceTime,
						mBackgroundBitmapOffset,
						BlockDrawerConfigCanvas.Background.DEFAULT,
						displacement, true);
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW] += tock();
				canvas.restore();

				if (GlobalTestSettings.BLOCK_DRAWER_SHOW_COVERED_AND_TOUCHING_REGIONS)
					drawTouchedCoveredTestToCanvas(canvas);

				// no need to blit.
				break;

			default:
				throw new IllegalStateException("Blit setting "
						+ mDrawSettings.getBlit() + " confuses and infuriates us");
			}

			mLastBitmapVeiled = false;
		}

		// //////////////////////////////////////////////////////////////////////
		// VEIL INSTRUCTIONS: At this point, mLastBitmap[BITMAP_FULL] is the
		// content to be drawn under the veil. Draw the veil over it.

		if (veilOnScreen(sliceTime)
				&& (configCanvas == null || configCanvas
						.equals(mDrawSettings.configCanvas))) {
			drawBitmapFullVeiledToCanvas(canvas, sliceTime,
					sliceStateChanged || fieldChanged || !mLastBitmapVeiled
							|| !sliceTime.hasBeenDrawnAtThisSliceTime());
			// only force a redraw if content changed, otherwise use our cached
			// veil.
			mLastBitmapVeiled = true;
		}

		long emphasisDuration = animationSettings.clearEmphTotalTime(
				mDrawSettings.alpha_lockedFill, mDrawSettings.alpha_emphFill);

		long timeSpentGlowing = sliceTime.getSlice()
				- animationSettings.clearEmphTotalTime(
						mDrawSettings.alpha_lockedFill,
						mDrawSettings.alpha_emphFill);

		// We have drawn to mLastBitmap[BITMAP_FULL]. Copy the slice and blit.
		if (fieldChanged || sliceStateChanged)
			mLastSlice.takeVals(slice);
		mNextSliceNeedsExplicitConfigCanvas = false;
		mNextSliceBreaksSequence = false;
		mNextSlicePossiblyInconsistent = false;
		mLastBitmapIsStableSlice = !emphasizing
				&& animationSettings.clearGlowFinished(0, 1, 0,
						timeSpentGlowing);
		mLastBitmapIsStableSliceIgnoringEffects = !emphasizing
				&& animationSettings.clearGlowPeaked(0, 1, 0, timeSpentGlowing);
		double portionOfFade = emphasisDuration == 0 ? 0.2 : 0.01;
		mLastBitmapIsStableSliceReadyToAdvanceEffects = !emphasizing
				&& timeSpentGlowing >= (long) (portionOfFade
						* animationSettings.clearGlowTimeToFinish(0, 1, 0) + (1 - portionOfFade)
						* animationSettings.clearGlowTimeToExitPeak(0, 1, 0));

		if (mLastBitmapIsStableSliceReadyToAdvanceEffects
				&& mDrawSettings.drawEffects == DrawSettings.DRAW_EFFECTS_THROUGH_SLICE)
			convertEffectsToUnpausedRelative(sliceTime);

		mBackgroundBitmapClipOrBlitIsBlitting = false;

		mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_TOTAL] += tock();
		mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_NUMBER]++;

		// Sounds!
		playSounds(sliceTime, pool);

		// last thing we do...
		sliceTime.setLastDrawn();
		clearExpiredEffects(sliceTime);

		if (mLastSliceTime != null && sliceTime != null)
			mLastSliceTime.takeVals(sliceTime);
	}
	
	
	/**
	 * Adds the sound effects used when rows "clear."
	 * 
	 * Three effect types are / could be added: clearEmphasis, clear, and penalty.
	 * 
	 * clearEmphasis starts immediately (at the provided 'startAt' time), but ONLY
	 * if the duration is >= 0 (otherwise, we assume there is no emphasis).
	 * 
	 * 'clear' -- and 'penalty', if appropriate -- start when the clear emphasis
	 * is complete (or immediately at startAt, if no clear emphasis).
	 * 
	 * @param slice
	 * @param clearEmphTotalTime
	 */
	private void drawRowsClearingWithLastSlice_helperAddSoundEffects(
			GameBlocksSlice slice, BlockDrawerSliceTime.RelativeTo relTo, long startAt,
			long clearEmphTotalTime, long extraPenaltyDelay ) {
		// Sound Effects: clear emphasis (if there is one), and clear.
		if (clearEmphTotalTime > 0)
			mLastEffectsSound.addClearEmphasis(
					relTo, startAt,
					slice.getPieceType(), slice.getClearCascadeNumber(),
					slice.getClears(), slice.getMonochromeClears());
		mLastEffectsSound.addClear(
				relTo, clearEmphTotalTime + startAt,
				slice.getPieceType(), slice.getClearCascadeNumber(),
				slice.getClears(), slice.getMonochromeClears());

		// TODO: Real penalty handling.
		// look for penalties
		boolean penalty = false;
		for (int qp = 0; qp < 2 && !penalty; qp++) {
			for (int row = 0; row < mDrawSettings.ROWS && !penalty; row++) {
				int r = row + slice.getEdge();
				if (slice.getClears()[r] != QOrientations.NO
						|| slice.getMonochromeClears()[r]) {
					for (int col = 0; col < mDrawSettings.COLS && !penalty; col++) {
						int c = col + slice.getEdge();
						int qo = slice.getClearClearedBlocks()[qp][r][c];
						penalty = penalty
								|| (qo == QOrientations.PUSH_DOWN || qo == QOrientations.PUSH_DOWN_ACTIVE);
					}
				}
			}
		}
		if (penalty) {
			mLastEffectsSound.addPenalty(
					relTo, extraPenaltyDelay + clearEmphTotalTime + startAt, QOrientations.PUSH_DOWN_ACTIVE) ;
		}
	}
	

	private void drawRowsClearingWithLastSlice_helperClipCoveredStablePostClear(
			GameBlocksSlice slice, Offset offset) {

		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_Q0_STABLE]);
		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_3D_STABLE]);
		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_Q1_STABLE]);

		// "post clear" is easily available; clip to cover the content.
		byte[][][] post_field = slice.getClearPostBlockfield();
		clipCoveredPath(mLastBitmapCoveredPath[BITMAP_REGION_Q0_STABLE],
				post_field, Consts.QPANE_0, 0, offset);
		clipCoveredPath(mLastBitmapCoveredPath[BITMAP_REGION_Q1_STABLE],
				post_field, Consts.QPANE_1, 0, offset);
		clipCoveredPath(mLastBitmapCoveredPath[BITMAP_REGION_3D_STABLE],
				post_field, Consts.QPANE_3D, 0, offset);
	}

	private void drawRowsClearingWithLastSlice_helperClipTouchedStablePreClear(
			GameBlocksSlice slice, Offset offset, int extendByPixels,
			boolean includeDisplacementRowsIfAvailable) {

		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q0_STABLE]);
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_3D_STABLE]);
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q1_STABLE]);

		drawRowsClearingWithLastSlice_helperClipTouchedStable(
				slice.getClearPreBlockfield(), mConfigRangeStandard, offset,
				extendByPixels, true);

		if (includeDisplacementRowsIfAvailable
				&& mDrawSettings.getBehaviorIs_displacement()) {
			clipDisplacementOffset.takeVals(offset);
			clipDisplacementOffset.offsetXY(0, mDrawSettings.ROWS
					* mDrawSettings.size_blockHeight);
			drawRowsClearingWithLastSlice_helperClipTouchedStable(
					slice.getDisplacementBlockfield(), mConfigRangeDisplaced,
					clipDisplacementOffset, extendByPixels, false);
		}

	}

	private void drawRowsClearingWithLastSlice_helperClipTouchedStablePostClear(
			GameBlocksSlice slice, Offset offset, int extendByPixels,
			boolean includeDisplacementRowsIfAvailable) {

		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q0_STABLE]);
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_3D_STABLE]);
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q1_STABLE]);

		drawRowsClearingWithLastSlice_helperClipTouchedStable(
				slice.getClearPostBlockfield(), mConfigRangeStandard, offset,
				extendByPixels, true);

		if (includeDisplacementRowsIfAvailable
				&& mDrawSettings.getBehaviorIs_displacement()) {
			clipDisplacementOffset.takeVals(offset);
			clipDisplacementOffset.offsetXY(0, mDrawSettings.ROWS
					* mDrawSettings.size_blockHeight);
			drawRowsClearingWithLastSlice_helperClipTouchedStable(
					slice.getDisplacementBlockfield(), mConfigRangeDisplaced,
					clipDisplacementOffset, extendByPixels, false);
		}

	}

	private void drawRowsClearingWithLastSlice_helperClipTouchedStable(
			byte[][][] field, BlockDrawerConfigRange configRange,
			Offset offset, int extendByPixels, boolean includeRowNegativeOne) {

		// "post clear" is easily available.
		clipTouchedPath(mLastBitmapTouchedPath[BITMAP_REGION_Q0_STABLE],
				field, configRange, Consts.QPANE_0, offset, extendByPixels);
		clipTouchedPath(mLastBitmapTouchedPath[BITMAP_REGION_Q1_STABLE],
				field, configRange, Consts.QPANE_1, offset, extendByPixels);
		clipTouchedPath(mLastBitmapTouchedPath[BITMAP_REGION_3D_STABLE],
				field, configRange, Consts.QPANE_3D, offset, extendByPixels);

		// row neg-1
		if (includeRowNegativeOne) {
			clipFullWidthRowNegativeOne(
					mLastBitmapTouchedPath[BITMAP_REGION_Q0_STABLE], 0,
					mDrawSettings.width, Consts.QPANE_0, offset, extendByPixels);
			clipFullWidthRowNegativeOne(
					mLastBitmapTouchedPath[BITMAP_REGION_Q1_STABLE], 0,
					mDrawSettings.width, Consts.QPANE_1, offset, extendByPixels);
		}
	}

	private void drawRowsClearingWithLastSlice_helperClipCoveredVolatile(
			GameBlocksSlice slice, Offset offset) {
		// Volatile covers only the cleared row content.
		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_Q0_VOLATILE]);
		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_3D_VOLATILE]);
		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_Q1_VOLATILE]);

		// "post clear" is easily available. We take the difference after
		// removing pulsing blocks.
		byte[][][] field = slice.getClearClearedBlocks();
		clipCoveredPath(mLastBitmapCoveredPath[BITMAP_REGION_Q0_VOLATILE],
				field, Consts.QPANE_0, 0, offset);
		reset(clipPath);
		clipPulseFill(clipPath, field, Consts.QPANE_0, 0, offset);
		op(mLastBitmapCoveredPath[BITMAP_REGION_Q0_VOLATILE], clipPath, Path.Op.DIFFERENCE);

		clipCoveredPath(mLastBitmapCoveredPath[BITMAP_REGION_Q1_VOLATILE],
				field, Consts.QPANE_1, 0, offset);
		reset(clipPath);
		clipPulseFill(clipPath, field, Consts.QPANE_1, 0, offset);
		op(mLastBitmapCoveredPath[BITMAP_REGION_Q1_VOLATILE], clipPath, Path.Op.DIFFERENCE);

		clipCoveredPath(mLastBitmapCoveredPath[BITMAP_REGION_3D_VOLATILE],
				field, Consts.QPANE_3D, 0, offset);
		// no pulses to remove in 3D pane.
	}

	private void drawRowsClearingWithLastSlice_helperClipTouchedVolatile(
			GameBlocksSlice slice, Offset offset, int extendByPixels) {
		// Volatile covers only the cleared row content - and OMITS any "pulse"
		// blocks.
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q0_VOLATILE]);
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_3D_VOLATILE]);
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q1_VOLATILE]);

		BlockDrawerConfigRange configRange = tempConfigRange;
		configRange.set(mConfigRangeStandard);

		// "post clear" is easily available. We take the difference after
		// removing pulsing blocks.
		byte[][][] field = slice.getClearClearedBlocks();
		clipTouchedPath(mLastBitmapTouchedPath[BITMAP_REGION_Q0_VOLATILE],
				field, configRange, Consts.QPANE_0, offset, extendByPixels);
		reset(clipPath);
		clipPulseFill(clipPath, field, Consts.QPANE_0, 0, offset);
		op(mLastBitmapTouchedPath[BITMAP_REGION_Q0_VOLATILE], clipPath, Path.Op.DIFFERENCE);

		clipTouchedPath(mLastBitmapTouchedPath[BITMAP_REGION_Q1_VOLATILE],
				field, configRange, Consts.QPANE_1, offset, extendByPixels);
		reset(clipPath);
		clipPulseFill(clipPath, field, Consts.QPANE_1, 0, offset);
		op(mLastBitmapTouchedPath[BITMAP_REGION_Q1_VOLATILE], clipPath, Path.Op.DIFFERENCE);

		clipTouchedPath(mLastBitmapTouchedPath[BITMAP_REGION_3D_VOLATILE],
				field, configRange, Consts.QPANE_3D, offset, extendByPixels);
		// no 3D pulses, so nothing to change.
	}

	private void drawRowsClearingWithLastSlice_helperClipCoveredVolatileEmpty() {
		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_Q0_VOLATILE]);
		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_3D_VOLATILE]);
		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_Q1_VOLATILE]);
	}

	private void drawRowsClearingWithLastSlice_helperClipTouchedVolatileEmpty() {
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q0_VOLATILE]);
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_3D_VOLATILE]);
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q1_VOLATILE]);
	}

	private void drawRowsClearingWithSlice_helperDrawStablePreClear(
			DrawSettings drawSettings, int qPane, Canvas canvas, Offset offset,
			int emphasisAlpha, GameBlocksSlice slice,
			BlockDrawerSliceTime sliceTime,
			boolean includeDisplacementRowsIfAvailable) {

		BlockDrawerConfigRange configRange = tempConfigRange;
		configRange.set(drawSettings.displayedRows, drawSettings.COLS);

		long currentTime = sliceTime.getUnpaused();

		float alphaScale_fillPulse = animationSettings == null ? 0
				: animationSettings.pulseAlpha(
						drawSettings.alphaScale_lockedFillPulse, currentTime);
		float alphaScale_BoxPulse = animationSettings == null ? 0
				: animationSettings.pulseAlpha(
						drawSettings.alphaScale_lockedBoxPulse, currentTime);

		// now COUPLE! I mean, DRAW!
		byte[][][] pre_field = slice.getClearPreBlockfield();
		byte[][][] cleared_field = slice.getClearClearedBlocks();
		byte[][][] post_field = slice.getClearPostBlockfield();
		byte[][][][] corners = mLastCorners_byField_byPaneCorner
				.get(INDEX_FIELD_CLEARING);
		short[][][] shadows = mLastFillShadowSets_byField_byPane
				.get(INDEX_FIELD_CLEARING);
		short[][][][] drop = mLastDropShadowSets_byField_byPane_byUniqueColor
				.get(INDEX_FIELD_CLEARING);
		byte[][][][] qo_corners = mLastQOConnectedCorners_byField_byPaneCorner
				.get(INDEX_FIELD_CLEARING);
		short[][][] qo_sets = mLastQOConnectedSets_byField_byPane
				.get(INDEX_FIELD_CLEARING);
		
		byte[][][][] displacement_corners = mLastCorners_byField_byPaneCorner.get(INDEX_FIELD_DISPLACEMENT) ;

		int pieceType = slice.getPieceType();

		// erase the background
		drawBackgroundBehaviorToCanvas(drawSettings, canvas, null, sliceTime,
				BlockDrawerConfigCanvas.Background.CLEAR);

		boolean drawQ0 = qPane == Consts.QPANE_0 || qPane == Consts.QPANE_ALL;
		boolean drawQ1 = qPane == Consts.QPANE_1 || qPane == Consts.QPANE_ALL;
		boolean draw3D = qPane == Consts.QPANE_3D || qPane == Consts.QPANE_ALL;

		if (includeDisplacementRowsIfAvailable
				&& drawSettings.getBehaviorIs_displacement()) {
			drawDisplacementOffset.takeVals(offset);
			drawDisplacementOffset.offsetXY(0,
					drawSettings.ROWS * drawSettings.size_blockHeight);
		}

		// draw to last bitmap canvas
		if (drawSettings.drawQ1 && drawQ1) {
			// PANE 1: displacement.
			if (includeDisplacementRowsIfAvailable
					&& drawSettings.getBehaviorIs_displacement()) {
				drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
						(drawSettings.alpha_displacementBorder > 0 ? STYLE_FILL_AND_BORDER : STYLE_FILL),
						canvas, slice.getDisplacementBlockfield(),
						mConfigRangeDisplaced, Consts.QPANE_1, pieceType,
						drawDisplacementOffset,
						drawSettings.alpha_displacementFill, 0, 0, 0, drawSettings.alpha_displacementBorder, 0, 0,
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_TL],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_TR],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_BL],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_BR],
						null, null, sliceTime,
						GlowEffect.TYPE_NONE, true, null);
			}
			// PANE 1: draw row neg 1
			if (drawSettings.behavior_border == DrawSettings.BEHAVIOR_BORDER_ROW_NEGATIVE_ONE)
				drawRowNegativeOneToCanvas(drawSettings, canvas,
						Consts.QPANE_1,
						drawSettings.alpha_rowNegativeOneBorder, offset);
			// PANE 1: field
			// draw:
			// post_field fill & top
			// cleared_field pulse fill & top
			// cleared top
			// pre_field everything else (shadows, borders, etc.)
			drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
					STYLE_FILL_AND_TOP, canvas, post_field, configRange,
					Consts.QPANE_1, pieceType, offset,
					drawSettings.alpha_lockedFill, alphaScale_fillPulse,
					drawSettings.alpha_lockedTop, 1.0f, 255, 255,
					255, // 255 to see bugs
					null, null, null, null, null, null, sliceTime,
					GlowEffect.TYPE_NONE, null);
			drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
					STYLE_PULSE_FILL, canvas, cleared_field, configRange,
					Consts.QPANE_1, pieceType, offset, emphasisAlpha,
					alphaScale_fillPulse, drawSettings.alpha_lockedTop, 1.0f,
					255, 255,
					255, // 255 to see bugs
					null, null, null, null, null, null, sliceTime,
					GlowEffect.TYPE_NONE, null);
			drawBlockFieldQPane2DAtAlignmentOffset(drawSettings, STYLE_TOP,
					canvas, cleared_field, configRange, Consts.QPANE_1,
					pieceType, offset, emphasisAlpha, alphaScale_fillPulse,
					drawSettings.alpha_lockedTop, 1.0f, 255, 255,
					255, // 255 to see bugs
					null, null, null, null, null, null, sliceTime,
					GlowEffect.TYPE_NONE, null);
			drawBlockFieldQPane2DAtAlignmentOffset(
					drawSettings,
					STYLE_ALL_BUT_FILL_AND_TOP,
					canvas,
					pre_field,
					configRange,
					Consts.QPANE_1,
					pieceType,
					offset,
					255,
					255,
					255,
					1.0f,
					drawSettings.alpha_lockedBorder,
					drawSettings.drawDetail >= DrawSettings.DRAW_DETAIL_MID ? 255
							: 0,
					255,
					corners[Consts.QPANE_1][INDEX_CORNER_TL], // no fills to
																// optimize
					corners[Consts.QPANE_1][INDEX_CORNER_TR],
					corners[Consts.QPANE_1][INDEX_CORNER_BL],
					corners[Consts.QPANE_1][INDEX_CORNER_BR],
					shadows[Consts.QPANE_1], drop[Consts.QPANE_1], sliceTime,
					GlowEffect.TYPE_NONE, null);
		}

		if (drawSettings.draw3D && draw3D) {
			// PANE 3D: draw the field
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas,
					pre_field, configRange, Consts.QPANE_3D, pieceType, offset,
					-1, drawSettings.alpha_lockedFill, alphaScale_BoxPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					corners[Consts.QPANE_0][INDEX_CORNER_TL],
					corners[Consts.QPANE_0][INDEX_CORNER_TR],
					corners[Consts.QPANE_0][INDEX_CORNER_BL],
					corners[Consts.QPANE_0][INDEX_CORNER_BR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BR], null, null,
					qo_sets[Consts.QPANE_0], sliceTime, GlowEffect.TYPE_NONE,
					null, FadeEffect.TYPE_NONE, null);
		}

		// draw to last bitmap canvas
		if (drawSettings.drawQ0 && drawQ0) {
			// PANE 1: displacement.
			if (includeDisplacementRowsIfAvailable
					&& drawSettings.getBehaviorIs_displacement()) {
				drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
						(drawSettings.alpha_displacementBorder > 0 ? STYLE_FILL_AND_BORDER : STYLE_FILL),
						canvas, slice.getDisplacementBlockfield(),
						mConfigRangeDisplaced, Consts.QPANE_0, pieceType,
						drawDisplacementOffset,
						drawSettings.alpha_displacementFill, 0, 0, 0, drawSettings.alpha_displacementBorder, 0, 0,
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_TL],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_TR],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_BL],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_BR],
						null, null, sliceTime,
						GlowEffect.TYPE_NONE, true, null);
			}
			// PANE 0: draw row neg 1
			if (drawSettings.behavior_border == DrawSettings.BEHAVIOR_BORDER_ROW_NEGATIVE_ONE)
				drawRowNegativeOneToCanvas(drawSettings, canvas,
						Consts.QPANE_0,
						drawSettings.alpha_rowNegativeOneBorder, offset);
			// PANE 0: field
			// draw:
			// post_field fill & top
			// pre_field everything else (shadows, borders, etc.)
			drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
					STYLE_FILL_AND_TOP, canvas, post_field, configRange,
					Consts.QPANE_0, pieceType, offset,
					drawSettings.alpha_lockedFill, alphaScale_fillPulse,
					drawSettings.alpha_lockedTop, 1.0f, 255, 255,
					255, // 255 to see bugs
					null, null, null, null, null, null, sliceTime,
					GlowEffect.TYPE_NONE, null);
			drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
					STYLE_PULSE_FILL, canvas, cleared_field, configRange,
					Consts.QPANE_0, pieceType, offset, emphasisAlpha,
					alphaScale_fillPulse, drawSettings.alpha_lockedTop, 1.0f,
					255, 255,
					255, // 255 to see bugs
					null, null, null, null, null, null, sliceTime,
					GlowEffect.TYPE_NONE, null);
			drawBlockFieldQPane2DAtAlignmentOffset(drawSettings, STYLE_TOP,
					canvas, cleared_field, configRange, Consts.QPANE_0,
					pieceType, offset, emphasisAlpha, alphaScale_fillPulse,
					drawSettings.alpha_lockedTop, 1.0f, 255, 255,
					255, // 255 to see bugs
					null, null, null, null, null, null, sliceTime,
					GlowEffect.TYPE_NONE, null);
			drawBlockFieldQPane2DAtAlignmentOffset(
					drawSettings,
					STYLE_ALL_BUT_FILL_AND_TOP,
					canvas,
					pre_field,
					configRange,
					Consts.QPANE_0,
					pieceType,
					offset,
					255,
					255,
					255,
					1.0f,
					drawSettings.alpha_lockedBorder,
					drawSettings.drawDetail >= DrawSettings.DRAW_DETAIL_MID ? 255
							: 0,
					255,
					corners[Consts.QPANE_0][INDEX_CORNER_TL], // no fills to
																// optimize
					corners[Consts.QPANE_0][INDEX_CORNER_TR],
					corners[Consts.QPANE_0][INDEX_CORNER_BL],
					corners[Consts.QPANE_0][INDEX_CORNER_BR],
					shadows[Consts.QPANE_0], drop[Consts.QPANE_0], sliceTime,
					GlowEffect.TYPE_NONE, null);
		}
	}

	private void drawRowsClearingWithSlice_helperDrawVolatilePreClear(
			DrawSettings drawSettings, int qPane, Canvas canvas, Offset offset,
			GameBlocksSlice slice, BlockDrawerSliceTime sliceTime) {

		BlockDrawerConfigRange configRange = tempConfigRange;
		configRange.set(drawSettings.displayedRows, drawSettings.COLS);

		int pieceType = slice.getPieceType();

		// erase the background
		drawBackgroundBehaviorToCanvas(drawSettings, canvas, null, sliceTime,
				BlockDrawerConfigCanvas.Background.CLEAR);

		boolean drawQ0 = qPane == Consts.QPANE_0 || qPane == Consts.QPANE_ALL;
		boolean drawQ1 = qPane == Consts.QPANE_1 || qPane == Consts.QPANE_ALL;
		boolean draw3D = qPane == Consts.QPANE_3D || qPane == Consts.QPANE_ALL;

		// now COUPLE! I mean, DRAW!
		byte[][][] cleared_field = slice.getClearClearedBlocks();

		// draw to last bitmap canvas
		if (drawSettings.drawQ1 && drawQ1) {
			// PANE 1: CLEARED FILL, drawn at full opacity. Omit pulsing squares
			// (they are used separately, in the "Stable" bitmaps). Full opacity
			// here allows us to blit with variable opacity without redrawing
			// this
			// bitmap, which we can't do if this bitmap contains pulsing
			// squares.
			drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
					STYLE_NOT_PULSE_FILL, canvas, cleared_field, configRange,
					Consts.QPANE_1, pieceType, offset, 255, 255, 255, 1.0f,
					255, 255,
					255, // 255 to see bugs
					null, null, null, null, null, null, null,
					GlowEffect.TYPE_NONE, null);
		}

		if (drawSettings.draw3D && draw3D) {
			// nothing to do here
		}

		// draw to last bitmap canvas
		if (drawSettings.drawQ0 && drawQ0) {
			// PANE 0: CLEARED FILL, drawn at full opacity.
			drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
					STYLE_NOT_PULSE_FILL, canvas, cleared_field, configRange,
					Consts.QPANE_0, pieceType, offset, 255, 255, 255, 1.0f,
					255, 255,
					255, // 255 to see bugs
					null, null, null, null, null, null, null,
					GlowEffect.TYPE_NONE, null);
		}
	}

	private void drawRowsClearingWithLastSlice_helperDrawStablePostClear(
			DrawSettings drawSettings, int qPane, Canvas canvas, Offset offset,
			GameBlocksSlice slice, BlockDrawerSliceTime sliceTime,
			boolean includeDisplacementRowsIfAvailable) {

		// This is equivalent to drawing 'stable.'
		this.drawStableToCanvas_withSlice(drawSettings, qPane, canvas, offset,
				slice, sliceTime, mConfigRangeStandard,
				DrawStableFieldType.STABLE, null,
				BlockDrawerConfigCanvas.Background.CLEAR, 0,
				includeDisplacementRowsIfAvailable);
	}

	private void drawRowsClearingToCanvas_withSlice(DrawSettings drawSettings,
			Canvas canvas, Offset offset, GameBlocksSlice slice,
			BlockDrawerSliceTime sliceTime, Offset offsetBackground,
			BlockDrawerConfigCanvas.Background configCanvasBackground,
			int blockCoveredYOffset, boolean includeDisplacementRowsIfAvailable) {

		BlockDrawerConfigRange configRange = tempConfigRange;
		configRange.set(drawSettings.displayedRows, drawSettings.COLS);

		long timeSpentAnimating = sliceTime.getSlice();
		long currentTime = sliceTime.getUnpaused();

		boolean drawingPreField = timeSpentAnimating < (animationSettings
				.clearEmphTotalTime(drawSettings.alpha_lockedFill,
						drawSettings.alpha_emphFill) + animationSettings
				.clearGlowTimeToPeak(0, 1, 0));

		float alphaScale_fillPulse = animationSettings == null ? 0
				: animationSettings.pulseAlpha(
						drawSettings.alphaScale_lockedFillPulse, currentTime);

		float alphaScale_boxPulse = animationSettings == null ? 0
				: animationSettings.pulseAlpha(
						drawSettings.alphaScale_lockedBoxPulse, currentTime);

		int emphFillAlpha = (animationSettings == null) ? drawSettings.alpha_lockedFill
				: animationSettings.clearEmphAlpha(
						drawSettings.alpha_lockedFill,
						drawSettings.alpha_emphFill, timeSpentAnimating);
		int emphTopAlpha = (animationSettings == null) ? drawSettings.alpha_lockedTop
				: animationSettings.clearEmphAlpha(
						drawSettings.alpha_lockedTop,
						drawSettings.alpha_emphTop, timeSpentAnimating);

		long timeSpentGlowing = timeSpentAnimating
				- animationSettings.clearEmphTotalTime(
						drawSettings.alpha_lockedFill,
						drawSettings.alpha_emphFill);

		// now COUPLE! I mean, DRAW!
		byte[][][] pre_field = slice.getClearPreBlockfield();
		byte[][][] post_field = slice.getClearPostBlockfield();
		byte[][][] cleared_field = slice.getClearClearedBlocks();
		byte[][][][] corners = mLastCorners_byField_byPaneCorner
				.get(INDEX_FIELD_CLEARING);
		short[][][] shadows = mLastFillShadowSets_byField_byPane
				.get(INDEX_FIELD_CLEARING);
		short[][][][] drop = mLastDropShadowSets_byField_byPane_byUniqueColor
				.get(INDEX_FIELD_CLEARING);

		byte[][][][] qo_corners = mLastQOConnectedCorners_byField_byPaneCorner
				.get(INDEX_FIELD_CLEARING);
		short[][][] qo_sets = mLastQOConnectedSets_byField_byPane
				.get(INDEX_FIELD_CLEARING);
		
		byte[][][][] displacement_corners = mLastCorners_byField_byPaneCorner.get(INDEX_FIELD_DISPLACEMENT) ;

		int pieceType = slice.getPieceType();

		// draw background
		// draw background: happens in 2 different steps. If we draw 'all,' we
		// fill
		// now. Otherwise, if BLOCK_FILL, we draw twice - first to set the
		// background
		// color, second to draw the fills themselves.
		fullBlitDrawBackground(drawSettings, canvas, offsetBackground,
				sliceTime, configCanvasBackground, 255, 255,
				blockCoveredYOffset);

		if (includeDisplacementRowsIfAvailable
				&& drawSettings.getBehaviorIs_displacement()) {
			drawDisplacementOffset.takeVals(offset);
			drawDisplacementOffset.offsetXY(0,
					drawSettings.ROWS * drawSettings.size_blockHeight);
		}

		// draw to last bitmap canvas
		if (drawSettings.drawQ1) {
			// PANE 1: displacement.
			if (includeDisplacementRowsIfAvailable
					&& drawSettings.getBehaviorIs_displacement()) {
				drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
						(drawSettings.alpha_displacementBorder > 0 ? STYLE_FILL_AND_BORDER : STYLE_FILL),
						canvas, slice.getDisplacementBlockfield(),
						mConfigRangeDisplaced, Consts.QPANE_1, pieceType,
						drawDisplacementOffset,
						drawSettings.alpha_displacementFill, 0, 0, 0, drawSettings.alpha_displacementBorder, 0, 0,
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_TL],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_TR],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_BL],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_BR],
						null, null, sliceTime,
						GlowEffect.TYPE_NONE, true, null);
			}
			// PANE 1: draw row neg 1
			if (drawSettings.behavior_border == DrawSettings.BEHAVIOR_BORDER_ROW_NEGATIVE_ONE)
				drawRowNegativeOneToCanvas(drawSettings, canvas,
						Consts.QPANE_1,
						drawSettings.alpha_rowNegativeOneBorder, offset);
			// PANE 1: field and glows
			// draw differs based on 'drawingPreField'. If false, draw only
			// the
			// post field with all content. If true, draw:
			// post_field fill & top
			// cleared fill & top
			// pre_field everything else (shadows, borders, etc.)
			if (drawingPreField) {
				drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
						STYLE_FILL_AND_TOP, canvas, post_field, configRange,
						Consts.QPANE_1, pieceType, offset,
						drawSettings.alpha_lockedFill, alphaScale_fillPulse,
						drawSettings.alpha_lockedTop, 1.0f, 255, 255,
						255, // 255 to see bugs
						null, null, null, null, null, null, sliceTime,
						GlowEffect.TYPE_NONE, null);
				drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
						STYLE_FILL_AND_TOP, canvas, cleared_field, configRange,
						Consts.QPANE_1, pieceType, offset, emphFillAlpha,
						alphaScale_fillPulse, emphTopAlpha, 1.0f, 255,
						255,
						255, // 255 to see bugs
						null, null, null, null, null, null, sliceTime,
						GlowEffect.TYPE_NONE, null);
				drawBlockFieldQPane2DAtAlignmentOffset(
						drawSettings,
						STYLE_ALL_BUT_FILL_AND_TOP,
						canvas,
						pre_field,
						configRange,
						Consts.QPANE_1,
						pieceType,
						offset,
						255,
						255,
						255,
						1.0f,
						drawSettings.alpha_lockedBorder,
						drawSettings.drawDetail >= DrawSettings.DRAW_DETAIL_MID ? 255
								: 0,
						255,
						corners[Consts.QPANE_1][INDEX_CORNER_TL], // no fills to
						// optimize
						corners[Consts.QPANE_1][INDEX_CORNER_TR],
						corners[Consts.QPANE_1][INDEX_CORNER_BL],
						corners[Consts.QPANE_1][INDEX_CORNER_BR],
						shadows[Consts.QPANE_1], drop[Consts.QPANE_1],
						sliceTime, GlowEffect.TYPE_NONE, null);
			} else {
				drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas,
						post_field, configRange, Consts.QPANE_1, pieceType,
						offset, -1, drawSettings.alpha_lockedFill,
						alphaScale_fillPulse, drawSettings.alpha_lockedTop,
						drawSettings.alpha_lockedBorder,
						corners[Consts.QPANE_1][INDEX_CORNER_TL],
						corners[Consts.QPANE_1][INDEX_CORNER_TR],
						corners[Consts.QPANE_1][INDEX_CORNER_BL],
						corners[Consts.QPANE_1][INDEX_CORNER_BR],
						qo_corners[Consts.QPANE_1][INDEX_CORNER_TL],
						qo_corners[Consts.QPANE_1][INDEX_CORNER_TR],
						qo_corners[Consts.QPANE_1][INDEX_CORNER_BL],
						qo_corners[Consts.QPANE_1][INDEX_CORNER_BR],
						shadows[Consts.QPANE_1], drop[Consts.QPANE_1],
						qo_sets[Consts.QPANE_1], sliceTime,
						GlowEffect.TYPE_NONE, null, FadeEffect.TYPE_NONE, null);
			}
			// draw clear glows on top, if we have any.
			if (timeSpentGlowing >= 0) {
				drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas,
						null, configRange, Consts.QPANE_1, pieceType, offset,
						-1, 255, 255, 255, 255, null, null, null, null, null,
						null, null, null, null, null, null, sliceTime,
						GlowEffect.TYPE_ANY, mLastEffectsGlow,
						FadeEffect.TYPE_NONE, null);
			}
		}

		if (drawSettings.draw3D) {
			// PANE 3D: draw the field
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas,
					drawingPreField ? pre_field : post_field, configRange,
					Consts.QPANE_3D, pieceType, offset, -1,
					drawSettings.alpha_lockedFill, alphaScale_boxPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					corners[Consts.QPANE_0][INDEX_CORNER_TL],
					corners[Consts.QPANE_0][INDEX_CORNER_TR],
					corners[Consts.QPANE_0][INDEX_CORNER_BL],
					corners[Consts.QPANE_0][INDEX_CORNER_BR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BR], null, null,
					qo_sets[Consts.QPANE_0], sliceTime, GlowEffect.TYPE_NONE,
					null, FadeEffect.TYPE_NONE, null);
		}

		// draw to last bitmap canvas
		if (drawSettings.drawQ0) {
			// PANE 0: displacement.
			if (includeDisplacementRowsIfAvailable
					&& drawSettings.getBehaviorIs_displacement()) {
				drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
						(drawSettings.alpha_displacementBorder > 0 ? STYLE_FILL_AND_BORDER : STYLE_FILL),
						canvas, slice.getDisplacementBlockfield(),
						mConfigRangeDisplaced, Consts.QPANE_0, pieceType,
						drawDisplacementOffset,
						drawSettings.alpha_displacementFill, 0, 0, 0, drawSettings.alpha_displacementBorder, 0, 0,
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_TL],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_TR],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_BL],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_BR],
						null, null, sliceTime,
						GlowEffect.TYPE_NONE, true, null);
			}
			// PANE 0: draw row neg 1
			if (drawSettings.behavior_border == DrawSettings.BEHAVIOR_BORDER_ROW_NEGATIVE_ONE)
				drawRowNegativeOneToCanvas(drawSettings, canvas,
						Consts.QPANE_0,
						drawSettings.alpha_rowNegativeOneBorder, offset);
			// PANE 0: field and glows
			// draw differs based on 'drawingPreField'. If false, draw only
			// the
			// post field with all content. If true, draw:
			// post_field fill & top
			// cleared fill & top
			// pre_field everything else (shadows, borders, etc.)
			if (drawingPreField) {
				drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
						STYLE_FILL_AND_TOP, canvas, post_field, configRange,
						Consts.QPANE_0, pieceType, offset,
						drawSettings.alpha_lockedFill, alphaScale_fillPulse,
						drawSettings.alpha_lockedTop, 1.0f, 255, 255,
						255, // 255 to see bugs
						null, null, null, null, null, null, sliceTime,
						GlowEffect.TYPE_NONE, null);
				drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
						STYLE_FILL_AND_TOP, canvas, cleared_field, configRange,
						Consts.QPANE_0, pieceType, offset, emphFillAlpha,
						alphaScale_fillPulse, emphTopAlpha, 1.0f, 255,
						255,
						255, // 255 to see bugs
						null, null, null, null, null, null, sliceTime,
						GlowEffect.TYPE_NONE, null);
				drawBlockFieldQPane2DAtAlignmentOffset(
						drawSettings,
						STYLE_ALL_BUT_FILL_AND_TOP,
						canvas,
						pre_field,
						configRange,
						Consts.QPANE_0,
						pieceType,
						offset,
						255,
						255,
						255,
						1.0f,
						drawSettings.alpha_lockedBorder,
						drawSettings.drawDetail >= DrawSettings.DRAW_DETAIL_MID ? 255
								: 0,
						255,
						corners[Consts.QPANE_0][INDEX_CORNER_TL], // no fills to
						// optimize
						corners[Consts.QPANE_0][INDEX_CORNER_TR],
						corners[Consts.QPANE_0][INDEX_CORNER_BL],
						corners[Consts.QPANE_0][INDEX_CORNER_BR],
						shadows[Consts.QPANE_0], drop[Consts.QPANE_0],
						sliceTime, GlowEffect.TYPE_NONE, null);
			} else {
				drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas,
						post_field, configRange, Consts.QPANE_0, pieceType,
						offset, -1, drawSettings.alpha_lockedFill,
						alphaScale_fillPulse, drawSettings.alpha_lockedTop,
						drawSettings.alpha_lockedBorder,
						corners[Consts.QPANE_0][INDEX_CORNER_TL],
						corners[Consts.QPANE_0][INDEX_CORNER_TR],
						corners[Consts.QPANE_0][INDEX_CORNER_BL],
						corners[Consts.QPANE_0][INDEX_CORNER_BR],
						qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
						qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
						qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
						qo_corners[Consts.QPANE_0][INDEX_CORNER_BR],
						shadows[Consts.QPANE_0], drop[Consts.QPANE_0],
						qo_sets[Consts.QPANE_0], sliceTime,
						GlowEffect.TYPE_NONE, null, FadeEffect.TYPE_NONE, null);
			}
			// draw clear glows on top, if we have any.
			if (timeSpentGlowing >= 0) {
				drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas,
						null, configRange, Consts.QPANE_0, pieceType, offset,
						-1, 255, 255,
						255,
						255,
						null, // no fills
						null, null, null, null, null, null, null, null, null,
						qo_sets[Consts.QPANE_0], sliceTime,
						GlowEffect.TYPE_ANY, mLastEffectsGlow,
						FadeEffect.TYPE_NONE, null);
			}
		}
	}

	private void drawMetamorphosisWithLastSlice(Canvas canvas,
			QuantroSoundPool pool, GameBlocksSlice slice,
			BlockDrawerSliceTime sliceTime, BlockDrawerConfigCanvas configCanvas) {

		if (configCanvas == null && mNextSliceNeedsExplicitConfigCanvas)
			configCanvas = mDrawSettings.configCanvas;

		if (this.veilOnScreen(sliceTime))
			throw new IllegalStateException(
					"Can only display veil in Stable or Piece Falling");

		tick();

		// Our "efficient" draw function. We draw to
		// mLastBitmapCanvas[BITMAP_FULL], then
		// draw mLastBitmap to the canvas provided.

		// 7/12 refactor: we are changing up metamorphosis to allow a little
		// more freedom
		// in mixing and matching metamorphosis styles. As much as possible, we
		// prefer a
		// single "snap to post" style. All transition animations should be
		// tailored to
		// fit that idea - a single moment where it is obviously appropriate to
		// change from
		// pre to post.

		// Lock Glows: --> post the moment the animation peaks.
		// Block Glows: --> post the moment the animation peaks.
		// Box Fade: --> post immediately, fade boxes away on the volatile
		// image.

		// align animations so the "post" moment happens immediately.
		// To do this:
		// 1, examine the pre/post for changes. Note which kind of
		// changes occur.
		// 2. calc the "time to post" for each metamorphosis style present
		// (subset of above)
		// 3. Take the maximum as the true timeToPostMax, and
		// timeToPostMax - timeToPost as the "began animating" moment for
		// each transition present.
		//
		// Note: among other things, this means that our glow draw code needs
		// to be modified to start at different times.

		// FIRST: determine our flags. If this is our first time animating, or
		// our
		// slice state or field changed, determine which of the metamorphosis
		// styles
		// occur here.
		tick();
		boolean backgroundChanged = backgroundLayerChanged(mLastSliceTime,
				sliceTime);
		boolean fieldChanged = false; // a change in underlying field. Either
										// 'pre' is not 'stable', or the field
										// has changed since the last

		boolean sliceStateChanged = mLastSlice.getBlocksState() != slice
				.getBlocksState() || !sliceTime.hasBeenDrawnEver();

		if (sliceStateChanged
				&& GlobalTestSettings.BLOCK_DRAWER_LOG_SLICE_STATE)
			log("now drawing metamorphosis");

		fieldChanged = mNextSliceBreaksSequence;
		fieldChanged = fieldChanged
				|| (mLastSlice.getBlocksState() != GameBlocksSlice.BLOCKS_METAMORPHOSIZING && (!mLastBitmapIsStableSlice || (mNextSlicePossiblyInconsistent && !ArrayOps
						.areEqual(mLastSlice.getBlockfieldStable(),
								slice.getMetamorphosisPreBlockfield()))));
		fieldChanged = fieldChanged
				|| (mLastSlice.getBlocksState() == GameBlocksSlice.BLOCKS_METAMORPHOSIZING
						&& mNextSlicePossiblyInconsistent && (!ArrayOps
						.areEqual(mLastSlice.getMetamorphosisPreBlockfield(),
								slice.getMetamorphosisPreBlockfield()) || !ArrayOps
						.areEqual(mLastSlice.getMetamorphosisPostBlockfield(),
								slice.getMetamorphosisPostBlockfield())));
		fieldChanged = fieldChanged || mLastBitmapDifferentDisplacement ;

		boolean firstTimeAnimating = sliceStateChanged || fieldChanged
				|| !sliceTime.hasBeenDrawnEver();

		if (fieldChanged || sliceStateChanged || firstTimeAnimating) {
			// determine which effects are used.
			this.mMetamorphosisHasBoxFades = false;
			this.mMetamorphosisHasLockGlows = false;
			this.mMetamorphosisHasMetamorphosisGlows = false;
			for (int qp = 0; qp < 2; qp++) {
				for (int r = 0; r < mDrawSettings.displayedRows; r++) {
					int row = r + mDrawSettings.blockFieldOuterBuffer;
					for (int c = 0; c < mDrawSettings.COLS; c++) {
						int col = c + mDrawSettings.blockFieldOuterBuffer;

						int qo1 = slice.getMetamorphosisPreBlockfield()[qp][row][col];
						int qo2 = slice.getMetamorphosisPostBlockfield()[qp][row][col];

						if (qo1 == qo2)
							continue;

						switch (mDrawSettings.behavior_qo_metamorphosis_from[qo1]) {
						case DrawSettings.BEHAVIOR_QO_METAMORPHOSIS_LOCK_GLOW:
							mMetamorphosisHasLockGlows = true;
							break;
						case DrawSettings.BEHAVIOR_QO_METAMORPHOSIS_GLOW:
							mMetamorphosisHasMetamorphosisGlows = true;
							break;
						case DrawSettings.BEHAVIOR_QO_METAMORPHOSIS_SMOOTH:
							mMetamorphosisHasBoxFades = true;
							break;
						}

						switch (mDrawSettings.behavior_qo_metamorphosis_to[qo2]) {
						case DrawSettings.BEHAVIOR_QO_METAMORPHOSIS_LOCK_GLOW:
							mMetamorphosisHasLockGlows = true;
							break;
						case DrawSettings.BEHAVIOR_QO_METAMORPHOSIS_GLOW:
							mMetamorphosisHasMetamorphosisGlows = true;
							break;
						case DrawSettings.BEHAVIOR_QO_METAMORPHOSIS_SMOOTH:
							mMetamorphosisHasBoxFades = true;
							break;
						}
					}
				}
			}
		}

		boolean newGlow = (fieldChanged || sliceStateChanged)
				&& (mMetamorphosisHasLockGlows || mMetamorphosisHasMetamorphosisGlows);
		boolean newFades = (fieldChanged || sliceStateChanged)
				&& (mMetamorphosisHasBoxFades);

		// how long to transition?
		long timeInPreField = 1;
		if (mMetamorphosisHasLockGlows)
			timeInPreField = Math.max(timeInPreField,
					animationSettings.lockGlowTimeToPeak(0, 1, 0));
		if (mMetamorphosisHasMetamorphosisGlows)
			timeInPreField = Math.max(timeInPreField,
					animationSettings.metamorphosisGlowTimeToPeak(0, 1, 0));
		// time for box fades is 0.

		// how long after transition?
		long timeInPostField = 1;
		if (mMetamorphosisHasLockGlows)
			timeInPostField = Math.max(timeInPostField,
					animationSettings.lockGlowTimeToFinish(0, 1, 0)
							- animationSettings.lockGlowTimeToPeak(0, 1, 0));
		if (mMetamorphosisHasMetamorphosisGlows)
			timeInPostField = Math.max(
					timeInPostField,
					animationSettings.metamorphosisGlowTimeToFinish(0, 1, 0)
							- animationSettings.metamorphosisGlowTimeToPeak(0,
									1, 0));
		if (mMetamorphosisHasBoxFades)
			timeInPostField = Math.max(timeInPostField,
					animationSettings.boxFadeTotalTime(0, 1));

		// Total time?
		long timeTotal = timeInPreField + timeInPostField;

		long timeSpentInPreField = Math.min(sliceTime.getSlice(),
				timeInPreField);
		long timeSpentInPostField = Math.max(0, sliceTime.getSlice()
				- timeInPreField);

		boolean preField = sliceTime.getSlice() < timeInPreField;
		boolean fieldTransition = (sliceTime.getLastDrawnSlice() < timeInPreField) != (preField);

		if (fieldChanged)
			mProfileBehavior = BlockDrawer.INDEX_PROFILE_SLICE_METAMORPHOSIS_BEHAVIOR_FIELD_CHANGED;
		else if (newGlow)
			mProfileBehavior = BlockDrawer.INDEX_PROFILE_SLICE_METAMORPHOSIS_BEHAVIOR_GLOW_CHANGED;
		else if (fieldTransition)
			mProfileBehavior = BlockDrawer.INDEX_PROFILE_SLICE_METAMORPHOSIS_BEHAVIOR_FIELD_TRANSITION;
		else
			mProfileBehavior = BlockDrawer.INDEX_PROFILE_SLICE_METAMORPHOSIS_BEHAVIOR_GLOW_ANIMATING;
		mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_CHECK_EQUALITY] += tock();

		if (fieldChanged || fieldTransition) {
			// Determine shadow sets and corners
			tick();
			byte[][][] field = preField ? slice.getMetamorphosisPreBlockfield()
					: slice.getMetamorphosisPostBlockfield();
			byte[][][][] corners = mLastCorners_byField_byPaneCorner
					.get(INDEX_FIELD_METAMORPHOSIS);
			short[][][] shadows = mLastFillShadowSets_byField_byPane
					.get(INDEX_FIELD_METAMORPHOSIS);
			short[][][][] drop = mLastDropShadowSets_byField_byPane_byUniqueColor
					.get(INDEX_FIELD_METAMORPHOSIS);
			setShadowsAndCorners(mDrawSettings, field, mConfigRangeStandard,
					shadows, drop, corners);

			byte[][][][] qoCorners = this.mLastQOConnectedCorners_byField_byPaneCorner
					.get(INDEX_FIELD_METAMORPHOSIS);
			short[][][] qoSets = this.mLastQOConnectedSets_byField_byPane
					.get(INDEX_FIELD_METAMORPHOSIS);
			setQOConnectionAndCorners(mDrawSettings, field,
					mConfigRangeStandard, qoSets, qoCorners);

			mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_SET_SHADOWS_AND_CORNERS] += tock();

			// for fading boxes, we need qo_ info on the 'pre' field, even when
			// in post.
			field = slice.getMetamorphosisPreBlockfield();
			qoCorners = this.mLastQOConnectedCorners_byField_byPaneCorner
					.get(INDEX_FIELD_METAMORPHOSIS_PRE);
			qoSets = this.mLastQOConnectedSets_byField_byPane
					.get(INDEX_FIELD_METAMORPHOSIS_PRE);
			setQOConnectionAndCorners(mDrawSettings, field,
					mConfigRangeStandard, qoSets, qoCorners);
		}
		if (newGlow) {
			tick();
			// Determine metamorphosis glows. There are two types to draw - lock
			// glows,
			// which follow normal lock glow procedure, and block glows.
			// We want to draw block glows on top of lock glows, which basically
			// means we
			// calculate lock glows and then block glows. In both cases, it is
			// useful to
			// have a set of exactly those blocks which change from pre to post.
			byte[][][] pre_field = slice.getMetamorphosisPreBlockfield();
			byte[][][] post_field = slice.getMetamorphosisPostBlockfield();

			boolean hasLocks = false, hasBlocks = false;
			long startLockGlowTime = timeInPreField
					- animationSettings.lockGlowTimeToPeak(0, 1, 0);
			long startBlockGlowTime = timeInPreField
					- animationSettings.metamorphosisGlowTimeToPeak(0, 1, 0);

			ArrayOps.setEmpty(tempBlockfield);
			for (int qp = 0; qp < 2; qp++) {
				for (int row = 0; row < mDrawSettings.displayedRows; row++) {
					int r = row + mDrawSettings.blockFieldOuterBuffer;
					for (int col = 0; col < mDrawSettings.COLS; col++) {
						int c = col + mDrawSettings.blockFieldOuterBuffer;
						byte pre_qo = pre_field[qp][r][c];
						byte post_qo = post_field[qp][r][c];
						if (pre_qo != post_qo
								&& (mDrawSettings.behavior_qo_metamorphosis_from[pre_qo] == DrawSettings.BEHAVIOR_QO_METAMORPHOSIS_LOCK_GLOW || mDrawSettings.behavior_qo_metamorphosis_to[post_qo] == DrawSettings.BEHAVIOR_QO_METAMORPHOSIS_LOCK_GLOW)) {
							tempBlockfield[qp][r][c] = pre_qo;
						}
					}
				}

				long lockGlowDuration = 0;
				for (int i = 0; i < mDrawSettings.glow_alphaPeakNormalized[Consts.GLOW_LOCK].length; i++) {
					lockGlowDuration = Math
							.max(lockGlowDuration,
									animationSettings
											.lockGlowTimeToFinish(
													0,
													mDrawSettings.glow_alphaPeakNormalized[Consts.GLOW_LOCK][i],
													0));
				}

				if ((qp == 0 && mDrawSettings.drawQ0)
						|| (qp == 1 && mDrawSettings.drawQ1)) {
					int numLockGlows = this.addLockGlows(mDrawSettings,
							tempBlockfield, post_field, qp, false,
							mLastEffectsGlow, startLockGlowTime,
							lockGlowDuration, 0);
					hasLocks = hasLocks || numLockGlows > 0;
				}

				for (int row = 0; row < mDrawSettings.displayedRows; row++) {
					int r = row + mDrawSettings.blockFieldOuterBuffer;
					for (int col = 0; col < mDrawSettings.COLS; col++) {
						int c = col + mDrawSettings.blockFieldOuterBuffer;
						byte pre_qo = pre_field[qp][r][c];
						byte post_qo = post_field[qp][r][c];
						if (pre_qo != post_qo
								&& (mDrawSettings.behavior_qo_metamorphosis_from[pre_qo] == DrawSettings.BEHAVIOR_QO_METAMORPHOSIS_GLOW || mDrawSettings.behavior_qo_metamorphosis_to[post_qo] == DrawSettings.BEHAVIOR_QO_METAMORPHOSIS_GLOW)) {
							tempBlockfield[qp][r][c] = pre_qo;
						} else {
							tempBlockfield[qp][r][c] = QOrientations.NO;
						}
					}
				}

				long blockGlowDuration = 0;
				for (int i = 0; i < mDrawSettings.glow_alphaPeakNormalized[Consts.GLOW_METAMORPHOSIS].length; i++) {
					blockGlowDuration = Math
							.max(blockGlowDuration,
									animationSettings
											.metamorphosisGlowTimeToFinish(
													0,
													mDrawSettings.glow_alphaPeakNormalized[Consts.GLOW_METAMORPHOSIS][i],
													0));
				}

				if ((qp == 0 && mDrawSettings.drawQ0)
						|| (qp == 1 && mDrawSettings.drawQ1)) {
					int numBlockGlows = this.addMetamorphosisBlockGlows(
							mDrawSettings, pre_field, post_field, qp,
							mLastEffectsGlow, startBlockGlowTime,
							blockGlowDuration, 0);
					hasBlocks = hasBlocks || numBlockGlows > 0;
				}
			}

			// Sound Effects
			// TODO: alter this to give accurate parameters for these effects.
			if (hasLocks)
				mLastEffectsSound.addLock(
						BlockDrawerSliceTime.RelativeTo.SLICE, startLockGlowTime,
						slice.getPieceType(), true, 0);
			if (hasBlocks)
				mLastEffectsSound.addMetamorphosis(
						BlockDrawerSliceTime.RelativeTo.SLICE, startBlockGlowTime, 0, 0);
			if (!hasLocks && slice.getMetamorphosisPreIncludesNewBlocks())
				mLastEffectsSound.addLand(
						BlockDrawerSliceTime.RelativeTo.SLICE, 0, slice.getPieceType(),
						true, 0);
			mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_SET_EFFECTS] += tock();
		}

		if (newFades) {
			// Make a fade.
			FadeEffect.Setter setter = (FadeEffect.Setter) mLastEffectsFade
					.add();

			setter.type(FadeEffect.TYPE_BOX);
			setter.startTimeSlice(timeInPreField).duration(
					animationSettings.boxFadeTotalTime(1, 0));
			// For the field, we copy only those blocks which have box-fade
			// metamorphosis behavior.
			byte[][][] pre_field = slice.getMetamorphosisPreBlockfield();
			byte[][][] post_field = slice.getMetamorphosisPostBlockfield();
			byte[][][] field = setter.directQOrientationsAccess();
			ArrayOps.setEmpty(field);
			for (int qp = 0; qp < 2; qp++) {
				for (int row = 0; row < mDrawSettings.displayedRows; row++) {
					int r = row + mDrawSettings.blockFieldOuterBuffer;
					for (int col = 0; col < mDrawSettings.COLS; col++) {
						int c = col + mDrawSettings.blockFieldOuterBuffer;
						byte pre_qo = pre_field[qp][r][c];
						byte post_qo = post_field[qp][r][c];
						if (pre_qo != post_qo
								&& (mDrawSettings.behavior_qo_metamorphosis_from[pre_qo] == DrawSettings.BEHAVIOR_QO_METAMORPHOSIS_SMOOTH || mDrawSettings.behavior_qo_metamorphosis_to[post_qo] == DrawSettings.BEHAVIOR_QO_METAMORPHOSIS_SMOOTH)) {
							field[qp][r][c] = pre_qo;
						} else {
							field[qp][r][c] = QOrientations.NO;
						}
					}
				}
			}

			// Easy method to get corners and connections.
			setQOConnectionAndCorners(mDrawSettings, field,
					mConfigRangeStandard,
					setter.directQOrientationEncodedConnectionsAccess(),
					setter.directQOrientationCornersAccess());

			// Everything is set.
			mLastEffectsFade.commit(setter);
		}

		int height = mDrawSettings.height;
		int blitHeight = mDrawSettings.configCanvas.region.height();

		// for clipping, we need to extend the clip by a certain distance
		// from each altered block. This lets us draw and re-draw our drop
		// shadow,
		// which extends slightly beyond the reach of each block.
		int extendByPixels = Math.max(boundDropShadowHeight(mDrawSettings),
				boundDropShadowWidth(mDrawSettings));

		boolean doubleBitmapOffset = mLastBitmap != null
				&& mDrawSettings.drawAnimations >= DrawSettings.DRAW_ANIMATIONS_STABLE_STUTTER
				&& mDrawSettings.getBlit() != DrawSettings.BLIT_SEPTUPLE
				&& !mDrawSettings.getBehaviorIs_displacement();

		// ////
		// /////////////////////////////////////////////////////////////////
		// Set the Touched / Covered regions.

		setAlignmentOffset(slice.getBlockfieldStable(), clipOffset);
		if (doubleBitmapOffset)
			clipOffset.y += height;

		if (fieldChanged || mLastBitmapVeiled || fieldTransition || mLastBitmapDifferentDisplacement) {
			// redo clipped area.
			if (preField) {
				drawMetamorphosisWithLastSlice_helperClipCoveredStablePreMetamorphosis(
						slice, clipOffset);
				drawMetamorphosisWithLastSlice_helperClipTouchedStablePreMetamorphosis(
						slice, clipOffset, extendByPixels, true);

				drawMetamorphosisWithLastSlice_helperClipCoveredVolatileEmpty();
				drawMetamorphosisWithLastSlice_helperClipTouchedVolatileEmpty();
			} else {
				drawMetamorphosisWithLastSlice_helperClipCoveredStablePostMetamorphosis(
						slice, clipOffset);
				drawMetamorphosisWithLastSlice_helperClipTouchedStablePostMetamorphosis(
						slice, clipOffset, extendByPixels, true);

				drawMetamorphosisWithLastSlice_helperClipCoveredVolatileBox(
						slice, clipOffset);
				drawMetamorphosisWithLastSlice_helperClipTouchedVolatileBox(
						slice, clipOffset);
			}
		}

		if (sliceStateChanged) {
			// empty volatile
			if (preField) {
				drawMetamorphosisWithLastSlice_helperClipCoveredVolatileEmpty();
				drawMetamorphosisWithLastSlice_helperClipTouchedVolatileEmpty();
			} else {
				drawMetamorphosisWithLastSlice_helperClipCoveredVolatileBox(
						slice, clipOffset);
				drawMetamorphosisWithLastSlice_helperClipTouchedVolatileBox(
						slice, clipOffset);
			}
		}

		if (fieldTransition) {
			// adjust our covered / touched clip
			drawMetamorphosisWithLastSlice_helperClipCoveredStablePostMetamorphosis(
					slice, clipOffset);
			drawMetamorphosisWithLastSlice_helperClipTouchedStablePostMetamorphosis(
					slice, clipOffset, extendByPixels, true);

			drawMetamorphosisWithLastSlice_helperClipCoveredVolatileBox(slice,
					clipOffset);
			drawMetamorphosisWithLastSlice_helperClipTouchedVolatileBox(slice,
					clipOffset);
		}

		if (!veilOnScreen(sliceTime) || !mLastBitmapVeiled || fieldChanged
				|| sliceStateChanged
				|| !sliceTime.hasBeenDrawnAtThisSliceTime()) {
			// If using BLIT_FULL, we set offsets to match the mLast, clip
			// according
			// to changes, draw to mLastBitmap and finally blit to the canvas.
			// If
			// using BLIT_NONE, we set offset to match the canvas, clip UNION
			// the
			// pulses (assuming an appropriate clip is already in place), and
			// draw
			// directly to the canvas.
			switch (mDrawSettings.getBlit()) {
			case DrawSettings.BLIT_SEPTUPLE:
				// set offsets
				if (fieldChanged || alignmentOffsetSet) {
					setAlignmentOffset(slice.getBlockfieldStable(),
							alignmentOffset);
					canvasAlignmentOffset.takeVals(alignmentOffset);

					alignmentOffsetSet = false;
				}
				canvasTranslationOffset.x = 0;
				canvasTranslationOffset.y = 0;

				byte[][][] pre_field = slice.getMetamorphosisPreBlockfield();
				byte[][][] post_field = slice.getMetamorphosisPostBlockfield();

				// clip
				tick();
				reset(mLastBitmapClipPath);
				if (fieldChanged || mLastBitmapVeiled || fieldTransition) {
					// redo EVERYTHING
					for (int i = 0; i < mLastBitmap.length; i++) {
					    unionRect(mLastBitmapClipPath[i], 0, 0,
                                mLastBitmapBounds[i].width(),
                                mLastBitmapBounds[i].height(),
                                Path.Direction.CW);
                    }
				}

				if (fieldTransition) {
					// whoooiiie boy! Clip the differences to stable and full!
					for (int qp = 0; qp < 3; qp++) {
						int qPane = -1, BMAP = -1;
						if (qp == 0) {
							qPane = Consts.QPANE_0;
							BMAP = BITMAP_SEPTUPLE_Q0_STABLE;
						} else if (qp == 1) {
							qPane = Consts.QPANE_1;
							BMAP = BITMAP_SEPTUPLE_Q1_STABLE;
						} else if (qp == 2) {
							qPane = Consts.QPANE_3D;
							BMAP = BITMAP_SEPTUPLE_3D_STABLE;
						}

						reset(clipPath);
						this.clipConservativeDifference(clipPath, pre_field,
								post_field, qPane, 0, alignmentOffset,
								extendByPixels);

						op(mLastBitmapClipPath[BMAP], clipPath, Path.Op.UNION);
						op(mLastBitmapClipPath[BITMAP_FULL], clipPath, Path.Op.UNION);
					}
				}

				// Clip pulses...
				reset(clipPath);
				boolean pulseQ0 = clipPulseFill(clipPath,
						preField ? pre_field : post_field, Consts.QPANE_0, 0,
						alignmentOffset);
				if (pulseQ0) {
					op(mLastBitmapClipPath[BITMAP_SEPTUPLE_Q0_STABLE], clipPath, Path.Op.UNION);
					op(mLastBitmapClipPath[BITMAP_FULL], clipPath, Path.Op.UNION);
				}

				reset(clipPath);
				boolean pulseQ1 = clipPulseFill(clipPath,
						preField ? pre_field : post_field, Consts.QPANE_1, 0,
						alignmentOffset);
				if (pulseQ1) {
					op(mLastBitmapClipPath[BITMAP_SEPTUPLE_Q1_STABLE], clipPath, Path.Op.UNION);
					op(mLastBitmapClipPath[BITMAP_FULL], clipPath, Path.Op.UNION);
				}

				reset(clipPath);
				boolean pulse3D = clipPulseFill(clipPath,
						preField ? pre_field : post_field, Consts.QPANE_3D, 0,
						alignmentOffset);
				if (pulse3D) {
                    op(mLastBitmapClipPath[BITMAP_SEPTUPLE_3D_STABLE], clipPath, Path.Op.UNION);
                    op(mLastBitmapClipPath[BITMAP_FULL], clipPath, Path.Op.UNION);
				}

				boolean pulse3DVolatile = false;
				if (!preField) {
					reset(clipPath);
					pulse3DVolatile = clipPulseFill(clipPath, pre_field,
							Consts.QPANE_3D, 0, alignmentOffset);
					if (pulse3DVolatile) {
						op(mLastBitmapClipPath[BITMAP_SEPTUPLE_3D_STABLE], clipPath, Path.Op.UNION);
						op(mLastBitmapClipPath[BITMAP_FULL], clipPath, Path.Op.UNION);
					}
				}

				// Lastly, clip glows.
				int numGlows = mLastEffectsGlow.size() ;
				for (int i = 0; i < numGlows; i++) {
					GlowEffect glowEffect = mLastEffectsGlow.get(i);
					if (glowEffect.active(sliceTime) || glowEffect.active(mLastSliceTime)) {
						this.clipGlowEffect(mLastBitmapClipPath[BITMAP_FULL], 
                                glowEffect, 0, alignmentOffset);
					}
				}
                if ((configCanvas != null && configCanvas.background != null)
                        || backgroundLayerChanged(mLastSliceTime, sliceTime)) {
                    // fully draw the BITMAP_FULL canvas
                    reset(mLastBitmapClipPath[BITMAP_FULL]);
                    unionRect(mLastBitmapClipPath[BITMAP_FULL], 0, 0,
                            mLastBitmap[BITMAP_FULL].getWidth(),
                            mLastBitmap[BITMAP_FULL].getHeight(),
                            Path.Direction.CW);
                }
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_CLIP] += tock();

                // All draw and blit operations performed under this clip; restored after blitting
                for (int i = 0; i < mLastBitmapCanvas.length; i++) {
                    mLastBitmapCanvas[i].save();
                    mLastBitmapCanvas[i].clipPath(mLastBitmapClipPath[i]);
                }

				// draw!
                tick();
				if (fieldChanged || fieldTransition || pulseQ0)
					drawMetamorphosisStableToCanvas_withSlice(mDrawSettings,
							Consts.QPANE_0,
							mLastBitmapCanvas[BITMAP_SEPTUPLE_Q0_STABLE],
							alignmentOffset, 0, slice, sliceTime, preField,
							null, true);
				if (fieldChanged || fieldTransition || pulseQ1)
					drawMetamorphosisStableToCanvas_withSlice(mDrawSettings,
							Consts.QPANE_1,
							mLastBitmapCanvas[BITMAP_SEPTUPLE_Q1_STABLE],
							alignmentOffset, 0, slice, sliceTime, preField,
							null, true);
				if (fieldChanged || fieldTransition || pulse3D)
					drawMetamorphosisStableToCanvas_withSlice(mDrawSettings,
							Consts.QPANE_3D,
							mLastBitmapCanvas[BITMAP_SEPTUPLE_3D_STABLE],
							alignmentOffset, 0, slice, sliceTime, preField,
							null, true);
				if (!preField && pulse3DVolatile)
					drawMetamorphosisPulseBoxToCanvas_withSlice(mDrawSettings,
							Consts.QPANE_3D,
							mLastBitmapCanvas[BITMAP_SEPTUPLE_3D_VOLATILE],
							alignmentOffset, 0, slice, sliceTime);
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW] += tock();

				// Compose and blit.
				tick();
				// canvas translation offset?
				setCanvasDestinationRect(
						mLastBitmapBlitRect[BITMAP_FULL],
						mLastBitmapBounds[BITMAP_FULL],
						mDrawSettings.configCanvas.region,
						-((int) Math.round(slice.getDisplacement()
								* mDrawSettings.size_blockHeight))
							+ mDrawSettings.displacementSafeMarginOffsetBlit);
				mLastBitmapBlitRect[BITMAP_SEPTUPLE_Q0_STABLE].set(0, 0,
						mLastBitmapBounds[BITMAP_SEPTUPLE_Q0_STABLE].width(),
						mLastBitmapBounds[BITMAP_SEPTUPLE_Q0_STABLE].height());
				mLastBitmapBlitRect[BITMAP_SEPTUPLE_Q1_STABLE].set(0, 0,
						mLastBitmapBounds[BITMAP_SEPTUPLE_Q1_STABLE].width(),
						mLastBitmapBounds[BITMAP_SEPTUPLE_Q1_STABLE].height());
				mLastBitmapBlitRect[BITMAP_SEPTUPLE_3D_STABLE].set(0, 0,
						mLastBitmapBounds[BITMAP_SEPTUPLE_3D_STABLE].width(),
						mLastBitmapBounds[BITMAP_SEPTUPLE_3D_STABLE].height());
				mLastBitmapBlitRect[BITMAP_SEPTUPLE_Q0_VOLATILE]
						.set(0, 0,
								mLastBitmapBounds[BITMAP_SEPTUPLE_Q0_VOLATILE]
										.width(),
								mLastBitmapBounds[BITMAP_SEPTUPLE_Q0_VOLATILE]
										.height());
				mLastBitmapBlitRect[BITMAP_SEPTUPLE_Q1_VOLATILE]
						.set(0, 0,
								mLastBitmapBounds[BITMAP_SEPTUPLE_Q1_VOLATILE]
										.width(),
								mLastBitmapBounds[BITMAP_SEPTUPLE_Q1_VOLATILE]
										.height());
				mLastBitmapBlitRect[BITMAP_SEPTUPLE_3D_VOLATILE]
						.set(0, 0,
								mLastBitmapBounds[BITMAP_SEPTUPLE_3D_VOLATILE]
										.width(),
								mLastBitmapBounds[BITMAP_SEPTUPLE_3D_VOLATILE]
										.height());

				// blitting behavior differs from most other modes, in which
				// STABLE is drawn
				// first, followed by a <Covered-by-Stable> clipped version of
				// VOLATILE.
				// Here, VOLATILE is drawn first followed by STABLE which
				// occludes it.
				//
				// Volatile layer 3d contains a pulsing box. This call obeys
				// background behavior.
				septupleBlitDrawBackground(sliceTime, configCanvas);
				// Get parameters for our blit...
				int volatileAlpha = preField || !mMetamorphosisHasBoxFades ? 0
						: animationSettings.boxFadeAlpha(255, 0,
								timeSpentInPostField);
				int pieceType = slice.getPieceType();
				// Blit...
				boolean doneGlowing = septupleBlitStableOccludes(255,
						volatileAlpha, alignmentOffset, pieceType, sliceTime);

                // now done with internal bitmap clips; restore
                for (int i = 0; i < mLastBitmapCanvas.length; i++) {
                    mLastBitmapCanvas[i].restore();
                }

				// blit to the main canvas
				if (configCanvas == null
						|| configCanvas.equals(mDrawSettings.configCanvas)) {
					canvas.save();
					if (mDrawSettings.configCanvas.clipRegion != null)
						canvas.clipRect(mDrawSettings.configCanvas.clipRegion,
								Region.Op.INTERSECT);

					if (mDrawSettings.behavior_background == DrawSettings.BEHAVIOR_BACKGROUND_BLIT_IMAGE) {
						drawLayeredBackgroundAssets(canvas,
								mDrawSettings.configCanvas.region, sliceTime,
								mDrawSettings.configCanvas.background);
					}

					canvas.drawBitmap(mLastBitmap[BITMAP_FULL],
							mLastBitmapBounds[BITMAP_FULL],
							mLastBitmapBlitRect[BITMAP_FULL], null);
					canvas.restore();
				} else {
					tempSrcRect.set(mLastBitmapBounds[BITMAP_FULL]);
					tempSrcRect.bottom = tempSrcRect.top + mDrawSettings.height;
					drawBitmapToCanvasWithConfig(canvas,
							mLastBitmap[BITMAP_FULL], tempSrcRect, slice,
							configCanvas, null);
				}

				// timer
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_BLIT] += tock();

				break;

			case DrawSettings.BLIT_FULL:
				// set our offset!
				canvasTranslationOffset.x = 0;
				canvasTranslationOffset.y = 0;
				setAlignmentOffset(slice.getBlockfieldStable(), alignmentOffset);
				alignmentOffsetSet = true;
				if (doubleBitmapOffset)
					alignmentOffset.y += height;

				// clip
				tick();
				reset(mLastBitmapClipPath[BITMAP_FULL]);
				if (fieldChanged || mBackgroundBitmapClipOrBlitIsBlitting
						|| mLastBitmapVeiled || configCanvas != null
						|| backgroundChanged) {
					// HACK HACK HACK:
					// This call is necessary because we haven't implemented an
					// "efficient" version for other
					// draw methods yet. Note that piece borders can very easily
					// change without the actual
					// value at a location changing.
					if (doubleBitmapOffset) {
					    unionRect(mLastBitmapClipPath[BITMAP_FULL], 0, height,
                                mLastBitmapBounds[BITMAP_FULL].width(),
                                height * 2, Path.Direction.CW);
					} else {
						// clip with extra space below, so we have room to draw
						// displacement rows.
						float extra = mDrawSettings.getBehaviorIs_displacement()
								? mDrawSettings.size_blockHeight * 3
								: 0 ;
						unionRect(mLastBitmapClipPath[BITMAP_FULL], 0, 0,
                                mLastBitmapBounds[BITMAP_FULL].width(),
                                mLastBitmapBounds[BITMAP_FULL].height() + extra,
                                Path.Direction.CW);
					}
				}
				if (fieldTransition) {
					// Efficiently clip those areas which changed or have new
					// borders.
					this.clipConservativeDifference(
							mLastBitmapClipPath[BITMAP_FULL],
							slice.getMetamorphosisPreBlockfield(),
							slice.getMetamorphosisPostBlockfield(), 0,
							alignmentOffset, extendByPixels);
				}
				// no matter what, we clip the glow areas. We expect these to
				// change every tick.
				numGlows = mLastEffectsGlow.size() ;
				for (int i = 0; i < numGlows; i++) {
					GlowEffect glowEffect = mLastEffectsGlow.get(i);
					if (glowEffect.active(sliceTime)
							|| glowEffect.active(mLastSliceTime)) {
						clipGlowEffect(mLastBitmapClipPath[BITMAP_FULL],
								glowEffect, 0, alignmentOffset);
					}
				}
				// Clip "pulse" behavior pieces.
				if (animationSettings != null) {
					clipPulseFill(mLastBitmapClipPath[BITMAP_FULL],
							preField ? slice.getMetamorphosisPreBlockfield()
									: slice.getMetamorphosisPostBlockfield(),
							0, alignmentOffset);
					if (!preField && mMetamorphosisHasBoxFades) {
						clipPulseFill(mLastBitmapClipPath[BITMAP_FULL],
								slice.getMetamorphosisPreBlockfield(),
								Consts.QPANE_3D, 0, alignmentOffset);
					}
				}
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_CLIP] += tock();

				if (GlobalTestSettings.BLOCK_DRAWER_SHOW_COVERED_AND_TOUCHING_REGIONS) {
                    reset(mLastBitmapClipPath[BITMAP_FULL]);
                    unionRect(mLastBitmapClipPath[BITMAP_FULL], 0, 0,
                            Integer.MAX_VALUE, Integer.MAX_VALUE,
                            Path.Direction.CW);
                }

				// draw to mLast.
				tick();
				mLastBitmapCanvas[BITMAP_FULL].save();
				mLastBitmapCanvas[BITMAP_FULL].clipPath(mLastBitmapClipPath[BITMAP_FULL]);
				float preBoxFadeAlpha = (!preField && mMetamorphosisHasBoxFades) ? animationSettings
						.boxFadeAlpha(1f, 0f, timeSpentInPostField) : 0;
				BlockDrawerConfigCanvas.Background backgroundDefault = mDrawSettings
						.getBehaviorIs_backgroundBlit() ? BlockDrawerConfigCanvas.Background.CLEAR
						: BlockDrawerConfigCanvas.Background.DEFAULT;
				drawMetamorphosisToCanvas_withSlice(mDrawSettings,
						mLastBitmapCanvas[BITMAP_FULL], alignmentOffset, slice,
						sliceTime, preBoxFadeAlpha, mBackgroundBitmapOffset,
						configCanvas != null ? configCanvas.background
								: backgroundDefault, 0, true);
				mLastBitmapCanvas[BITMAP_FULL].restore();
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW] += tock();

				if (GlobalTestSettings.BLOCK_DRAWER_SHOW_COVERED_AND_TOUCHING_REGIONS)
					drawTouchedCoveredTestToCanvas(mLastBitmapCanvas[BITMAP_FULL]);

				// blit
				tick();
				if (mDrawSettings.getBehaviorIs_displacement()) {
					setCanvasDestinationRect(
							mLastBitmapBlitRect[BITMAP_FULL],
							mLastBitmapBounds[BITMAP_FULL],
							mDrawSettings.configCanvas.region,
							-((int) Math.round(slice.getDisplacement()
									* mDrawSettings.size_blockHeight))
								+ mDrawSettings.displacementSafeMarginOffsetBlit);
				} else {
					mLastBitmapBlitRect[BITMAP_FULL].set(
							mDrawSettings.configCanvas.region.left,
							mDrawSettings.configCanvas.region.top
									- (doubleBitmapOffset ? blitHeight : 0),
							mDrawSettings.configCanvas.region.right,
							mDrawSettings.configCanvas.region.top + blitHeight);
				}

				if (configCanvas == null
						|| configCanvas.equals(mDrawSettings.configCanvas)) {
					canvas.save();
					if (mDrawSettings.configCanvas.clipRegion != null)
						canvas.clipRect(mDrawSettings.configCanvas.clipRegion,
								Region.Op.INTERSECT);

					if (mDrawSettings.getBehaviorIs_backgroundBlit()) {
						drawLayeredBackgroundAssets(canvas,
								mDrawSettings.configCanvas.region, sliceTime,
								mDrawSettings.configCanvas.background);
					}

					canvas.drawBitmap(mLastBitmap[BITMAP_FULL],
							mLastBitmapBounds[BITMAP_FULL],
							mLastBitmapBlitRect[BITMAP_FULL], blitPaint);
					canvas.restore();
				} else {
					// our content is available in mLastBitmap. However,
					// depending on
					// our background settings and config canvas settings, this
					// might fail.
					// throw an exception so we know this is unacceptable.
					tempSrcRect.set(mLastBitmapBounds[BITMAP_FULL]);
					tempSrcRect.bottom = tempSrcRect.top + height;
					if (doubleBitmapOffset)
						tempSrcRect.offset(0, height);
					drawBitmapToCanvasWithConfig(canvas,
							mLastBitmap[BITMAP_FULL], tempSrcRect, slice,
							configCanvas, blitPaint);
				}
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_BLIT] += tock();

				// done and done
				break;

			case DrawSettings.BLIT_NONE:
				// determine offset based on canvas
				setCanvasTranslationOffset(canvas);
				setAlignmentOffset(slice.getBlockfieldStable(), alignmentOffset);
				int displacement = 0;
				if (mDrawSettings.getBehaviorIs_displacement()) {
					displacement = -((int) Math.round(slice.getDisplacement()
							* mDrawSettings.size_blockHeight));
					alignmentOffset.y += displacement;
				}
				alignmentOffsetSet = true;

				// We don't set the clip, assuming that has been taken care of

				// draw
				tick();
				canvas.save();
				if (mDrawSettings.configCanvas.clipRegion != null)
					canvas.clipRect(mDrawSettings.configCanvas.clipRegion,
							Region.Op.INTERSECT);
				float preBoxFadeAlphaTemp = (!preField && mMetamorphosisHasBoxFades) ? animationSettings
						.boxFadeAlpha(255, 0, timeSpentInPostField) : 0;
				drawMetamorphosisToCanvas_withSlice(mDrawSettings, canvas,
						alignmentOffset, slice, sliceTime, preBoxFadeAlphaTemp,
						mBackgroundBitmapOffset,
						BlockDrawerConfigCanvas.Background.DEFAULT,
						displacement, true);
				canvas.restore();
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW] += tock();

				if (GlobalTestSettings.BLOCK_DRAWER_SHOW_COVERED_AND_TOUCHING_REGIONS)
					drawTouchedCoveredTestToCanvas(canvas);

				// no need to blit
				break;

			default:
				throw new IllegalStateException("Blit setting "
						+ mDrawSettings.getBlit() + " confuses and infuriates us");
			}

			mLastBitmapVeiled = false;
		}

		// //////////////////////////////////////////////////////////////////////
		// VEIL INSTRUCTIONS: At this point, mLastBitmap[BITMAP_FULL] is the
		// content to be drawn under the veil. Draw the veil over it.

		if (veilOnScreen(sliceTime)
				&& (configCanvas == null || configCanvas
						.equals(mDrawSettings.configCanvas))) {
			drawBitmapFullVeiledToCanvas(canvas, sliceTime,
					sliceStateChanged || fieldChanged || !mLastBitmapVeiled
							|| !sliceTime.hasBeenDrawnAtThisSliceTime());
			// only force a redraw if content changed, otherwise use our cached
			// veil.
			mLastBitmapVeiled = true;
		}

		// We have drawn to mLastBitmap[BITMAP_FULL]. Copy the slice and blit.
		if (fieldChanged || sliceStateChanged)
			mLastSlice.takeVals(slice);
		mNextSliceNeedsExplicitConfigCanvas = false;
		mNextSliceBreaksSequence = false;
		mNextSlicePossiblyInconsistent = false;
		mLastBitmapIsStableSlice = sliceTime.getSlice() >= timeTotal;
		mLastBitmapIsStableSliceIgnoringEffects = sliceTime.getSlice() > timeInPreField;
		mLastBitmapIsStableSliceReadyToAdvanceEffects = sliceTime.getSlice() > timeInPreField;
		if (mLastBitmapIsStableSliceReadyToAdvanceEffects
				&& mDrawSettings.drawEffects == DrawSettings.DRAW_EFFECTS_THROUGH_SLICE)
			convertEffectsToUnpausedRelative(sliceTime);

		mBackgroundBitmapClipOrBlitIsBlitting = false;

		mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_TOTAL] += tock();
		mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_NUMBER]++;

		// Sounds!
		playSounds(sliceTime, pool);

		sliceTime.setLastDrawn();
		clearExpiredEffects(sliceTime);

		if (mLastSliceTime != null && sliceTime != null)
			mLastSliceTime.takeVals(sliceTime);
	}

	private void drawMetamorphosisWithLastSlice_helperClipCoveredStablePreMetamorphosis(
			GameBlocksSlice slice, Offset offset) {

		byte[][][] pre_field = slice.getMetamorphosisPreBlockfield();
		drawMetamorphosisWithLastSlice_helperClipCovered(pre_field, offset);
	}

	private void drawMetamorphosisWithLastSlice_helperClipCoveredStablePostMetamorphosis(
			GameBlocksSlice slice, Offset offset) {

		byte[][][] post_field = slice.getMetamorphosisPostBlockfield();
		drawMetamorphosisWithLastSlice_helperClipCovered(post_field, offset);
	}

	private void drawMetamorphosisWithLastSlice_helperClipCovered(
			byte[][][] field, Offset offset) {

		// Reset coverage regions
		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_Q0_STABLE]);
		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_3D_STABLE]);
		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_Q1_STABLE]);

		clipCoveredPath(mLastBitmapCoveredPath[BITMAP_REGION_Q0_STABLE],
				field, Consts.QPANE_0, 0, offset);
		clipCoveredPath(mLastBitmapCoveredPath[BITMAP_REGION_Q1_STABLE],
				field, Consts.QPANE_1, 0, offset);
		clipCoveredPath(mLastBitmapCoveredPath[BITMAP_REGION_3D_STABLE],
				field, Consts.QPANE_3D, 0, offset);
	}

	private void drawMetamorphosisWithLastSlice_helperClipTouchedStablePreMetamorphosis(
			GameBlocksSlice slice, Offset offset, int extendByPixels,
			boolean includeDisplacementRowsIfAvailable) {

		// Reset touched regions
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q0_STABLE]);
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_3D_STABLE]);
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q1_STABLE]);

		byte[][][] pre_field = slice.getMetamorphosisPreBlockfield();
		drawMetamorphosisWithLastSlice_helperClipTouched(pre_field,
				mConfigRangeStandard, offset, extendByPixels, true);

		if (includeDisplacementRowsIfAvailable
				&& mDrawSettings.getBehaviorIs_displacement()) {
			clipDisplacementOffset.takeVals(offset);
			clipDisplacementOffset.offsetXY(0, mDrawSettings.ROWS
					* mDrawSettings.size_blockHeight);
			drawMetamorphosisWithLastSlice_helperClipTouched(
					slice.getDisplacementBlockfield(), mConfigRangeDisplaced,
					clipDisplacementOffset, extendByPixels, false);
		}
	}

	private void drawMetamorphosisWithLastSlice_helperClipTouchedStablePostMetamorphosis(
			GameBlocksSlice slice, Offset offset, int extendByPixels,
			boolean includeDisplacementRowsIfAvailable) {

		// Reset touched regions
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q0_STABLE]);
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_3D_STABLE]);
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q1_STABLE]);

		byte[][][] post_field = slice.getMetamorphosisPostBlockfield();
		drawMetamorphosisWithLastSlice_helperClipTouched(post_field,
				mConfigRangeStandard, offset, extendByPixels, true);

		if (includeDisplacementRowsIfAvailable
				&& mDrawSettings.getBehaviorIs_displacement()) {
			clipDisplacementOffset.takeVals(offset);
			clipDisplacementOffset.offsetXY(0, mDrawSettings.ROWS
					* mDrawSettings.size_blockHeight);
			drawMetamorphosisWithLastSlice_helperClipTouched(
					slice.getDisplacementBlockfield(), mConfigRangeDisplaced,
					clipDisplacementOffset, extendByPixels, false);
		}
	}

	private void drawMetamorphosisWithLastSlice_helperClipTouched(
			byte[][][] field, BlockDrawerConfigRange configRange,
			Offset offset, int extendByPixels, boolean includeRowNegativeOne) {

		clipTouchedPath(mLastBitmapTouchedPath[BITMAP_REGION_Q0_STABLE],
				field, configRange, Consts.QPANE_0, offset, extendByPixels);
		clipTouchedPath(mLastBitmapTouchedPath[BITMAP_REGION_Q1_STABLE],
				field, configRange, Consts.QPANE_1, offset, extendByPixels);
		clipTouchedPath(mLastBitmapTouchedPath[BITMAP_REGION_3D_STABLE],
				field, configRange, Consts.QPANE_3D, offset, extendByPixels);

		if (includeRowNegativeOne) {
			// Include Row neg 1!
			clipFullWidthRowNegativeOne(
					mLastBitmapTouchedPath[BITMAP_REGION_Q0_STABLE], 0,
					mDrawSettings.width, Consts.QPANE_0, offset, extendByPixels);
			clipFullWidthRowNegativeOne(
					mLastBitmapTouchedPath[BITMAP_REGION_Q1_STABLE], 0,
					mDrawSettings.width, Consts.QPANE_1, offset, extendByPixels);
		}
	}

	private void drawMetamorphosisWithLastSlice_helperClipCoveredVolatileEmpty() {
		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_Q0_VOLATILE]);
		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_3D_VOLATILE]);
		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_Q1_VOLATILE]);
	}

	private void drawMetamorphosisWithLastSlice_helperClipTouchedVolatileEmpty() {
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q0_VOLATILE]);
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_3D_VOLATILE]);
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q1_VOLATILE]);
	}

	private void drawMetamorphosisWithLastSlice_helperClipCoveredVolatileBox(
			GameBlocksSlice slice, Offset offset) {
		// We use 'volatile' to represent a fading pulse box. Guess what
		// though? This fading box does not "cover" anything! That's easy
		// enough.
		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_Q0_VOLATILE]);
		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_3D_VOLATILE]);
		emptyWithOutOfBounds(mLastBitmapCoveredPath[BITMAP_REGION_Q1_VOLATILE]);
	}

	private void drawMetamorphosisWithLastSlice_helperClipTouchedVolatileBox(
			GameBlocksSlice slice, Offset offset) {
		// We use 'volatile' to represent a fading pulse box.
		// This box "touches" the pulsed area in the 3D pane according
		// to the 'pre' field.
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q0_VOLATILE]);
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_3D_VOLATILE]);
		emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q1_VOLATILE]);

		clipPulseFill(mLastBitmapTouchedPath[BITMAP_REGION_3D_VOLATILE],
				slice.getMetamorphosisPreBlockfield(), Consts.QPANE_3D, 0,
				offset);
	}

	/**
	 * Primarily intended as a helper for drawStableWithLastSlice. Provide a
	 * canvas, a draw offset, a GameBlocksSlice to draw and the current time
	 * (for pulses).
	 * 
	 * PRECONDITIONS: The provided canvas has been clipped appropriately. When
	 * drawing efficiently (i.e. to mLastBitmapCanvas, this clip should cover
	 * only those blocks which have changed; when drawing directly to the
	 * OS-provided canvas, a clip has likely already been applied; redraw
	 * everything.
	 * 
	 * 'canvasTransation' has been set in advance, according to whether the
	 * provided canvas includes any transation.
	 * 
	 * mLastCorners_ and mLastInnerShadowSets have been configured.
	 * 
	 * POSTCONDITIONS: The stable block slice has been drawn to the canvas.
	 */
	private void drawMetamorphosisStableToCanvas_withSlice(
			DrawSettings drawSettings, int qPane, Canvas canvas, Offset offset,
			int extraRows, GameBlocksSlice slice,
			BlockDrawerSliceTime sliceTime, boolean preField,
			Offset offsetBackground, boolean includeDisplacementRowsIfAvailable) {

		BlockDrawerConfigRange configRange = tempConfigRange;
		configRange.set(drawSettings.displayedRows + extraRows,
				drawSettings.COLS);

		long currentTime = sliceTime.getUnpaused();

		float alphaScale_fillPulse = animationSettings == null ? 0
				: animationSettings.pulseAlpha(
						drawSettings.alphaScale_lockedFillPulse, currentTime);
		float alphaScale_boxPulse = animationSettings == null ? 0
				: animationSettings.pulseAlpha(
						drawSettings.alphaScale_lockedBoxPulse, currentTime);

		byte[][][] field = preField ? slice.getMetamorphosisPreBlockfield()
				: slice.getMetamorphosisPostBlockfield();
		byte[][][][] corners = mLastCorners_byField_byPaneCorner
				.get(INDEX_FIELD_STABLE);
		short[][][] shadows = mLastFillShadowSets_byField_byPane
				.get(INDEX_FIELD_STABLE);
		short[][][][] drop = mLastDropShadowSets_byField_byPane_byUniqueColor
				.get(INDEX_FIELD_STABLE);

		byte[][][][] qo_corners = mLastQOConnectedCorners_byField_byPaneCorner
				.get(INDEX_FIELD_STABLE);
		short[][][] qo_sets = mLastQOConnectedSets_byField_byPane
				.get(INDEX_FIELD_STABLE);
		
		byte[][][][] displacement_corners = mLastCorners_byField_byPaneCorner.get(INDEX_FIELD_DISPLACEMENT) ;

		int pieceType = slice.getPieceType();

		// Drop shadows: Because there is only 1 blockfield to consider
		// (stable), we can safely
		// draw the drop shadows as part of our normal style.

		// draw background: happens in 2 different steps. If we draw 'all,' we
		// fill
		// now. Otherwise, if BLOCK_FILL, we draw twice - first to set the
		// background
		// color, second to draw the fills themselves.

		drawBackgroundBehaviorToCanvas(drawSettings, canvas, offsetBackground,
				sliceTime, BlockDrawerConfigCanvas.Background.CLEAR);

		boolean drawQ1 = qPane == Consts.QPANE_ALL || qPane == Consts.QPANE_1;
		boolean drawQ0 = qPane == Consts.QPANE_ALL || qPane == Consts.QPANE_0;
		boolean draw3d = qPane == Consts.QPANE_ALL || qPane == Consts.QPANE_3D;

		if (includeDisplacementRowsIfAvailable
				&& drawSettings.getBehaviorIs_displacement()) {
			drawDisplacementOffset.takeVals(offset);
			drawDisplacementOffset.offsetXY(0,
					drawSettings.ROWS * drawSettings.size_blockHeight);
		}

		// draw to last bitmap canvas
		if (drawSettings.drawQ1 && drawQ1) {
			// PANE 1: displacement.
			if (includeDisplacementRowsIfAvailable
					&& drawSettings.getBehaviorIs_displacement()) {
				drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
						(drawSettings.alpha_displacementBorder > 0 ? STYLE_FILL_AND_BORDER : STYLE_FILL),
						canvas, slice.getDisplacementBlockfield(),
						mConfigRangeDisplaced, Consts.QPANE_1, pieceType,
						drawDisplacementOffset,
						drawSettings.alpha_displacementFill, 0, 0, 0, drawSettings.alpha_displacementBorder, 0, 0,
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_TL],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_TR],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_BL],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_BR],
						null, null, sliceTime,
						GlowEffect.TYPE_NONE, true, null);
			}
			// PANE 1: draw row neg 1
			if (drawSettings.behavior_border == DrawSettings.BEHAVIOR_BORDER_ROW_NEGATIVE_ONE)
				drawRowNegativeOneToCanvas(drawSettings, canvas,
						Consts.QPANE_1,
						drawSettings.alpha_rowNegativeOneBorder, offset);
			// PANE 1: field
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, field,
					configRange, Consts.QPANE_1, pieceType, offset, -1,
					drawSettings.alpha_lockedFill, alphaScale_fillPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					corners[Consts.QPANE_1][INDEX_CORNER_TL],
					corners[Consts.QPANE_1][INDEX_CORNER_TR],
					corners[Consts.QPANE_1][INDEX_CORNER_BL],
					corners[Consts.QPANE_1][INDEX_CORNER_BR],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_TL],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_TR],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_BL],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_BR],
					shadows[Consts.QPANE_1], drop[Consts.QPANE_1],
					qo_sets[Consts.QPANE_1], sliceTime, GlowEffect.TYPE_NONE,
					null, FadeEffect.TYPE_NONE, null);
		}

		if (drawSettings.draw3D && draw3d) {
			// PANE 3D: field
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, field,
					configRange, Consts.QPANE_3D, pieceType, offset, -1,
					drawSettings.alpha_lockedFill, alphaScale_boxPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					corners[Consts.QPANE_0][INDEX_CORNER_TL],
					corners[Consts.QPANE_0][INDEX_CORNER_TR],
					corners[Consts.QPANE_0][INDEX_CORNER_BL],
					corners[Consts.QPANE_0][INDEX_CORNER_BR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BR], null, null,
					qo_sets[Consts.QPANE_0], sliceTime, GlowEffect.TYPE_NONE,
					null, FadeEffect.TYPE_NONE, null);
		}

		// draw to last bitmap canvas
		if (drawSettings.drawQ0 && drawQ0) {
			// PANE 1: displacement.
			if (includeDisplacementRowsIfAvailable
					&& drawSettings.getBehaviorIs_displacement()) {
				drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
						(drawSettings.alpha_displacementBorder > 0 ? STYLE_FILL_AND_BORDER : STYLE_FILL),
						canvas, slice.getDisplacementBlockfield(),
						mConfigRangeDisplaced, Consts.QPANE_0, pieceType,
						drawDisplacementOffset,
						drawSettings.alpha_displacementFill, 0, 0, 0, drawSettings.alpha_displacementBorder, 0, 0,
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_TL],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_TR],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_BL],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_BR],
						null, null, sliceTime,
						GlowEffect.TYPE_NONE, true, null);
			}
			// PANE 0: draw row neg 1.
			if (drawSettings.behavior_border == DrawSettings.BEHAVIOR_BORDER_ROW_NEGATIVE_ONE)
				drawRowNegativeOneToCanvas(drawSettings, canvas,
						Consts.QPANE_0,
						drawSettings.alpha_rowNegativeOneBorder, offset);
			// PANE 1: field
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, field,
					configRange, Consts.QPANE_0, pieceType, offset, -1,
					drawSettings.alpha_lockedFill, alphaScale_fillPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					corners[Consts.QPANE_0][INDEX_CORNER_TL],
					corners[Consts.QPANE_0][INDEX_CORNER_TR],
					corners[Consts.QPANE_0][INDEX_CORNER_BL],
					corners[Consts.QPANE_0][INDEX_CORNER_BR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BR],
					shadows[Consts.QPANE_0], drop[Consts.QPANE_0],
					qo_sets[Consts.QPANE_0], sliceTime, GlowEffect.TYPE_NONE,
					null, FadeEffect.TYPE_NONE, null);
		}
	}

	/**
	 * Draws only and exactly the 3D pulse box of the 'pre' blockfield to the
	 * provided canvas. We draw at standard pulse alpha and allow blitting to
	 * take care of the fade-out.
	 */
	private void drawMetamorphosisPulseBoxToCanvas_withSlice(
			DrawSettings drawSettings, int qPane, Canvas canvas, Offset offset,
			int extraRows, GameBlocksSlice slice, BlockDrawerSliceTime sliceTime) {

		BlockDrawerConfigRange configRange = tempConfigRange;
		configRange.set(drawSettings.displayedRows, drawSettings.COLS);

		long currentTime = sliceTime.getUnpaused();

		float alphaScale_boxPulse = animationSettings == null ? 0
				: animationSettings.pulseAlpha(
						drawSettings.alphaScale_lockedBoxPulse, currentTime);

		byte[][][] field = slice.getMetamorphosisPreBlockfield();
		byte[][][][] qo_corners = mLastQOConnectedCorners_byField_byPaneCorner
				.get(INDEX_FIELD_METAMORPHOSIS_PRE);
		short[][][] qo_sets = mLastQOConnectedSets_byField_byPane
				.get(INDEX_FIELD_METAMORPHOSIS_PRE);

		// Drop shadows: Because there is only 1 blockfield to consider
		// (stable), we can safely
		// draw the drop shadows as part of our normal style.

		// draw background: happens in 2 different steps. If we draw 'all,' we
		// fill
		// now. Otherwise, if BLOCK_FILL, we draw twice - first to set the
		// background
		// color, second to draw the fills themselves.

		// erase!
		drawBackgroundBehaviorToCanvas(drawSettings, canvas, null, sliceTime,
				BlockDrawerConfigCanvas.Background.CLEAR);

		boolean draw3d = qPane == Consts.QPANE_ALL || qPane == Consts.QPANE_3D;

		if (drawSettings.draw3D && draw3d) {
			// draw boxes!
			drawBlockFieldQPane3DAtAlignmentOffset(drawSettings, canvas, field,
					null, configRange, alignmentOffset, null, null, null, null,
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BR], null, null,
					null, null, qo_sets[Consts.QPANE_0], 0, 0,
					alphaScale_boxPulse, 0, false, sliceTime,
					FadeEffect.TYPE_NONE, null);
		}
	}

	private void drawMetamorphosisToCanvas_withSlice(DrawSettings drawSettings,
			Canvas canvas, Offset offset, GameBlocksSlice slice,
			BlockDrawerSliceTime sliceTime, float boxFadeAlphaMult,
			Offset offsetBackground,
			BlockDrawerConfigCanvas.Background configCanvasBackground,
			int blockCoveredYOffset, boolean includeDisplacementRowsIfAvailable) {

		BlockDrawerConfigRange configRange = tempConfigRange;
		configRange.set(drawSettings.displayedRows, drawSettings.COLS);

		long timeSpentAnimating = sliceTime.getSlice();
		long currentTime = sliceTime.getUnpaused();

		boolean preField = timeSpentAnimating < animationSettings
				.metamorphosisGlowTimeToPeak(0, 1, 0);

		float alphaScale_fillPulse = animationSettings == null ? 0
				: animationSettings.pulseAlpha(
						drawSettings.alphaScale_lockedFillPulse, currentTime);
		float alphaScale_boxPulse = animationSettings == null ? 0
				: animationSettings.pulseAlpha(
						drawSettings.alphaScale_lockedBoxPulse, currentTime);

		// now COUPLE! I mean, DRAW!
		byte[][][] field = preField ? slice.getMetamorphosisPreBlockfield()
				: slice.getMetamorphosisPostBlockfield();
		byte[][][][] corners = mLastCorners_byField_byPaneCorner
				.get(INDEX_FIELD_METAMORPHOSIS);
		short[][][] shadows = mLastFillShadowSets_byField_byPane
				.get(INDEX_FIELD_METAMORPHOSIS);
		short[][][][] drop = mLastDropShadowSets_byField_byPane_byUniqueColor
				.get(INDEX_FIELD_METAMORPHOSIS);
		byte[][][][] qo_corners = mLastQOConnectedCorners_byField_byPaneCorner
				.get(INDEX_FIELD_METAMORPHOSIS);
		short[][][] qo_sets = mLastQOConnectedSets_byField_byPane
				.get(INDEX_FIELD_METAMORPHOSIS);

		byte[][][] pre_field = slice.getMetamorphosisPreBlockfield();
		byte[][][][] qo_pre_corners = mLastQOConnectedCorners_byField_byPaneCorner
				.get(INDEX_FIELD_METAMORPHOSIS_PRE);
		short[][][] qo_pre_sets = mLastQOConnectedSets_byField_byPane
				.get(INDEX_FIELD_METAMORPHOSIS_PRE);
		
		byte[][][][] displacement_corners = mLastCorners_byField_byPaneCorner.get(INDEX_FIELD_DISPLACEMENT) ;

		int pieceType = slice.getPieceType();

		// draw background
		// draw background: happens in 2 different steps. If we draw 'all,' we
		// fill
		// now. Otherwise, if BLOCK_FILL, we draw twice - first to set the
		// background
		// color, second to draw the fills themselves.
		fullBlitDrawBackground(drawSettings, canvas, offsetBackground,
				sliceTime, configCanvasBackground, 255, 255,
				blockCoveredYOffset);

		// set canvas translation
		canvasTranslationOffset.x = canvasTranslationOffset.y = 0;

		if (includeDisplacementRowsIfAvailable
				&& drawSettings.getBehaviorIs_displacement()) {
			drawDisplacementOffset.takeVals(offset);
			drawDisplacementOffset.offsetXY(0,
					drawSettings.ROWS * drawSettings.size_blockHeight);
		}

		// draw to last bitmap canvas
		if (drawSettings.drawQ1) {
			// PANE 1: displacement.
			if (includeDisplacementRowsIfAvailable
					&& drawSettings.getBehaviorIs_displacement()) {
				drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
						(drawSettings.alpha_displacementBorder > 0 ? STYLE_FILL_AND_BORDER : STYLE_FILL),
						canvas, slice.getDisplacementBlockfield(),
						mConfigRangeDisplaced, Consts.QPANE_1, pieceType,
						drawDisplacementOffset,
						drawSettings.alpha_displacementFill, 0, 0, 0, drawSettings.alpha_displacementBorder, 0, 0,
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_TL],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_TR],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_BL],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_BR],
						null, null, sliceTime,
						GlowEffect.TYPE_NONE, true, null);
			}
			// PANE 1: draw row neg 1
			if (drawSettings.behavior_border == DrawSettings.BEHAVIOR_BORDER_ROW_NEGATIVE_ONE)
				drawRowNegativeOneToCanvas(drawSettings, canvas,
						Consts.QPANE_1,
						drawSettings.alpha_rowNegativeOneBorder, offset);
			// PANE 1: field and glows
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, field,
					configRange, Consts.QPANE_1, pieceType, offset, -1,
					drawSettings.alpha_lockedFill, alphaScale_fillPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					corners[Consts.QPANE_1][INDEX_CORNER_TL],
					corners[Consts.QPANE_1][INDEX_CORNER_TR],
					corners[Consts.QPANE_1][INDEX_CORNER_BL],
					corners[Consts.QPANE_1][INDEX_CORNER_BR],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_TL],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_TR],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_BL],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_BR],
					shadows[Consts.QPANE_1], drop[Consts.QPANE_1],
					qo_sets[Consts.QPANE_1], sliceTime, GlowEffect.TYPE_NONE,
					null, FadeEffect.TYPE_NONE, null);

			// glows...
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, null,
					configRange, Consts.QPANE_1, pieceType, offset, -1, 255,
					255, 255, 255, null, null, null, null, null, null, null,
					null, null, null, null, sliceTime, GlowEffect.TYPE_ANY,
					mLastEffectsGlow, FadeEffect.TYPE_NONE, null);

		}

		if (drawSettings.draw3D) {
			// PANE 3D: draw the field
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, field,
					configRange, Consts.QPANE_3D, pieceType, offset, -1,
					drawSettings.alpha_lockedFill, alphaScale_boxPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					corners[Consts.QPANE_0][INDEX_CORNER_TL],
					corners[Consts.QPANE_0][INDEX_CORNER_TR],
					corners[Consts.QPANE_0][INDEX_CORNER_BL],
					corners[Consts.QPANE_0][INDEX_CORNER_BR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BR], null, null,
					qo_sets[Consts.QPANE_0], sliceTime, GlowEffect.TYPE_NONE,
					null, FadeEffect.TYPE_NONE, null);
			// guess what? We might draw boxes!
			drawBlockFieldQPane3DAtAlignmentOffset(drawSettings, canvas,
					pre_field, null, configRange, alignmentOffset, null, null,
					null, null,
					qo_pre_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					qo_pre_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					qo_pre_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					qo_pre_corners[Consts.QPANE_0][INDEX_CORNER_BR], null,
					null, null, null, qo_pre_sets[Consts.QPANE_0], 0, 0,
					alphaScale_boxPulse * boxFadeAlphaMult, 0, false,
					sliceTime, FadeEffect.TYPE_NONE, null);

		}

		// draw to last bitmap canvas
		if (drawSettings.drawQ0) {
			// PANE 0: displacement.
			if (includeDisplacementRowsIfAvailable
					&& drawSettings.getBehaviorIs_displacement()) {
				drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
						(drawSettings.alpha_displacementBorder > 0 ? STYLE_FILL_AND_BORDER : STYLE_FILL),
						canvas, slice.getDisplacementBlockfield(),
						mConfigRangeDisplaced, Consts.QPANE_0, pieceType,
						drawDisplacementOffset,
						drawSettings.alpha_displacementFill, 0, 0, 0, drawSettings.alpha_displacementBorder, 0, 0,
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_TL],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_TR],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_BL],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_BR],
						null, null, sliceTime,
						GlowEffect.TYPE_NONE, true, null);
			}
			// PANE 0: draw row neg 1
			if (drawSettings.behavior_border == DrawSettings.BEHAVIOR_BORDER_ROW_NEGATIVE_ONE)
				drawRowNegativeOneToCanvas(drawSettings, canvas,
						Consts.QPANE_0,
						drawSettings.alpha_rowNegativeOneBorder, offset);
			// PANE 0: field and glows
			// field...
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, field,
					configRange, Consts.QPANE_0, pieceType, offset, -1,
					drawSettings.alpha_lockedFill, alphaScale_fillPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					corners[Consts.QPANE_0][INDEX_CORNER_TL],
					corners[Consts.QPANE_0][INDEX_CORNER_TR],
					corners[Consts.QPANE_0][INDEX_CORNER_BL],
					corners[Consts.QPANE_0][INDEX_CORNER_BR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BR],
					shadows[Consts.QPANE_0], drop[Consts.QPANE_0],
					qo_sets[Consts.QPANE_0], sliceTime, GlowEffect.TYPE_NONE,
					null, FadeEffect.TYPE_NONE, null);

			// lock glows...
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, null,
					configRange, Consts.QPANE_0, pieceType, offset, -1, 255,
					255, 255, 255, null, null, null, null, null, null, null,
					null, null, null, null, sliceTime, GlowEffect.TYPE_ANY,
					mLastEffectsGlow, FadeEffect.TYPE_NONE, null);

		}
	}

	private void drawPushingBlockFieldWithLastSlice(Canvas canvas,
			QuantroSoundPool pool, GameBlocksSlice slice,
			BlockDrawerSliceTime sliceTime, BlockDrawerConfigCanvas configCanvas) {

		if (configCanvas == null && mNextSliceNeedsExplicitConfigCanvas)
			configCanvas = mDrawSettings.configCanvas;

		if (this.veilOnScreen(sliceTime))
			throw new IllegalStateException(
					"Can only display veil in Stable or Piece Falling");

		tick();

		// Our "efficient" draw function. We draw to
		// mLastBitmapCanvas[BITMAP_FULL], then
		// draw mLastBitmap to the canvas provided.
		boolean backgroundChanged = backgroundLayerChanged(mLastSliceTime,
				sliceTime);
		boolean fieldChanged = false; // a change in underlying field. True
										// unless the provided slice is
										// basically identical.

		int rowsRisen = slice.getNumRowsAddedByPush();
		int extraRows = Math.min(rowsRisen, mDrawSettings.ROWS
				- mDrawSettings.displayedRows);

		// extend by this amount.
		mConfigRangeExtended.set(mDrawSettings.displayedRows + extraRows,
				mDrawSettings.COLS);

		// Next: determine what changed. If the field changed (including
		// if the last slice was a different state)
		tick();
		boolean sliceStateChanged = mLastSlice.getBlocksState() != slice
				.getBlocksState() || !sliceTime.hasBeenDrawnEver();

		if (sliceStateChanged
				&& GlobalTestSettings.BLOCK_DRAWER_LOG_SLICE_STATE)
			log("now drawing pushing blocks");

		fieldChanged = mNextSliceBreaksSequence;
		fieldChanged = fieldChanged
				|| mLastSlice.getBlocksState() != GameBlocksSlice.BLOCKS_PUSHING_ROWS
				|| mLastSlice.getNumRowsPushedDown() != slice
						.getNumRowsPushedDown()
				|| mLastSlice.getNumRowsPushedUp() != slice
						.getNumRowsPushedUp()
				|| (mNextSlicePossiblyInconsistent
						&& (!ArrayOps.areEqual(
								mLastSlice.getBlockfieldStable(),
								slice.getBlockfieldStable())) || !ArrayOps
						.areEqual(mLastSlice.getPushingRowsPreBlockfield(),
								slice.getPushingRowsPreBlockfield()));
		fieldChanged = fieldChanged || mLastBitmapDifferentDisplacement ;

		// use pre or post blockfield?
		long timeInPreField = animationSettings.timeToPushMinimum(
				slice.getNumRowsPushedDown(), slice.getNumRowsPushedUp());
		boolean inPostField = sliceTime.getSlice() >= timeInPreField;
		boolean firstTimeInField = sliceStateChanged || fieldChanged
				|| !sliceTime.hasBeenDrawnEver()
				|| (inPostField && mLastSliceTime.getSlice() < timeInPreField);

		if (fieldChanged)
			mProfileBehavior = BlockDrawer.INDEX_PROFILE_SLICE_RISING_BEHAVIOR_FIELD_CHANGED;
		else
			mProfileBehavior = BlockDrawer.INDEX_PROFILE_SLICE_RISING_BEHAVIOR_GLOW_ANIMATING;
		mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_CHECK_EQUALITY] += tock();

		// Next: get shadows, corners, etc. for the purposes of drawing.
		// Probably this should
		// only happen at most twice - once in 'pre', once in 'post.'
		if (fieldChanged) {
			// Determine shadow sets, corners, glows
			tick();
			byte[][][] pre_field = slice.getPushingRowsPreBlockfield();
			byte[][][] post_field = slice.getPushingRowsPostBlockfield();
			for (int i = 0; i < 2; i++) {
				byte[][][] field = i == 0 ? pre_field : post_field;
				int index_field = i == 0 ? INDEX_FIELD_PUSHING_PRE
						: INDEX_FIELD_PUSHING;
				byte[][][][] corners = mLastCorners_byField_byPaneCorner
						.get(index_field);
				short[][][] shadows = mLastFillShadowSets_byField_byPane
						.get(index_field);
				short[][][][] drop = mLastDropShadowSets_byField_byPane_byUniqueColor
						.get(index_field);
				setShadowsAndCorners(mDrawSettings, field,
						mConfigRangeExtended, shadows, drop, corners);

				byte[][][][] qoCorners = this.mLastQOConnectedCorners_byField_byPaneCorner
						.get(index_field);
				short[][][] qoSets = this.mLastQOConnectedSets_byField_byPane
						.get(index_field);
				setQOConnectionAndCorners(mDrawSettings, field,
						mConfigRangeExtended, qoSets, qoCorners);
			}

			mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_SET_SHADOWS_AND_CORNERS] += tock();

			tick();
			long lockGlowDuration = 0;
			for (int i = 0; i < mDrawSettings.glow_alphaPeakNormalized[Consts.GLOW_LOCK].length; i++) {
				lockGlowDuration = Math
						.max(lockGlowDuration,
								animationSettings
										.lockGlowTimeToFinish(
												0,
												mDrawSettings.glow_alphaPeakNormalized[Consts.GLOW_LOCK][i],
												0));
			}
			long enterGlowDuration = 0;
			for (int i = 0; i < mDrawSettings.glow_alphaPeakNormalized[Consts.GLOW_ENTER].length; i++) {
				enterGlowDuration = Math
						.max(enterGlowDuration,
								animationSettings
										.enterGlowTimeToFinish(
												0,
												mDrawSettings.glow_alphaPeakNormalized[Consts.GLOW_ENTER][i],
												0));
			}

			// before adding new glows, let's offset the existing ones.
			int shiftUp = 0;
			shiftUp += slice.getNumRowsAddedByTransfer();
			shiftUp += Math.max(0, slice.getNumRowsAddedByPush());
			mLastEffectsGlow.translate(shiftUp, 0,
					BlockDrawer.GLOW_SET_INDEX_NONE);

			// we push down by 'pushDown', then push p by 'pushedUp.' Only
			// 'pushedUp'
			// rows create glow effects. Furthermore, we only create those glow
			// effects
			// starting at the row which is different in pre and post field.
			// If pushedUp > pushDown, then we AT LEAST include every net
			// increase row.
			// We include up to pushedUp rows, starting from the first different
			// row among
			// those pushed in.
			int rowOffset = slice.getNumRowsPushedUp()
					- slice.getNumRowsPushedDown()
					+ slice.getNumRowsAddedByTransfer();
			// add to row in pre to reach corresponding row in post.

			// the number of (bottom n) rows in post field which are entirely
			// new.
			// at the very least, any net added row is new.
			int firstDifferenceInPost = -1;
			for (int row = slice.getNumRowsPushedDown(); row >= 0
					&& firstDifferenceInPost == -1; row--) {
				int r = row + slice.getEdge();
				boolean diff = false;
				int rPost = r + rowOffset;
				int rowPost = row + rowOffset;
				if (rowPost >= 0) {
					for (int qp = 0; qp < 2 && firstDifferenceInPost == -1; qp++) {
						for (int c = slice.getEdge(); c < mDrawSettings.COLS
								+ slice.getEdge()
								&& firstDifferenceInPost == -1; c++) {
							if (pre_field[qp][r][c] != post_field[qp][rPost][r]) {
								firstDifferenceInPost = rowPost;
							}
						}
					}
				}
			}
			int newRows = Math.max(
					firstDifferenceInPost,
					slice.getNumRowsAddedByPush()
							+ slice.getNumRowsAddedByTransfer());
			// we add rising glows for the rows added by the push. For now,
			// this is a cheat -- we assume we never Push and Transfer rows
			// in the same step.
			if (slice.getNumRowsPushedDown() >= 0 || slice.getNumRowsPushedUp() > 0) {
				boolean hasLockGlows = false;
				byte[][][] field = slice.getPushingRowsPostBlockfield();
				for (int qp = 0; qp < 2; qp++) {
					if ((qp == 0 && mDrawSettings.drawQ0)
							|| (qp == 1 && mDrawSettings.drawQ1)) {
						int numGlows = addRisingLockGlows(
								mDrawSettings,
								field,
								slice.getNumRowsPushedUp()
										+ slice.getNumRowsAddedByTransfer(),
								qp, mLastEffectsGlow, timeInPreField,
								lockGlowDuration, newRows);
						hasLockGlows = hasLockGlows || numGlows > 0;
					}
				}
				if (hasLockGlows)
					mLastEffectsSound.addLock(
							BlockDrawerSliceTime.RelativeTo.SLICE, timeInPreField,
							slice.getPieceType(), false, 0);
				
			}
			
			// Adds garbage and row push sound effects.  Does NOT add 'enter' effects.
			drawPushedBlockFieldWithLastSlice_helperAddRowPushSoundEffects(
					slice, BlockDrawerSliceTime.RelativeTo.SLICE, 0 ) ;

			if (slice.getNumRowsAddedByTransfer() > 0) {
				// the slice's 'displacement' is AFTER rows are added.
				// we can approximate the displacement before they are
				// added with a simple addition.
				// NOTE: previously, rows "entered" well after their
				// position had been displayed onscreen.  Now, we prefer
				// to enter them before their position has reached visibility.
				// Obviously, because we only enter new rows BETWEEN pieces,
				// it's possible to mess this up, but whatever.  The point being:
				// we only want to draw glows (and play the sound effect) if
				// something VISIBLE has changed onscreen!  The glows cover
				// up the change, and the sound effect makes the glow cooler.
				// So how to determine if something has changed?
				// Well, we can attempt to calculate the previous displacement,
				// and see if any bottom-borders were on the screen at that
				// time.  If they were, play the sound and do the glow.
				double prevDisp = (slice.getDisplacement() + slice.getNumRowsAddedByTransfer())
						* mDrawSettings.size_blockHeight ;
				// assume "bottom aligned"...
				double distanceToHideRowZeroBottomBorder = Math.abs( mDrawSettings.size_qYOffset )
						+ mDrawSettings.size_borderHeight ;
				if ( prevDisp > -distanceToHideRowZeroBottomBorder ) {
					boolean hasEnterGlows = false;
					byte[][][] field = slice.getPushingRowsPostBlockfield();
					for (int qp = 0; qp < 2; qp++) {
						if ((qp == 0 && mDrawSettings.drawQ0)
								|| (qp == 1 && mDrawSettings.drawQ1)) {
							int numGlows = this.addEnterGlowsFromBottom(
									mDrawSettings, field,
									slice.getNumRowsAddedByTransfer(), qp,
									mLastEffectsGlow, timeInPreField,
									enterGlowDuration);
							hasEnterGlows = hasEnterGlows || numGlows > 0;
						}
					}
					if (hasEnterGlows)
						mLastEffectsSound.addEnter(
								BlockDrawerSliceTime.RelativeTo.SLICE, timeInPreField, 0);
				}
			}
			mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_SET_EFFECTS] += tock();
		}

		int height = mDrawSettings.height;
		int blitHeight = mDrawSettings.configCanvas.region.height();

		// calculate how to blit and all that.
		float blocksRisenFromPre = animationSettings.distanceRowsPushed(
				sliceTime.getSlice(), slice.getNumRowsPushedDown(),
				slice.getNumRowsPushedUp());
		long lastTime = (fieldChanged || sliceStateChanged) ? 0 : sliceTime
				.getLastDrawnSlice();
		float blocksRisenLastFromPre = animationSettings.distanceRowsPushed(
				lastTime, slice.getNumRowsPushedDown(),
				slice.getNumRowsPushedUp());

		float blocksRisenFromPost = blocksRisenFromPre
				- slice.getNumRowsAddedByPush();
		float blocksRisenLastFromPost = blocksRisenLastFromPre
				- slice.getNumRowsAddedByPush();

		// convert to current field.
		float blocksOffsetFromField = -(inPostField ? blocksRisenFromPost
				: blocksRisenFromPre);
		float blocksOffsetLastFromField = -(inPostField ? blocksRisenLastFromPost
				: blocksRisenLastFromPre);

		int pixelsOffsetFromField = (int) Math.round(blocksOffsetFromField
				* mDrawSettings.size_blockHeight);
		int pixelsOffsetLastFromField = (int) Math
				.round(blocksOffsetLastFromField
						* mDrawSettings.size_blockHeight);

		/*
		 * log("drawing pushing blocks with " +
		 * slice.getNumRowsPushedDown() + " down, " + slice.getNumRowsPushedUp()
		 * + " up.  Time is " + sliceTime.getSlice() + " out of " +
		 * animationSettings.timeToPushDistance(slice.getNumRowsPushedDown(),
		 * slice.getNumRowsPushedUp()) + " with pixel offset " +
		 * pixelsOffsetFromField + " from " + (inPostField ? "post" : "pre") +
		 * " still with " + mLastEffectsGlow.size() + " glows" + " real time " +
		 * sliceTime.getTotal()) ;
		 */

		boolean risingBlit = true;

		int blitHeightOffset;
		int drawHeightOffset;

		if (risingBlit) {
			blitHeightOffset = Math.round(blocksOffsetFromField
					* mDrawSettings.getBlitBlockHeight());
			// note: no need to change this for quarter blit;
			// getBlitBlockHeight has already scaled.
			drawHeightOffset = 0;
		} else {
			blitHeightOffset = 0;
			drawHeightOffset = Math.round(blocksOffsetFromField
					* mDrawSettings.size_blockHeight);
		}

		// log("blitHeightOffset " + blitHeightOffset +
		// ", drawHeightOffset " + drawHeightOffset) ;

		int extendByPixels = Math.max(boundDropShadowHeight(mDrawSettings),
				boundDropShadowWidth(mDrawSettings));

		boolean doubleBitmapOffset = mLastBitmap != null
				&& mDrawSettings.drawAnimations >= DrawSettings.DRAW_ANIMATIONS_STABLE_STUTTER
				&& mDrawSettings.getBlit() != DrawSettings.BLIT_SEPTUPLE
				&& !mDrawSettings.getBehaviorIs_displacement();

		// ////
		// /////////////////////////////////////////////////////////////////
		// CLIP TOUCHED AND COVERED
		if (fieldChanged || sliceStateChanged || mLastBitmapVeiled
				|| firstTimeInField || mLastBitmapDifferentDisplacement) {

			setAlignmentOffset(inPostField ? slice.getBlockfieldStable()
					: slice.getPushingRowsPreBlockfield(), clipOffset);
			if (doubleBitmapOffset)
				clipOffset.y += height;

			// here's where we completely reset STABLE and VOLATILE.
			// FOR SEPTUPLE:
			// STABLE should be drawn as the new "stable field" - the
			// way things will
			// be after the blocks have risen. In other words, we draw
			// it completely normally
			// - we can even borrow drawStable's helper methods to do
			// so. Note that if
			// the blocks rise very far, some blocks might be pushed off
			// the top and would
			// not be visible within STABLE. That's fine! We're putting
			// them in VOLATILE.

			// VOLATILE is drawn as the new "stable field" as well,
			// except that it is drawn
			// to represent the "top portion" - everything above the top
			// row. Just in case,
			// though, we offset it by 'displayedRows - 1' so the bottom
			// row in VOLATILE
			// is "displayedRows - 1". This doesn't require any special
			// setup; just draw
			// with an offset pushing things down this far.

			// FOR FULL:
			// STABLE should be drawn as everything, full-height.

			// Reset coverage
			if (inPostField) {
				this.drawPushedBlockFieldWithLastSlice_helperClipCoveredPostBlockField(
						slice, extraRows, clipOffset);
				this.drawPushedBlockFieldWithLastSlice_helperClipTouchedPostBlockField(
						slice, extraRows, clipOffset, extendByPixels, true);
			} else {
				this.drawPushedBlockFieldWithLastSlice_helperClipCoveredPreBlockField(
						slice, extraRows, clipOffset);
				this.drawPushedBlockFieldWithLastSlice_helperClipTouchedPreBlockField(
						slice, extraRows, clipOffset, extendByPixels, true);
			}
		}

		mConfigRangeExtended.set(mDrawSettings.displayedRows + extraRows,
				mDrawSettings.COLS);

		if (!veilOnScreen(sliceTime) || !mLastBitmapVeiled || fieldChanged
				|| sliceStateChanged
				|| !sliceTime.hasBeenDrawnAtThisSliceTime()) {

			// If using BLIT_FULL, we set offsets to match the mLast, clip
			// according
			// to changes, draw to mLastBitmap and finally blit to the canvas.
			// If
			// using BLIT_NONE, we set offset to match the canvas, clip UNION
			// the
			// pulses (assuming an appropriate clip is already in place), and
			// draw
			// directly to the canvas.
			switch (mDrawSettings.getBlit()) {
			case DrawSettings.BLIT_SEPTUPLE:
				// set offsets
				if (fieldChanged || alignmentOffsetSet || sliceStateChanged
						|| firstTimeInField) {
					setAlignmentOffset(
							inPostField ? slice.getBlockfieldStable()
									: slice.getPushingRowsPreBlockfield(),
							alignmentOffset);
					canvasAlignmentOffset.takeVals(alignmentOffset);

					alignmentOffsetSet = false;
				}
				canvasTranslationOffset.x = 0;
				canvasTranslationOffset.y = 0;

				// clip
				tick();
                reset(mLastBitmapClipPath);
				if (fieldChanged || sliceStateChanged || mLastBitmapVeiled
						|| firstTimeInField) {
					// here's where we completely reset STABLE and VOLATILE.
					// STABLE should be drawn as the new "stable field" - the
					// way things will
					// be after the blocks have risen. In other words, we draw
					// it completely normally
					// - we can even borrow drawStable's helper methods to do
					// so. Note that if
					// the blocks rise very far, some blocks might be pushed off
					// the top and would
					// not be visible within STABLE. That's fine! We're putting
					// them in VOLATILE.

					// VOLATILE is drawn as the new "stable field" as well,
					// except that it is drawn
					// to represent the "top portion" - everything above the top
					// row. Just in case,
					// though, we offset it by 'displayedRows - 1' so the bottom
					// row in VOLATILE
					// is "displayedRows - 1". This doesn't require any special
					// setup; just draw
					// with an offset pushing things down this far.

					// In both cases, we COMPLETELY reclip all of them (and
					// full, of course).
					for (int i = 0; i < mLastBitmap.length; i++) {
					    unionRect(mLastBitmapClipPath[i], 0, 0,
                                mLastBitmapBounds[i].width(),
                                mLastBitmapBounds[i].height(),
                                Path.Direction.CW);
                    }

					// Reset coverage
					if (inPostField) {
						this.drawPushedBlockFieldWithLastSlice_helperClipCoveredPostBlockField(
								slice, extraRows, alignmentOffset);
						this.drawPushedBlockFieldWithLastSlice_helperClipTouchedPostBlockField(
								slice, extraRows, alignmentOffset,
								extendByPixels, true);
					} else {
						this.drawPushedBlockFieldWithLastSlice_helperClipCoveredPreBlockField(
								slice, extraRows, alignmentOffset);
						this.drawPushedBlockFieldWithLastSlice_helperClipTouchedPreBlockField(
								slice, extraRows, alignmentOffset,
								extendByPixels, true);
					}
				}

				// While the blocks rise, it's important to refresh FULL. This
				// is a pretty
				// easy clip - get the blockfield difference as a region (diff
				// between current
				// height and previous height) and apply it.
				tempOffset.takeVals(alignmentOffset);
				tempOffset2.takeVals(alignmentOffset);
				tempOffset.y += pixelsOffsetFromField;
				tempOffset2.y += pixelsOffsetLastFromField;

				byte[][][] field = inPostField ? slice
						.getPushingRowsPostBlockfield() : slice
						.getPushingRowsPreBlockfield();

				this.clipConservativeDifference(mLastBitmapClipPath[BITMAP_FULL],
						field, field, extraRows, tempOffset, tempOffset2,
						extendByPixels);

				// Clip pulsing blocks.
				// Remember that Stable and Volatile represent the same field.
				reset(clipPath);
				boolean pulseQ0 = this.clipPulseFill(clipPath, field,
						Consts.QPANE_0, extraRows, alignmentOffset);
				if (pulseQ0) {
					op(mLastBitmapClipPath[BITMAP_SEPTUPLE_Q0_STABLE], clipPath, Path.Op.UNION);
					clipPath.offset(0, (mDrawSettings.displayedRows - 1)
							* mDrawSettings.size_blockHeight);
					op(mLastBitmapClipPath[BITMAP_SEPTUPLE_Q0_VOLATILE], clipPath, Path.Op.UNION);
					clipPath.offset(0, -(mDrawSettings.displayedRows - 1)
							* mDrawSettings.size_blockHeight);
					clipPath.offset(0, pixelsOffsetFromField);
					op(mLastBitmapClipPath[BITMAP_FULL], clipPath, Path.Op.UNION);
				}
				reset(clipPath);
				boolean pulseQ1 = this.clipPulseFill(clipPath, field,
						Consts.QPANE_1, extraRows, alignmentOffset);
				if (pulseQ1) {
					op(mLastBitmapClipPath[BITMAP_SEPTUPLE_Q1_STABLE], clipPath, Path.Op.UNION);
					clipPath.offset(0, (mDrawSettings.displayedRows - 1)
							* mDrawSettings.size_blockHeight);
					op(mLastBitmapClipPath[BITMAP_SEPTUPLE_Q1_VOLATILE], clipPath, Path.Op.UNION);
					clipPath.offset(0, -(mDrawSettings.displayedRows - 1)
							* mDrawSettings.size_blockHeight);
					clipPath.offset(0, pixelsOffsetFromField);
					op(mLastBitmapClipPath[BITMAP_FULL], clipPath, Path.Op.UNION);
				}
				reset(clipPath);
				boolean pulse3D = this.clipPulseFill(clipPath, field,
						Consts.QPANE_3D, extraRows, alignmentOffset);
				if (pulse3D) {
					op(mLastBitmapClipPath[BITMAP_SEPTUPLE_3D_STABLE], clipPath, Path.Op.UNION);
					clipPath.offset(0, (mDrawSettings.displayedRows - 1)
							* mDrawSettings.size_blockHeight);
					op(mLastBitmapClipPath[BITMAP_SEPTUPLE_3D_VOLATILE], clipPath, Path.Op.UNION);
					clipPath.offset(0, -(mDrawSettings.displayedRows - 1)
							* mDrawSettings.size_blockHeight);
					clipPath.offset(0, pixelsOffsetFromField);
					op(mLastBitmapClipPath[BITMAP_FULL], clipPath, Path.Op.UNION);
				}

				// no matter what, we clip the glow areas. We expect these to
				// change every tick.
				tempOffset.takeVals(alignmentOffset);
				tempOffset.y += pixelsOffsetFromField;
				int numGlows = mLastEffectsGlow.size() ;
				for (int i = 0; i < numGlows; i++) {
					GlowEffect glowEffect = mLastEffectsGlow.get(i);
					if (glowEffect.active(sliceTime)
							|| glowEffect.active(mLastSliceTime)) {
						clipGlowEffect(mLastBitmapClipPath[BITMAP_FULL],
								glowEffect, extraRows, tempOffset);
					}
				}
                // draw the entire full bitmap if the background is changing or custom
                if ((configCanvas != null && configCanvas.background != null)
                        || backgroundLayerChanged(mLastSliceTime, sliceTime)) {
                    reset(mLastBitmapClipPath[BITMAP_FULL]);
                    unionRect(mLastBitmapClipPath[BITMAP_FULL], 0, 0,
                            mLastBitmap[BITMAP_FULL].getWidth(),
                            mLastBitmap[BITMAP_FULL].getHeight(),
                            Path.Direction.CW);
                }
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_CLIP] += tock();

                // All draw and blit operations performed under this clip; restored after blitting
                for (int i = 0; i < mLastBitmapCanvas.length; i++) {
                    mLastBitmapCanvas[i].save();
                    mLastBitmapCanvas[i].clipPath(mLastBitmapClipPath[i]);
                }

				// draw
				tick();
				DrawStableFieldType type = inPostField ? DrawStableFieldType.PUSHING_POST
						: DrawStableFieldType.PUSHING_PRE;
				if (fieldChanged || sliceStateChanged || firstTimeInField
						|| pulseQ0) {
					drawStableToCanvas_withSlice(mDrawSettings, Consts.QPANE_0,
							mLastBitmapCanvas[BITMAP_SEPTUPLE_Q0_STABLE],
							alignmentOffset, slice, sliceTime,
							mConfigRangeStandard, type, null,
							BlockDrawerConfigCanvas.Background.CLEAR, 0, true);
					tempOffset.takeVals(alignmentOffset);
					tempOffset.y += (mDrawSettings.displayedRows - 1)
							* mDrawSettings.size_blockHeight;
					drawStableToCanvas_withSlice(mDrawSettings, Consts.QPANE_0,
							mLastBitmapCanvas[BITMAP_SEPTUPLE_Q0_VOLATILE],
							tempOffset, slice, sliceTime, mConfigRangeExtended,
							type, null,
							BlockDrawerConfigCanvas.Background.CLEAR, 0, false);
				}
				if (fieldChanged || sliceStateChanged || firstTimeInField
						|| pulseQ1) {
					drawStableToCanvas_withSlice(mDrawSettings, Consts.QPANE_1,
							mLastBitmapCanvas[BITMAP_SEPTUPLE_Q1_STABLE],
							alignmentOffset, slice, sliceTime,
							mConfigRangeStandard, type, null,
							BlockDrawerConfigCanvas.Background.CLEAR, 0, true);
					tempOffset.takeVals(alignmentOffset);
					tempOffset.y += (mDrawSettings.displayedRows - 1)
							* mDrawSettings.size_blockHeight;
					drawStableToCanvas_withSlice(mDrawSettings, Consts.QPANE_1,
							mLastBitmapCanvas[BITMAP_SEPTUPLE_Q1_VOLATILE],
							tempOffset, slice, sliceTime, mConfigRangeExtended,
							type, null,
							BlockDrawerConfigCanvas.Background.CLEAR, 0, false);
				}
				if (fieldChanged || sliceStateChanged || firstTimeInField
						|| pulse3D) {
					drawStableToCanvas_withSlice(mDrawSettings,
							Consts.QPANE_3D,
							mLastBitmapCanvas[BITMAP_SEPTUPLE_3D_STABLE],
							alignmentOffset, slice, sliceTime,
							mConfigRangeStandard, type, null,
							BlockDrawerConfigCanvas.Background.CLEAR, 0, true);
					tempOffset.takeVals(alignmentOffset);
					tempOffset.y += (mDrawSettings.displayedRows - 1)
							* mDrawSettings.size_blockHeight;
					drawStableToCanvas_withSlice(mDrawSettings,
							Consts.QPANE_3D,
							mLastBitmapCanvas[BITMAP_SEPTUPLE_3D_VOLATILE],
							tempOffset, slice, sliceTime, mConfigRangeExtended,
							type, null,
							BlockDrawerConfigCanvas.Background.CLEAR, 0, false);
				}
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW] += tock();

				// blit
				tick();
				// canvas translation offset?
				int volatileOffset = (mDrawSettings.displayedRows - 1)
						* mDrawSettings.size_blockHeight;
				setCanvasDestinationRect(
						mLastBitmapBlitRect[BITMAP_FULL],
						mLastBitmapBounds[BITMAP_FULL],
						mDrawSettings.configCanvas.region,
						-((int) Math.round(slice.getDisplacement()
								* mDrawSettings.size_blockHeight))
							+ mDrawSettings.displacementSafeMarginOffsetBlit);
				mLastBitmapBlitRect[BITMAP_SEPTUPLE_Q0_STABLE].set(0,
						pixelsOffsetFromField,
						mLastBitmapBounds[BITMAP_SEPTUPLE_Q0_STABLE].width(),
						mLastBitmapBounds[BITMAP_SEPTUPLE_Q0_STABLE].height()
								+ pixelsOffsetFromField);
				mLastBitmapBlitRect[BITMAP_SEPTUPLE_Q1_STABLE].set(0,
						pixelsOffsetFromField,
						mLastBitmapBounds[BITMAP_SEPTUPLE_Q1_STABLE].width(),
						mLastBitmapBounds[BITMAP_SEPTUPLE_Q1_STABLE].height()
								+ pixelsOffsetFromField);
				mLastBitmapBlitRect[BITMAP_SEPTUPLE_3D_STABLE].set(0,
						pixelsOffsetFromField,
						mLastBitmapBounds[BITMAP_SEPTUPLE_3D_STABLE].width(),
						mLastBitmapBounds[BITMAP_SEPTUPLE_3D_STABLE].height()
								+ pixelsOffsetFromField);
				mLastBitmapBlitRect[BITMAP_SEPTUPLE_Q0_VOLATILE].set(0,
						pixelsOffsetFromField - volatileOffset,
						mLastBitmapBounds[BITMAP_SEPTUPLE_Q0_VOLATILE].width(),
						mLastBitmapBounds[BITMAP_SEPTUPLE_Q0_VOLATILE].height()
								+ pixelsOffsetFromField - volatileOffset);
				mLastBitmapBlitRect[BITMAP_SEPTUPLE_Q1_VOLATILE].set(0,
						pixelsOffsetFromField - volatileOffset,
						mLastBitmapBounds[BITMAP_SEPTUPLE_Q1_VOLATILE].width(),
						mLastBitmapBounds[BITMAP_SEPTUPLE_Q1_VOLATILE].height()
								+ pixelsOffsetFromField - volatileOffset);
				mLastBitmapBlitRect[BITMAP_SEPTUPLE_3D_VOLATILE].set(0,
						pixelsOffsetFromField - volatileOffset,
						mLastBitmapBounds[BITMAP_SEPTUPLE_3D_VOLATILE].width(),
						mLastBitmapBounds[BITMAP_SEPTUPLE_3D_VOLATILE].height()
								+ pixelsOffsetFromField - volatileOffset);

				// blitting behavior differs from most other modes, in which
				// STABLE is drawn
				// first, followed by a <Covered-by-Stable> clipped version of
				// VOLATILE.
				// Here, VOLATILE is drawn first (remember that if
				// drawingPostField, VOLATILE
				// has clipped-empty content), followed by STABLE which occludes
				// it.
				//
				// Volatile layers were drawn with only and exactly their fill
				// colors, at full alpha.
				// those layers need to be blitted at the emphasis alpha.
				// This call obeys background behavior.
				septupleBlitDrawBackground(sliceTime, configCanvas);
				// Get parameters for our blit...
				int pieceType = slice.getPieceType();
				// Blit...
				tempOffset.takeVals(alignmentOffset);
				tempOffset.y += pixelsOffsetFromField;
				boolean doneGlowing = septupleBlitStableOccludes(255, 255,
						tempOffset, pieceType, sliceTime);

                // now done with internal bitmap clips; restore
                for (int i = 0; i < mLastBitmapCanvas.length; i++) {
                    mLastBitmapCanvas[i].restore();
                }

				// blit to the main canvas
				if (configCanvas == null
						|| configCanvas.equals(mDrawSettings.configCanvas)) {
					canvas.save();
					if (mDrawSettings.configCanvas.clipRegion != null)
						canvas.clipRect(mDrawSettings.configCanvas.clipRegion,
								Region.Op.INTERSECT);

					if (mDrawSettings.behavior_background == DrawSettings.BEHAVIOR_BACKGROUND_BLIT_IMAGE) {
						drawLayeredBackgroundAssets(canvas,
								mDrawSettings.configCanvas.region, sliceTime,
								mDrawSettings.configCanvas.background);
					}

					canvas.drawBitmap(mLastBitmap[BITMAP_FULL],
							mLastBitmapBounds[BITMAP_FULL],
							mLastBitmapBlitRect[BITMAP_FULL], null);
					canvas.restore();
				} else {
					tempSrcRect.set(mLastBitmapBounds[BITMAP_FULL]);
					tempSrcRect.bottom = tempSrcRect.top + mDrawSettings.height;
					drawBitmapToCanvasWithConfig(canvas,
							mLastBitmap[BITMAP_FULL], tempSrcRect, slice,
							configCanvas, null);
				}

				// timer
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_BLIT] += tock();

				break;

			case DrawSettings.BLIT_FULL:
				// determine the offsets
				canvasTranslationOffset.x = 0;
				canvasTranslationOffset.y = 0;
				setAlignmentOffset(inPostField ? slice.getBlockfieldStable()
						: slice.getPushingRowsPreBlockfield(), alignmentOffset);
				alignmentOffsetSet = true;
				if (doubleBitmapOffset)
					alignmentOffset.y += height;

				tempOffset.takeVals(alignmentOffset);
				if (!fieldChanged && !sliceStateChanged)
					tempOffset.y += mLastBitmapRisingBlockfield_drawHeightOffset;

				// we offset by the draw height
				alignmentOffset.y += drawHeightOffset;

				// clip
				tick();
				reset(clipPath);
				if (fieldChanged
						|| (mBackgroundBitmapClipOrBlitIsBlitting != risingBlit)
						|| mLastBitmapVeiled || firstTimeInField
						|| configCanvas != null || backgroundChanged) {
					// HACK HACK HACK:
					// This call is necessary because we haven't implemented an
					// "efficient" version for other
					// draw methods yet. Note that piece borders can very easily
					// change without the actual
					// value at a location changing.
					// NOTE ALSO: we have set our clip to the full dimensions of
					// the bitmap, so we can draw
					// the entire rising area (now just the bottom part).
					if (doubleBitmapOffset) {
						// visual bug: content at the top of the image, resembling
						// the bottom (?), appears when new rows are pushing in.
						// We clear additional space above, just in case.
						float rowsDisplayedAbove = slice.getNumGarbageRowsAdded() ;
						rowsDisplayedAbove = Math.max( rowsDisplayedAbove, slice.getNumNonGarbageRowsAdded() ) ;
						rowsDisplayedAbove = Math.max( rowsDisplayedAbove, slice.getNumRowsAddedByPush() ) ;
						rowsDisplayedAbove = Math.max( rowsDisplayedAbove, slice.getNumRowsAddedByTransfer() ) ;
						rowsDisplayedAbove = Math.max( rowsDisplayedAbove, slice.getNumRowsPushedDown() ) ;
						rowsDisplayedAbove = Math.max( rowsDisplayedAbove, slice.getNumRowsPushedUp() ) ;
						rowsDisplayedAbove = Math.max( rowsDisplayedAbove, 0 ) ;
						rowsDisplayedAbove += animationSettings == null ? 0 : animationSettings.rowPushIn_overExtend ;
						unionRect(clipPath, 0,
                                (float)Math.floor( height - rowsDisplayedAbove * mDrawSettings.size_blockHeight ),
                                mLastBitmapBounds[BITMAP_FULL].width(),
                                height * 2,
                                Path.Direction.CW);
					} else {
						// clip with extra space below, so we have room to draw
						// displacement rows.
						float extra = mDrawSettings.getBehaviorIs_displacement()
								? mDrawSettings.size_blockHeight * 3
								: 0 ;
						unionRect(clipPath, 0, 0,
                                mLastBitmapBounds[BITMAP_FULL].width(),
                                mLastBitmapBounds[BITMAP_FULL].height() + extra,
                                Path.Direction.CW);
					}
				}
				// no matter what, we clip the glow areas. We expect these to
				// change every tick.
				numGlows = mLastEffectsGlow.size() ;
				for (int i = 0; i < numGlows; i++) {
					GlowEffect glowEffect = mLastEffectsGlow.get(i);
					if (glowEffect.active(sliceTime)
							|| glowEffect.active(mLastSliceTime)) {
						clipGlowEffect(clipPath, glowEffect, extraRows, alignmentOffset);
					}
				}

				field = inPostField ? slice.getPushingRowsPostBlockfield()
						: slice.getPushingRowsPreBlockfield();
				// Clip "pulse" behavior pieces.
				if (animationSettings != null) {
					clipPulseFill(clipPath, field, extraRows, alignmentOffset);
				}
				// If not rising the blit, we are rising our draw alignment. Our
				// clip is
				// much more complicated.
				if (!risingBlit) {
					// first, reclip the previous clips using the previous
					// offset.
					numGlows = mLastEffectsGlow.size() ;
					for (int i = 0; i < numGlows; i++) {
						GlowEffect glowEffect = mLastEffectsGlow.get(i);
						if (glowEffect.active(sliceTime)
								|| glowEffect.active(mLastSliceTime)) {
							clipGlowEffect(clipPath, glowEffect, extraRows, tempOffset);
						}
					}
					// Clip "pulse" behavior pieces.
					if (animationSettings != null) {
						clipPulseFill(clipPath, field, extraRows, tempOffset);
					}

					// clip block differences.
					clipConservativeDifference(clipPath,
							field, field, extraRows, alignmentOffset,
							tempOffset, extendByPixels);
				}

				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_CLIP] += tock();

				if (GlobalTestSettings.BLOCK_DRAWER_SHOW_COVERED_AND_TOUCHING_REGIONS) {
				    reset(clipPath);
				    unionRect(clipPath, 0, 0,
                            Integer.MAX_VALUE, Integer.MAX_VALUE,
                            Path.Direction.CW);
                }

				// draw
				tick();
				canvas.save();
				canvas.clipPath(clipPath);
				BlockDrawerConfigCanvas.Background backgroundDefault = mDrawSettings
						.getBehaviorIs_backgroundBlit() ? BlockDrawerConfigCanvas.Background.CLEAR
						: BlockDrawerConfigCanvas.Background.DEFAULT;
				drawPushingBlockfieldToCanvas_withSlice(
						mDrawSettings,
						mLastBitmapCanvas[BITMAP_FULL],
						alignmentOffset,
						slice,
						sliceTime,
						inPostField,
						mBackgroundBitmapOffset,
						(configCanvas != null && !risingBlit) ? configCanvas.background
								: (risingBlit ? BlockDrawerConfigCanvas.Background.CLEAR
										: backgroundDefault), 0, true);
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW] += tock();

				if (GlobalTestSettings.BLOCK_DRAWER_SHOW_COVERED_AND_TOUCHING_REGIONS)
					drawTouchedCoveredTestToCanvas(mLastBitmapCanvas[BITMAP_FULL]);

				canvas.restore();

				// blit
				tick();
				if (mDrawSettings.getBehaviorIs_displacement()) {
					setCanvasDestinationRect(
							mLastBitmapBlitRect[BITMAP_FULL],
							mLastBitmapBounds[BITMAP_FULL],
							mDrawSettings.configCanvas.region,
							-((int) Math.round(slice.getDisplacement()
									* mDrawSettings.size_blockHeight))
								+ mDrawSettings.displacementSafeMarginOffsetBlit);
				} else {
					mLastBitmapBlitRect[BITMAP_FULL].set(
							mDrawSettings.configCanvas.region.left,
							mDrawSettings.configCanvas.region.top
									- (doubleBitmapOffset ? blitHeight : 0),
							mDrawSettings.configCanvas.region.right,
							mDrawSettings.configCanvas.region.top + blitHeight);
					mLastBitmapBlitRect[BITMAP_FULL]
							.offset(0, blitHeightOffset);
				}

				if (configCanvas == null
						|| configCanvas.equals(mDrawSettings.configCanvas)) {
					canvas.save();
					if (mDrawSettings.configCanvas.clipRegion != null)
						canvas.clipRect(mDrawSettings.configCanvas.clipRegion,
								Region.Op.INTERSECT);

					if ((mDrawSettings.behavior_background == DrawSettings.BEHAVIOR_BACKGROUND_CLIP_OR_BLIT_IMAGE && risingBlit)
							|| (mDrawSettings.getBehaviorIs_backgroundBlit())) {
						drawLayeredBackgroundAssets(canvas,
								mDrawSettings.configCanvas.region, sliceTime,
								mDrawSettings.configCanvas.background);
					}

					canvas.drawBitmap(mLastBitmap[BITMAP_FULL],
							mLastBitmapBounds[BITMAP_FULL],
							mLastBitmapBlitRect[BITMAP_FULL], blitPaint);
					canvas.restore();
				} else {
					// our content is available in mLastBitmap. However,
					// depending on
					// our background settings and config canvas settings, this
					// might fail.
					// throw an exception so we know this is unacceptable.
					tempSrcRect.set(mLastBitmapBounds[BITMAP_FULL]);
					tempSrcRect.bottom = tempSrcRect.top + height;
					if (doubleBitmapOffset)
						tempSrcRect.offset(0, height);
					drawBitmapToCanvasWithConfig(canvas,
							mLastBitmap[BITMAP_FULL], tempSrcRect, slice,
							configCanvas, blitPaint);
				}
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_BLIT] += tock();

				// finished
				break;

			case DrawSettings.BLIT_NONE:
				// set offsets
				setCanvasTranslationOffset(canvas);
				setAlignmentOffset(slice.getBlockfieldStable(), alignmentOffset);
				int displacement = 0;
				if (mDrawSettings.getBehaviorIs_displacement()) {
					displacement = -((int) Math.round(slice.getDisplacement()
							* mDrawSettings.size_blockHeight));
					alignmentOffset.y += displacement;
				}
				alignmentOffsetSet = true;
				alignmentOffset.y += blitHeightOffset + drawHeightOffset;

				// We assume clip has been set for us

				// TRANSLATE DOWN OR UP W/ THE FIELD
				this.mLastBitmapCoveredPath[BITMAP_REGION_FULL_STABLE]
						.offset(0, blitHeightOffset + drawHeightOffset);
				this.mLastBitmapTouchedPath[BITMAP_REGION_FULL_STABLE]
						.offset(0, blitHeightOffset + drawHeightOffset);

				// draw
				tick();
				canvas.save();
				if (mDrawSettings.configCanvas.clipRegion != null)
					canvas.clipRect(mDrawSettings.configCanvas.clipRegion,
							Region.Op.INTERSECT);
				drawPushingBlockfieldToCanvas_withSlice(mDrawSettings, canvas,
						alignmentOffset, slice, sliceTime, inPostField,
						mBackgroundBitmapOffset,
						BlockDrawerConfigCanvas.Background.DEFAULT,
						displacement, true);
				mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW] += tock();

				if (GlobalTestSettings.BLOCK_DRAWER_SHOW_COVERED_AND_TOUCHING_REGIONS)
					drawTouchedCoveredTestToCanvas(canvas);

				canvas.restore();

				// UNTRANSLATE DOWN OR UP W/ THE FIELD
				this.mLastBitmapCoveredPath[BITMAP_REGION_FULL_STABLE]
						.offset(0, -blitHeightOffset - drawHeightOffset);
				this.mLastBitmapTouchedPath[BITMAP_REGION_FULL_STABLE]
						.offset(0, -blitHeightOffset - drawHeightOffset);

				// no need to blit
				break;

			default:
				throw new IllegalStateException("Blit setting "
						+ mDrawSettings.getBlit() + " confuses and infuriates us");
			}

			mLastBitmapVeiled = false;
		}

		// //////////////////////////////////////////////////////////////////////
		// VEIL INSTRUCTIONS: At this point, mLastBitmap[BITMAP_FULL] is the
		// content to be drawn under the veil. Draw the veil over it.

		if (veilOnScreen(sliceTime)
				&& (configCanvas == null || configCanvas
						.equals(mDrawSettings.configCanvas))) {
			drawBitmapFullVeiledToCanvas(canvas, sliceTime,
					sliceStateChanged || fieldChanged || !mLastBitmapVeiled
							|| !sliceTime.hasBeenDrawnAtThisSliceTime());
			// only force a redraw if content changed, otherwise use our cached
			// veil.
			mLastBitmapVeiled = true;
		}

		// We have drawn to mLastBitmap[BITMAP_FULL]. Copy the slice and blit.
		if (fieldChanged)
			mLastSlice.takeVals(slice);

		// stable if there are no glows or we have finished animating them, AND
		// we are at heightOffset of zero.
		mNextSliceNeedsExplicitConfigCanvas = false;
		mNextSliceBreaksSequence = false;
		mNextSlicePossiblyInconsistent = false;
		// HACK: we are stable if we are done animating OR there is nothing to
		// animate
		// (and we have reached the top).
		mLastBitmapIsStableSlice = true ;
		if ( slice.getNumRowsPushedDown() >= 0
					|| slice.getNumRowsPushedUp() > 0 ) {
			// a push animation.
			// We have tried advancing early, when the rows have risen and only
			// glows
			// remain. However, that interacts poorly with veiling, so we now play
			// out the animation fully.
			mLastBitmapIsStableSlice = (animationSettings.lockGlowFinished(0, 1, 0,
					sliceTime.getSlice() - timeInPreField) || mLastEffectsGlow.size() == 0)
				&& blitHeightOffset == 0
				&& drawHeightOffset == 0
				&& pixelsOffsetFromField == 0 && inPostField;
			mLastBitmapIsStableSliceIgnoringEffects =
					blitHeightOffset == 0
					&& drawHeightOffset == 0
					&& pixelsOffsetFromField == 0 && inPostField;
			mLastBitmapIsStableSliceReadyToAdvanceEffects = mLastBitmapIsStableSlice ;
			//log("pushing in draw (has push) ReadyToAdvanceEffects is " + mLastBitmapIsStableSliceReadyToAdvanceEffects) ;
		} else {
			// only enter animations.
			mLastBitmapIsStableSlice = (animationSettings.enterGlowFinished(0, 1, 0,
					sliceTime.getSlice() - timeInPreField) || mLastEffectsGlow.size() == 0) ;
			mLastBitmapIsStableSliceIgnoringEffects = true ;
			mLastBitmapIsStableSliceReadyToAdvanceEffects = inPostField ;
			//log("pushing in draw (no push) ReadyToAdvanceEffects is " + mLastBitmapIsStableSliceReadyToAdvanceEffects) ;
		}

		mLastBitmapRisingBlockfield_drawHeightOffset = drawHeightOffset;

		mBackgroundBitmapClipOrBlitIsBlitting = risingBlit;

		mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_TOTAL] += tock();
		mProfileMillisSpent[mProfileBehavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_NUMBER]++;

		// SOUNDS!
		playSounds(sliceTime, pool);

		sliceTime.setLastDrawn();
		clearExpiredEffects(sliceTime);

		if (mLastSliceTime != null && sliceTime != null)
			mLastSliceTime.takeVals(sliceTime);
	}
	
	
	private void drawPushedBlockFieldWithLastSlice_helperAddRowPushSoundEffects(
			GameBlocksSlice slice, BlockDrawerSliceTime.RelativeTo relativeTo,
			long startAt ) {
		// add sound effects: if garbage rows were added, add the garbage sound effect.
		if ( slice.getNumGarbageRowsAdded() != 0 ) {
			mLastEffectsSound.addGarbageRows(
					relativeTo, startAt, slice.getNumGarbageRowsAdded()) ;
		}
		// if there are rows pushed down, or rows pushed up that are not == garbage, add
		// a pushing sound effect.
		if ( slice.getNumRowsPushedDown() >= 0 || slice.getNumRowsPushedUp() != slice.getNumGarbageRowsAdded() ) {
			mLastEffectsSound.addAddRows(
					relativeTo, startAt,
					slice.getNumRowsAddedByPush() - slice.getNumGarbageRowsAdded());
		}
	}
	

	private void drawPushedBlockFieldWithLastSlice_helperClipCoveredPreBlockField(
			GameBlocksSlice slice, int extraRows, Offset offset) {

		if (mDrawSettings.getBlit() == DrawSettings.BLIT_SEPTUPLE) {
			tempOffset2.takeVals(offset);
			tempOffset2.y += (mDrawSettings.displayedRows - 1)
					* mDrawSettings.size_blockHeight;

			drawPushedBlockFieldWithLastSlice_helperClipCovered(true,
					slice.getPushingRowsPreBlockfield(), 0, offset);

			drawPushedBlockFieldWithLastSlice_helperClipCovered(false,
					slice.getPushingRowsPreBlockfield(), extraRows, tempOffset2);
		} else {
			// Blit using everything in STABLE.
			drawPushedBlockFieldWithLastSlice_helperClipCovered(true,
					slice.getPushingRowsPreBlockfield(), extraRows, offset);
		}
	}

	private void drawPushedBlockFieldWithLastSlice_helperClipCoveredPostBlockField(
			GameBlocksSlice slice, int extraRows, Offset offset) {

		if (mDrawSettings.getBlit() == DrawSettings.BLIT_SEPTUPLE) {
			tempOffset2.takeVals(offset);
			tempOffset2.y += (mDrawSettings.displayedRows - 1)
					* mDrawSettings.size_blockHeight;

			drawPushedBlockFieldWithLastSlice_helperClipCovered(true,
					slice.getPushingRowsPostBlockfield(), 0, offset);

			drawPushedBlockFieldWithLastSlice_helperClipCovered(false,
					slice.getPushingRowsPostBlockfield(), extraRows,
					tempOffset2);
		} else {
			// Blit everything in STABLE
			drawPushedBlockFieldWithLastSlice_helperClipCovered(true,
					slice.getPushingRowsPostBlockfield(), extraRows, offset);
		}
	}

	private void drawPushedBlockFieldWithLastSlice_helperClipCovered(
			boolean stable, byte[][][] field, int extraRows, Offset offset) {
		int bitmapQ0 = stable ? BITMAP_REGION_Q0_STABLE
				: BITMAP_REGION_Q0_VOLATILE;
		int bitmapQ1 = stable ? BITMAP_REGION_Q1_STABLE
				: BITMAP_REGION_Q1_VOLATILE;
		int bitmap3D = stable ? BITMAP_REGION_3D_STABLE
				: BITMAP_REGION_3D_VOLATILE;

		emptyWithOutOfBounds(mLastBitmapCoveredPath[bitmapQ0]);
		emptyWithOutOfBounds(mLastBitmapCoveredPath[bitmapQ1]);
		emptyWithOutOfBounds(mLastBitmapCoveredPath[bitmap3D]);

		clipCoveredPath(mLastBitmapCoveredPath[bitmapQ0], field,
				Consts.QPANE_0, extraRows, offset);
		clipCoveredPath(mLastBitmapCoveredPath[bitmapQ1], field,
				Consts.QPANE_1, extraRows, offset);
		clipCoveredPath(mLastBitmapCoveredPath[bitmap3D], field,
				Consts.QPANE_3D, extraRows, offset);

		if (mDrawSettings.getBlit() == DrawSettings.BLIT_SEPTUPLE) {
			// BTW, we don't want the covered area to extend beyond the bounds
			// of the image; it will prevent the drawing of blocks above.
            reset(tempPath);
            unionRect(tempPath, 0, 0,
                    mLastBitmapBounds[bitmapQ0].width(),
                    mLastBitmapBounds[bitmapQ0].height(),
                    Path.Direction.CW);
            op(mLastBitmapCoveredPath[bitmapQ0], tempPath, Path.Op.INTERSECT);

            reset(tempPath);
            unionRect(tempPath, 0, 0,
                    mLastBitmapBounds[bitmapQ1].width(),
                    mLastBitmapBounds[bitmapQ1].height(),
                    Path.Direction.CW);
            op(mLastBitmapCoveredPath[bitmapQ1], tempPath, Path.Op.INTERSECT);

            reset(tempPath);
            unionRect(tempPath, 0, 0,
                    mLastBitmapBounds[bitmap3D].width(),
                    mLastBitmapBounds[bitmap3D].height(),
                    Path.Direction.CW);
            op(mLastBitmapCoveredPath[bitmap3D], tempPath, Path.Op.INTERSECT);
		}
	}

	private void drawPushedBlockFieldWithLastSlice_helperClipTouchedPreBlockField(
			GameBlocksSlice slice, int extraRows, Offset offset,
			int extendByPixels, boolean includeDisplacementRowsIfAvailable) {

		mConfigRangeExtended.set(mConfigRangeStandard.rowFirst,
				mConfigRangeStandard.rowBound + extraRows,
				mConfigRangeStandard.columnFirst,
				mConfigRangeStandard.columnBound);

		if (mDrawSettings.getBlit() == DrawSettings.BLIT_SEPTUPLE) {
			emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q0_STABLE]);
			emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q1_STABLE]);
			emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_3D_STABLE]);
			emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q0_VOLATILE]);
			emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q1_VOLATILE]);
			emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_3D_VOLATILE]);

			tempOffset2.takeVals(offset);
			tempOffset2.y += (mDrawSettings.displayedRows - 1)
					* mDrawSettings.size_blockHeight;

			drawRisingBlockFieldWithLastSlice_helperClipTouched(true,
					slice.getPushingRowsPreBlockfield(), mConfigRangeStandard,
					offset, extendByPixels, true);

			drawRisingBlockFieldWithLastSlice_helperClipTouched(false,
					slice.getPushingRowsPreBlockfield(), mConfigRangeExtended,
					tempOffset2, extendByPixels, false);
		} else {
			emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q0_STABLE]);
			emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q1_STABLE]);
			emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_3D_STABLE]);
			// clip everything to STABLE
			drawRisingBlockFieldWithLastSlice_helperClipTouched(true,
					slice.getPushingRowsPreBlockfield(), mConfigRangeExtended,
					offset, extendByPixels, true);
		}

		if (includeDisplacementRowsIfAvailable
				&& mDrawSettings.getBehaviorIs_displacement()) {
			clipDisplacementOffset.takeVals(offset);
			clipDisplacementOffset.offsetXY(0, mDrawSettings.ROWS
					* mDrawSettings.size_blockHeight);
			drawRisingBlockFieldWithLastSlice_helperClipTouched(true,
					slice.getDisplacementBlockfield(), mConfigRangeDisplaced,
					clipDisplacementOffset, extendByPixels, false);
		}
	}

	private void drawPushedBlockFieldWithLastSlice_helperClipTouchedPostBlockField(
			GameBlocksSlice slice, int extraRows, Offset offset,
			int extendByPixels, boolean includeDisplacementRowsIfAvailable) {

		mConfigRangeExtended.set(mConfigRangeStandard.rowFirst,
				mConfigRangeStandard.rowBound + extraRows,
				mConfigRangeStandard.columnFirst,
				mConfigRangeStandard.columnBound);

		if (mDrawSettings.getBlit() == DrawSettings.BLIT_SEPTUPLE) {
			emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q0_STABLE]);
			emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q1_STABLE]);
			emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_3D_STABLE]);
			emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q0_VOLATILE]);
			emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q1_VOLATILE]);
			emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_3D_VOLATILE]);

			tempOffset2.takeVals(offset);
			tempOffset2.y += (mDrawSettings.displayedRows - 1)
					* mDrawSettings.size_blockHeight;

			drawRisingBlockFieldWithLastSlice_helperClipTouched(true,
					slice.getPushingRowsPostBlockfield(), mConfigRangeStandard,
					offset, extendByPixels, true);

			drawRisingBlockFieldWithLastSlice_helperClipTouched(false,
					slice.getPushingRowsPostBlockfield(), mConfigRangeExtended,
					tempOffset2, extendByPixels, false);
		} else {
			emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q0_STABLE]);
			emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_Q1_STABLE]);
			emptyWithOutOfBounds(mLastBitmapTouchedPath[BITMAP_REGION_3D_STABLE]);
			// clip everything to STABLE
			drawRisingBlockFieldWithLastSlice_helperClipTouched(true,
					slice.getPushingRowsPostBlockfield(), mConfigRangeExtended,
					offset, extendByPixels, true);
		}

		if (includeDisplacementRowsIfAvailable
				&& mDrawSettings.getBehaviorIs_displacement()) {
			clipDisplacementOffset.takeVals(offset);
			clipDisplacementOffset.offsetXY(0, mDrawSettings.ROWS
					* mDrawSettings.size_blockHeight);
			drawRisingBlockFieldWithLastSlice_helperClipTouched(true,
					slice.getDisplacementBlockfield(), mConfigRangeDisplaced,
					clipDisplacementOffset, extendByPixels, false);
		}
	}

	private void drawRisingBlockFieldWithLastSlice_helperClipTouched(
			boolean stable, byte[][][] field,
			BlockDrawerConfigRange configRange, Offset offset,
			int extendByPixels, boolean includeRowNegativeOne) {

		int bitmapQ0 = stable ? BITMAP_REGION_Q0_STABLE
				: BITMAP_REGION_Q0_VOLATILE;
		int bitmapQ1 = stable ? BITMAP_REGION_Q1_STABLE
				: BITMAP_REGION_Q1_VOLATILE;
		int bitmap3D = stable ? BITMAP_REGION_3D_STABLE
				: BITMAP_REGION_3D_VOLATILE;

		clipTouchedPath(mLastBitmapTouchedPath[bitmapQ0], field,
				configRange, Consts.QPANE_0, offset, extendByPixels);
		clipTouchedPath(mLastBitmapTouchedPath[bitmapQ1], field,
				configRange, Consts.QPANE_1, offset, extendByPixels);
		clipTouchedPath(mLastBitmapTouchedPath[bitmap3D], field,
				configRange, Consts.QPANE_3D, offset, extendByPixels);

		// clip row -1
		if (includeRowNegativeOne) {
			clipFullWidthRowNegativeOne(mLastBitmapTouchedPath[bitmapQ0], 0,
					mDrawSettings.width, Consts.QPANE_0, offset, extendByPixels);
			clipFullWidthRowNegativeOne(mLastBitmapTouchedPath[bitmapQ1], 0,
					mDrawSettings.width, Consts.QPANE_1, offset, extendByPixels);
		}
	}

	private void drawPushingBlockfieldToCanvas_withSlice(
			DrawSettings drawSettings, Canvas canvas, Offset offset,
			GameBlocksSlice slice, BlockDrawerSliceTime sliceTime,
			boolean inPostField, Offset offsetBackground,
			BlockDrawerConfigCanvas.Background configCanvasBackground,
			int blockCoveredYOffset, boolean includeDisplacementRowsIfAvailable) {

		long currentTime = sliceTime.getUnpaused();

		float alphaScale_fillPulse = animationSettings == null ? 0
				: animationSettings.pulseAlpha(
						drawSettings.alphaScale_lockedFillPulse, currentTime);
		float alphaScale_boxPulse = animationSettings == null ? 0
				: animationSettings.pulseAlpha(
						drawSettings.alphaScale_lockedBoxPulse, currentTime);

		int extraRows = Math.min(
				Math.max(slice.getNumRowsPushedDown(),
						slice.getNumRowsPushedUp()), drawSettings.ROWS
						- drawSettings.displayedRows);
		BlockDrawerConfigRange configRange = tempConfigRange;
		configRange.set(drawSettings.displayedRows + extraRows,
				drawSettings.COLS);

		byte[][][] field;
		int field_index;
		if (inPostField) {
			field = slice.getPushingRowsPostBlockfield();
			field_index = INDEX_FIELD_PUSHING;
		} else {
			field = slice.getPushingRowsPreBlockfield();
			field_index = INDEX_FIELD_PUSHING_PRE;
		}

		byte[][][][] corners = mLastCorners_byField_byPaneCorner
				.get(field_index);
		short[][][] shadows = mLastFillShadowSets_byField_byPane
				.get(field_index);
		short[][][][] drop = mLastDropShadowSets_byField_byPane_byUniqueColor
				.get(field_index);

		byte[][][][] qo_corners = mLastQOConnectedCorners_byField_byPaneCorner
				.get(field_index);
		short[][][] qo_sets = mLastQOConnectedSets_byField_byPane
				.get(field_index);
		
		byte[][][][] displacement_corners = mLastCorners_byField_byPaneCorner.get(INDEX_FIELD_DISPLACEMENT) ;

		int pieceType = slice.getPieceType();

		// draw background
		// draw background: happens in 2 different steps. If we draw 'all,' we
		// fill
		// now. Otherwise, if BLOCK_FILL, we draw twice - first to set the
		// background
		// color, second to draw the fills themselves.
		fullBlitDrawBackground(drawSettings, canvas, offsetBackground,
				sliceTime, configCanvasBackground, 255, 255,
				blockCoveredYOffset);

		// set canvas translation
		canvasTranslationOffset.x = canvasTranslationOffset.y = 0;

		if (includeDisplacementRowsIfAvailable
				&& drawSettings.getBehaviorIs_displacement()) {
			drawDisplacementOffset.takeVals(offset);
			drawDisplacementOffset.offsetXY(0,
					drawSettings.ROWS * drawSettings.size_blockHeight);
		}

		// draw to last bitmap canvas
		if (drawSettings.drawQ1) {
			// PANE 1: displacement.
			if (includeDisplacementRowsIfAvailable
					&& drawSettings.getBehaviorIs_displacement()) {
				drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
						(drawSettings.alpha_displacementBorder > 0 ? STYLE_FILL_AND_BORDER : STYLE_FILL),
						canvas, slice.getDisplacementBlockfield(),
						mConfigRangeDisplaced, Consts.QPANE_1, pieceType,
						drawDisplacementOffset,
						drawSettings.alpha_displacementFill, 0, 0, 0, drawSettings.alpha_displacementBorder, 0, 0,
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_TL],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_TR],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_BL],
						displacement_corners[Consts.QPANE_1][INDEX_CORNER_BR],
						null, null, sliceTime,
						GlowEffect.TYPE_NONE, true, null);
			}
			// PANE 1: draw row neg 1
			if (drawSettings.behavior_border == DrawSettings.BEHAVIOR_BORDER_ROW_NEGATIVE_ONE)
				drawRowNegativeOneToCanvas(drawSettings, canvas,
						Consts.QPANE_1,
						drawSettings.alpha_rowNegativeOneBorder, offset);
			// PANE 1: field and glows
			// field...
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, field,
					configRange, Consts.QPANE_1, pieceType, offset, -1,
					drawSettings.alpha_lockedFill, alphaScale_fillPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					corners[Consts.QPANE_1][INDEX_CORNER_TL],
					corners[Consts.QPANE_1][INDEX_CORNER_TR],
					corners[Consts.QPANE_1][INDEX_CORNER_BL],
					corners[Consts.QPANE_1][INDEX_CORNER_BR],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_TL],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_TR],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_BL],
					qo_corners[Consts.QPANE_1][INDEX_CORNER_BR],
					shadows[Consts.QPANE_1], drop[Consts.QPANE_1],
					qo_sets[Consts.QPANE_1], sliceTime, GlowEffect.TYPE_NONE,
					null, FadeEffect.TYPE_NONE, null);

			// lock glows...
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, null,
					configRange, Consts.QPANE_1, pieceType, offset, -1, 255,
					255, 255, 255, null, null, null, null, null, null, null,
					null, null, null, null, sliceTime, GlowEffect.TYPE_ANY,
					mLastEffectsGlow, FadeEffect.TYPE_NONE, null);

		}

		if (drawSettings.draw3D) {
			// PANE 3D: draw the field
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, field,
					configRange, Consts.QPANE_3D, pieceType, offset, -1,
					drawSettings.alpha_lockedFill, alphaScale_boxPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					corners[Consts.QPANE_0][INDEX_CORNER_TL],
					corners[Consts.QPANE_0][INDEX_CORNER_TR],
					corners[Consts.QPANE_0][INDEX_CORNER_BL],
					corners[Consts.QPANE_0][INDEX_CORNER_BR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BR], null, null,
					qo_sets[Consts.QPANE_0], sliceTime, GlowEffect.TYPE_NONE,
					null, FadeEffect.TYPE_NONE, null);
		}

		// draw to last bitmap canvas
		if (drawSettings.drawQ0) {
			// PANE 1: displacement.
			if (includeDisplacementRowsIfAvailable
					&& drawSettings.getBehaviorIs_displacement()) {
				drawBlockFieldQPane2DAtAlignmentOffset(drawSettings,
						(drawSettings.alpha_displacementBorder > 0 ? STYLE_FILL_AND_BORDER : STYLE_FILL),
						canvas, slice.getDisplacementBlockfield(),
						mConfigRangeDisplaced, Consts.QPANE_0, pieceType,
						drawDisplacementOffset,
						drawSettings.alpha_displacementFill, 0, 0, 0, drawSettings.alpha_displacementBorder, 0, 0,
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_TL],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_TR],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_BL],
						displacement_corners[Consts.QPANE_0][INDEX_CORNER_BR],
						null, null, sliceTime,
						GlowEffect.TYPE_NONE, true, null);
			}
			// PANE 0: draw row neg 1
			if (drawSettings.behavior_border == DrawSettings.BEHAVIOR_BORDER_ROW_NEGATIVE_ONE)
				drawRowNegativeOneToCanvas(drawSettings, canvas,
						Consts.QPANE_0,
						drawSettings.alpha_rowNegativeOneBorder, offset);
			// PANE 0: field and glows
			// field...
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, field,
					configRange, Consts.QPANE_0, pieceType, offset, -1,
					drawSettings.alpha_lockedFill, alphaScale_fillPulse,
					drawSettings.alpha_lockedTop,
					drawSettings.alpha_lockedBorder,
					corners[Consts.QPANE_0][INDEX_CORNER_TL],
					corners[Consts.QPANE_0][INDEX_CORNER_TR],
					corners[Consts.QPANE_0][INDEX_CORNER_BL],
					corners[Consts.QPANE_0][INDEX_CORNER_BR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_TR],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BL],
					qo_corners[Consts.QPANE_0][INDEX_CORNER_BR],
					shadows[Consts.QPANE_0], drop[Consts.QPANE_0],
					qo_sets[Consts.QPANE_0], sliceTime, GlowEffect.TYPE_NONE,
					null, FadeEffect.TYPE_NONE, null);

			// lock glows...
			drawBlockFieldQPaneAtAlignmentOffset(drawSettings, canvas, null,
					configRange, Consts.QPANE_0, pieceType, offset, -1, 255,
					255, 255, 255, null, null, null, null, null, null, null,
					null, null, null, null, sliceTime, GlowEffect.TYPE_ANY,
					mLastEffectsGlow, FadeEffect.TYPE_NONE, null);

		}
	}

	private int heightAvailableToRise(byte[][][] field, byte[][][] chunk,
			int chunkHeight, int extraRows) {
		int R = Math.min(mDrawSettings.displayedRows + extraRows - chunkHeight,
				chunk[0].length - mDrawSettings.blockFieldOuterBuffer);
		int R2 = Math.min(mDrawSettings.displayedRows, field[0].length
				- mDrawSettings.blockFieldOuterBuffer - chunkHeight);
		int maxHeight = Integer.MAX_VALUE;
		for (int qp = 0; qp < 2; qp++) {
			for (int row = 0; row < R; row++) {
				int r = row + mDrawSettings.blockFieldOuterBuffer;
				for (int col = 0; col < mDrawSettings.COLS; col++) {
					int c = col + mDrawSettings.blockFieldOuterBuffer;
					if (chunk[qp][r][c] != QOrientations.NO) {
						// see how much room we have. Rise until 1. it hits a
						// block
						// in the same QOrientation, or 2. it hits a block in
						// the other
						// QOrientations AFTER empty space.
						boolean oppositeEmpty = false;
						for (int row2 = row; row2 < R2; row2++) {
							int r2 = row2 + mDrawSettings.blockFieldOuterBuffer
									+ chunkHeight;
							if (field[(qp + 1) % 2][r2][c] == QOrientations.NO)
								oppositeEmpty = true;
							if (field[qp][r2][c] != QOrientations.NO
									|| (oppositeEmpty && field[(qp + 1) % 2][r2][c] != QOrientations.NO)) {
								maxHeight = Math.max(
										0,
										Math.min(maxHeight, row2 - row - 1
												- chunkHeight));
								break;
							}
						}
					}
				}
			}
		}
		return maxHeight;
	}

	/**
	 * Iterates through mLastSoundEffects, playing every sound effect which:
	 * 
	 * 1. Has started since the last time this slice was drawn, AND 2. Has not
	 * expired (we have not yet reached the ending-time).
	 * 
	 * Because SoundEffects are played exactly once (compare against
	 * GlowEffects, drawn every frame), their "duration" serves as less of an
	 * actual effect duration, and more of a window in which it is appropriate
	 * to trigger the sound effects.
	 * 
	 * Effects which have not yet been played, but whose 'duration' has expired,
	 * should NOT be played since the associated event and/or animation is
	 * already too far in the past for the sound to make an sense to the player.
	 * 
	 * @param sliceTime
	 * @param pool
	 */
	private void playSounds(BlockDrawerSliceTime sliceTime,
			QuantroSoundPool pool) {
		if (mLastEffectsSound != null && pool != null) {
			int numSounds = mLastEffectsSound.size() ;
			for (int i = 0; i < numSounds; i++) {
				SoundEffect se = mLastEffectsSound.get(i);
				if (se.startedSinceLastDraw(sliceTime)
						&& se.timeSinceEnded(sliceTime) <= 0)
					se.play(pool);
			}
		}
	}

	/**
	 * Clears all effects in our Last*Effects lists.
	 */
	private void clearEffects() {
		if (mLastEffectsGlow != null)
			mLastEffectsGlow.clear();
		if (mLastEffectsSound != null)
			mLastEffectsSound.clear();
		if (mLastEffectsFade != null)
			mLastEffectsFade.clear();
	}

	/**
	 * Clears all expired effects in our Last*Effects lists.
	 * 
	 * @param sliceTime
	 */
	private void clearExpiredEffects(BlockDrawerSliceTime sliceTime) {
		// Glow those glow effects which have expired
		if (mLastEffectsGlow != null)
			mLastEffectsGlow.clearExpired(sliceTime);
		// clear those sound effects which have been played.
		if (mLastEffectsSound != null)
			mLastEffectsSound.clearStarted(sliceTime);
		if (mLastEffectsFade != null)
			mLastEffectsFade.clearExpired(sliceTime);
	}

	private void convertEffectsToUnpausedRelative(BlockDrawerSliceTime sliceTime) {
		if (mLastEffectsGlow != null)
			mLastEffectsGlow.convertStartTimeToUnpausedRelative(sliceTime);
		if (mLastEffectsSound != null)
			mLastEffectsSound.convertStartTimeToUnpausedRelative(sliceTime);
		if (mLastEffectsFade != null)
			mLastEffectsFade.convertStartTimeToUnpausedRelative(sliceTime);
	}

	/**
	 * Examines the provided arrays - chunkLocking and blockfield - in the
	 * specified pane. Looks for potential lock glows according to the current
	 * draw settings.
	 * 
	 * If any lock glows are found, they will be added to the provided
	 * structures (glowSets and glowSetQOs) with either the appropriate QO (if
	 * 2D) or the pane's SX qo (if 3D).
	 * 
	 * Returns the number glow sets added to the array by this operation.
	 * 
	 * If called with glowSets and glowSetQOs set to null, will determine the
	 * number of glow sets that WOULD be added, but obviously make no difference
	 * to those structures.
	 */
	private int addLockGlows(DrawSettings ds, byte[][][] chunkLocking,
			byte[][][] blockfield, int qPane, boolean chunkMustGrow,
			GlowEffectList glowEffects, long millisInSliceEffectStarts,
			long duration, int extraRows) {

		if (!mDrawSettings.draw3D) {
			ArrayOps.setEmpty(glowCandidates);
			int numRegions = 1;
			// This call uses fallingChunks as the starting point for a flood,
			// and will flood
			// within the provided block field. Returns the number of regions
			// added.
			int regionsAdded = floodRegions(ds, chunkLocking, null, null, null,
					blockfield, null, null, qPane, glowCandidates, numRegions,
					extraRows, FLOOD_NEIGHBORHOOD_FOUR, // flood in 4 ways
					FLOOD_STARTING_EXACT_BLOCKS, // flood starting from exactly
													// the starting blocks
					FLOOD_TO_SAME, // flood to exactly the same QO
					FLOOD_COMPARE_WITHIN_FIELD, // flood compare within the
												// blockfield alone
					FLOOD_LIMIT_NONE, // no limit to size; might glow giant
										// sections.
					chunkMustGrow ? FLOOD_INCLUDE_REGION_GROWN
							: FLOOD_INCLUDE_REGION_ALL);
			numRegions += regionsAdded;

			if (glowEffects != null) {
				for (int glowRegion = 1; glowRegion < numRegions; glowRegion++) {
					int qo = -1;
					for (int j = 0; j < glowCandidates.length && qo == -1; j++) {
						for (int k = 0; k < glowCandidates[0].length
								&& qo == -1; k++) {
							if (glowCandidates[j][k] == glowRegion) {
								qo = blockfield[qPane][j
										+ mDrawSettings.blockFieldOuterBuffer][k
										+ mDrawSettings.blockFieldOuterBuffer];
							}
						}
					}

					GlowEffect.Setter setter = (GlowEffect.Setter) glowEffects
							.add();

					setter.type(GlowEffect.TYPE_LOCK).qPane(qPane)
							.startTimeSlice(millisInSliceEffectStarts)
							.duration(duration)
							.qOrientation(qo >= 0 ? qo : QOrientations.NO);

					setGlowSetIndices(ds, setter.directDrawCodeAccess(),
							glowCandidates, glowRegion, extraRows);

					glowEffects.commit(setter);
				}
			}

			return numRegions - 1;
		} else {
			ArrayOps.setEmpty(glowCandidates);
			// This call uses fallingChunks as the starting point for a flood,
			// and will flood
			// within the provided block field. Returns the number of regions
			// added.
			int numRegions = 1;
			int regionsAdded = floodRegions(
					ds,
					chunkLocking,
					null,
					null,
					null,
					blockfield,
					null,
					null,
					qPane,
					glowCandidates,
					numRegions,
					extraRows,
					FLOOD_NEIGHBORHOOD_FOUR, // flood in 4 ways
					FLOOD_STARTING_EXACT_BLOCKS_AND_NEIGHBORHOOD_FOUR, // flood
																		// starting
																		// from
																		// exactly
																		// the
																		// starting
																		// blocks
					FLOOD_TO_NO_BORDER_OR_NO_STARTING_OR_NO_CHANGE, // flood to
																	// exactly
																	// the same
																	// QO
					FLOOD_COMPARE_WITHIN_FIELD_AND_STARTING, // flood compare
																// within the
																// blockfield
																// alone
					FLOOD_LIMIT_STARTING_BLOCKS_AND_NEIGHBORHOOD_FOUR,
					FLOOD_INCLUDE_REGION_ALL_STARTING_AND_OTHER); // FLOOD_INCLUDE_REGION_ALL_MERGE_NOT_NEIGHBORS
																	// ) ;
			// 6/15 optimization: merging regions is an intensive operation, and
			// possibly unnecessary.
			// 7/2 sanity fix: merging served an important role in preventing
			// "neighboring blocks"
			// (stationary blocks into which a chunk glowed) from causing glows
			// against each other.
			// Merging them into the same group resolved a visual bug.
			// However, there may be other ways to resolve this, such as
			// labeling 2 regions:
			// the "chunkLocking" regions, i.e. those within the chunk, and
			// "blockField"
			// regions, i.e., those NOT within the chunk.
			numRegions += regionsAdded;

			boolean hasGlows = false;

			if (glowEffects != null) {
				if (numRegions > 1) {
					int qo = qPane == 0 ? QOrientations.S0 : QOrientations.S1;

					GlowEffect.Setter setter = (GlowEffect.Setter) glowEffects
							.add();

					setter.type(GlowEffect.TYPE_LOCK).qPane(qPane)
							.startTimeSlice(millisInSliceEffectStarts)
							.duration(duration).qOrientation(qo);

					hasGlows = setBorderGlowSetIndices(ds,
							setter.directDrawCodeAccess(), chunkLocking,
							glowCandidates, qPane, extraRows);

					if (hasGlows)
						glowEffects.commit(setter);
					else
						glowEffects.cancel(setter);
				}
			}

			return hasGlows ? 1 : 0;
		}
	}

	private int addClearGlows(DrawSettings ds, int[] clears,
			boolean[] monoClears, int qPane, GlowEffectList glowEffects,
			long millisInSliceEffectStarts, long duration, int extraRows) {
		int numRegions = 0;
		ArrayOps.setEmpty(glowCandidates);
		for (int row = 0; row < mDrawSettings.displayedRows + extraRows; row++) {
			int rowPos = row + mDrawSettings.blockFieldOuterBuffer;
			// mark this one?
			if (clears[rowPos] == QCombinations.SL
					|| monoClears[rowPos]
					|| clears[rowPos] == (qPane == Consts.QPANE_0 ? QCombinations.S0
							: QCombinations.S1)) {

				numRegions = 1;
				for (int c = 0; c < mDrawSettings.COLS; c++)
					glowCandidates[row][c] = 1;
			}
		}

		if (glowEffects != null) {
			if (numRegions > 0) {
				GlowEffect.Setter setter = (GlowEffect.Setter) glowEffects
						.add();

				setter.type(GlowEffect.TYPE_CLEAR).qPane(qPane)
						.startTimeSlice(millisInSliceEffectStarts)
						.duration(duration).qOrientation(QOrientations.NO);

				setGlowSetIndices(ds, setter.directDrawCodeAccess(),
						glowCandidates, 1, extraRows);

				glowEffects.commit(setter);
			}
		}

		return numRegions;
	}

	private int addRisingLockGlows(DrawSettings ds, byte[][][] blockfield,
			int rowsRisen, int qPane, GlowEffectList glowEffects,
			long millisInSliceEffectStarts, long duration, int extraRows) {
		int numRegions = 0;
		ArrayOps.setEmpty(glowCandidates);
		if (rowsRisen > 0) {
			if (!mDrawSettings.draw3D) {
				for (int c = 0; c < mDrawSettings.COLS; c++) {
					int qo = blockfield[qPane][rowsRisen
							+ mDrawSettings.blockFieldOuterBuffer][c
							+ mDrawSettings.blockFieldOuterBuffer];
					if (glowCandidates[rowsRisen][c] == 0
							&& qo != 0
							&& qo == blockfield[qPane][rowsRisen - 1
									+ mDrawSettings.blockFieldOuterBuffer][c
									+ mDrawSettings.blockFieldOuterBuffer]) {
						tempOffset.y = rowsRisen;
						tempOffset.x = c;
						tempOffset2.y = tempOffset.y + 1;
						tempOffset2.x = tempOffset.x + 1;
						numRegions++;
						floodRegions(ds, blockfield, tempOffset, tempOffset2,
								null, blockfield, null, null, 0,
								glowCandidates, numRegions,
								FLOOD_NEIGHBORHOOD_FOUR, // flood in 4 ways
								FLOOD_STARTING_EXACT_BLOCKS, // flood starting
																// from exactly
																// the starting
																// blocks
								FLOOD_TO_SAME, // flood to exactly the same QO
								FLOOD_COMPARE_WITHIN_FIELD, // flood compare
															// within the
															// blockfield alone
								FLOOD_LIMIT_NONE, FLOOD_INCLUDE_REGION_ALL); // no
																				// limit
																				// to
																				// size;
																				// might
																				// glow
																				// giant
																				// sections.
					}
				}

				if (glowEffects != null) {
					for (int glowRegion = 1; glowRegion <= numRegions; glowRegion++) {

						// set the qorientation
						int qo = -1;
						for (int j = 0; j < glowCandidates.length && qo == -1; j++) {
							for (int k = 0; k < glowCandidates[j].length
									&& qo == -1; k++) {
								if (glowCandidates[j][k] == glowRegion) {
									qo = blockfield[qPane][j
											+ mDrawSettings.blockFieldOuterBuffer][k
											+ mDrawSettings.blockFieldOuterBuffer];
								}
							}
						}

						GlowEffect.Setter setter = (GlowEffect.Setter) glowEffects
								.add();

						// set type, qp, and start time
						setter.type(GlowEffect.TYPE_LOCK).qPane(qPane)
								.startTimeSlice(millisInSliceEffectStarts)
								.duration(duration)
								.qOrientation(qo > -1 ? qo : QOrientations.NO);

						// set the draw codes
						setGlowSetIndices(ds, setter.directDrawCodeAccess(),
								glowCandidates, glowRegion, extraRows);

						glowEffects.commit(setter);
					}
				}
				return numRegions;
			} else {
				ArrayOps.setEmpty(glowCandidates);
				numRegions = 0;
				if (rowsRisen > 0) {
					for (int c = 0; c < mDrawSettings.COLS; c++) {
						int qo = blockfield[qPane][rowsRisen
								+ mDrawSettings.blockFieldOuterBuffer][c
								+ mDrawSettings.blockFieldOuterBuffer];
						if (qo != 0) {
							glowCandidates[rowsRisen][c] = 1;
							numRegions = Math.max(numRegions, 1);

							int qo2 = blockfield[qPane][rowsRisen - 1
									+ mDrawSettings.blockFieldOuterBuffer][c
									+ mDrawSettings.blockFieldOuterBuffer];
							if (mDrawSettings.fillRegionConnects(qo, qo2)) {
								glowCandidates[rowsRisen - 1][c] = 2;
								numRegions = 2;
							}
						}
					}

					if (numRegions == 2) {
						boolean hasGlows = true;
						if (glowEffects != null) {

							int qo = -1;
							for (int j = 0; j < glowCandidates.length
									&& qo == -1; j++) {
								for (int k = 0; k < glowCandidates[j].length
										&& qo == -1; k++) {
									if (glowCandidates[j][k] == 1) {
										qo = blockfield[qPane][j
												+ mDrawSettings.blockFieldOuterBuffer][k
												+ mDrawSettings.blockFieldOuterBuffer];
									}
								}
							}

							GlowEffect.Setter setter = (GlowEffect.Setter) glowEffects
									.add();

							// set type, qp, and start time
							setter.type(GlowEffect.TYPE_LOCK)
									.qPane(qPane)
									.startTimeSlice(millisInSliceEffectStarts)
									.duration(duration)
									.qOrientation(
											qo > -1 ? qo : QOrientations.NO);

							// set the draw codes
							hasGlows = setBorderGlowSetIndices(ds,
									setter.directDrawCodeAccess(), null,
									glowCandidates, qPane, extraRows);

							if (hasGlows)
								glowEffects.commit(setter);
							else
								glowEffects.cancel(setter);
						}

						return hasGlows ? 1 : 0;
					}
				}
			}
		}
		return 0;
	}
	
	
	
	private int addColumnUnlockGlows(DrawSettings ds, byte[][][][] blockfields,
			byte[][][][] fallingChunks, int[] fallDistances, int qPane,
			int firstChunk, int numChunks, ArrayList<Offset> unlockedColumns,
			int numUnlockedColumns, GlowEffectList glowEffects,
			long millisInSliceEffectStarts, long duration, int glowQO,
			int extraRows) {
		
		return countColumnUnlockGlows(ds, blockfields, fallingChunks, fallDistances, qPane,
				firstChunk, numChunks, unlockedColumns, numUnlockedColumns, glowEffects,
				millisInSliceEffectStarts, duration, glowQO, extraRows) ;
		
	}
	
	
	private boolean hasColumnUnlockGlows(GameBlocksSlice slice) {
		if ( slice.getBlocksState() != GameBlocksSlice.BLOCKS_CHUNKS_FALLING )
			return false ;
		
		for ( int qp = 0; qp < 2; qp++ ) {
			if ( countColumnUnlockGlows( mDrawSettings, slice.getBlockfields(),
					slice.getChunks(), slice.getFallDistances(), qp,
					slice.getFirstChunk(), slice.getNumChunks(), slice.getUnlockedColumns(),
					slice.getNumUnlockedColumns(), null, 0, 0, 0, 0 ) > 0 ) {
				return true ;
			}
		}
		
		return false ;
	}
	

	private int countColumnUnlockGlows(DrawSettings ds, byte[][][][] blockfields,
			byte[][][][] fallingChunks, int[] fallDistances, int qPane,
			int firstChunk, int numChunks, ArrayList<Offset> unlockedColumns,
			int numUnlockedColumns, GlowEffectList glowEffects,
			long millisInSliceEffectStarts, long duration, int glowQO,
			int extraRows) {
		// We determine the borders to glow by 1st marking all the
		// falling chunks WITHIN THE UNLOCKED COLUMNS, with a unique
		// region for each fall distance; if it is adajcent to a block with
		// a different fall distance, mark that block as well using region 1.
		// One note: we include all those chunks with a fall distance <= 0
		// in the "stationary block field" for the purpose of marking glows;
		// we don't indicate an unlock if the resulting chunk will fall exactly
		// zero distance.
		ArrayOps.setEmpty(glowCandidates);

		int region = 2;
		boolean glowsExist = false;

		for (int i = firstChunk; i < numChunks + firstChunk; i++) {
			byte[][][] chunk;
			if (fallDistances[i] <= 0
					&& (fallDistances[i + 1] > 0 || i + 1 == numChunks
							+ firstChunk))
				chunk = blockfields[i]; // either the last "no fall", or the
										// last, period.
			else if (fallDistances[i] > 0)
				chunk = fallingChunks[i];
			else
				continue;
			// mark those blocks within the columns that
			// are included at this fall distance, and then check
			// adjacent blocks in each other blockfield.
			for (int colNum = 0; colNum < numUnlockedColumns; colNum++) {
				int col = unlockedColumns.get(colNum).x;
				int c = col + mDrawSettings.blockFieldOuterBuffer;
				// Iterate over "on-screen" rows, from the starting unlock
				// column to the top of the
				// displayed area. When converting to 'r', the falling chunk row
				// index, subtract the
				// fall distance while adding the outer buffer.
				for (int row = Math.max(0, unlockedColumns.get(colNum).y); row < mDrawSettings.displayedRows
						+ extraRows; row++) {
					int r = row + mDrawSettings.blockFieldOuterBuffer
							- (i > firstChunk ? fallDistances[i] : 0);
					if (r < 0)
						continue;
					if (mDrawSettings.behavior_qo_lock_glow[chunk[qPane][r][c]] == DrawSettings.BEHAVIOR_QO_LOCK_GLOW_NORMAL) {
						glowsExist = true;
						glowCandidates[row][col] = region;
						// look for anything to the left or right at a different
						// fall distance.
						// 'r' is an index; the on-screen position is row + (i
						// >= firstFalling ? fallDistance[i] : 0).
						// moving in reverse, from the onscreen row position rp,
						// use
						// row = rp - (i >= fF ? fD[i] : 0). Thus:
						// r2 = r + (i >= fF ? fD[i] : 0) - (j >= fF ? fD[j] :
						// 0)
						// is the index into 2ndChunk that aligns with index 'r'
						// into chunk.
						// however, it is easier to simply calculate from 'row'.
						for (int j = firstChunk; j < numChunks + firstChunk; j++) {
							byte[][][] secondChunk;
							if (fallDistances[j] <= 0
									&& (fallDistances[j + 1] > 0 || j + 1 == numChunks
											+ firstChunk))
								secondChunk = blockfields[j]; // either the last
																// "no fall", or
																// the last,
																// period.
							else if (fallDistances[j] > 0)
								secondChunk = fallingChunks[j];
							else
								continue;
							if (i != j) {
								// horizontal check!
								int r2 = row
										+ mDrawSettings.blockFieldOuterBuffer
										- (j > firstChunk ? fallDistances[j]
												: 0);
								if (r2 < 0)
									continue;
								if (col > 0
										&& mDrawSettings.behavior_qo_lock_glow[secondChunk[qPane][r2][c - 1]] == DrawSettings.BEHAVIOR_QO_LOCK_GLOW_NORMAL)
									glowCandidates[row][col - 1] = 1;
								if (col < mDrawSettings.COLS - 1
										&& mDrawSettings.behavior_qo_lock_glow[secondChunk[qPane][r2][c + 1]] == DrawSettings.BEHAVIOR_QO_LOCK_GLOW_NORMAL)
									glowCandidates[row][col + 1] = 1;
							}
						}
					}
				}
			}
			region++;
		}

		if (glowsExist && glowEffects != null) {
			GlowEffect.Setter setter = (GlowEffect.Setter) glowEffects.add();
			setter.type(GlowEffect.TYPE_UNLOCK).qPane(qPane)
					.startTimeSlice(millisInSliceEffectStarts)
					.duration(duration).qOrientation(glowQO);

			glowsExist = setBorderGlowSetIndices(ds,
					setter.directDrawCodeAccess(), null, glowCandidates, qPane,
					extraRows);

			if (glowsExist)
				glowEffects.commit(setter);
			else
				glowEffects.cancel(setter);
		}

		return glowsExist ? 1 : 0;
	}

	/**
	 * Examines the provided arrays - pre_ and post_blockfield - in the
	 * specified pane. Looks for potential metamorphosis block glows according
	 * to the current draw settings.
	 * 
	 * If any metamorphosis glows are found, they will be added to the provided
	 * structures (glowSets and glowSetQOs) with the appropriate QO.
	 * 
	 * Returns the number glow sets in the array after this operation, which
	 * will be >= the provided firstGlowSet. ( == if no glows are added )
	 * 
	 * @param pre_blockfield
	 * @param post_blockfield
	 * @param qPane
	 * @param extraRows
	 * @return
	 */
	private int addMetamorphosisBlockGlows(DrawSettings ds,
			byte[][][] pre_blockfield, byte[][][] post_blockfield, int qPane,
			GlowEffectList glowEffects, long millisInSliceEffectStarts,
			long duration, int extraRows) {

		// mark candidates. A "region" is every occurence of a QO that appears
		// in the field.
		int numRegions = 1;
		ArrayOps.setEmpty(glowCandidates);
		for (int row = 0; row < mDrawSettings.displayedRows + extraRows; row++) {
			int r = row + mDrawSettings.blockFieldOuterBuffer;
			for (int col = 0; col < mDrawSettings.COLS; col++) {
				int c = col + mDrawSettings.blockFieldOuterBuffer;
				int pre_qo = pre_blockfield[qPane][r][c];
				int post_qo = post_blockfield[qPane][r][c];
				if (pre_qo != post_qo) {
					if (glowCandidates[row][col] == 0
							&& mDrawSettings.behavior_qo_metamorphosis_from[pre_qo] == DrawSettings.BEHAVIOR_QO_METAMORPHOSIS_GLOW) {
						for (int row2 = row; row2 < mDrawSettings.displayedRows
								+ extraRows; row2++) {
							int r2 = row2 + mDrawSettings.blockFieldOuterBuffer;
							for (int col2 = 0; col2 < mDrawSettings.COLS; col2++) {
								int c2 = col2
										+ mDrawSettings.blockFieldOuterBuffer;
								if (pre_blockfield[qPane][r2][c2] == pre_qo
										&& post_blockfield[qPane][r2][c2] != pre_qo)
									glowCandidates[row][col] = numRegions;
							}
						}
						numRegions++;
					} else if (glowCandidates[row][col] == 0
							&& mDrawSettings.behavior_qo_metamorphosis_to[post_qo] == DrawSettings.BEHAVIOR_QO_METAMORPHOSIS_GLOW) {
						for (int row2 = row; row2 < mDrawSettings.displayedRows
								+ extraRows; row2++) {
							int r2 = row2 + mDrawSettings.blockFieldOuterBuffer;
							for (int col2 = 0; col2 < mDrawSettings.COLS; col2++) {
								int c2 = col2
										+ mDrawSettings.blockFieldOuterBuffer;
								if (post_blockfield[qPane][r2][c2] == post_qo
										&& pre_blockfield[qPane][r2][c2] != post_qo)
									glowCandidates[row][col] = numRegions;
							}
						}
						numRegions++;
					}
				}
			}
		}

		// now translate into glow set(s).
		if (glowEffects != null) {
			for (int i = 1; i < numRegions; i++) {
				int qo = -1;
				for (int j = 0; j < glowCandidates.length && qo == -1; j++) {
					for (int k = 0; k < glowCandidates[j].length && qo == -1; k++) {
						if (glowCandidates[j][k] == i) {
							qo = post_blockfield[qPane][j
									+ mDrawSettings.blockFieldOuterBuffer][k
									+ mDrawSettings.blockFieldOuterBuffer];
						}
					}
				}

				GlowEffect.Setter setter = (GlowEffect.Setter) glowEffects
						.add();

				setter.type(GlowEffect.TYPE_METAMORPHOSIS).qPane(qPane)
						.startTimeSlice(millisInSliceEffectStarts)
						.duration(duration)
						.qOrientation(qo > -1 ? qo : QOrientations.NO);

				setGlowSetIndices(ds, setter.directDrawCodeAccess(),
						glowCandidates, i, extraRows);

				glowEffects.commit(setter);
			}
		}

		return numRegions - 1;
	}

	/**
	 * Creates "entry" glows for those blocks which have been added in the
	 * bottom 'newRows' rows. Entry glows are distinct from 'lock' glows in that
	 * entry glows cover exactly those blocks which are new.
	 * 
	 * In other words, for Quantro-types, a rising lock glow indicates the
	 * "seam lines" formed by new blocks; "entry" glows the entire block. For
	 * Retro-types, a rising glow shows the new "regions" formed by the entry;
	 * 
	 * @param ds
	 * @param blockfield
	 * @param newRows
	 * @param qPane
	 * @param glowEffects
	 * @param millisInSliceEffectStarts
	 * @param duration
	 * @return
	 */
	private int addEnterGlowsFromBottom(DrawSettings ds, byte[][][] blockfield,
			int newRows, int qPane, GlowEffectList glowEffects,
			long millisInSliceEffectStarts, long duration) {

		// relatively simple. We mark distinct QOrientations
		// within the row(s) added as distinct regions. This
		// behavior is consistent between 2D and 3D games.
		// There is no expansion beyond these bounds, and no need for
		// 'floodRegions.' For now, each unique QOrientation gets
		// its own GlowEffect.
		// NOTE: we may change this to every block in the qPane getting
		// placed into the same region. This requires rewriting the specs
		// for 2D Enter Glows in DrawSettings to not rely on underlying
		// QO color.

		ArrayOps.setEmpty(glowCandidates);
		int numRegions = 0;
		for (int row = 0; row < newRows; row++) {
			int r = row + ds.blockFieldOuterBuffer;
			for (int col = 0; col < ds.COLS; col++) {
				int c = col + ds.blockFieldOuterBuffer;
				int qo = blockfield[qPane][r][c];
				if (qo != 0 && glowCandidates[row][col] == 0) {
					// a nonzero QOrientation that has not been
					// assigned a region yet. Search the remaining
					// blocks for it and matches.
					numRegions++;
					// we use this as the region number when marking.

					// iterate from here across the remaining space. Note
					// that we include [row, col] as the starting position
					// so it gets marked as well.
					for (int row2 = row; row2 < newRows; row2++) {
						int r2 = row2 + ds.blockFieldOuterBuffer;
						for (int col2 = (row2 == row ? col : 0); col2 < ds.COLS; col2++) {
							// iterate col2 from col to COL (the remaining
							// columns)
							// if we're in the starting row; otherwise, iterate
							// the full length.
							int c2 = col2 + ds.blockFieldOuterBuffer;
							int qo2 = blockfield[qPane][r2][c2];
							if (qo == qo2) {
								glowCandidates[row2][col2] = numRegions;
							}
						}
					}
				}
			}
		}

		// We have now marked each unique QOrientation as a distinct
		// glow. This is basically a stop-gap measure for how we generally
		// expect this glow to behave. A more general solution should be
		// implemented when needed.
		if (glowEffects != null) {
			for (int region = 1; region <= numRegions; region++) {
				// iterate to <=, because if we have 1 region, it is labeled 1.
				// find the qOrientation?
				int qo = -1;
				for (int j = 0; j < glowCandidates.length && qo == -1; j++) {
					for (int k = 0; k < glowCandidates[0].length && qo == -1; k++) {
						if (glowCandidates[j][k] == region) {
							qo = blockfield[qPane][j
									+ mDrawSettings.blockFieldOuterBuffer][k
									+ mDrawSettings.blockFieldOuterBuffer];
						}
					}
				}

				GlowEffect.Setter setter = (GlowEffect.Setter) glowEffects
						.add();

				setter.type(GlowEffect.TYPE_ENTER).qPane(qPane)
						.startTimeSlice(millisInSliceEffectStarts)
						.duration(duration)
						.qOrientation(qo >= 0 ? qo : QOrientations.NO);

				setGlowSetIndices(ds, setter.directDrawCodeAccess(),
						glowCandidates, region, 0);

				glowEffects.commit(setter);
			}
		}

		return numRegions;
	}

	/**
	 * Examines the provided arrays - chunkLocking and blockfield - in the
	 * specified pane. Looks for potential lock glows according to the current
	 * draw settings.
	 * 
	 * If any lock glows are found, they will be added to the provided
	 * structures (glowSets and glowSetQOs) with either the appropriate QO (if
	 * 2D) or the pane's SX qo (if 3D).
	 * 
	 * Returns the number glow sets added to the array by this operation.
	 * 
	 * If called with glowSets and glowSetQOs set to null, will determine the
	 * number of glow sets that WOULD be added, but obviously make no difference
	 * to those structures.
	 * 
	 * @param chunkLocking
	 * @param blockfield
	 * @param qPane
	 * @param glowSets
	 * @param glowSetQOs
	 * @param firstGlowSet
	 * @param extraRows
	 * @return
	 */
	private int setLockGlows(DrawSettings ds, byte[][][] chunkLocking,
			byte[][][] blockfield, int qPane, boolean chunkMustGrow,
			ArrayList<short[][]> glowSets, ArrayList<Integer> glowSetQOs,
			int firstGlowSet, int extraRows) {

		if (!mDrawSettings.draw3D) {
			ArrayOps.setEmpty(glowCandidates);
			int numRegions = 1;
			// This call uses fallingChunks as the starting point for a flood,
			// and will flood
			// within the provided block field. Returns the number of regions
			// added.
			int regionsAdded = floodRegions(ds, chunkLocking, null, null, null,
					blockfield, null, null, qPane, glowCandidates, numRegions,
					extraRows, FLOOD_NEIGHBORHOOD_FOUR, // flood in 4 ways
					FLOOD_STARTING_EXACT_BLOCKS, // flood starting from exactly
													// the starting blocks
					FLOOD_TO_SAME, // flood to exactly the same QO
					FLOOD_COMPARE_WITHIN_FIELD, // flood compare within the
												// blockfield alone
					FLOOD_LIMIT_NONE, // no limit to size; might glow giant
										// sections.
					chunkMustGrow ? FLOOD_INCLUDE_REGION_GROWN
							: FLOOD_INCLUDE_REGION_ALL);
			numRegions += regionsAdded;

			if (glowSets != null && glowSetQOs != null) {
				for (int glowRegion = 1; glowRegion < numRegions; glowRegion++) {
					if (glowSets.size() < glowRegion + firstGlowSet) {
						glowSets.add(new short[mDrawSettings.ROWS
								+ mDrawSettings.blockFieldOuterBuffer * 2][mDrawSettings.COLS
								+ mDrawSettings.blockFieldOuterBuffer * 2]);
						glowSetQOs.add(null);
					}
					setGlowSetIndices(ds,
							glowSets.get(glowRegion - 1 + firstGlowSet),
							glowCandidates, glowRegion, extraRows);
					boolean found = false;
					int qo = -1;
					for (int j = 0; j < glowCandidates.length && !found; j++) {
						for (int k = 0; k < glowCandidates[0].length && !found; k++) {
							if (glowCandidates[j][k] == glowRegion) {
								qo = blockfield[qPane][j
										+ mDrawSettings.blockFieldOuterBuffer][k
										+ mDrawSettings.blockFieldOuterBuffer];
								found = true;
							}
						}
					}
					glowSetQOs.set(glowRegion - 1 + firstGlowSet,
							(qo > -1 ? QOrientations.getInteger(qo) : null));
				}
			}

			return numRegions - 1;
		} else {
			ArrayOps.setEmpty(glowCandidates);
			// This call uses fallingChunks as the starting point for a flood,
			// and will flood
			// within the provided block field. Returns the number of regions
			// added.
			int numRegions = 1;
			int regionsAdded = floodRegions(
					ds,
					chunkLocking,
					null,
					null,
					null,
					blockfield,
					null,
					null,
					qPane,
					glowCandidates,
					numRegions,
					extraRows,
					FLOOD_NEIGHBORHOOD_FOUR, // flood in 4 ways
					FLOOD_STARTING_EXACT_BLOCKS_AND_NEIGHBORHOOD_FOUR, // flood
																		// starting
																		// from
																		// exactly
																		// the
																		// starting
																		// blocks
					FLOOD_TO_NO_BORDER_OR_NO_STARTING_OR_NO_CHANGE, // flood to
																	// exactly
																	// the same
																	// QO
					FLOOD_COMPARE_WITHIN_FIELD_AND_STARTING, // flood compare
																// within the
																// blockfield
																// alone
					FLOOD_LIMIT_STARTING_BLOCKS_AND_NEIGHBORHOOD_FOUR,
					FLOOD_INCLUDE_REGION_ALL_STARTING_AND_OTHER); // FLOOD_INCLUDE_REGION_ALL_MERGE_NOT_NEIGHBORS
																	// ) ;
			// 6/15 optimization: merging regions is an intensive operation, and
			// possibly unnecessary.
			// 7/2 sanity fix: merging served an important role in preventing
			// "neighboring blocks"
			// (stationary blocks into which a chunk glowed) from causing glows
			// against each other.
			// Merging them into the same group resolved a visual bug.
			// However, there may be other ways to resolve this, such as
			// labeling 2 regions:
			// the "chunkLocking" regions, i.e. those within the chunk, and
			// "blockField"
			// regions, i.e., those NOT within the chunk.
			numRegions += regionsAdded;

			boolean hasGlows = false;

			if (glowSets != null && glowSetQOs != null) {
				if (numRegions > 1) {
					if (glowSets.size() < 1 + firstGlowSet) {
						glowSets.add(new short[mDrawSettings.ROWS
								+ mDrawSettings.blockFieldOuterBuffer * 2][mDrawSettings.COLS
								+ mDrawSettings.blockFieldOuterBuffer * 2]);
						glowSetQOs.add(null);
					}
					hasGlows = setBorderGlowSetIndices(ds,
							glowSets.get(firstGlowSet), chunkLocking,
							glowCandidates, qPane, extraRows);
					int qo = qPane == 0 ? QOrientations.S0 : QOrientations.S1;
					glowSetQOs.set(firstGlowSet, QOrientations.getInteger(qo));
				}
			}

			return hasGlows ? 1 : 0;
		}
	}

	private int setClearGlows(DrawSettings ds, int[] clears,
			boolean[] monoClears, int qPane, ArrayList<short[][]> glowSets,
			ArrayList<Integer> glowSetQOs, int firstGlowSet, int extraRows) {
		int numRegions = 0;
		ArrayOps.setEmpty(glowCandidates);
		for (int row = 0; row < mDrawSettings.displayedRows + extraRows; row++) {
			int rowPos = row + mDrawSettings.blockFieldOuterBuffer;
			// mark this one?
			if (clears[rowPos] == QCombinations.SL
					|| monoClears[rowPos]
					|| clears[rowPos] == (qPane == Consts.QPANE_0 ? QCombinations.S0
							: QCombinations.S1)) {

				numRegions = 1;
				for (int c = 0; c < mDrawSettings.COLS; c++)
					glowCandidates[row][c] = 1;
			}
		}

		if (glowSets != null && glowSetQOs != null) {
			if (numRegions > 0) {
				if (glowSets.size() < 1 + firstGlowSet) {
					glowSets.add(new short[mDrawSettings.ROWS
							+ mDrawSettings.blockFieldOuterBuffer * 2][mDrawSettings.COLS
							+ mDrawSettings.blockFieldOuterBuffer * 2]);
					glowSetQOs.add(null);
				}
				setGlowSetIndices(ds, glowSets.get(firstGlowSet),
						glowCandidates, 1, extraRows);
				glowSetQOs.set(firstGlowSet, null);
			}
		}

		return numRegions;
	}

	private int setRisingLockGlows(DrawSettings ds, byte[][][] blockfield,
			int rowsRisen, int qPane, ArrayList<short[][]> glowSets,
			ArrayList<Integer> glowSetQOs, int firstGlowSet, int extraRows) {
		int numRegions = 0;
		ArrayOps.setEmpty(glowCandidates);
		if (rowsRisen > 0) {
			if (!mDrawSettings.draw3D) {
				for (int c = 0; c < mDrawSettings.COLS; c++) {
					int qo = blockfield[qPane][rowsRisen
							+ mDrawSettings.blockFieldOuterBuffer][c
							+ mDrawSettings.blockFieldOuterBuffer];
					if (glowCandidates[rowsRisen][c] == 0
							&& qo != 0
							&& qo == blockfield[qPane][rowsRisen - 1
									+ mDrawSettings.blockFieldOuterBuffer][c
									+ mDrawSettings.blockFieldOuterBuffer]) {
						tempOffset.y = rowsRisen;
						tempOffset.x = c;
						tempOffset2.y = tempOffset.y + 1;
						tempOffset2.x = tempOffset.x + 1;
						numRegions++;
						floodRegions(ds, blockfield, tempOffset, tempOffset2,
								null, blockfield, null, null, 0,
								glowCandidates, numRegions,
								FLOOD_NEIGHBORHOOD_FOUR, // flood in 4 ways
								FLOOD_STARTING_EXACT_BLOCKS, // flood starting
																// from exactly
																// the starting
																// blocks
								FLOOD_TO_SAME, // flood to exactly the same QO
								FLOOD_COMPARE_WITHIN_FIELD, // flood compare
															// within the
															// blockfield alone
								FLOOD_LIMIT_NONE, FLOOD_INCLUDE_REGION_ALL); // no
																				// limit
																				// to
																				// size;
																				// might
																				// glow
																				// giant
																				// sections.
					}
				}

				if (glowSets != null && glowSetQOs != null) {
					for (int glowRegion = 1; glowRegion <= numRegions; glowRegion++) {
						if (glowSets.size() < glowRegion + firstGlowSet) {
							glowSets.add(new short[mDrawSettings.ROWS
									+ mDrawSettings.blockFieldOuterBuffer * 2][mDrawSettings.COLS
									+ mDrawSettings.blockFieldOuterBuffer * 2]);
							glowSetQOs.add(null);
						}
						setGlowSetIndices(ds,
								glowSets.get(glowRegion - 1 + firstGlowSet),
								glowCandidates, glowRegion, extraRows);
						boolean found = false;
						int qo = -1;
						for (int j = 0; j < glowCandidates.length && !found; j++) {
							for (int k = 0; k < glowCandidates[j].length
									&& !found; k++) {
								if (glowCandidates[j][k] == glowRegion) {
									qo = blockfield[qPane][j
											+ mDrawSettings.blockFieldOuterBuffer][k
											+ mDrawSettings.blockFieldOuterBuffer];
									found = true;
								}
							}
						}
						glowSetQOs
								.set(glowRegion - 1 + firstGlowSet,
										(qo > -1 ? QOrientations.getInteger(qo)
												: null));
					}
				}
				return numRegions;
			} else {
				ArrayOps.setEmpty(glowCandidates);
				numRegions = 0;
				if (rowsRisen > 0) {
					for (int c = 0; c < mDrawSettings.COLS; c++) {
						int qo = blockfield[qPane][rowsRisen
								+ mDrawSettings.blockFieldOuterBuffer][c
								+ mDrawSettings.blockFieldOuterBuffer];
						if (qo != 0) {
							glowCandidates[rowsRisen][c] = 1;
							numRegions = Math.max(numRegions, 1);

							int qo2 = blockfield[qPane][rowsRisen - 1
									+ mDrawSettings.blockFieldOuterBuffer][c
									+ mDrawSettings.blockFieldOuterBuffer];
							if (mDrawSettings.fillRegionConnects(qo, qo2)) {
								glowCandidates[rowsRisen - 1][c] = 2;
								numRegions = 2;
							}
						}
					}

					if (numRegions == 2) {
						boolean hasGlows = true;
						if (glowSets != null && glowSetQOs != null) {
							if (glowSets.size() < numRegions - 1 + firstGlowSet) {
								glowSets.add(new short[mDrawSettings.ROWS
										+ mDrawSettings.blockFieldOuterBuffer
										* 2][mDrawSettings.COLS
										+ mDrawSettings.blockFieldOuterBuffer
										* 2]);
								glowSetQOs.add(null);
							}
							hasGlows = setBorderGlowSetIndices(ds,
									glowSets.get(firstGlowSet), null,
									glowCandidates, qPane, extraRows);
							boolean found = false;
							int qo = -1;
							for (int j = 0; j < glowCandidates.length && !found; j++) {
								for (int k = 0; k < glowCandidates[j].length
										&& !found; k++) {
									if (glowCandidates[j][k] == 1) {
										qo = blockfield[qPane][j
												+ mDrawSettings.blockFieldOuterBuffer][k
												+ mDrawSettings.blockFieldOuterBuffer];
										found = true;
									}
								}
							}
							glowSetQOs.set(firstGlowSet,
									QOrientations.getInteger(qo));
						}

						return hasGlows ? 1 : 0;
					}
				}
			}
		}
		return 0;
	}

	private int setColumnUnlockGlows(DrawSettings ds, byte[][][][] blockfields,
			byte[][][][] fallingChunks, int[] fallDistances, int qPane,
			int firstChunk, int numChunks, ArrayList<Offset> unlockedColumns,
			int numUnlockedColumns, ArrayList<short[][]> glowSets,
			ArrayList<Integer> glowSetQOs, int firstGlowSet, int extraRows) {
		// We determine the borders to glow by 1st marking all the
		// falling chunks WITHIN THE UNLOCKED COLUMNS, with a unique
		// region for each fall distance; if it is adajcent to a block with
		// a different fall distance, mark that block as well using region 1.
		// One note: we include all those chunks with a fall distance <= 0
		// in the "stationary block field" for the purpose of marking glows;
		// we don't indicate an unlock if the resulting chunk will fall exactly
		// zero distance.
		ArrayOps.setEmpty(glowCandidates);

		int region = 2;
		boolean glowsExist = false;

		for (int i = firstChunk; i < numChunks + firstChunk; i++) {
			byte[][][] chunk;
			if (fallDistances[i] <= 0
					&& (fallDistances[i + 1] > 0 || i + 1 == numChunks
							+ firstChunk))
				chunk = blockfields[i]; // either the last "no fall", or the
										// last, period.
			else if (fallDistances[i] > 0)
				chunk = fallingChunks[i];
			else
				continue;
			// mark those blocks within the columns that
			// are included at this fall distance, and then check
			// adjacent blocks in each other blockfield.
			for (int colNum = 0; colNum < numUnlockedColumns; colNum++) {
				int col = unlockedColumns.get(colNum).x;
				int c = col + mDrawSettings.blockFieldOuterBuffer;
				// Iterate over "on-screen" rows, from the starting unlock
				// column to the top of the
				// displayed area. When converting to 'r', the falling chunk row
				// index, subtract the
				// fall distance while adding the outer buffer.
				for (int row = Math.max(0, unlockedColumns.get(colNum).y); row < mDrawSettings.displayedRows
						+ extraRows; row++) {
					int r = row + mDrawSettings.blockFieldOuterBuffer
							- (i > firstChunk ? fallDistances[i] : 0);
					if (r < 0)
						continue;
					if (mDrawSettings.behavior_qo_lock_glow[chunk[qPane][r][c]] == DrawSettings.BEHAVIOR_QO_LOCK_GLOW_NORMAL) {
						glowsExist = true;
						glowCandidates[row][col] = region;
						// look for anything to the left or right at a different
						// fall distance.
						// 'r' is an index; the on-screen position is row + (i
						// >= firstFalling ? fallDistance[i] : 0).
						// moving in reverse, from the onscreen row position rp,
						// use
						// row = rp - (i >= fF ? fD[i] : 0). Thus:
						// r2 = r + (i >= fF ? fD[i] : 0) - (j >= fF ? fD[j] :
						// 0)
						// is the index into 2ndChunk that aligns with index 'r'
						// into chunk.
						// however, it is easier to simply calculate from 'row'.
						for (int j = firstChunk; j < numChunks + firstChunk; j++) {
							byte[][][] secondChunk;
							if (fallDistances[j] <= 0
									&& (fallDistances[j + 1] > 0 || j + 1 == numChunks
											+ firstChunk))
								secondChunk = blockfields[j]; // either the last
																// "no fall", or
																// the last,
																// period.
							else if (fallDistances[j] > 0)
								secondChunk = fallingChunks[j];
							else
								continue;
							if (i != j) {
								// horizontal check!
								int r2 = row
										+ mDrawSettings.blockFieldOuterBuffer
										- (j > firstChunk ? fallDistances[j]
												: 0);
								if (r2 < 0)
									continue;
								if (col > 0
										&& mDrawSettings.behavior_qo_lock_glow[secondChunk[qPane][r2][c - 1]] == DrawSettings.BEHAVIOR_QO_LOCK_GLOW_NORMAL)
									glowCandidates[row][col - 1] = 1;
								if (col < mDrawSettings.COLS - 1
										&& mDrawSettings.behavior_qo_lock_glow[secondChunk[qPane][r2][c + 1]] == DrawSettings.BEHAVIOR_QO_LOCK_GLOW_NORMAL)
									glowCandidates[row][col + 1] = 1;
							}
						}
					}
				}
			}
			region++;
		}

		if (glowsExist && glowSets != null && glowSetQOs != null) {
			if (glowSets.size() < firstGlowSet) {
				glowSets.add(new short[mDrawSettings.ROWS
						+ mDrawSettings.blockFieldOuterBuffer * 2][mDrawSettings.COLS
						+ mDrawSettings.blockFieldOuterBuffer * 2]);
				glowSetQOs.add(null);
			}
			glowsExist = setBorderGlowSetIndices(ds,
					glowSets.get(firstGlowSet), null, glowCandidates, qPane,
					extraRows);
			glowSetQOs.set(firstGlowSet, null);
		}

		return glowsExist ? 1 : 0;
	}

	/**
	 * Examines the provided arrays - pre_ and post_blockfield - in the
	 * specified pane. Looks for potential metamorphosis block glows according
	 * to the current draw settings.
	 * 
	 * If any metamorphosis glows are found, they will be added to the provided
	 * structures (glowSets and glowSetQOs) with the appropriate QO.
	 * 
	 * Returns the number glow sets in the array after this operation, which
	 * will be >= the provided firstGlowSet. ( == if no glows are added )
	 * 
	 * @param pre_blockfield
	 * @param post_blockfield
	 * @param qPane
	 * @param glowSets
	 * @param glowSetQOs
	 * @param firstGlowSet
	 * @param extraRows
	 * @return
	 */
	private int setMetamorphosisBlockGlows(DrawSettings ds,
			byte[][][] pre_blockfield, byte[][][] post_blockfield, int qPane,
			ArrayList<short[][]> glowSets, ArrayList<Integer> glowSetQOs,
			int firstGlowSet, int extraRows) {

		// mark candidates. A "region" is every occurence of a QO that appears
		// in the field.
		int numRegions = 1;
		ArrayOps.setEmpty(glowCandidates);
		for (int row = 0; row < mDrawSettings.displayedRows + extraRows; row++) {
			int r = row + mDrawSettings.blockFieldOuterBuffer;
			for (int col = 0; col < mDrawSettings.COLS; col++) {
				int c = col + mDrawSettings.blockFieldOuterBuffer;
				int pre_qo = pre_blockfield[qPane][r][c];
				int post_qo = post_blockfield[qPane][r][c];
				if (pre_qo != post_qo) {
					if (glowCandidates[row][col] == 0
							&& mDrawSettings.behavior_qo_metamorphosis_from[pre_qo] == DrawSettings.BEHAVIOR_QO_METAMORPHOSIS_GLOW) {
						for (int row2 = row; row2 < mDrawSettings.displayedRows
								+ extraRows; row2++) {
							int r2 = row2 + mDrawSettings.blockFieldOuterBuffer;
							for (int col2 = 0; col2 < mDrawSettings.COLS; col2++) {
								int c2 = col2
										+ mDrawSettings.blockFieldOuterBuffer;
								if (pre_blockfield[qPane][r2][c2] == pre_qo
										&& post_blockfield[qPane][r2][c2] != pre_qo)
									glowCandidates[row][col] = numRegions;
							}
						}
						numRegions++;
					} else if (glowCandidates[row][col] == 0
							&& mDrawSettings.behavior_qo_metamorphosis_to[post_qo] == DrawSettings.BEHAVIOR_QO_METAMORPHOSIS_GLOW) {
						for (int row2 = row; row2 < mDrawSettings.displayedRows
								+ extraRows; row2++) {
							int r2 = row2 + mDrawSettings.blockFieldOuterBuffer;
							for (int col2 = 0; col2 < mDrawSettings.COLS; col2++) {
								int c2 = col2
										+ mDrawSettings.blockFieldOuterBuffer;
								if (post_blockfield[qPane][r2][c2] == post_qo
										&& pre_blockfield[qPane][r2][c2] != post_qo)
									glowCandidates[row][col] = numRegions;
							}
						}
						numRegions++;
					}
				}
			}
		}

		// now translate into glow set(s).
		if (glowSets != null && glowSetQOs != null) {
			for (int i = 1; i < numRegions; i++) {
				if (glowSets.size() < i - 1 + firstGlowSet) {
					glowSets.add(new short[mDrawSettings.ROWS
							+ mDrawSettings.blockFieldOuterBuffer * 2][mDrawSettings.COLS
							+ mDrawSettings.blockFieldOuterBuffer * 2]);
					glowSetQOs.add(null);
				}
				setGlowSetIndices(ds, glowSets.get(i - 1 + firstGlowSet),
						glowCandidates, i, extraRows);
				// what's the QO for this?
				int qo = -1;
				boolean found = false;
				for (int j = 0; j < glowCandidates.length && !found; j++) {
					for (int k = 0; k < glowCandidates[j].length && !found; k++) {
						if (glowCandidates[j][k] == i) {
							qo = post_blockfield[qPane][j
									+ mDrawSettings.blockFieldOuterBuffer][k
									+ mDrawSettings.blockFieldOuterBuffer];
							found = true;
						}
					}
				}
				glowSetQOs.set(i - 1 + firstGlowSet,
						found ? QOrientations.getInteger(qo) : null);
			}
		}

		return numRegions - 1;
	}

	private void setShadowsAndCorners(DrawSettings ds, byte[][][] field,
			BlockDrawerConfigRange configRange, short[][][] shadows,
			short[][][][] drop, byte[][][][] corners) {
		for (int qp = 0; qp < 2; qp++) {
			if (corners != null)
				setCornerArrays(ds, field, qp, corners[qp][INDEX_CORNER_TL],
						corners[qp][INDEX_CORNER_TR],
						corners[qp][INDEX_CORNER_BL],
						corners[qp][INDEX_CORNER_BR]);
			if (shadows != null)
				setInnerShadowSetIndices(ds, shadows[qp], field, configRange,
						qp);
			if (drop != null)
				setOuterShadowSetIndices(ds, drop[qp], field, configRange, qp);
		}
	}

	private void setShadowsAndCorners(DrawSettings ds, byte[][][] field,
			BlockDrawerConfigRange configRange, int qPane, short[][][] shadows,
			short[][][][] drop, byte[][][][] corners) {
		if (corners != null)
			setCornerArrays(ds, field, qPane, corners[qPane][INDEX_CORNER_TL],
					corners[qPane][INDEX_CORNER_TR],
					corners[qPane][INDEX_CORNER_BL],
					corners[qPane][INDEX_CORNER_BR]);
		if (shadows != null)
			setInnerShadowSetIndices(ds, shadows[qPane], field, configRange,
					qPane);
		if (drop != null)
			setOuterShadowSetIndices(ds, drop[qPane], field, configRange, qPane);
	}

	private void setQOConnectionAndCorners(DrawSettings ds, byte[][][] field,
			BlockDrawerConfigRange configRange, short[][][] sets,
			byte[][][][] corners) {
		for (int qp = 0; qp < 2; qp++) {
			setQOConnectionAndCorners(ds, field, configRange, qp,
					sets == null ? null : sets[qp], corners == null ? null
							: corners[qp]);
		}
	}

	private void setQOConnectionAndCorners(DrawSettings ds, byte[][][] field,
			BlockDrawerConfigRange configRange, int qp, short[][] sets,
			byte[][][] corners) {
		if (corners != null)
			setQOCornerArays(ds, field, qp, corners[INDEX_CORNER_TL],
					corners[INDEX_CORNER_TR], corners[INDEX_CORNER_BL],
					corners[INDEX_CORNER_BR]);
		if (sets != null)
			setQOSetIndices(ds, sets, field, configRange, qp);
	}

	private void setQOConnectionAndCorners(DrawSettings ds, byte[][][] field,
			BlockDrawerConfigRange configRange, int qPane, short[][][] sets,
			byte[][][][] corners, int extraRows) {
		if (corners != null)
			setQOCornerArays(ds, field, qPane, corners[qPane][INDEX_CORNER_TL],
					corners[qPane][INDEX_CORNER_TR],
					corners[qPane][INDEX_CORNER_BL],
					corners[qPane][INDEX_CORNER_BR]);
		if (sets != null)
			setQOSetIndices(ds, sets[qPane], field, configRange, qPane);
	}

	private void printProfileSummary() {
		StringBuilder sb;
		log("---------------[ PROFILING SUMMARY ]---------------");
		// STABLE DRAWS
		log("-- STABLE --");
		sb = new StringBuilder();
		sb.append("Field changed: ")
				.append(summarizeBehavior(INDEX_PROFILE_SLICE_STABLE_BEHAVIOR_FIELD_CHANGED))
				.append("\n");
		sb.append("Nothn changed: ")
				.append(summarizeBehavior(INDEX_PROFILE_SLICE_STABLE_BEHAVIOR_NOTHING_CHANGED))
				.append("\n");
		for (int i = 0; i < NUM_INDEX_PROFILE_SLICE_ACTIONS; i++)
			mProfileMillisSpent[INDEX_PROFILE_SLICE_STABLE_BEHAVIOR_TOTAL][i] = 0;
		for (int i = 0; i < NUM_INDEX_PROFILE_SLICE_ACTIONS; i++) {
			mProfileMillisSpent[INDEX_PROFILE_SLICE_STABLE_BEHAVIOR_TOTAL][i] += mProfileMillisSpent[INDEX_PROFILE_SLICE_STABLE_BEHAVIOR_FIELD_CHANGED][i];
			mProfileMillisSpent[INDEX_PROFILE_SLICE_STABLE_BEHAVIOR_TOTAL][i] += mProfileMillisSpent[INDEX_PROFILE_SLICE_STABLE_BEHAVIOR_NOTHING_CHANGED][i];
		}
		sb.append("Total changed: ")
				.append(summarizeBehavior(INDEX_PROFILE_SLICE_STABLE_BEHAVIOR_TOTAL))
				.append("\n");
		log(sb.toString());

		// Pieces falling
		log("-- FALLING PIECES --");
		sb = new StringBuilder();
		sb.append("Field changed: ")
				.append(summarizeBehavior(INDEX_PROFILE_SLICE_PIECE_BEHAVIOR_FIELD_CHANGED))
				.append("\n");
		sb.append("Piece changed: ")
				.append(summarizeBehavior(INDEX_PROFILE_SLICE_PIECE_BEHAVIOR_PIECE_CHANGED))
				.append("\n");
		sb.append("Nothn changed: ")
				.append(summarizeBehavior(INDEX_PROFILE_SLICE_PIECE_BEHAVIOR_NOTHING_CHANGED))
				.append("\n");
		for (int i = 0; i < NUM_INDEX_PROFILE_SLICE_ACTIONS; i++)
			mProfileMillisSpent[INDEX_PROFILE_SLICE_PIECE_BEHAVIOR_TOTAL][i] = 0;
		for (int i = 0; i < NUM_INDEX_PROFILE_SLICE_ACTIONS; i++) {
			mProfileMillisSpent[INDEX_PROFILE_SLICE_PIECE_BEHAVIOR_TOTAL][i] += mProfileMillisSpent[INDEX_PROFILE_SLICE_PIECE_BEHAVIOR_FIELD_CHANGED][i];
			mProfileMillisSpent[INDEX_PROFILE_SLICE_PIECE_BEHAVIOR_TOTAL][i] += mProfileMillisSpent[INDEX_PROFILE_SLICE_PIECE_BEHAVIOR_PIECE_CHANGED][i];
			mProfileMillisSpent[INDEX_PROFILE_SLICE_PIECE_BEHAVIOR_TOTAL][i] += mProfileMillisSpent[INDEX_PROFILE_SLICE_PIECE_BEHAVIOR_NOTHING_CHANGED][i];
		}
		sb.append("Total changed: ")
				.append(summarizeBehavior(INDEX_PROFILE_SLICE_PIECE_BEHAVIOR_TOTAL))
				.append("\n");
		log(sb.toString());

		// Chunks falling
		log("-- FALLING CHUNKS --");
		sb = new StringBuilder();
		sb.append("Field changed: ")
				.append(summarizeBehavior(INDEX_PROFILE_SLICE_FALLING_BEHAVIOR_FIELD_CHANGED))
				.append("\n");
		sb.append("Unlocking chk: ")
				.append(summarizeBehavior(INDEX_PROFILE_SLICE_FALLING_BEHAVIOR_UNLOCKING))
				.append("\n");
		sb.append("Chunk transtn: ")
				.append(summarizeBehavior(INDEX_PROFILE_SLICE_FALLING_BEHAVIOR_CHUNK_TRANSITION))
				.append("\n");
		sb.append("Chunk falling: ")
				.append(summarizeBehavior(INDEX_PROFILE_SLICE_FALLING_BEHAVIOR_CHUNK_FALLING))
				.append("\n");

		for (int i = 0; i < NUM_INDEX_PROFILE_SLICE_ACTIONS; i++)
			mProfileMillisSpent[INDEX_PROFILE_SLICE_FALLING_BEHAVIOR_TOTAL][i] = 0;
		for (int i = 0; i < NUM_INDEX_PROFILE_SLICE_ACTIONS; i++) {
			mProfileMillisSpent[INDEX_PROFILE_SLICE_FALLING_BEHAVIOR_TOTAL][i] += mProfileMillisSpent[INDEX_PROFILE_SLICE_FALLING_BEHAVIOR_FIELD_CHANGED][i];
			mProfileMillisSpent[INDEX_PROFILE_SLICE_FALLING_BEHAVIOR_TOTAL][i] += mProfileMillisSpent[INDEX_PROFILE_SLICE_FALLING_BEHAVIOR_UNLOCKING][i];
			mProfileMillisSpent[INDEX_PROFILE_SLICE_FALLING_BEHAVIOR_TOTAL][i] += mProfileMillisSpent[INDEX_PROFILE_SLICE_FALLING_BEHAVIOR_CHUNK_TRANSITION][i];
			mProfileMillisSpent[INDEX_PROFILE_SLICE_FALLING_BEHAVIOR_TOTAL][i] += mProfileMillisSpent[INDEX_PROFILE_SLICE_FALLING_BEHAVIOR_CHUNK_FALLING][i];
		}
		sb.append("Total changed: ")
				.append(summarizeBehavior(INDEX_PROFILE_SLICE_FALLING_BEHAVIOR_TOTAL))
				.append("\n");
		log(sb.toString());

		// Clears
		log("-- Clearing Rows --");
		sb = new StringBuilder();
		sb.append("Field changed: ")
				.append(summarizeBehavior(INDEX_PROFILE_SLICE_CLEARING_BEHAVIOR_FIELD_CHANGED))
				.append("\n");
		sb.append("Row  emphasis: ")
				.append(summarizeBehavior(INDEX_PROFILE_SLICE_CLEARING_BEHAVIOR_EMPHASIZING_ROWS))
				.append("\n");
		sb.append("Field transtn: ")
				.append(summarizeBehavior(INDEX_PROFILE_SLICE_CLEARING_BEHAVIOR_FIELD_TRANSITION))
				.append("\n");
		sb.append("Glow animatng: ")
				.append(summarizeBehavior(INDEX_PROFILE_SLICE_CLEARING_BEHAVIOR_GLOWING_ROWS))
				.append("\n");

		for (int i = 0; i < NUM_INDEX_PROFILE_SLICE_ACTIONS; i++)
			mProfileMillisSpent[INDEX_PROFILE_SLICE_CLEARING_BEHAVIOR_TOTAL][i] = 0;
		for (int i = 0; i < NUM_INDEX_PROFILE_SLICE_ACTIONS; i++) {
			mProfileMillisSpent[INDEX_PROFILE_SLICE_CLEARING_BEHAVIOR_TOTAL][i] += mProfileMillisSpent[INDEX_PROFILE_SLICE_CLEARING_BEHAVIOR_FIELD_CHANGED][i];
			mProfileMillisSpent[INDEX_PROFILE_SLICE_CLEARING_BEHAVIOR_TOTAL][i] += mProfileMillisSpent[INDEX_PROFILE_SLICE_CLEARING_BEHAVIOR_EMPHASIZING_ROWS][i];
			mProfileMillisSpent[INDEX_PROFILE_SLICE_CLEARING_BEHAVIOR_TOTAL][i] += mProfileMillisSpent[INDEX_PROFILE_SLICE_CLEARING_BEHAVIOR_FIELD_TRANSITION][i];
			mProfileMillisSpent[INDEX_PROFILE_SLICE_CLEARING_BEHAVIOR_TOTAL][i] += mProfileMillisSpent[INDEX_PROFILE_SLICE_CLEARING_BEHAVIOR_GLOWING_ROWS][i];
		}
		sb.append("Total changed: ")
				.append(summarizeBehavior(INDEX_PROFILE_SLICE_CLEARING_BEHAVIOR_TOTAL))
				.append("\n");
		log(sb.toString());

		// Metamorph
		log("-- METAMORPHOSIS --");
		sb = new StringBuilder();
		sb.append("Field changed: ")
				.append(summarizeBehavior(INDEX_PROFILE_SLICE_METAMORPHOSIS_BEHAVIOR_FIELD_CHANGED))
				.append("\n");
		sb.append("Glow  changed: ")
				.append(summarizeBehavior(INDEX_PROFILE_SLICE_METAMORPHOSIS_BEHAVIOR_GLOW_CHANGED))
				.append("\n");
		sb.append("Field transtn: ")
				.append(summarizeBehavior(INDEX_PROFILE_SLICE_METAMORPHOSIS_BEHAVIOR_FIELD_TRANSITION))
				.append("\n");
		sb.append("Glow animatng: ")
				.append(summarizeBehavior(INDEX_PROFILE_SLICE_METAMORPHOSIS_BEHAVIOR_GLOW_ANIMATING))
				.append("\n");

		for (int i = 0; i < NUM_INDEX_PROFILE_SLICE_ACTIONS; i++)
			mProfileMillisSpent[INDEX_PROFILE_SLICE_METAMORPHOSIS_BEHAVIOR_TOTAL][i] = 0;
		for (int i = 0; i < NUM_INDEX_PROFILE_SLICE_ACTIONS; i++) {
			mProfileMillisSpent[INDEX_PROFILE_SLICE_METAMORPHOSIS_BEHAVIOR_TOTAL][i] += mProfileMillisSpent[INDEX_PROFILE_SLICE_METAMORPHOSIS_BEHAVIOR_FIELD_CHANGED][i];
			mProfileMillisSpent[INDEX_PROFILE_SLICE_METAMORPHOSIS_BEHAVIOR_TOTAL][i] += mProfileMillisSpent[INDEX_PROFILE_SLICE_METAMORPHOSIS_BEHAVIOR_GLOW_CHANGED][i];
			mProfileMillisSpent[INDEX_PROFILE_SLICE_METAMORPHOSIS_BEHAVIOR_TOTAL][i] += mProfileMillisSpent[INDEX_PROFILE_SLICE_METAMORPHOSIS_BEHAVIOR_FIELD_TRANSITION][i];
			mProfileMillisSpent[INDEX_PROFILE_SLICE_METAMORPHOSIS_BEHAVIOR_TOTAL][i] += mProfileMillisSpent[INDEX_PROFILE_SLICE_METAMORPHOSIS_BEHAVIOR_GLOW_ANIMATING][i];
		}
		sb.append("Total changed: ")
				.append(summarizeBehavior(INDEX_PROFILE_SLICE_METAMORPHOSIS_BEHAVIOR_TOTAL))
				.append("\n");
		log(sb.toString());

		// Metamorph
		log("-- BLOCKS RISING --");
		sb = new StringBuilder();
		sb.append("Field changed: ")
				.append(summarizeBehavior(INDEX_PROFILE_SLICE_RISING_BEHAVIOR_FIELD_CHANGED))
				.append("\n");
		sb.append("Rise animatng: ")
				.append(summarizeBehavior(INDEX_PROFILE_SLICE_RISING_BEHAVIOR_GLOW_ANIMATING))
				.append("\n");

		for (int i = 0; i < NUM_INDEX_PROFILE_SLICE_ACTIONS; i++)
			mProfileMillisSpent[INDEX_PROFILE_SLICE_RISING_BEHAVIOR_TOTAL][i] = 0;
		for (int i = 0; i < NUM_INDEX_PROFILE_SLICE_ACTIONS; i++) {
			mProfileMillisSpent[INDEX_PROFILE_SLICE_RISING_BEHAVIOR_TOTAL][i] += mProfileMillisSpent[INDEX_PROFILE_SLICE_RISING_BEHAVIOR_FIELD_CHANGED][i];
			mProfileMillisSpent[INDEX_PROFILE_SLICE_RISING_BEHAVIOR_TOTAL][i] += mProfileMillisSpent[INDEX_PROFILE_SLICE_RISING_BEHAVIOR_GLOW_ANIMATING][i];
		}
		sb.append("Total changed: ")
				.append(summarizeBehavior(INDEX_PROFILE_SLICE_RISING_BEHAVIOR_TOTAL))
				.append("\n");
		log(sb.toString());

	}

	private String summarizeBehavior(int behavior) {
		StringBuilder sb = new StringBuilder();
		long total = mProfileMillisSpent[behavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_TOTAL];
		if (total > 0) {
			sb.append("avg: ")
					.append(total
							/ mProfileMillisSpent[behavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_NUMBER])
					.append(" ");
			sb.append("coarse: ");
			sb.append("chk=")
					.append(((float) (1000 * mProfileMillisSpent[behavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_CHECK_EQUALITY] / total)) / 10)
					.append("% ");
			sb.append("ssc=")
					.append(((float) (1000 * mProfileMillisSpent[behavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_SET_SHADOWS_AND_CORNERS] / total)) / 10)
					.append("% ");
			sb.append("clp=")
					.append(((float) (1000 * mProfileMillisSpent[behavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_CLIP] / total)) / 10)
					.append("% ");
			sb.append("dra=")
					.append(((float) (1000 * mProfileMillisSpent[behavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW] / total)) / 10)
					.append("% ");
			sb.append("blt=")
					.append(((float) (1000 * mProfileMillisSpent[behavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_BLIT] / total)) / 10)
					.append("% ");
			sb.append("\t");

			total = mProfileMillisSpent[behavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_FILL]
					+ mProfileMillisSpent[behavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_TOP]
					+ mProfileMillisSpent[behavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_SHADOW]
					+ mProfileMillisSpent[behavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_DROP_SHADOW]
					+ mProfileMillisSpent[behavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_BORDER]
					+ mProfileMillisSpent[behavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_BORDER_SHINE]
					+ mProfileMillisSpent[behavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_3D]
					+ mProfileMillisSpent[behavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_GLOW];
			if (total > 0) {
				sb.append("fine: ");
				sb.append("fil=")
						.append(((float) (1000 * mProfileMillisSpent[behavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_FILL] / total)) / 10)
						.append("% ");
				sb.append("top=")
						.append(((float) (1000 * mProfileMillisSpent[behavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_TOP] / total)) / 10)
						.append("% ");
				sb.append("shd=")
						.append(((float) (1000 * mProfileMillisSpent[behavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_SHADOW] / total)) / 10)
						.append("% ");
				sb.append("dsh=")
						.append(((float) (1000 * mProfileMillisSpent[behavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_DROP_SHADOW] / total)) / 10)
						.append("% ");
				sb.append("brd=")
						.append(((float) (1000 * mProfileMillisSpent[behavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_BORDER] / total)) / 10)
						.append("% ");
				sb.append("brd_d=")
						.append(((float) (1000 * mProfileMillisSpent[behavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_BORDER_DRAWABLE_METHODS] / total)) / 10)
						.append("% ");
				sb.append("bsh=")
						.append(((float) (1000 * mProfileMillisSpent[behavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_BORDER_SHINE] / total)) / 10)
						.append("% ");
				sb.append("glo=")
						.append(((float) (1000 * mProfileMillisSpent[behavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_GLOW] / total)) / 10)
						.append("% ");
				sb.append("d3d=")
						.append(((float) (1000 * mProfileMillisSpent[behavior][BlockDrawer.INDEX_PROFILE_SLICE_ACTION_DRAW_3D] / total)) / 10)
						.append("% ");
			} else {
				sb.append("fine: none");
			}
		} else {
			sb.append("total is zero");
		}

		return sb.toString();
	}

	private int countNonEmptyBlocks(byte[][][] blockField, int extraRows) {
		int num = 0;
		for (int qp = 0; qp < 2; qp++) {
			for (int row = 0; row < mDrawSettings.displayedRows + extraRows; row++) {
				int posRow = row + mDrawSettings.blockFieldOuterBuffer;
				for (int col = 0; col < mDrawSettings.COLS; col++) {
					int posCol = col + mDrawSettings.blockFieldOuterBuffer;

					if (blockField[qp][posRow][posCol] != 0)
						num++;
				}
			}
		}

		return num;
	}

	/**
	 * Clips (via UNION) those pixels which are covered by the specified
	 * blockfield in the specified qPane.
	 * 
	 * "Covered" indicates that the value of the pixel is independent of any
	 * background paint or pixel; e.g. the interior of a semi-transparent fill
	 * is covered (because it is semi-transparent w.r.t. its own block fill
	 * color and what's behind it, NOT to the background image itself), but the
	 * drop-shadow around a block is NOT covered because it is drawn
	 * semi-transparently over a background.
	 * 
	 * This method will err on the side of under-inclusion - there may be some
	 * covered pixels which are not UNION clipped, but there will be no UNION
	 * clipped pixels which are not covered.
	 */
	private void clipCoveredPath(Path path, byte[][][] blockField,
                                 int qPane, int extraRows, Offset clipOffset) {
		if (qPane == 0 && !mDrawSettings.drawQ0)
			return;
		if (qPane == 1 && !mDrawSettings.drawQ1)
			return;
		if (qPane == Consts.QPANE_3D)
			return; // under-filled is OK
		if (qPane == Consts.QPANE_ALL) {
			clipCoveredPath(path, blockField, Consts.QPANE_0, extraRows,
					clipOffset);
			clipCoveredPath(path, blockField, Consts.QPANE_1, extraRows,
					clipOffset);
			clipCoveredPath(path, blockField, Consts.QPANE_3D, extraRows,
					clipOffset);
			return;
		}

		int top_y = mDrawSettings.getBlockYPosition(qPane, -1) + clipOffset.y;
		for (int row = 0; row < mDrawSettings.displayedRows + extraRows; row++) {
			top_y -= mDrawSettings.size_blockHeight;
			int posRow = row + mDrawSettings.blockFieldOuterBuffer;

			int left_x = mDrawSettings.getBlockXPosition(qPane, -1)
					+ clipOffset.x;
			for (int col = 0; col < mDrawSettings.COLS; col++) {
				left_x += mDrawSettings.size_blockWidth;

				int posCol = col + mDrawSettings.blockFieldOuterBuffer;
				int qo = blockField[qPane][posRow][posCol];
				int border_behavior = mDrawSettings.behavior_qo_border[qo];

				switch (border_behavior) {
				case DrawSettings.BEHAVIOR_QO_BORDER_NONE:
					break;

				case DrawSettings.BEHAVIOR_QO_BORDER_INNER:
				case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER:
				case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY:
				case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY_BLEND:
				case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE:
				case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE:
					// all of these indicate a full-square.
                    unionRect(path, left_x, top_y,
							left_x + mDrawSettings.size_blockWidth, top_y
									+ mDrawSettings.size_blockHeight,
							Path.Direction.CW);
					break;

				case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INSET:
				case DrawSettings.BEHAVIOR_QO_BORDER_Q_PANE_INSET:
					// a square inset by a predictable amount.
					unionRect(path, left_x + mDrawSettings.size_innerBorderXInset,
							top_y + mDrawSettings.size_innerBorderYInset,
							left_x + mDrawSettings.size_blockWidth
									- mDrawSettings.size_innerBorderXInset,
							top_y + mDrawSettings.size_blockHeight
									- mDrawSettings.size_innerBorderYInset,
							Path.Direction.CW);
					break;

				case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI:
					// a square inset by a greater, but still predictable
					// amount.
					unionRect(path, left_x + mDrawSettings.size_miniBorderXInset,
							top_y + mDrawSettings.size_miniBorderYInset, left_x
									+ mDrawSettings.size_blockWidth
									- mDrawSettings.size_miniBorderXInset,
							top_y + mDrawSettings.size_blockHeight
									- mDrawSettings.size_miniBorderYInset,
							Path.Direction.CW);
					break;

				case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_HORIZONTAL_OVER:
				case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_VERTICAL_OVER:
					// slightly complex; normally we would ignore. However,
					// because we know
					// use the union of "Covered" as our paint_background_piece
					// fill region
					// (we can't just draw bg fills to each layer separately,
					// they all need
					// to be applied together) we need an exact fill region
					// here. Thankfully,
					// we have one.
                    tempPath.set(customFillPath_byQPane_QOrientation[qPane][qo]);
                    tempPath.offset(left_x, top_y);
					op(path, tempPath, Path.Op.UNION);
					break;

				default:
					throw new IllegalArgumentException(
							"clipCoveredPath: can't handle QO_BORDER behavior "
									+ border_behavior);
				}
			}
		}
	}

	/**
	 * Clips (via UNION) those pixels which are touched by the specified
	 * blockfield in the specified qPane.
	 * 
	 * "Touched" indicates that the value of the pixel is influenced by the
	 * layer; e.g. the interior of a semi-transparent fill is touched, as is the
	 * drop-shadow. (incidentally, the former is also 'covered' while the later
	 * is not).
	 * 
	 * This method will err on the side of over-inclusion - every pixel with
	 * nonzero alpha will be UNION clipped, and possibly a few pixels with zero
	 * alpha as well.
	 * 
	 * If 'extendByPixels' is negative, this method makes calls to
	 * boundDropShadowWidth/Height. Otherwise, the extendByPixels value is used.
	 * 
	 * @param path
	 * @param blockField
	 * @param clipOffset
	 * @param extendByPixels
	 */
	private void clipTouchedPath(Path path, byte[][][] blockField,
                                 BlockDrawerConfigRange configRange, int qPane, Offset clipOffset,
                                 int extendByPixels) {
		if (extendByPixels < 0)
			extendByPixels = Math.max(this.boundDropShadowWidth(mDrawSettings),
					this.boundDropShadowHeight(mDrawSettings));

		if (qPane == 0 && !mDrawSettings.drawQ0)
			return;
		if (qPane == 1 && !mDrawSettings.drawQ1)
			return;
		if (qPane == Consts.QPANE_ALL) {
			clipTouchedPath(path, blockField, configRange, Consts.QPANE_0,
					clipOffset, extendByPixels);
			clipTouchedPath(path, blockField, configRange, Consts.QPANE_1,
					clipOffset, extendByPixels);
			clipTouchedPath(path, blockField, configRange, Consts.QPANE_3D,
					clipOffset, extendByPixels);
			return;
		}

		if (qPane != Consts.QPANE_3D) {
			int top_y = mDrawSettings.getBlockYPosition(qPane,
					configRange.rowFirst - 1) + clipOffset.y;
			for (int posRow = configRange.indexRowFirst; posRow < configRange.indexRowBound; posRow++) {
				top_y -= mDrawSettings.size_blockHeight;

				int left_x = mDrawSettings.getBlockXPosition(qPane, -1)
						+ clipOffset.x;
				for (int posCol = configRange.indexColFirst; posCol < configRange.indexColBound; posCol++) {
					left_x += mDrawSettings.size_blockWidth;

					// int col = configRange.indexToCol( posCol ) ;
					// int posCol = configRange.colToIndex(col);
					int qo = blockField[qPane][posRow][posCol];
					int border_behavior = mDrawSettings.behavior_qo_border[qo];

					switch (border_behavior) {
					case DrawSettings.BEHAVIOR_QO_BORDER_NONE:
						break;

					case DrawSettings.BEHAVIOR_QO_BORDER_INNER:
					case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER:
					case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY:
					case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY_BLEND:
					case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE:
					case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE:
						// all of these indicate a full-square.
						unionRect(path, left_x - extendByPixels, top_y
								- extendByPixels,
								left_x + mDrawSettings.size_blockWidth
										+ extendByPixels,
								top_y + mDrawSettings.size_blockHeight
										+ extendByPixels, Path.Direction.CW);
						break;

					case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INSET:
					case DrawSettings.BEHAVIOR_QO_BORDER_Q_PANE_INSET:
						// a square inset by a predictable amount.
						unionRect(path, left_x + mDrawSettings.size_innerBorderXInset
								- extendByPixels, top_y
								+ mDrawSettings.size_innerBorderYInset
								- extendByPixels,
								left_x + mDrawSettings.size_blockWidth
										- mDrawSettings.size_innerBorderXInset
										+ extendByPixels,
								top_y + mDrawSettings.size_blockHeight
										- mDrawSettings.size_innerBorderYInset
										+ extendByPixels, Path.Direction.CW);
						break;

					case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI:
					case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_HORIZONTAL_OVER:
					case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_VERTICAL_OVER:
						// MINI is a square inset by a greater, but still
						// predictable amount.
						// MINI_NONOVERLAP is slightly complex. An inset square
						// that does not overlap with
						// its QOrientation.
						// In keeping with our "over-represented" promize, we
						// can safely clip the entire
						// thing as if it overlapped.
						unionRect(path, left_x + mDrawSettings.size_miniBorderXInset
								- extendByPixels, top_y
								+ mDrawSettings.size_miniBorderYInset
								- extendByPixels,
								left_x + mDrawSettings.size_blockWidth
										- mDrawSettings.size_miniBorderXInset
										+ extendByPixels,
								top_y + mDrawSettings.size_blockHeight
										- mDrawSettings.size_miniBorderYInset
										+ extendByPixels, Path.Direction.CW);
						break;

					default:
						throw new IllegalArgumentException(
								"clipTouchedRegion: can't handle QO_BORDER behavior "
										+ border_behavior);
					}
				}
			}
		} else {
			int boundWidth = mDrawSettings.size_blockWidth
					+ Math.abs(mDrawSettings.size_qXOffset);
			int boundHeight = mDrawSettings.size_blockHeight
					+ Math.abs(mDrawSettings.size_qYOffset);

			// use the top/left bounds. Add boundWidth / boundHeight when
			// necessary.
			int top_y = mDrawSettings.getBlockYPosition(-1,
					configRange.rowFirst - 1) + clipOffset.y;
			for (int posRow = configRange.indexRowFirst; posRow < configRange.indexRowBound; posRow++) {
				top_y -= mDrawSettings.size_blockHeight;

				int left_x = mDrawSettings.getBlockXPosition(-1, -1)
						+ clipOffset.x;
				for (int posCol = configRange.indexColFirst; posCol < configRange.indexColBound; posCol++) {
					left_x += mDrawSettings.size_blockWidth;
					
					int qo = blockField[0][posRow][posCol];
					int behavior_3d = mDrawSettings.behavior_qo_3d[qo];

					// because over-representation is fine, we do something you
					// might consider extreme: if 3D behavior is anything but
					// NONE,
					// we clip a bounding box around this square in both panes.
					// We
					// assume 3D structures do not extend beyond this box.
					if (behavior_3d != DrawSettings.BEHAVIOR_QO_3D_NONE) {
						unionRect(path, left_x, top_y, left_x + boundWidth, top_y
								+ boundHeight, Path.Direction.CW);
					}
				}
			}
		}
	}

	private Path tempClipPath = path();

	private void clipGlowSetsIntersection(Canvas canvas, int qPane,
			ArrayList<short[][]> glowSets, int firstSet, int numSets,
			int extraRows, Offset clipOffset) {

        reset(tempClipPath);
		clipGlowSets(tempClipPath, qPane, glowSets, firstSet, numSets,
				extraRows, clipOffset);
		canvas.clipPath(tempClipPath);
	}

	private void clipGlowSets(Path p, int qPane,
			ArrayList<short[][]> glowSets, int firstSet, int numSets,
			int extraRows, Offset clipOffset) {

		int UNSET = Integer.MIN_VALUE;

		for (int index = firstSet; index < firstSet + numSets; index++) {
			short[][] thisGlowSet = glowSets.get(index);
			// everything in the glow set other than "NONE" gets a clip.
			for (int posRow = 0; posRow < 2
					* mDrawSettings.blockFieldOuterBuffer
					+ mDrawSettings.displayedRows + extraRows; posRow++) {
				int top_y = UNSET;
				int row = posRow - mDrawSettings.blockFieldOuterBuffer;
				for (int posCol = 0; posCol < 2
						* mDrawSettings.blockFieldOuterBuffer
						+ mDrawSettings.COLS; posCol++) {
					int col = posCol - mDrawSettings.blockFieldOuterBuffer;
					if (thisGlowSet[posRow][posCol] != BlockDrawer.GLOW_SET_INDEX_NONE) {
						int left_x = mDrawSettings
								.getBlockXPosition(qPane, col) + clipOffset.x;
						if (top_y == UNSET)
							top_y = mDrawSettings.getBlockYPosition(qPane, row)
									+ clipOffset.y;

						unionRect(p, left_x, top_y,
								left_x + mDrawSettings.size_blockWidth,
								top_y + mDrawSettings.size_blockHeight,
								Path.Direction.CW);
					}
				}
			}
		}
	}

	private void clipGlowEffectIntersection(Canvas canvas, GlowEffect glowEffect,
			int extraRows, Offset clipOffset) {

		reset(tempClipPath);
		clipGlowEffect(tempClipPath, glowEffect, extraRows, clipOffset);
		canvas.clipPath(tempClipPath);
	}

	private void clipGlowEffect(Path p, GlowEffect glowEffect, int extraRows, Offset clipOffset) {
		int UNSET = Integer.MIN_VALUE;

		short[][] thisGlowSet = glowEffect.directDrawCodeAccess();
		int qPane = glowEffect.qPane();
		// everything in the glow set other than "NONE" gets a clip.
		for (int posRow = 0; posRow < 2 * mDrawSettings.blockFieldOuterBuffer
				+ mDrawSettings.displayedRows + extraRows; posRow++) {
			int top_y = UNSET;
			int row = posRow - mDrawSettings.blockFieldOuterBuffer;
			for (int posCol = 0; posCol < 2
					* mDrawSettings.blockFieldOuterBuffer + mDrawSettings.COLS; posCol++) {
				int col = posCol - mDrawSettings.blockFieldOuterBuffer;
				if (thisGlowSet[posRow][posCol] != BlockDrawer.GLOW_SET_INDEX_NONE) {
					int left_x = mDrawSettings.getBlockXPosition(qPane, col)
							+ clipOffset.x;
					if (top_y == UNSET)
						top_y = mDrawSettings.getBlockYPosition(qPane, row)
								+ clipOffset.y;

					unionRect(p, left_x, top_y,
							left_x + mDrawSettings.size_blockWidth,
                            top_y + mDrawSettings.size_blockHeight,
							Path.Direction.CW);
				}
			}
		}
	}

	/**
	 * Can be "extended" around each square by the specified number of pixels.
	 * 
	 * @param canvas
	 * @param field1
	 * @param field2
	 * @param clipOffset
	 */
	private void clipContentDifferenceIntersection(Canvas canvas, byte[][][] field1,
			byte[][][] field2, Offset clipOffset, int extendByPixels) {
		for (int qp = 0; qp < 2; qp++)
			clipContentDifferenceIntersection(canvas, field1, field2, qp, clipOffset,
					extendByPixels);
	}

	private void clipContentDifferenceIntersection(Canvas canvas, byte[][][] field1,
			byte[][][] field2, int qPane, Offset clipOffset, int extendByPixels) {
		reset(tempClipPath);
		clipContentDifference(tempClipPath, field1, field2, qPane,
				clipOffset, extendByPixels);
		canvas.clipPath(tempClipPath);
	}

	/**
	 * Can be "extended" around each square by the specified number of pixels.
	 * 
	 * @param path
	 * @param field1
	 * @param field2
	 * @param clipOffset
	 */
	private void clipContentDifference(Path path, byte[][][] field1,
			byte[][][] field2, int qPane, Offset clipOffset, int extendByPixels) {
		if (qPane == Consts.QPANE_ALL) {
			clipContentDifference(path, field1, field2, Consts.QPANE_0,
					clipOffset, extendByPixels);
			clipContentDifference(path, field1, field2, Consts.QPANE_1,
					clipOffset, extendByPixels);
			clipContentDifference(path, field1, field2, Consts.QPANE_3D,
					clipOffset, 0);
		}

		if (qPane == 0 && !mDrawSettings.drawQ0)
			return;
		if (qPane == 1 && !mDrawSettings.drawQ1)
			return;
		if (qPane == Consts.QPANE_3D && !mDrawSettings.draw3D)
			return;

		if (qPane != Consts.QPANE_3D) {
			int top_y = mDrawSettings.getBlockYPosition(qPane, -1)
					+ clipOffset.y;
			for (int row = 0; row < mDrawSettings.displayedRows; row++) {
				top_y -= mDrawSettings.size_blockHeight;
				int posRow = row + mDrawSettings.blockFieldOuterBuffer;

				int left_x = mDrawSettings.getBlockXPosition(qPane, -1)
						+ clipOffset.x;
				for (int col = 0; col < mDrawSettings.COLS; col++) {
					left_x += mDrawSettings.size_blockWidth;
					int posCol = col + mDrawSettings.blockFieldOuterBuffer;
					int qo1 = field1[qPane][posRow][posCol];
					int qo2 = field2[qPane][posRow][posCol];
					if (qo1 != qo2) {
						unionRect(path, left_x - extendByPixels, top_y
								- extendByPixels,
								left_x + mDrawSettings.size_blockWidth
										+ extendByPixels,
								top_y + mDrawSettings.size_blockHeight
										+ extendByPixels, Path.Direction.CW);
					}
				}
			}
		} else {
			int boundWidth = mDrawSettings.size_blockWidth
					+ Math.abs(mDrawSettings.size_qXOffset);
			int boundHeight = mDrawSettings.size_blockHeight
					+ Math.abs(mDrawSettings.size_qYOffset);

			for (int qp = 0; qp < 2; qp++) {
				int top_y = mDrawSettings.getBlockYPosition(-1, -1)
						+ clipOffset.y;
				for (int row = 0; row < mDrawSettings.displayedRows; row++) {
					top_y -= mDrawSettings.size_blockHeight;
					int posRow = row + mDrawSettings.blockFieldOuterBuffer;

					int left_x = mDrawSettings.getBlockXPosition(-1, -1)
							+ clipOffset.x;
					for (int col = 0; col < mDrawSettings.COLS; col++) {
						left_x += mDrawSettings.size_blockWidth;
						int posCol = col + mDrawSettings.blockFieldOuterBuffer;
						int qo1 = field1[qp][posRow][posCol];
						int qo2 = field2[qp][posRow][posCol];

						if (mDrawSettings.behavior_qo_3d[qo1] == DrawSettings.BEHAVIOR_QO_3D_NONE
								&& mDrawSettings.behavior_qo_3d[qo2] == DrawSettings.BEHAVIOR_QO_3D_NONE)
							continue;

						if (qo1 != qo2) {
							unionRect(path, left_x - extendByPixels, top_y
									- extendByPixels, left_x + boundWidth
									+ extendByPixels, top_y + boundHeight
									+ extendByPixels, Path.Direction.CW);
						}
					}
				}
			}
		}
	}

	/**
	 * Compares the two fields provided, conservatively clipping the difference
	 * between them. The fields are assumed to be drawn in the same location,
	 * with field1 the content of a previous draw, field2 the content of this
	 * draw.
	 * 
	 * Guarantees: we will clip such that
	 * 
	 * 1. any block whose QO has change will be clipped to fully contain the
	 * elements within.
	 * 
	 * 2. any block containing a border whose length has changed will be fully
	 * clipped.
	 * 
	 * We may clip beyond the above.
	 * 
	 * PRECONDITION: mDrawSettings.blockFieldOuterBuffer is at least 1.
	 * 
	 * @param path
	 * @param field1
	 * @param field2
	 * @param clipOffset
	 */
	private void clipConservativeDifference(Path path, byte[][][] field1,
			byte[][][] field2, int extraRows, Offset clipOffset,
			int extendByPixels) {
		clipConservativeDifference(path, field1, field2, Consts.QPANE_ALL,
				extraRows, clipOffset, extendByPixels);
	}

	/**
	 * Compares the two fields provided, conservatively clipping the difference
	 * between them. The fields are assumed to be drawn in the same location,
	 * with field1 the content of a previous draw, field2 the content of this
	 * draw.
	 * 
	 * Guarantees: we will clip such that
	 * 
	 * 1. any block whose QO has change will be clipped to fully contain the
	 * elements within.
	 * 
	 * 2. any block containing a border whose length has changed will be fully
	 * clipped.
	 * 
	 * We may clip beyond the above.
	 * 
	 * PRECONDITION: mDrawSettings.blockFieldOuterBuffer is at least 1.
	 *
	 * @param field1
	 * @param field2
	 * @param clipOffset
	 */
	private void clipConservativeDifference(Path path, byte[][][] field1,
			byte[][][] field2, int qPane, int extraRows, Offset clipOffset,
			int extendByPixels) {

		if (qPane == Consts.QPANE_ALL) {
			clipConservativeDifference(path, field1, field2, Consts.QPANE_0,
					extraRows, clipOffset, extendByPixels);
			clipConservativeDifference(path, field1, field2, Consts.QPANE_1,
					extraRows, clipOffset, extendByPixels);
			clipConservativeDifference(path, field1, field2, Consts.QPANE_3D,
					extraRows, clipOffset, 0);
			return;
		}

		if (mDrawSettings.blockFieldOuterBuffer < 1)
			throw new IllegalStateException(
					"clipConservativeDifference relies on mDrawSettings.blockFieldOuterBuffer >= 1");

		// simplest possible implementation: to guarantee #1, we clip any
		// block whose value has changed, and (if 3d) we clip a larger
		// bounding area around the block. To guarantee #2, we clip any
		// block which occurs on a border, even if its value has not changed.

		// We define "occurs on a border" as being
		// BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER,
		// BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE,
		// BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY,
		// or BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY_BLEND and having a
		// 'false' response
		// in any direction to fillRegionConnects (or being in the 1st / last
		// column or row).

		if (qPane == 0 && !mDrawSettings.drawQ0)
			return;
		if (qPane == 1 && !mDrawSettings.drawQ1)
			return;
		if (qPane == Consts.QPANE_3D && !mDrawSettings.draw3D)
			return;

		// We fulfill #1 and #2 by direct, naive examination.
		if (qPane != Consts.QPANE_3D) {
			int top_y = mDrawSettings.getBlockYPosition(qPane, -1) + clipOffset.y;
			for (int row = 0; row < mDrawSettings.displayedRows + extraRows; row++) {
				top_y -= mDrawSettings.size_blockHeight;
				int posRow = row + mDrawSettings.blockFieldOuterBuffer;

				int left_x = mDrawSettings.getBlockXPosition(qPane, -1) + clipOffset.x;

				for (int col = 0; col < mDrawSettings.COLS; col++) {
					left_x += mDrawSettings.size_blockWidth;
					int posCol = col + mDrawSettings.blockFieldOuterBuffer;
					int qo1 = field1[qPane][posRow][posCol];
					int qo2 = field2[qPane][posRow][posCol];

					boolean clip = false;

					if (qo1 != qo2) {
						clip = true;
					} else {
						// check for borders
						int behavior = mDrawSettings.behavior_qo_border[qo1];
						if (behavior == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER
								|| behavior == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE
								|| behavior == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY
								|| behavior == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY_BLEND
								|| behavior == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE) {

							// examine in all directions, possibly clip.

							for (int rowOffset = -1; rowOffset < 2 && !clip; rowOffset++) {
								for (int colOffset = -1; colOffset < 2 && !clip; colOffset++) {
									clip = clip
											|| !mDrawSettings
													.fillRegionConnects(
															qo1,
															field1[qPane][posRow
																	+ rowOffset][posCol
																	+ colOffset])
											|| !mDrawSettings
													.fillRegionConnects(
															qo2,
															field2[qPane][posRow
																	+ rowOffset][posCol
																	+ colOffset]);
								}
							}
						}
					}

					if (clip) {
						unionRect(path, left_x - extendByPixels, top_y - extendByPixels,
								left_x + mDrawSettings.size_blockWidth + extendByPixels,
								top_y + mDrawSettings.size_blockHeight + extendByPixels,
                                Path.Direction.CW);
					}
				}
			}
		} else {
			int boundWidth = mDrawSettings.size_blockWidth
					+ Math.abs(mDrawSettings.size_qXOffset);
			int boundHeight = mDrawSettings.size_blockHeight
					+ Math.abs(mDrawSettings.size_qYOffset);

			for (int qp = 0; qp < 2; qp++) {
				int top_y = mDrawSettings.getBlockYPosition(-1, -1)
						+ clipOffset.y;
				for (int row = 0; row < mDrawSettings.displayedRows + extraRows; row++) {
					top_y -= mDrawSettings.size_blockHeight;
					int posRow = row + mDrawSettings.blockFieldOuterBuffer;

					int left_x = mDrawSettings.getBlockXPosition(-1, -1)
							+ clipOffset.x;
					for (int col = 0; col < mDrawSettings.COLS; col++) {
						left_x += mDrawSettings.size_blockWidth;
						int posCol = col + mDrawSettings.blockFieldOuterBuffer;
						int qo1 = field1[qp][posRow][posCol];
						int qo2 = field2[qp][posRow][posCol];

						boolean clip = false;

						if (mDrawSettings.behavior_qo_3d[qo1] == DrawSettings.BEHAVIOR_QO_3D_NONE
								&& mDrawSettings.behavior_qo_3d[qo2] == DrawSettings.BEHAVIOR_QO_3D_NONE)
							continue;

						if (qo1 != qo2) {
							clip = true;
						} else {
							// check for borders
							int behavior = mDrawSettings.behavior_qo_3d[qo1];
							if (behavior == DrawSettings.BEHAVIOR_QO_3D_PAINT_BORDER_EXTRUDED_SIDES_ONLY) {
								// examine in all directions, possibly clip.

								for (int rowOffset = -1; rowOffset < 2 && !clip; rowOffset++) {
									for (int colOffset = -1; colOffset < 2
											&& !clip; colOffset++) {
										clip = clip
												|| !mDrawSettings
														.fillRegionConnects(
																qo1,
																field1[qp][posRow
																		+ rowOffset][posCol
																		+ colOffset])
												|| !mDrawSettings
														.fillRegionConnects(
																qo2,
																field2[qp][posRow
																		+ rowOffset][posCol
																		+ colOffset]);
									}
								}
							} else if (behavior == DrawSettings.BEHAVIOR_QO_3D_PAINT_EXTRUDED_QO_PULSE_BOX) {
								// examine in all directions, possibly clip.

								for (int rowOffset = -1; rowOffset < 2 && !clip; rowOffset++) {
									for (int colOffset = -1; colOffset < 2
											&& !clip; colOffset++) {
										clip = clip
												|| qo1 != field1[qp][posRow
														+ rowOffset][posCol
														+ colOffset]
												|| qo2 != field2[qp][posRow
														+ rowOffset][posCol
														+ colOffset];
									}
								}
							}
						}

						if (clip) {
							unionRect(path, left_x, top_y, left_x + boundWidth, top_y
									+ boundHeight, Path.Direction.CW);
						}
					}
				}
			}
		}
	}

	/**
	 * Compares the two fields provided, conservatively clipping the difference
	 * between them. The fields are assumed to be drawn at different locations.
	 * If clipOffset1 equiv. clipOffset2, or clipOffset2 == null, this method is
	 * equivalent to the 1-offset parameterized version.
	 * 
	 * If the clipOffsets are different, then in addition to looking for block
	 * changes we look for motion that would produce a block change. We assume
	 * field2 is to be drawn at clipOffset2.
	 * 
	 * Guarantees: we will clip such that
	 * 
	 * 1. any block whose QO has change will be clipped to fully contain the
	 * elements within.
	 * 
	 * 2. any block containing a border whose length has changed will be fully
	 * clipped.
	 * 
	 * 3. any pixel whose value has changed due to the shift will be clipped
	 * 
	 * We may clip beyond the above.
	 * 
	 * PRECONDITION: mDrawSettings.blockFieldOuterBuffer is at least 1. The two
	 * offsets, if different, are different only in y (they have identical x).
	 *
	 * @param field1
	 * @param field2
	 */
	private void clipConservativeDifference(Path path, byte[][][] field1,
			byte[][][] field2, int extraRows, Offset clipOffset1,
			Offset clipOffset2, int extendByPixels) {

		if (clipOffset2 == null
				|| (clipOffset2.x == clipOffset1.x && clipOffset2.y == clipOffset1.y)) {

			clipConservativeDifference(path, field1, field2, extraRows,
					clipOffset1, extendByPixels);
			return;
		}

		if (mDrawSettings.blockFieldOuterBuffer < 1)
			throw new IllegalStateException(
					"clipConservativeDifference relies on mDrawSettings.blockFieldOuterBuffer >= 1");
		if (clipOffset2.x != clipOffset1.x)
			throw new IllegalArgumentException(
					"clipConvservativeDifference requires offset1.x == offset2.x");

		// Unlike the simpler one offset method, we cannot simply compare blocks
		// in the same position. We take a relatively naive approach to work
		// around this
		// (knowing that the benefit of limited clipped will probably outweigh
		// the extra effort here). We examine the fields in sequence, comparing
		// 1 against 2 and then 2 against 1. For each comparison, we choose
		// whether
		// to clip the boundaries of the square (or slightly beyond for 3d
		// boundaries).

		// Remember that we can safely assume a vertical translation > 0 by the
		// checks above.
		// Following this translation, a block (A) in 1 overlaps with two blocks
		// (B, C) in 2.
		// We clip A (within or extended beyond borders according to 3D
		// behavior) if any
		// of the following is true:

		// A has a qo which differs from either B or C
		//
		// A has border behavior other than INNER_*, has TOP values, or has 3D
		// prisms.
		//
		// A, B and C have INNER_* behavior, and any one of them a border in any
		// direction.

		// For the purposes of the above, any block outside the bounds of a
		// field is
		// considered to be NO.

		// We define "occurs on a border" as being
		// BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER,
		// BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY,
		// or BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY_BLEND and having a
		// 'false' response
		// in any direction to fillRegionConnects (or being in the 1st / last
		// column or row).
		
		
		// OPTIMIZATION TARGET: this method, in massive cascade tests, accounts for 4.6% of
		// CPU time, taking 13.394 cycles per call.  We wish to reduce this time sink, especially
		// because it is called at every tick during drawChunksFalling.

		// Iteration bounds: we iterate indices over these ranges.
		int rowMax = mDrawSettings.displayedRows + extraRows;
		
		int rFirst = mDrawSettings.blockFieldOuterBuffer ;
		int rBound = rowMax + mDrawSettings.blockFieldOuterBuffer ;
		int cFirst = mDrawSettings.blockFieldOuterBuffer ;
		int cBound = mDrawSettings.COLS + mDrawSettings.blockFieldOuterBuffer ;

		// this method is often called with both fields identical.  That's 
		for (int fieldNum = 0; fieldNum < 2; fieldNum++) {

			byte[][][] fieldA;
			byte[][][] fieldB;
			Offset clipOffset;

			int rowOffsetB, rowOffsetC;

			if (fieldNum == 0) {
				fieldA = field1;
				fieldB = field2;
				clipOffset = clipOffset1;
				rowOffsetB = -(int) Math
						.floor(((double) clipOffset2.y - clipOffset1.y)
								/ mDrawSettings.size_blockHeight);
				rowOffsetC = -(int) Math
						.ceil(((double) clipOffset2.y - clipOffset1.y)
								/ mDrawSettings.size_blockHeight);
				// add this offset to row in field1 to get the row in field2.
				// We negate because a positive change in y is a NEGATIVE change
				// in row number.
			} else {
				fieldA = field2;
				fieldB = field1;
				clipOffset = clipOffset2;
				rowOffsetB = -(int) Math
						.floor(((double) clipOffset1.y - clipOffset2.y)
								/ mDrawSettings.size_blockHeight);
				rowOffsetC = -(int) Math
						.ceil(((double) clipOffset1.y - clipOffset2.y)
								/ mDrawSettings.size_blockHeight);
				// add this offset to row in field1 to get the row in field2.
				// We negate because a positive change in y is a NEGATIVE change
				// in row number.
			}
			
			// Clipping bounds: we clip a "bounding box" for each different square.  We can
			// precompute the dimension of that box; the only change needed is to add the 
			// "block X, block Y" position at the appropriate time.
			int clip2DLeftX = clipOffset.x - extendByPixels ;
			int clip2DRightX = clip2DLeftX + extendByPixels*2 + mDrawSettings.size_blockWidth ;
			int clip2DTopY = clipOffset.y - extendByPixels ;
			int clip2DBottomY = clip2DTopY + extendByPixels*2 + mDrawSettings.size_blockHeight ;
			// add the block X, block Y to these to get the bounds.  Use the current qPane.
			
			int clip3DLeftX = clip2DLeftX ;
			int clip3DRightX = clip2DRightX + Math.abs( mDrawSettings.size_qXOffset ) ;
			int clip3DTopY = clip2DTopY ;
			int clip3DBottomY = clip2DBottomY + Math.abs( mDrawSettings.size_qYOffset ) ;
			// add the block X, block Y to these to get the bounds.  Use qPane "-1".

			for (int qp = 0; qp < 2; qp++) {
				if (qp == 0 && !mDrawSettings.drawQ0)
					continue;
				if (qp == 1 && !mDrawSettings.drawQ1)
					continue;

				// We fulfill #1 and #2 by direct, naive examination.
				for (int posRow = rFirst; posRow < rBound; posRow++) {
					int row = posRow - mDrawSettings.blockFieldOuterBuffer ;
					int posRowB = posRow + rowOffsetB ;
					int posRowC = posRow + rowOffsetC ;
					for (int posCol = cFirst; posCol < cBound; posCol++) {
						boolean clip = false;
						
						int qoA = fieldA[qp][posRow][posCol];
						int qoB = (posRowB < rFirst || posRowB >= rBound) ? QOrientations.NO
								: fieldB[qp][posRowB][posCol];
						int qoC = (posRowC < rFirst || posRowC >= rBound) ? QOrientations.NO
								: fieldB[qp][posRowC][posCol];

						if (qoA != qoB || qoA != qoC) {
							clip = true ;
						} else {
							// All have the same QO. Look for TOP or 3D
							// behavior.
							int behaviorTop = mDrawSettings.behavior_qo_top[qoA];
							int behavior3D = mDrawSettings.behavior_qo_3d[qoA];
							int behaviorBorder = mDrawSettings.behavior_qo_border[qoA];

							if (behaviorTop != DrawSettings.BEHAVIOR_QO_TOP_NONE
									|| behavior3D != DrawSettings.BEHAVIOR_QO_3D_NONE) {
								// TODO: change this to allow 3d extruded walls
								// w/o border?
								clip = true;
							} else {
								switch( behaviorBorder ) {
								case DrawSettings.BEHAVIOR_QO_BORDER_NONE:
									// nope
									break ;
									
								case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER:
								case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE:
								case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY:
								case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY_BLEND:
								case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE:
									// check all three for clip.  helpful assumption: the fields have zeros
									// outside their boundaries.  thus, because all three values have
									// QOrientation that allows inner borders, all three are within the
									// boundaries and we can safely examine 1 step out.
									for (int rowOffset = -1; rowOffset < 2 && !clip; rowOffset++) {
										for (int colOffset = -1; colOffset < 2 && !clip; colOffset++) {
											clip = clip
													|| !mDrawSettings.fillRegionConnects(
																	qoA,
																	fieldA[qp]
																	       [posRow + rowOffset]
																	        [posCol + colOffset])
													|| !mDrawSettings.fillRegionConnects(
																	qoB,
																	fieldB[qp][posRowB + rowOffset]
																	           [posCol + colOffset])
													|| !mDrawSettings.fillRegionConnects(
																	qoC,
																	fieldB[qp][posRowC + rowOffset]
																	           [posCol + colOffset]);
										}
									}
									break ;
									
								default:
									// anything else and we do clip.
									clip = true ;
									break ;
								}
							}
						}

						// do the clipping
						if (clip) {
							int col = posCol - mDrawSettings.blockFieldOuterBuffer ;
							// log( 
							// "clipConservativeDifference: should clip at " +
							// row + ", " + col) ;
							int block_x, block_y;
							if (qp == 0
									&& (mDrawSettings.behavior_qo_3d[qoA] != DrawSettings.BEHAVIOR_QO_3D_NONE)) {
								block_x = mDrawSettings.getBlockXPosition(-1, col) ;
								block_y = mDrawSettings.getBlockYPosition(-1, row) ;
								unionRect(path, 
										clip3DLeftX + block_x,
										clip3DTopY + block_y,
										clip3DRightX + block_x,
										clip3DBottomY + block_y,
										Path.Direction.CW);
							} else {
								block_x = mDrawSettings.getBlockXPosition(qp, col) ;
								block_y = mDrawSettings.getBlockYPosition(qp, row) ;
								unionRect(path, 
										clip2DLeftX + block_x,
										clip2DTopY + block_y,
										clip2DRightX + block_x,
										clip2DBottomY + block_y,
										Path.Direction.CW);
							}
						}
					}
				}
			}
		}
	}

	private void clipConservativeDifferenceIntersection(Canvas canvas, byte[][][] field1,
			byte[][][] field2, int extraRows, Offset clipOffset1,
			Offset clipOffset2, int extendByPixels) {
		reset(tempClipPath);
		clipConservativeDifference(tempClipPath, field1, field2, extraRows,
				clipOffset1, clipOffset2, extendByPixels);
		canvas.clipPath(tempClipPath);
	}

	private void clipContentUnionIntersection(Canvas canvas, byte[][][] blockField,
			Offset clipOffset, int extendByPixels) {
	    reset(tempClipPath);
		for (int qp = 0; qp < 2; qp++) {
            clipContentUnion(tempClipPath, blockField, qp, 0, clipOffset, extendByPixels);
        }
        canvas.clipPath(tempClipPath);
	}

	private void clipContentUnionIntersection(Canvas canvas, byte[][][] blockField,
			int qPane, Offset clipOffset, int extendByPixels) {
		reset(tempClipPath);
		clipContentUnion(tempClipPath, blockField, qPane, 0, clipOffset, extendByPixels);
		canvas.clipPath(tempClipPath);
	}

    private void clipContentUnion(Path path, byte[][][] blockField, Offset clipOffset, int extendByPixels) {
        for (int qp = 0; qp < 2; qp++) {
            clipContentUnion(path, blockField, qp, 0, clipOffset, extendByPixels);
        }
    }

	private void clipContentUnion(Path path, byte[][][] blockField,
			int qPane, int extraRows, Offset clipOffset, int extendByPixels) {
		if (qPane == Consts.QPANE_ALL) {
			clipContentUnion(path, blockField, Consts.QPANE_0, extraRows,
					clipOffset, extendByPixels);
			clipContentUnion(path, blockField, Consts.QPANE_1, extraRows,
					clipOffset, extendByPixels);
			clipContentUnion(path, blockField, Consts.QPANE_3D, extraRows,
					clipOffset, 0);
			return;
		}

		if (qPane == 0 && !mDrawSettings.drawQ0)
			return;
		if (qPane == 1 && !mDrawSettings.drawQ1)
			return;
		if (qPane == Consts.QPANE_3D && !mDrawSettings.draw3D)
			return;

		if (qPane != Consts.QPANE_3D) {
			int top_y = mDrawSettings.getBlockYPosition(qPane, -1)
					+ clipOffset.y;
			for (int row = 0; row < mDrawSettings.displayedRows; row++) {
				top_y -= mDrawSettings.size_blockHeight;
				int posRow = row + mDrawSettings.blockFieldOuterBuffer;

				int left_x = mDrawSettings.getBlockXPosition(qPane, -1)
						+ clipOffset.x;
				for (int col = 0; col < mDrawSettings.COLS; col++) {
					left_x += mDrawSettings.size_blockWidth;
					int posCol = col + mDrawSettings.blockFieldOuterBuffer;
					int qo = blockField[qPane][posRow][posCol];
					if (qo != QOrientations.NO) {
						unionRect(path, left_x - extendByPixels, top_y
								- extendByPixels,
								left_x + mDrawSettings.size_blockWidth
										+ extendByPixels,
								top_y + mDrawSettings.size_blockHeight
										+ extendByPixels, Path.Direction.CW);
					}
				}
			}
		} else {
			int boundWidth = mDrawSettings.size_blockWidth
					+ Math.abs(mDrawSettings.size_qXOffset);
			int boundHeight = mDrawSettings.size_blockHeight
					+ Math.abs(mDrawSettings.size_qYOffset);

			for (int qp = 0; qp < 2; qp++) {
				int top_y = mDrawSettings.getBlockYPosition(-1, -1)
						+ clipOffset.y;
				for (int row = 0; row < mDrawSettings.displayedRows; row++) {
					top_y -= mDrawSettings.size_blockHeight;
					int posRow = row + mDrawSettings.blockFieldOuterBuffer;

					int left_x = mDrawSettings.getBlockXPosition(-1, -1)
							+ clipOffset.x;
					for (int col = 0; col < mDrawSettings.COLS; col++) {
						left_x += mDrawSettings.size_blockWidth;
						int posCol = col + mDrawSettings.blockFieldOuterBuffer;
						int qo = blockField[qp][posRow][posCol];

						if (mDrawSettings.behavior_qo_3d[qo] == DrawSettings.BEHAVIOR_QO_3D_NONE)
							continue;

						unionRect(path, left_x, top_y, left_x + boundWidth, top_y
								+ boundHeight, Path.Direction.CW);
					}
				}
			}
		}
	}

	private Path clipClearedRows(Path path, int[] clears,
			boolean[] monoClears, int extraRows, Offset clipOffset,
			int extendByPixels) {
		for (int qp = 0; qp < 2; qp++) {
			if (qp == 0 && !mDrawSettings.drawQ0)
				continue;
			if (qp == 1 && !mDrawSettings.drawQ1)
				continue;
			for (int row = 0; row < mDrawSettings.displayedRows + extraRows; row++) {
				int posRow = row + mDrawSettings.blockFieldOuterBuffer;
				if (clears[posRow] == QCombinations.SL
						|| clears[posRow] == (qp == 0 ? QCombinations.S0
								: QCombinations.S1) || monoClears[posRow]) {
					for (int col = 0; col < mDrawSettings.COLS; col++) {
						int left_x = mDrawSettings.getBlockXPosition(qp, col)
								+ clipOffset.x;
						int top_y = mDrawSettings.getBlockYPosition(qp, row)
								+ clipOffset.y;

                        unionRect(path, left_x - extendByPixels, top_y
								- extendByPixels,
								left_x + mDrawSettings.size_blockWidth
										+ extendByPixels,
								top_y + mDrawSettings.size_blockHeight
										+ extendByPixels,
                                Path.Direction.CW);
					}
				}
			}
		}
		return path;
	}

	/**
	 * Unions all "PULSE FILL" areas of the provided blockfield to the clip of
	 * the provided canvas.
	 * 
	 * Returns whether any such regions were added. 'false' guarantees no new
	 * clips; a return of 'true' indicates that new clips were unioned, although
	 * they may or may not represent actual pixels that have been added.
	 * 
	 * @param canvas
	 * @param blockField
	 * @param extraRows
	 * @param clipOffset
	 * @return
	 */
	private boolean clipPulseFillIntersection(Canvas canvas, byte[][][] blockField,
			int extraRows, Offset clipOffset) {
        reset(tempClipPath);
		boolean newClip = false;
		newClip = clipPulseFill(tempClipPath, blockField, Consts.QPANE_0,
				extraRows, clipOffset) || newClip;
		newClip = clipPulseFill(tempClipPath, blockField, Consts.QPANE_1,
				extraRows, clipOffset) || newClip;
		newClip = clipPulseFill(tempClipPath, blockField, Consts.QPANE_3D,
				extraRows, clipOffset) || newClip;
        canvas.clipPath(tempClipPath);
		return newClip;
	}

	private boolean clipPulseFillIntersection(Canvas canvas, byte[][][] blockField,
			int qPane, int extraRows, Offset clipOffset) {
		reset(tempClipPath);
		boolean has = clipPulseFill(tempClipPath, blockField, qPane,
				extraRows, clipOffset);
		canvas.clipPath(tempClipPath);
		return has;
	}

	private boolean clipPulseFill(Path path, byte[][][] blockField,
                                  int extraRows, Offset clipOffset) {
        boolean newClip = false;
        newClip = clipPulseFill(path, blockField, Consts.QPANE_0,
                extraRows, clipOffset) || newClip;
        newClip = clipPulseFill(path, blockField, Consts.QPANE_1,
                extraRows, clipOffset) || newClip;
        newClip = clipPulseFill(path, blockField, Consts.QPANE_3D,
                extraRows, clipOffset) || newClip;
        return newClip;
    }

	private boolean clipPulseFill(Path path, byte[][][] blockField,
			int qPane, int extraRows, Offset clipOffset) {
		if (qPane == Consts.QPANE_0 && !mDrawSettings.drawQ0)
			return false;
		if (qPane == Consts.QPANE_1 && !mDrawSettings.drawQ1)
			return false;
		if (qPane == Consts.QPANE_3D && !mDrawSettings.draw3D)
			return false;
		boolean newClip = false;
		if (qPane == Consts.QPANE_0 || qPane == Consts.QPANE_1) {
			for (int row = 0; row < mDrawSettings.displayedRows + extraRows; row++) {
				int posRow = row + mDrawSettings.blockFieldOuterBuffer;
				for (int col = 0; col < mDrawSettings.COLS; col++) {
					int posCol = col + mDrawSettings.blockFieldOuterBuffer;
					int qo = blockField[qPane][posRow][posCol];
					if (mDrawSettings.behavior_qo_pulse[qo] == DrawSettings.BEHAVIOR_QO_PULSE_FILL) {
						newClip = true;

						int left_x = mDrawSettings
								.getBlockXPosition(qPane, col) + clipOffset.x;
						int top_y = mDrawSettings.getBlockYPosition(qPane, row)
								+ clipOffset.y;

						unionRect(path, left_x, top_y,
								left_x + mDrawSettings.size_blockWidth,
								top_y + mDrawSettings.size_blockHeight,
								Path.Direction.CW);
					}
				}
			}
		} else {
			int boundWidth = mDrawSettings.size_blockWidth
					+ Math.abs(mDrawSettings.size_qXOffset);
			int boundHeight = mDrawSettings.size_blockHeight
					+ Math.abs(mDrawSettings.size_qYOffset);

			for (int row = 0; row < mDrawSettings.displayedRows + extraRows; row++) {
				int posRow = row + mDrawSettings.blockFieldOuterBuffer;
				for (int col = 0; col < mDrawSettings.COLS; col++) {
					int posCol = col + mDrawSettings.blockFieldOuterBuffer;
					int qo = blockField[Consts.QPANE_0][posRow][posCol];
					if (mDrawSettings.behavior_qo_3d[qo] == DrawSettings.BEHAVIOR_QO_3D_PAINT_EXTRUDED_QO_PULSE_BOX) {
						newClip = true;

						int left_x = mDrawSettings.getBlockXPosition(-1, col)
								+ clipOffset.x;
						int top_y = mDrawSettings.getBlockYPosition(-1, row)
								+ clipOffset.y;

						unionRect(path, left_x, top_y, left_x + boundWidth, top_y + boundHeight, Path.Direction.CW);
					}
				}
			}
		}
		return newClip;
	}

	private final void setAlignmentOffset(byte[][][] blockField, Offset offset) {

		// configure our alignment offset as if our draw region
		// is (0,0) to (ds.width, ds.height). As a final step,
		// perform an offset if blit_none so we can align to
		// the appropriate canvas area.
		switch (mDrawSettings.behavior_align_vertical) {
		case DrawSettings.BEHAVIOR_ALIGN_GRID:
			offset.y = 0;
			break;
		case DrawSettings.BEHAVIOR_ALIGN_CENTER_GRID:
		case DrawSettings.BEHAVIOR_ALIGN_CENTER_BLOCKS:
			// Scan the blockField, looking for the first and last rows
			// with block content. Offset to center the 1/2 way mark within
			// the draw region. If CENTER_GRID, we set yMin to row 0, yMax to
			// displayedRows.
			int yMin = Integer.MAX_VALUE; // pretty big!
			int yMax = Integer.MIN_VALUE; // small!
			if (mDrawSettings.behavior_align_vertical == DrawSettings.BEHAVIOR_ALIGN_CENTER_BLOCKS) {
				for (int q = 0; q < 2; q++) {
					for (int r = 0; r < mDrawSettings.displayedRows; r++) {
						for (int c = 0; c < mDrawSettings.COLS; c++) {
							if (blockField[q][r
									+ mDrawSettings.blockFieldOuterBuffer][c
									+ mDrawSettings.blockFieldOuterBuffer] != QOrientations.NO) {
								yMin = Math.min(yMin,
										mDrawSettings.getBlockYPosition(q, r));
								yMax = Math.max(yMax, mDrawSettings
										.getBlockYPosition(q, r - 1));
							}
						}
					}
				}
			} else {
				for (int q = 0; q < 2; q++) {
					yMin = Math
							.min(yMin, mDrawSettings.getBlockYPosition(q, 0));
					yMax = Math.max(yMax, mDrawSettings.getBlockYPosition(q,
							mDrawSettings.displayedRows));

				}
			}

			// Find the 1/2 way point.
			if (yMin > yMax)
				offset.y = 0;
			else {
				// Get an offset that puts the midpoint between yMin and yMax at
				// the center of the draw region.
				offset.y = mDrawSettings.height / 2 - ((yMin + yMax) / 2);
			}
			break;
		}

		switch (mDrawSettings.behavior_align_horizontal) {
		case DrawSettings.BEHAVIOR_ALIGN_GRID:
			offset.x = 0;
			break;
		case DrawSettings.BEHAVIOR_ALIGN_CENTER_BLOCKS:
		case DrawSettings.BEHAVIOR_ALIGN_CENTER_GRID:
			// Scan the blockField, looking for the first and last rows
			// with block content. Offset to center the 1/2 way mark within
			// the draw region.
			int xMin = Integer.MAX_VALUE; // pretty big!
			int xMax = Integer.MIN_VALUE; // small!
			if (mDrawSettings.behavior_align_horizontal == DrawSettings.BEHAVIOR_ALIGN_CENTER_BLOCKS) {
				for (int q = 0; q < 2; q++) {
					for (int c = 0; c < mDrawSettings.COLS; c++) {
						for (int r = 0; r < mDrawSettings.displayedRows; r++) {
							if (blockField[q][r
									+ mDrawSettings.blockFieldOuterBuffer][c
									+ mDrawSettings.blockFieldOuterBuffer] != QOrientations.NO) {
								xMin = Math.min(xMin,
										mDrawSettings.getBlockXPosition(q, c));
								xMax = Math.max(xMax, mDrawSettings
										.getBlockXPosition(q, c + 1));
							}
						}
					}
				}
			} else {
				for (int q = 0; q < 2; q++) {
					xMin = Math
							.min(xMin, mDrawSettings.getBlockXPosition(q, 0));
					xMax = Math.max(xMax, mDrawSettings.getBlockXPosition(q,
							mDrawSettings.COLS));

				}
			}

			// Find the 1/2 way point.
			if (xMin > xMax)
				offset.x = 0;
			else {
				// Get an offset that puts the midpoint between yMin and yMax at
				// the center of the draw region.
				offset.x = mDrawSettings.width / 2 - ((xMin + xMax) / 2);
			}
			break;
		}

		if (mDrawSettings.getBlit() == DrawSettings.BLIT_NONE)
			offset.offsetXY(mDrawSettings.configCanvas.region.left,
					mDrawSettings.configCanvas.region.top);
		
		// Offset by a safe margin for displacement.
		offset.offsetXY(0, mDrawSettings.displacementSafeMarginOffsetDraw) ;
	}

	private final void setCanvasTranslationOffset(Canvas canvas) {
		canvas.getMatrix(canvasMatrix);
		canvasMatrix.mapPoints(zeroZeroDst, zeroZero);
		canvasTranslationOffset.x = Math.round(zeroZeroDst[0]);
		canvasTranslationOffset.y = Math.round(zeroZeroDst[1]);

	}

	/**
	 * Steps through the specified qPane of the blockField, using the provided
	 * paints to draw fill colors at the specified backgrounds.
	 */
	private void drawFillLayerToCanvas(DrawSettings ds, int style,
			Canvas canvas, byte[][][] blockField,
			BlockDrawerConfigRange configRange, int qPane, int fillAlpha,
			float pulseAlphaScale, boolean simplifiedColor, Offset drawOffset) {

		// TEST TEST TEST: to test naive fill optimization, comment out the
		// following line.
		// naivelyOptimizePaintFills = false ;

		tempColorPaint.setAlpha(255);

		// calculate the pulse alpha from the scale.
		int pulseAlpha = fillAlpha;
		if (pulseAlphaScale > 0)
			pulseAlpha = Math.round((255 - pulseAlpha) * pulseAlphaScale
					+ pulseAlpha);
		else
			pulseAlpha = Math.round(pulseAlpha * (1.0f + pulseAlphaScale));

		// if ( pulseAlpha != fillAlpha )
		// log("fillAlpha " + fillAlpha + " pulseAlpha " + pulseAlpha +
		// " scale " + pulseAlphaScale)
		// Step through the blockField, drawing the color
		// for each thing in the right place.

		// The "fill layer" is simple enough; for now,
		// it either fills the square, or is not drawn
		// at all.

		// corner_x_offset, corner_y_offset give the distance
		// between the top-left of the view and the top-left of
		// block blockField[qPane][0][0].

		// log("drawFillLayerToCanvas alpha: " + fillAlpha) ;

		// int UNSET = Integer.MIN_VALUE ;

		int top_y = ds.getBlockYPosition(qPane, configRange.rowFirst - 1)
				+ drawOffset.y;
		int bottom_y;

		int blockFillColor = 0;

		for (int row = configRange.rowFirst; row < configRange.rowBound; row++) {
			// y bounds for this block?
			bottom_y = top_y;
			top_y -= ds.size_blockHeight;

			int r = configRange.rowToIndex(row);

			// if ( canvas.quickReject(0, top_y, canvas.getWidth(), bottom_y,
			// Canvas.EdgeType.BW))
			// continue ;

			for (int c = configRange.indexColFirst; c < configRange.indexColBound; c++) {
				// Draw
				int qo = blockField[qPane][r][c];

				// shortcut
				if (qo == QOrientations.NO)
					continue;

				if (style == STYLE_FILL_WITHOUT_BOX
						&& ds.behavior_qo_3d[qo] == DrawSettings.BEHAVIOR_QO_3D_PAINT_EXTRUDED_QO_PULSE_BOX)
					continue;

				int behavior = ds.behavior_qo_fill[qo];
				int borderBehavior = ds.behavior_qo_border[qo];
				int pulseBehavior = ds.behavior_qo_pulse[qo];

				// pulse match our style?
				if (style == STYLE_PULSE_FILL
						&& pulseBehavior != DrawSettings.BEHAVIOR_QO_PULSE_FILL)
					continue;
				if (style == STYLE_NOT_PULSE_FILL
						&& pulseBehavior != DrawSettings.BEHAVIOR_QO_PULSE_NONE)
					continue;

				// if ( qo != QOrientations.NO )
				// log("drawFillLayeToCanvas: qo is " + qo +
				// ", behavior is " + behavior ) ;
				if (behavior == DrawSettings.BEHAVIOR_QO_FILL_PAINT_NONE
						&& borderBehavior == DrawSettings.BEHAVIOR_QO_BORDER_NONE)
					continue;

				// bounds?
				int left_x = ds.getBlockXPosition(qPane, c
						- ds.blockFieldOuterBuffer)
						+ drawOffset.x;
				int right_x = left_x + ds.size_blockWidth;

				// if ( canvas.quickReject(left_x, top_y, right_x, bottom_y,
				// Canvas.EdgeType.BW) )
				// continue ;

				boolean drawRect = false;
				boolean drawPath = false;
				boolean canNaivelyOptimize = false;
				// We will set tempRectF and tempRegion according to these
				// booleans.

				Bitmap bitmapStretch = null ;
				switch (behavior) {
				case DrawSettings.BEHAVIOR_QO_FILL_PAINT_Q_ORIENTATION_FRIENDLY_BLEND:
					// look for a neighbor to blend with. If we find a
					// candidate,
					// set the drawable. If not, fall through to Q_ORIENTATION.
					if ( simplifiedColor ) {
						bitmapStretch = (Bitmap)findFriendlyBlendObject(blockField, qPane, r, c,
								friendlyFillBlendSimplified_byQPaneQOrientationFromToDirection);
					} else {
						bitmapStretch = (Bitmap)findFriendlyBlendObject(blockField, qPane, r, c,
								friendlyFillBlend_byQPaneQOrientationFromToDirection);
					}
					if (bitmapStretch != null)
						break;

					// Is it a generic fill?
				case DrawSettings.BEHAVIOR_QO_FILL_PAINT_Q_ORIENTATION:
					blockFillColor = simplifiedColor
							? ds.colorSimplified_qOrientationQPaneFill[qo][qPane]
							: ds.color_qOrientationQPaneFill[qo][qPane];
					tempRect.set(left_x, top_y, right_x, bottom_y);
					drawRect = true;
					canNaivelyOptimize = true;

                    // canvas.save();
                    // canvas.clipRect(left_x-3, top_y-3, right_x+3, bottom_y+3);
                    // canvas.drawColor(Color.argb(255, 255, 0, 255));
					// log("drawFillLayerToCanvas: draw with [" + left_x
					//     + ", " + top_y + ", " + right_x + ", " + bottom_y) ;
					// canvas.restore();
					break;

				case DrawSettings.BEHAVIOR_QO_FILL_PAINT_Q_ORIENTATION_INSET:
					blockFillColor = simplifiedColor
							? ds.colorSimplified_qOrientationQPaneFill[qo][qPane]
							: ds.color_qOrientationQPaneFill[qo][qPane];
					tempRect.set(left_x + ds.size_innerBorderXInset
							+ ds.size_innerBorderWidth, top_y
							+ ds.size_innerBorderYInset
							+ ds.size_innerBorderHeight, right_x
							- ds.size_innerBorderXInset
							- ds.size_innerBorderWidth, bottom_y
							- ds.size_innerBorderYInset
							- ds.size_innerBorderHeight);
					drawRect = true;
					canNaivelyOptimize = true;
					break;

				case DrawSettings.BEHAVIOR_QO_FILL_PAINT_Q_ORIENTATION_MINI:
					blockFillColor = simplifiedColor
							? ds.colorSimplified_qOrientationQPaneFill[qo][qPane]
							: ds.color_qOrientationQPaneFill[qo][qPane];
					tempRect.set(left_x + ds.size_miniBorderXInset
							+ ds.size_miniBorderWidth, top_y
							+ ds.size_miniBorderYInset
							+ ds.size_miniBorderHeight, right_x
							- ds.size_miniBorderXInset
							- ds.size_miniBorderWidth, bottom_y
							- ds.size_miniBorderYInset
							- ds.size_miniBorderHeight);
					drawRect = true;
					canNaivelyOptimize = true;
					break;

				case DrawSettings.BEHAVIOR_QO_FILL_PAINT_Q_PANE:
					if ( simplifiedColor ) {
						blockFillColor = (qPane == 0)
								? ds.colorSimplified_qOrientationQPaneFill[QOrientations.S0][qPane]
								: ds.colorSimplified_qOrientationQPaneFill[QOrientations.S1][qPane];
					} else {
						blockFillColor = (qPane == 0)
								? ds.color_qOrientationQPaneFill[QOrientations.S0][qPane]
								: ds.color_qOrientationQPaneFill[QOrientations.S1][qPane];
					}
					tempRect.set(left_x, top_y, right_x, bottom_y);
					// canvas.clipRect(left_x, top_y, right_x, bottom_y,
					// Region.Op.REPLACE) ;
					// canvas.drawRect(left_x-3, top_y-3, right_x+3, bottom_y+3,
					// p) ;
					drawRect = true;
					canNaivelyOptimize = true;
					break;

				case DrawSettings.BEHAVIOR_QO_FILL_PAINT_Q_ORIENTATION_MINI_NONOVERLAP:
					// we have a custom region for this.
					blockFillColor = simplifiedColor
							? ds.colorSimplified_qOrientationQPaneFill[qo][qPane]
							: ds.color_qOrientationQPaneFill[qo][qPane];
					tempRect.set(left_x, top_y, right_x, bottom_y);
					tempPath.set(customFillPath_byQPane_QOrientation[qPane][qo]);
					tempPath.offset(left_x, top_y);
					drawRect = true;
					drawPath = true;
					canNaivelyOptimize = true;
					break;

				case DrawSettings.BEHAVIOR_QO_FILL_PAINT_NONE:
					if (borderBehavior == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INSET) {
						// F0/F1 special case - again. This time, our region is
						// the BorderRegion.
						blockFillColor = simplifiedColor
								? ds.colorSimplified_qOrientationQPaneBorder[qo][qPane]
								: ds.color_qOrientationQPaneBorder[qo][qPane];
						tempPath.set(customBorderPath_byQPane_QOrientation[qPane][qo]);
						tempPath.offset(left_x, top_y);
						tempRect.set(left_x, top_y, right_x, bottom_y);
						drawPath = true;
						drawRect = true;
					} else if (borderBehavior == DrawSettings.BEHAVIOR_QO_BORDER_INNER) {
						// PUSH special case.
						blockFillColor = simplifiedColor
								? ds.colorSimplified_qOrientationQPaneBorder[qo][qPane]
								: ds.color_qOrientationQPaneBorder[qo][qPane];
						tempPath.set(customBorderPath_byQPane_QOrientation[qPane][qo]);
						tempPath.offset(left_x, top_y);
						tempRect.set(left_x, top_y, right_x, bottom_y);
						drawPath = true;
						drawRect = true;
					}
					break;
				}

				// First naive-optimization check. If we're filling with
				// background, can
				// naively optimize, and have been TOLD to do so, we can skip
				// this one.

				if (drawPath) {
					canvas.save();
					canvas.clipPath(tempPath);
				}

				if (bitmapStretch != null) {
					int alpha ;
					if (pulseBehavior == DrawSettings.BEHAVIOR_QO_PULSE_FILL)
						alpha = (int) (pulseAlpha * ds.alphamult_qOrientationFill[qo]) ;
					else
						alpha = (int) (fillAlpha * ds.alphamult_qOrientationFill[qo]) ;
					tempColorPaint.setColor(0xffffffff) ;
					tempColorPaint.setAlpha(alpha) ;
					tempDstRect.set(left_x, top_y, right_x, bottom_y) ;
					canvas.drawBitmap(bitmapStretch, null, tempDstRect, tempColorPaint) ;
				}

				if (drawRect) {
					// find the appropriate color to layer over...
					int alpha = pulseBehavior == DrawSettings.BEHAVIOR_QO_PULSE_FILL ? (int) (pulseAlpha * ds.alphamult_qOrientationFill[qo])
							: (int) (fillAlpha * ds.alphamult_qOrientationFill[qo]);

					fillPaint.setColor(blockFillColor);
					fillPaint.setAlpha(alpha) ;
					canvas.drawRect(tempRect, fillPaint);
				}

				if (drawPath) {
					canvas.restore();
				}
			}
		}

	}

	private void drawTopLayerToCanvas(DrawSettings ds, Canvas canvas,
			byte[][][] blockField, BlockDrawerConfigRange configRange,
			int qPane, int colorAlpha) {

		drawTopLayerToCanvas(ds, canvas, blockField, configRange, qPane,
				colorAlpha, 1, OFFSET_NONE);
	}

	private void drawTopLayerToCanvas(DrawSettings ds, Canvas canvas,
			byte[][][] blockField, BlockDrawerConfigRange configRange,
			int qPane, int colorAlpha, float alphaMult, Offset drawOffset) {

		int top_y, bottom_y, left_x, right_x;
		final int y_step = ds.size_blockHeight ;
		final int x_step = ds.size_blockWidth ;

		// FIRST: draw any hashing that might occur.
		// Now draw any hashing that might occur.
		if (ds.behavior_hashing != DrawSettings.BEHAVIOR_HASHING_NONE) {
			boolean haveHashing = false;
			reset(tempHashingMask);
			
			// iterate from bottom to top.  At each iteration, set bottom_y
			// to the previous top_y, and decrement top_y by block height.
			top_y = ds.getBlockYPosition(qPane, configRange.rowFirst -1) + drawOffset.y ;
			for (int r = configRange.indexRowFirst; r < configRange.indexRowBound; r++) {
				// y bounds for this block?
				bottom_y = top_y ;
				top_y -= y_step ;

				// iterate from left to right.  At each iter, set left_x to
				// previous right_x, and increment right_x by the block width.
				right_x = ds.getBlockXPosition(qPane, configRange.columnFirst) + drawOffset.x ;
				for (int c = configRange.indexColFirst; c < configRange.indexColBound; c++) {
					left_x = right_x ;
					right_x += x_step ;

					// Draw
					int qo = blockField[qPane][r][c];
					int hashing_behavior = ds.behavior_qo_hashing[qo];

					if (hashing_behavior == DrawSettings.BEHAVIOR_QO_HASHING_QPANE) {
						haveHashing = true;

						int fill_behavior = ds.behavior_qo_fill[qo];
						// we need to determine the region to fill (we set it in tempRegion).
						switch (fill_behavior) {
						case DrawSettings.BEHAVIOR_QO_FILL_PAINT_Q_ORIENTATION_FRIENDLY_BLEND:
						case DrawSettings.BEHAVIOR_QO_FILL_PAINT_Q_ORIENTATION:
						case DrawSettings.BEHAVIOR_QO_FILL_PAINT_Q_PANE:
							// Some kind of generic, "full square" fill.
							unionRect(tempHashingMask, left_x, top_y, right_x, bottom_y, Path.Direction.CW);
							break;

						case DrawSettings.BEHAVIOR_QO_FILL_PAINT_Q_ORIENTATION_INSET:
							tempRectF.set(left_x + ds.size_innerBorderXInset
									+ ds.size_innerBorderWidth, top_y
									+ ds.size_innerBorderYInset
									+ ds.size_innerBorderHeight, right_x
									- ds.size_innerBorderXInset
									- ds.size_innerBorderWidth, bottom_y
									- ds.size_innerBorderYInset
									- ds.size_innerBorderHeight);
							unionRect(tempHashingMask, tempRectF, Path.Direction.CW);
							break;

						case DrawSettings.BEHAVIOR_QO_FILL_PAINT_Q_ORIENTATION_MINI:
							tempRectF.set(left_x + ds.size_miniBorderXInset
									+ ds.size_miniBorderWidth, top_y
									+ ds.size_miniBorderYInset
									+ ds.size_miniBorderHeight, right_x
									- ds.size_miniBorderXInset
									- ds.size_miniBorderWidth, bottom_y
									- ds.size_miniBorderYInset
									- ds.size_miniBorderHeight);
							unionRect(tempHashingMask, tempRectF, Path.Direction.CW);
							break;

						case DrawSettings.BEHAVIOR_QO_FILL_PAINT_Q_ORIENTATION_MINI_NONOVERLAP:
							// we have a custom region for this.
                            tempPath.set(customFillPath_byQPane_QOrientation[qPane][qo]);
                            tempPath.offset(left_x, top_y);
							op(tempHashingMask, tempPath, Path.Op.UNION);
						}
					}
				}
			}

			if (haveHashing) {
				tempHashingMask.offset(canvasTranslationOffset.x, canvasTranslationOffset.y);
				hashing_byQPane[qPane].setBounds(0, 0, canvas.getWidth(),
						canvas.getHeight());
				canvas.save();
				canvas.clipPath(tempHashingMask);
				hashing_byQPane[qPane].draw(canvas);
				canvas.restore();
			}
		}

		float smallPrismXOffset = (ds.size_blockWidth - ds.size_smallPrismWidth) / 2;
		float smallPrismYOffset = (ds.size_blockHeight - ds.size_smallPrismHeight) / 2;
		
		for (int r = configRange.indexRowFirst; r < configRange.indexRowBound; r++) {
			int row = configRange.indexToRow(r) ;
			for (int c = configRange.indexColFirst; c < configRange.indexColBound; c++) {

				int qo = blockField[qPane][r][c];
				int behavior = ds.behavior_qo_top[qo];

				float left_f, top_f, right_f, bottom_f;

				int left, top;

				switch (behavior) {
				case DrawSettings.BEHAVIOR_QO_TOP_PAINT_Q_ORIENTATION_SMALL_PRISM_TOP:
					fillPaint
							.setColor(ds.color_qOrientationQPaneFill[qo][qPane]);
					fillPaint
							.setAlpha((int) (255 * ds.alphamult_qOrientationFill[qo]));
					// Small prism top!
					left_f = ds.getBlockXPosition(qPane, configRange.indexToCol(c))
							+ smallPrismXOffset + drawOffset.x;
					top_f = ds.getBlockYPosition(qPane, row)
							+ smallPrismYOffset + drawOffset.y;
					right_f = left_f + ds.size_smallPrismWidth;
					bottom_f = top_f + ds.size_smallPrismHeight;
					canvas.save();
					canvas.clipRect(left_f, top_f, right_f, bottom_f,
							Region.Op.INTERSECT);
					canvas.drawPaint(fillPaint);
					canvas.restore();
					break;

				case DrawSettings.BEHAVIOR_QO_TOP_PAINT_STANDARD_SMALL_PRISM_TOP:
					fillPaint.setColor(ds.color_prismSides);
					fillPaint
							.setAlpha((int) (colorAlpha * ds.alphamult_qOrientationFill[qo]));
					// Small prism top!
					left_f = ds.getBlockXPosition(qPane, configRange.indexToCol(c))
							+ smallPrismXOffset + drawOffset.x;
					top_f = ds.getBlockYPosition(qPane, row)
							+ smallPrismYOffset + drawOffset.y;
					right_f = left_f + ds.size_smallPrismWidth;
					bottom_f = top_f + ds.size_smallPrismHeight;
					canvas.save();
					canvas.clipRect(left_f, top_f, right_f, bottom_f,
							Region.Op.INTERSECT);
					canvas.drawPaint(fillPaint);
					canvas.restore();
					break;

				case DrawSettings.BEHAVIOR_QO_TOP_CUSTOM_BITMAP:
					Bitmap b = customBitmap_byQOrientation[qo];
					Rect bounds = customBitmapBounds_byQOrientation[qo];
					left = ds.getBlockXPosition(qPane, configRange.indexToCol(c)) + drawOffset.x;
					top = ds.getBlockYPosition(qPane, row) + drawOffset.y;
					tempDstRect.set(left, top, left + ds.size_blockWidth,
							top + ds.size_blockHeight);
					tempColorPaint.setColor(0xffffffff);
					tempColorPaint.setAlpha((int) Math.round(colorAlpha
							* alphaMult)); // TODO: configurable alpha?
					// log("BEHAVIOR_QO_TOP_CUSTOM_BITMAP for qo  " + qo
					// + " canvas " + b + " " + bounds + " " + tempDstRect + " "
					// + tempColorPaint) ;
					// if ( b != null )
					// log("b recycled? " + b.isRecycled()) ;
					canvas.drawBitmap(b, bounds, tempDstRect, tempColorPaint);
					break;

				case DrawSettings.BEHAVIOR_QO_TOP_PAINT_BLAND_FILL:
					if (alphaMult == Float.POSITIVE_INFINITY) {
						new Exception("alphaMult is infinity?")
								.printStackTrace();
					}
					left = ds.getBlockXPosition(qPane, configRange.indexToCol(c)) + drawOffset.x;
					top = ds.getBlockYPosition(qPane, row) + drawOffset.y;
					tempDstRect.set(left, top, left + ds.size_blockWidth,
							top + ds.size_blockHeight);
					tempColorPaint
							.setColor(ds.color_qOrientationQPaneFill[ds.draw3D ? QOrientations.SL
									: QOrientations.RAINBOW_BLAND][qPane]);
					tempColorPaint.setAlpha((int) Math.round(colorAlpha
							* alphaMult));
					canvas.drawRect(tempDstRect, tempColorPaint);
					break;
					
				case DrawSettings.BEHAVIOR_QO_TOP_PAINT_DETAIL_FILL:
					if (alphaMult == Float.POSITIVE_INFINITY) {
						new Exception("alphaMult is infinity?")
								.printStackTrace();
					}
					if ( ds.color_qOrientationDetailColors[qo] != null ) {
						left = ds.getBlockXPosition(qPane, configRange.indexToCol(c)) + drawOffset.x;
						top = ds.getBlockYPosition(qPane, row) + drawOffset.y;
						tempDstRect.set(left, top, left + ds.size_blockWidth,
								top + ds.size_blockHeight);
						tempColorPaint
								.setColor(ds.color_qOrientationDetailColors[qo][0]);
						tempColorPaint.setAlpha((int) Math.round(colorAlpha
								* alphaMult));
						canvas.drawRect(tempDstRect, tempColorPaint);
					}
					break;
					
				}
			}
		}
	}

	private static final short SHADOW_SET_INDEX_NONE = 255; // none =
															// zero-indexed
															// sheet
	private static final short SHADOW_SET_OFFSET_CUSTOM = 256;

	private void drawShadowLayerToCanvas(DrawSettings ds, Canvas canvas,
			byte[][][] blockField, BlockDrawerConfigRange configRange,
			int qPane, int shadowAlpha, Offset drawOffset) {

		setInnerShadowSetIndices(ds, mShadowSets, blockField, configRange,
				qPane);
		drawInnerShadowSetsToCanvas(ds, canvas, mShadowSets, blockField,
				configRange, qPane, shadowAlpha, drawOffset);

	}

	private void setInnerShadowSetIndices(DrawSettings ds,
			short[][] shadowSets, byte[][][] blockField,
			BlockDrawerConfigRange configRange, int qPane) {
		ArrayOps.fill(shadowSets, SHADOW_SET_INDEX_NONE);

		tempConfigRange.set(configRange);
		if (!tempConfigRange.shrinkToFit(blockField))
			return; // no blocks

		tempConnected[1][1] = true;

		for (int posRow = tempConfigRange.indexRowFirst; posRow < tempConfigRange.indexRowBound; posRow++) {
			for (int posCol = tempConfigRange.indexColFirst; posCol < tempConfigRange.indexColBound; posCol++) {

				// get the q orientation, compare against immediate
				// neighborhood.
				// int posRow = tempConfigRange.rowToIndex(row);
				// int posCol = tempConfigRange.colToIndex(col);

				int qo = blockField[qPane][posRow][posCol];

				// Only shade Q Orientation Inner, with its friendly varients,
				// gets a custom border.
				if (ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_INNER
						|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER
						|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY
						|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY_BLEND
						|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE
						|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE) {
					// remember, connected is in x/y format, not
					// row/col.ds.behavior_qo_border[qo] ==
					// DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER
					if (ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_INNER) {
						for (int r = -1; r <= 1; r++) {
							for (int c = -1; c <= 1; c++) {
								if (r != 0 || c != 0) {
									tempConnected[1 + c][1 - r] = false;
								}
							}
						}
					} else if (ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER
							|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE) {
						for (int r = -1; r <= 1; r++) {
							for (int c = -1; c <= 1; c++) {
								if (r != 0 || c != 0) {
									tempConnected[1 + c][1 - r] = qo == blockField[qPane][posRow
											+ r][posCol + c];
								}
							}
						}
					} else if (ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY
							|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY_BLEND) {
						for (int r = -1; r <= 1; r++) {
							for (int c = -1; c <= 1; c++) {
								if (r != 0 || c != 0) {
									int qoNeighbor = blockField[qPane][posRow
											+ r][posCol + c];
									int behavior = ds.behavior_qo_border[qoNeighbor];
									tempConnected[1 + c][1 - r] = behavior == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY
											|| behavior == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY_BLEND;
								}
							}
						}
					} else if (ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE) {
						for (int r = -1; r <= 1; r++) {
							for (int c = -1; c <= 1; c++) {
								if (r != 0 || c != 0) {
									int qoNeighbor = blockField[qPane][posRow
											+ r][posCol + c];
									tempConnected[1 + c][1 - r] = ds.behavior_qo_border[qoNeighbor] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE
											&& ds.color_qOrientationQPaneBorder[qo][qPane] == ds.color_qOrientationQPaneBorder[qoNeighbor][qPane];
								}
							}
						}
					}

					indexByNeighbors_sanityFix(tempConnected, 1, 1);
					short index = indexByNeighbors(tempConnected, 1, 1);
					shadowSets[posRow][posCol] = index < 255 ? index
							: SHADOW_SET_INDEX_NONE;
					
					if ( ds.behavior_qo_bitmap[qo] == DrawSettings.BEHAVIOR_QO_BITMAP_CHEVRON_BORDER )
						shadowSets[posRow][posCol] += SHADOW_SET_OFFSET_CUSTOM ;
				}

				else if (ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INSET
						|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI
						|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_HORIZONTAL_OVER
						|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_VERTICAL_OVER) {
					shadowSets[posRow][posCol] = SHADOW_SET_OFFSET_CUSTOM
							+ SHADOW_SET_INDEX_NONE;
				}
			}
		}
	}

	/**
	 * Sets the connection sets as if QOs connect only with identical QOs,
	 * ignoring behaviors. Draw settings is provided only for array bounds.
	 */
	private void setQOSetIndices(DrawSettings ds, short[][] sets,
			byte[][][] blockField, BlockDrawerConfigRange configRange, int qPane) {
		ArrayOps.fill(sets, (short) SHADOW_SET_INDEX_NONE);

		tempConfigRange.set(configRange);
		if (!tempConfigRange.shrinkToFit(blockField))
			return; // no blocks

		tempConnected[1][1] = true;

		for (int posRow = tempConfigRange.indexRowFirst; posRow < tempConfigRange.indexRowBound; posRow++) {
			for (int posCol = tempConfigRange.indexColFirst; posCol < tempConfigRange.indexColBound; posCol++) {

				// get the q orientation, compare against immediate
				// neighborhood.

				int qo = blockField[qPane][posRow][posCol];
				if (qo == QOrientations.NO)
					continue;

				for (int r = -1; r <= 1; r++) {
					for (int c = -1; c <= 1; c++) {
						if (r != 0 || c != 0) {
							tempConnected[1 + c][1 - r] = qo == blockField[qPane][posRow
									+ r][posCol + c];
						}
					}
				}

				indexByNeighbors_sanityFix(tempConnected, 1, 1);
				int index = indexByNeighbors(tempConnected, 1, 1);
				sets[posRow][posCol] = (short) (index < 255 ? index
						: SHADOW_SET_INDEX_NONE);

			}
		}
	}

	/**
	 * Very similar to the inverse of setInnerShadowSetIndices for standard
	 * InnerBorder blocks (custom shadows behave differently, and are described
	 * below). Squares with an InnerBorder block have no outer shadow (there is
	 * nowhere to draw it, after all), while squares which merely BORDER an
	 * InnerBorder block have a shadow cast into them. The actual shadow cast
	 * is, again, the inverse of innerBorders: those squares which DO contain
	 * blocks are considered "disconnected", those which are empty are
	 * "connected."
	 * 
	 * Special consideration is given to custom shadow blocks, such as INSET or
	 * MINI blocks. Note that for inner shadows, there is exactly 1 shadow
	 * template used in each block (usually NONE which counts as a template).
	 * However, for outer shadows, multiple shadow types could contribute to a
	 * square's shadow content: it could border 1 or more InnerBorder blocks
	 * (casting a standard InnerBorder shadow, as described), and in addition it
	 * could contain a Custom shadow block with its own drop shadow. These
	 * shadows are cast "on top" of each other (it's too much effort to manually
	 * form every possible combination).
	 * 
	 * We assume that custom blocks do NOT cast independent shadows into
	 * neighboring spaces. To compensate for this assumption, we allow the
	 * actual custom shadow bitmap to extend beyond the squares borders. (For
	 * now we assume they extend down-and-right and thus draw at the top-left of
	 * the square).
	 * 
	 * In short, shadow indices can represent exactly 1 shadow set (including
	 * NONE as an option), PLUS (optionally) a custom flag indicating that a
	 * custom shadow should be drawn.
	 */
	private void setOuterShadowSetIndices(DrawSettings ds,
			short[][][] shadowSets, byte[][][] blockField,
			BlockDrawerConfigRange configRange, int qPane) {

		// Set to None those rows which we won't touch in our main loop.
		ArrayOps.fill(shadowSets, SHADOW_SET_INDEX_NONE);

		// we quickly narrow down rows and columns within blockField that
		// contain nonzero blocks.
		// We then expand by 1 in each direction (if possible). This leaves open
		// the possibility
		// of a "too-large" region, but still better than nothing and very
		// simple to do.

		// 6/15/12: this method accounts for 8.4% of CPU time in stress testing.
		// It is a prime
		// candidate for optimization.

		// Only ~3.3% of time spent within this.
		tempConfigRange.set(configRange);
		if (!tempConfigRange.shrinkToFit(blockField))
			return; // no blocks

		// OPTIMIZATION: previously we used tempConnected for easy examination.
		// Because
		// this method ended up being such a time-hog, we're changing things up
		// a little bit.
		// We have started each entry as SHADOW_SET_INDEX_NONE, meaning a
		// connection in all
		// directions. We iterate through the blocks within the margins and, for
		// each SHADOW-CASTING
		// block, we DECREMENT the shadow index of all its neighbors by the
		// appropriate
		// IBN_OFFSET_CONNECTED_DIRECTION value (remember to index in reverse,
		// i.e. for the block
		// to the upper-left of the examined one, we take the lower-right
		// connected direction).

		// Shadows are "cast" thus into every neighboring block, except those
		// which are themselves InnerBorder blocks (those blocks are assumed
		// to fill the available space, leaving no room for an additional shadow).
		
		// Note: we have tested a particular optimization: ignoring this check
		// in the "cast" cycle, and then doing one final pass to "reset" these
		// inner shadow blocks.  That approach is less efficient and so we check
		// during the initial "cast" step.

		// do NOT expand; iterate over exactly the rows / cols with content.
		for (int posRow = tempConfigRange.indexRowFirst; posRow < tempConfigRange.indexRowBound; posRow++) {
			// int posRow = tempConfigRange.rowToIndex(row);
			for (int posCol = tempConfigRange.indexColFirst; posCol < tempConfigRange.indexColBound; posCol++) {
				// int posCol = tempConfigRange.colToIndex(col);

				int qo = blockField[qPane][posRow][posCol];
				int uniqueColor = this.mLastDropShadowSetsUniqueColor_byQOrientation_byPane[qo][qPane];

				int behavior = ds.behavior_qo_border[qo];

				// NOTE: methods exist to check for behavior status, either custom
				// or index.  This method previously used those methods and if / else if
				// construction here.  However, as an optimization, we have inlined
				// the switch itself, saving about 2 cycles per call (a massive improvement,
				// from 2.5 to 0.5!).
				switch( behavior ) {
				case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INSET:
				case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI:
				case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_HORIZONTAL_OVER:
				case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_VERTICAL_OVER:
					// CUSTOM
					shadowSets[uniqueColor][posRow][posCol] += SHADOW_SET_OFFSET_CUSTOM;
					break ;
				case DrawSettings.BEHAVIOR_QO_BORDER_INNER:
				case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER:
				case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY:
				case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY_BLEND:
				case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE:
				case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE:
					// INNER BORDER
					// casts as shadow to all neighboring squares. It is always
					// okay to extend by 1 (note the blockFieldOuterBorder!)
					for (int r = -1; r < 2; r++) {
						int offsetPosRow = posRow + r ;
						for (int c = -1; c < 2; c++) {
							int offsetPosCol = posCol + c ;
							if ( (r != 0 || c != 0)	// an offset
									&& !setShadow_behaviorIsInnerBorder( ds.behavior_qo_border[ blockField[qPane][offsetPosRow][offsetPosCol] ] ) )
							{
								shadowSets[uniqueColor][offsetPosRow][offsetPosCol] -= IBN_OFFSET_CONNECTED_DIRECTION[1 - c][1 + r];
							}
						}
					}
					break ;
					// remember to REVERSE the perspective
					// ("OFFSET_CONNECTED_DIRECTION" is
					// FROM posRow+r, posCol+c, NOT "towards" it)
					// Thus if r = -1, c = -1 (up and left), we adjust by the
					// down-right direction offset.
				}
			}
		}

		// that's it
	}

	private boolean setShadow_behaviorIsInnerBorder(int behavior) {
		switch( behavior ) {
		case DrawSettings.BEHAVIOR_QO_BORDER_INNER:
		case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER:
		case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY:
		case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY_BLEND:
		case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE:
		case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE:
			return true ;
		}
		return false ;
	}

	private boolean setShadow_behaviorIsCustom(int behavior) {
		switch( behavior ) {
		case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INSET:
		case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI:
		case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_HORIZONTAL_OVER:
		case DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_VERTICAL_OVER:
			return true ;
		}
		return false ;
	}

	/**
	 * Given r, a rectangle showing existing margins for the field within which
	 * all nonzero values appear, shrinks the contents in all directions to
	 * exactly contain the nonzero elements.
	 * 
	 * Convention: ll, ur give inclusive and exclusive bounds.
	 */
	private boolean shrinkMargins(byte[][][] field, Offset ll, Offset ur) {
		// raise floor...
		boolean has = false;
		while (ll.y < ur.y) {
			for (int c = ll.x; c < ur.x; c++) {
				if (field[0][ll.y][c] != QOrientations.NO
						|| field[1][ll.y][c] != QOrientations.NO) {
					has = true;
					break;
				}
			}
			if (has)
				break;
			ll.y++;
		}
		// lower ceiling...
		has = false;
		while (ll.y < ur.y) {
			for (int c = ll.x; c < ur.x; c++) {
				if (field[0][ur.y - 1][c] != QOrientations.NO
						|| field[1][ur.y - 1][c] != QOrientations.NO) {
					has = true;
					break;
				}
			}
			if (has)
				break;
			ur.y--;
		}
		// left edge rightward...
		has = false;
		while (ll.x < ur.x) {
			for (int r = ll.y; r < ur.y; r++) {
				if (field[0][r][ll.x] != QOrientations.NO
						|| field[1][r][ll.x] != QOrientations.NO) {
					has = true;
					break;
				}
			}
			if (has)
				break;
			ll.x++;
		}
		// lower ceiling...
		has = false;
		while (ll.x < ur.x) {
			for (int r = ll.y; r < ur.y; r++) {
				if (field[0][r][ur.x - 1] != QOrientations.NO
						|| field[1][r][ur.x - 1] != QOrientations.NO) {
					has = true;
					break;
				}
			}
			if (has)
				break;
			ur.x--;
		}

		return ll.x < ur.x && ll.y < ur.y;
	}

	/**
	 * Given r, a rectangle showing existing margins for the field within which
	 * all nonzero values appear, shrinks the contents in all directions to
	 * exactly contain the nonzero elements.
	 * 
	 * Convention: ll, ur give inclusive and exclusive bounds.
	 */
	synchronized private boolean shrinkMargins(Offset ll, Offset ur,
			byte[][][]... fields) {
		if (shrinkMargins_tempOffset_ll == null) {
			shrinkMargins_tempOffset_ll = new Offset();
			shrinkMargins_tempOffset_ur = new Offset();
			shrinkMargins_resultOffset_ll = new Offset();
			shrinkMargins_resultOffset_ur = new Offset();
		}

		shrinkMargins_resultOffset_ll.setXY(Integer.MAX_VALUE,
				Integer.MAX_VALUE);
		shrinkMargins_resultOffset_ur.setXY(-1, -1);

		boolean any = false;

		for (int f = 0; f < fields.length; f++) {
			shrinkMargins_tempOffset_ll.takeVals(ll);
			shrinkMargins_tempOffset_ur.takeVals(ur);

			any = shrinkMargins(fields[f], shrinkMargins_tempOffset_ll,
					shrinkMargins_tempOffset_ur) || any;

			shrinkMargins_resultOffset_ll.x = Math.min(
					shrinkMargins_tempOffset_ll.x,
					shrinkMargins_resultOffset_ll.x);
			shrinkMargins_resultOffset_ll.y = Math.min(
					shrinkMargins_tempOffset_ll.y,
					shrinkMargins_resultOffset_ll.y);
			shrinkMargins_resultOffset_ur.x = Math.max(
					shrinkMargins_tempOffset_ur.x,
					shrinkMargins_resultOffset_ur.x);
			shrinkMargins_resultOffset_ur.y = Math.max(
					shrinkMargins_tempOffset_ur.y,
					shrinkMargins_resultOffset_ur.y);
		}

		ll.takeVals(shrinkMargins_resultOffset_ll);
		ur.takeVals(shrinkMargins_resultOffset_ur);

		return any;
	}

	private Offset shrinkMargins_tempOffset_ll = null;
	private Offset shrinkMargins_tempOffset_ur = null;
	private Offset shrinkMargins_resultOffset_ll = null;
	private Offset shrinkMargins_resultOffset_ur = null;

	private void drawInnerShadowSetsToCanvas(DrawSettings ds, Canvas canvas,
			short[][] shadowSets, byte[][][] blockField,
			BlockDrawerConfigRange configRange, int qPane, int shadowAlpha,
			Offset drawOffset) {

		// 6/28/2012: SHORT-CIRCUIT!
		if (ds.drawDetail <= DrawSettings.DRAW_DETAIL_LOW)
			return;

		drawShadowSetsToCanvas(
				ds,
				canvas,
				shadowSets,
				blockField,
				configRange,
				qPane,
				shadowAlpha,
				drawOffset,
				0,
				ds.drawDetail >= DrawSettings.DRAW_DETAIL_MID ? innerBorderFillShadowSheet
						: null, innerBorderFillShadowSheetBounds, null, null,
				false, 0, null, customFillShadow_byQPaneQOrientation,
				customFillShadowBounds_byQPaneQOrientation, null);
	}

	private void drawOuterShadowSetsToCanvas(DrawSettings ds, Canvas canvas,
			short[][][] shadowSets, byte[][][] blockField,
			BlockDrawerConfigRange configRange, int qPane, int shadowAlpha,
			Offset drawOffset) {

		// 6/19/12: SHORT-CIRCUIT! If using an all-black background with black
		// shadows, we
		// skip the drop shadow process entirely.
		if (ds.behavior_background == DrawSettings.BEHAVIOR_BACKGROUND_ALL_EMPTY
				|| ds.behavior_background == DrawSettings.BEHAVIOR_BACKGROUND_EMPTY_AND_PIECE) {
			if (ds.getBackground().getColor() == 0xff000000
					&& this.mLastDropShadowSetsColor_byUniqueColor.length == 1)
				return;
		}

		// log("drawing outer shadow sets...") ;
		// log("" + innerBorderDropShadowSheet) ;
		// log("" + innerBorderDropShadowRegion ) ;
		// log("" + customDropShadow_byQPaneQOrientation ) ;
		// log("" + customDropShadowRegion_byQPaneQOrientation ) ;

		for (int i = 0; i < shadowSets.length; i++)
			drawShadowSetsToCanvas(
					ds,
					canvas,
					shadowSets[i],
					blockField,
					configRange,
					qPane,
					shadowAlpha,
					drawOffset,
					ds.blockFieldOuterBuffer > 0 ? 1 : 0,
					ds.drawDetail >= DrawSettings.DRAW_DETAIL_MID ? innerBorderDropShadowSheet
							: null, innerBorderDropShadowSheetBounds,
                    innerBorderDropShadowPath, innerBorderDropShadowRects,
					true, mLastDropShadowSetsColor_byUniqueColor[i],
					mLastDropShadowSetsColorFilterPaint_byUniqueColor[i],
					customDropShadow_byQPaneQOrientation,
					customDropShadowBounds_byQPaneQOrientation,
                    customDropShadowPath_byQPaneQOrientation);
	}

	private void drawShadowSetsToCanvas(DrawSettings ds, Canvas canvas,
			short[][] shadowSets, byte[][][] blockField,
			BlockDrawerConfigRange configRange, int qPane, int shadowAlpha,
			Offset drawOffset, int buffer, Bitmap shadowSheet,
			Rect shadowSheetBounds, Path[] shadowPaths,
			Rect[][] shadowRects, boolean drop, int dropColor, Paint dropPaint,
			Bitmap[][] customShadow_byQPaneQOrientation,
			Rect[][] customShadowBounds_byQPaneQOrientation,
			Path[][] customShadowPath_byQPaneQOrientation) {

		int sheetBlockWidth = shadowSheetBounds == null ? 0 : shadowSheetBounds
				.width() / 16;
		int sheetBlockHeight = shadowSheetBounds == null ? 0
				: shadowSheetBounds.height() / 16;

		tempColorPaint.setColor(Color.BLACK);
		tempColorPaint.setAlpha(shadowAlpha);
		tempDitherPaint.setAlpha(shadowAlpha);
		// if ( shadowRegions != null )
		// log("alpha is " + shadowAlpha) ;

		int lsl = 0; // left shadow left
		int lsr = estimateDropShadowWidth(ds); // left shadow right
		int rsl = ds.size_blockWidth - lsr; // right shadow left
		int rsr = ds.size_blockWidth; // right shadow right
		int tst = 0; // top shadow top
		int tsb = estimateDropShadowHeight(ds); // top shadow bottom
		int bst = ds.size_blockHeight - tsb; // bottom shadow top
		int bsb = ds.size_blockHeight; // bottom shadow bottom

		int lastDrawn = Integer.MIN_VALUE;

		int UNSET = Integer.MIN_VALUE;

		// 'buffer' indicates the distance from the row bounds beyond which
		// we expand.
		
		int size_blockWidth = ds.size_blockWidth ;
		int size_blockHeight = ds.size_blockHeight ;

		int lastPrerenderedIndex = Integer.MIN_VALUE;
		int lastPrerenderedQO = Integer.MIN_VALUE;
		
		// iteration bounds...
		int indexRowFirst = configRange.indexRowFirst - buffer ;
		int indexRowBound = configRange.indexRowBound + buffer ;
		int indexColFirst = configRange.indexColFirst - buffer ;
		int indexColBound = configRange.indexColBound + buffer ;
		
		//log("QuantroApp drawShadowSetsToCanvas Stacktrace " + Log.getStackTraceString( new Exception() ) ) ;
		//log("QuantroApp drawShadowSetsToCanvas main iteration over posRows "
		//		+ indexRowFirst + " -> " + indexRowBound + ", posCols " + indexColFirst + " -> " + indexColBound) ;
		
		//boolean drewCustom = false ;
		//boolean drewIndex = false ;

		for (int posRow = indexRowFirst; posRow < indexRowBound; posRow++) {
			// int row = configRange.indexToRow( posRow ) ;
			// int posRow = configRange.rowToIndex(row);
			// y bounds for this block?
			int top_y = UNSET;

			for (int posCol = indexColFirst; posCol < indexColBound; posCol++) {
				// int col = configRange.indexToCol( posCol ) ;
				// int posCol = configRange.colToIndex(col);

				int left_x = UNSET;

				// get the q orientation, compare against immediate
				// neighborhood.
				// int row = posRow - ds.blockFieldOuterBuffer ;
				// int col = posCol - ds.blockFieldOuterBuffer ;

				int index = shadowSets[posRow][posCol];
				boolean custom = (index / SHADOW_SET_OFFSET_CUSTOM) % 2 == 1;
				if (custom)
					index -= SHADOW_SET_OFFSET_CUSTOM;

				int qo = blockField[qPane][posRow][posCol];

				if (custom) {
					if (top_y == UNSET)
						top_y = ds.getBlockYPosition(qPane, posRow
								- ds.blockFieldOuterBuffer)
								+ drawOffset.y;
					if (left_x == UNSET)
						left_x = ds.getBlockXPosition(qPane, posCol
								- ds.blockFieldOuterBuffer)
								+ drawOffset.x;

					if (customShadow_byQPaneQOrientation != null
							&& customShadow_byQPaneQOrientation[qPane][qo] != null) {
						
						tempDstRect.set(left_x, top_y,
								left_x + size_blockWidth,
								top_y + size_blockHeight);
						
						/*
						if ( !drewCustom ) {
							log("QuantroApp - drawShadowSetsToCanvas drawing custom with source "
									+ customShadow_byQPaneQOrientation[qPane][qo].getConfig()
									+ " " + customShadowBounds_byQPaneQOrientation[qPane][qo] 
									+ " to destination " + tempDstRect ) ;
							drewCustom = true ;
						}
						*/
						
						if ((drop && dropColor == Color.BLACK)
								|| ds.color_qOrientationQPaneFillShadow[qo][qPane] == Color.BLACK) {
							canvas.drawBitmap(
									customShadow_byQPaneQOrientation[qPane][qo],
									customShadowBounds_byQPaneQOrientation[qPane][qo],
									tempDstRect, null);
						} else if ( drop && dropPaint != null ) {
							canvas.drawBitmap(
									customShadow_byQPaneQOrientation[qPane][qo],
									customShadowBounds_byQPaneQOrientation[qPane][qo],
									tempDstRect, dropPaint);
						} else {
							int fillC = this.mLastFillShadowSetsUniqueColor_byQOrientation_byPane[qo][qPane];
							if (!drop
									&& this.mLastFillShadowSetsColorFilterPaint_byUniqueColor[fillC] != null) {
								Paint p = mLastFillShadowSetsColorFilterPaint_byUniqueColor[fillC];
								canvas.drawBitmap(
										customShadow_byQPaneQOrientation[qPane][qo],
										customShadowBounds_byQPaneQOrientation[qPane][qo],
										tempDstRect, p);
							} else if (!canvas.quickReject(tempDstRect.left,
									tempDstRect.top, tempDstRect.right,
									tempDstRect.bottom, Canvas.EdgeType.BW)) {
								// Placeholder a colored shadow render, then
								// draw to canvas.
								renderScratchCanvas.drawPaint(clearPaint);
								renderScratchCanvas.drawBitmap(
										customShadow_byQPaneQOrientation[qPane][qo],
										customShadowBounds_byQPaneQOrientation[qPane][qo],
										renderScratchBounds, null);
								if (!drop)
									maskFirstPaint
											.setColor(ds.color_qOrientationQPaneFillShadow[qo][qPane]);
								else
									maskFirstPaint.setColor(dropColor);
								maskFirstPaint.setAlpha(shadowAlpha);
								renderScratchCanvas
										.drawPaint(maskFirstPaint);
								lastPrerenderedIndex = Integer.MIN_VALUE ;
								canvas.drawBitmap(renderScratchBitmap,
										renderScratchBounds, tempDstRect, null);
							}
						}
						
					} else if (customShadowPath_byQPaneQOrientation != null
							&& customShadowPath_byQPaneQOrientation[qPane][qo] != null) {
						// log("drawing custom region") ;
						canvas.save();
						tempPath.set(customShadowPath_byQPaneQOrientation[qPane][qo]);
						tempPath.offset(left_x, top_y);
						canvas.clipPath(tempPath);
						canvas.drawRect(left_x, top_y,
								left_x + size_blockWidth * 2, top_y
										+ size_blockHeight * 2,
								tempColorPaint);
						canvas.restore();
					}
				}
				if (index != SHADOW_SET_INDEX_NONE) {
					if (top_y == UNSET)
						top_y = ds.getBlockYPosition(qPane, posRow
								- ds.blockFieldOuterBuffer)
								+ drawOffset.y;
					if (left_x == UNSET)
						left_x = ds.getBlockXPosition(qPane, posCol
								- ds.blockFieldOuterBuffer)
								+ drawOffset.x;

					// log("drawing qorientation " + qo + " bitmap : " +
					// b + " index " + index + " canonical index " +
					// indexByNeighbors_toCanonicalRepresentation(index)) ;
					if (shadowSheet != null) {
						indexByNeighbors_sheetRect(tempSrcRect, index,
								sheetBlockWidth, sheetBlockHeight);
						tempDstRect.left = left_x;
						tempDstRect.right = tempDstRect.left
								+ size_blockWidth ;
						tempDstRect.top = top_y;
						tempDstRect.bottom = tempDstRect.top
								+ size_blockHeight ;
						
						/*
						if ( !drewIndex ) {
							log("QuantroApp - drawShadowSetsToCanvas drawing index with source "
									+ shadowSheet.getConfig()
									+ " " + tempSrcRect
									+ " to destination " + tempDstRect ) ;
							drewIndex = true ;
						}
						*/

						if ((drop && dropColor == Color.BLACK)
								|| ds.color_qOrientationQPaneFillShadow[qo][qPane] == Color.BLACK)
							canvas.drawBitmap(shadowSheet, tempSrcRect,
									tempDstRect, tempDitherPaint);
						else {
							int fillC = this.mLastFillShadowSetsUniqueColor_byQOrientation_byPane[qo][qPane];
							if (drop && dropPaint != null) {
								canvas.drawBitmap(shadowSheet, tempSrcRect,
										tempDstRect, dropPaint);
							} else if (!drop
									&& this.mLastFillShadowSetsColorFilterPaint_byUniqueColor[fillC] != null) {
								Paint p = mLastFillShadowSetsColorFilterPaint_byUniqueColor[fillC];
								canvas.drawBitmap(shadowSheet, tempSrcRect,
										tempDstRect, p);
							} else if (!canvas.quickReject(tempDstRect.left,
									tempDstRect.top, tempDstRect.right,
									tempDstRect.bottom, Canvas.EdgeType.BW)) {
								// Placeholder a colored shadow render, then
								// draw to canvas.
								if (lastPrerenderedIndex != index
										|| lastPrerenderedQO != qo) {
									renderScratchCanvas.drawPaint(clearPaint);
									renderScratchCanvas.drawBitmap(shadowSheet,
											tempSrcRect, renderScratchBounds,
											null);
									if (!drop)
										maskFirstPaint
												.setColor(ds.color_qOrientationQPaneFillShadow[qo][qPane]);
									else
										maskFirstPaint.setColor(dropColor);
									maskFirstPaint.setAlpha(shadowAlpha);
									renderScratchCanvas
											.drawPaint(maskFirstPaint);
									lastPrerenderedIndex = index;
								}
								tempDstRect.set(left_x, top_y,
										left_x + size_blockWidth ,
										top_y + size_blockHeight);
								canvas.drawBitmap(renderScratchBitmap,
										renderScratchBounds, tempDstRect, null);
							}
						}
					} else if (shadowRects != null) {
						Paint p;
						if (!drop) {
							tempColorPaint
									.setColor(ds.color_qOrientationQPaneFillShadow[qo][qPane]);
							tempColorPaint.setAlpha(shadowAlpha);
							p = tempColorPaint;
						} else if (drop && dropPaint != null) {
							p = dropPaint;
						} else {
							tempColorPaint.setColor(dropColor);
							tempColorPaint.setAlpha(shadowAlpha);
							p = tempColorPaint;
						}
						for (int i = 0; i < shadowRects[index].length; i++) {
							Rect r = shadowRects[index][i];
							if (r != null) {
								r.offset(left_x, top_y);
								canvas.drawRect(r, p);
								r.offset(-left_x, -top_y);
							}
						}
					} else if (shadowPaths != null) {
						Paint p;
						if (!drop) {
							tempColorPaint
									.setColor(ds.color_qOrientationQPaneFillShadow[qo][qPane]);
							tempColorPaint.setAlpha(shadowAlpha);
							p = tempColorPaint;
						} else if (drop && dropPaint != null) {
							p = dropPaint;
						} else {
							tempColorPaint.setColor(dropColor);
							tempColorPaint.setAlpha(shadowAlpha);
							p = tempColorPaint;
						}
						canvas.save();
						tempPath.set(shadowPaths[index]);
						tempPath.offset(left_x, top_y);
						canvas.clipPath(tempPath);
						canvas.drawRect(tempDstRect, p);
						canvas.restore();
					} else if (drop) {
						Paint p;
						if (dropPaint != null) {
							p = dropPaint;
						} else {
							tempColorPaint.setColor(dropColor);
							tempColorPaint.setAlpha(shadowAlpha);
							p = tempColorPaint;
						}
						// manually draw rects
						if (lastDrawn != index) {
							neighborsByIndex(index, tempConnected, 1, 1);
							lastDrawn = index;
						}
						if (!tempConnected[0][1]) // left edge
							canvas.drawRect(left_x + lsl, top_y + tsb, left_x
									+ lsr, top_y + bst, p);
						if (!tempConnected[1][0]) // top edge
							canvas.drawRect(left_x + lsr, top_y + tst, left_x
									+ rsl, top_y + tsb, p);
						if (!tempConnected[2][1]) // right edge
							canvas.drawRect(left_x + rsl, top_y + tsb, left_x
									+ rsr, top_y + bst, p);
						if (!tempConnected[1][2]) // bottom edge
							canvas.drawRect(left_x + lsr, top_y + bst, left_x
									+ rsl, top_y + bsb, p);

						if (!tempConnected[0][0] || !tempConnected[0][1]
								|| !tempConnected[1][0]) // top-left
							canvas.drawRect(left_x + lsl, top_y + tst, left_x
									+ lsr, top_y + tsb, p);
						if (!tempConnected[2][0] || !tempConnected[2][1]
								|| !tempConnected[1][0]) // top-right
							canvas.drawRect(left_x + rsl, top_y + tst, left_x
									+ rsr, top_y + tsb, p);
						if (!tempConnected[0][2] || !tempConnected[0][1]
								|| !tempConnected[1][2]) // bottom-left
							canvas.drawRect(left_x + lsl, top_y + bst, left_x
									+ lsr, top_y + bsb, p);
						if (!tempConnected[2][2] || !tempConnected[2][1]
								|| !tempConnected[1][2]) // bottom-right
							canvas.drawRect(left_x + rsl, top_y + bst, left_x
									+ rsr, top_y + bsb, p);

					}
				}
			}
		}

	}

	Paint edgeDropShadowColorPaint = new Paint();
	Paint edgeDropShadowDitherPaint = new Paint();
	boolean[][] edgeDropShadowTempConnected = new boolean[3][3];
	Rect edgeDropShadowTempSrc = new Rect();
	Rect edgeDropShadowTempDest = new Rect();

	private void drawEdgeDropShadowsToBitmap(DrawSettings ds, Bitmap b,
			Rect drawArea, int shadowAlpha) {
		double ratio = (double) drawArea.width() / (double) ds.width;
		int destWidth = (int) Math.round(ds.size_blockWidth * ratio);
		int destHeight = (int) Math.round(ds.size_blockHeight * ratio);

		edgeDropShadowColorPaint.setColor(Color.BLACK);
		edgeDropShadowColorPaint.setAlpha(shadowAlpha);
		edgeDropShadowDitherPaint.setAlpha(shadowAlpha);
		edgeDropShadowDitherPaint.setFilterBitmap(true);
		// if ( shadowRegions != null )
		// log("alpha is " + shadowAlpha) ;

		Canvas c = new Canvas(b);
		c.clipRect(drawArea);

		// draw the left edge!
		if (innerBorderDropShadowSheet != null) {
			for (int w = 0; w < 2; w++) {
				if (w == 0) {
					// left wall
					for (int i = 0; i < 3; i++)
						for (int j = 0; j < 3; j++)
							edgeDropShadowTempConnected[i][j] = i != 0; // left
																		// edge
																		// is
																		// wall
					edgeDropShadowTempDest.left = drawArea.left;
					edgeDropShadowTempDest.right = drawArea.left + destWidth;
				} else {
					// right wall
					for (int i = 0; i < 3; i++)
						for (int j = 0; j < 3; j++)
							edgeDropShadowTempConnected[i][j] = i != 2; // right
																		// edge
																		// is
																		// wall
					edgeDropShadowTempDest.left = drawArea.right - destWidth;
					edgeDropShadowTempDest.right = drawArea.right;
				}

				int index = indexByNeighbors(edgeDropShadowTempConnected, 1, 1);
				indexByNeighbors_sheetRect(edgeDropShadowTempSrc, index,
						sheetBlockWidth, sheetBlockHeight);

				edgeDropShadowTempDest.top = drawArea.top;
				edgeDropShadowTempDest.bottom = drawArea.top + destHeight;

                // Drawing edge shadows at different draw scales produces unfortunate artifacts
                // around the edges of the stamp. I'd love to diagnose and fix in a better way
                // than this but for now, inset the stamp borders slightly to avoid black creeping
                // pixels. This slightly stretches the shadow horizontally; sad but necessary.
                edgeDropShadowTempSrc.bottom -= 1;
                if (w == 0) {
                    edgeDropShadowTempSrc.right -= 1;
                } else {
                    edgeDropShadowTempSrc.left += 1;
                }

                while (edgeDropShadowTempDest.top < drawArea.bottom) {
                    c.drawBitmap(innerBorderDropShadowSheet,
							edgeDropShadowTempSrc, edgeDropShadowTempDest,
							edgeDropShadowDitherPaint);
					edgeDropShadowTempDest.top += destHeight;
					edgeDropShadowTempDest.bottom += destHeight;

				}
			}
		} else {
			// low-fi!
			float width = (float) (estimateDropShadowWidth(ds) * ratio);
			c.drawRect(drawArea.left, drawArea.top, drawArea.left + width,
					drawArea.bottom, edgeDropShadowColorPaint);
			c.drawRect(drawArea.right - width, drawArea.top, drawArea.right,
					drawArea.bottom, edgeDropShadowColorPaint);
		}
		
		log("drawEdgeDropShadowsToBitmap complete") ;
	}

	private void drawBorderShineToCanvas(DrawSettings ds, Canvas canvas,
			byte[][][] blockField, int qPane, byte[][] tlCorners,
			byte[][] trCorners, byte[][] blCorners, byte[][] brCorners,
			int shineAlpha, Offset drawOffset) {

		float alphaMult = shineAlpha / 255.0f;

		// An inner border shine is drawn for any qOrientation possessing an
		// inner border and shine corner colors.

		// iterate from top-left across and down. Draw every corner found.
		// Corners exist in a particular direction (diagonal):
		// XY CONVEX if this qo has inner border, and X and Y are both
		// different.
		// XY CONCAVE if this qo has inner border, X and Y are both the same,
		// and XY is different.
		// XY_(-X)Y CONCAVE EXTEND if X has (-X)Y CONCAVE.
		// XY_X(-Y) CONCAVE EXTEND if Y has X(-Y) CONCAVE.

		// We draw corners in a solid-color rectangle with dimensions
		// borderWidth * borderHeight, placed according to XY, and colored
		// according to either XY in most cases, or the "extended" corner
		// orientation if extended. In other words, CONCAVE corners extend
		// into neighboring blocks and are colored consistently with the
		// original color.

		// In addition to drawing colors, we also draw our ShineDrawables
		// to extend from corner to corner. For horizontal borders, we
		// match vertical dimensions to the border and horizontal to sit
		// flush between the corners drawn above.

		// Do these things. We start from the top-left (top row, min column)
		// and iterate rightward, then downward. We draw corner rectangles
		// upon discovery, then shines leftward and downward. Shines extend
		// from CONVEX and CONCAVE EXTEND corners, but not from CONCAVE.

		// Lastly, it is worth noting that inner borders only connect
		// the same QOrientation with itself. We can therefore check
		// for specific QOrientations, rather than use complex QInteractions.
		// We iterate by QOrientation first, drawing the borders for it
		// before moving on to the next.

		// Draw our corners block-by-block, and extend each rightward and
		// downward if appropriate.

		for (int row = ds.displayedRows - 1; row >= 0; row--) {
			// y bounds for this block?
			int top_y = ds.getBlockYPosition(qPane, row) + drawOffset.y;
			int bottom_y = top_y + ds.size_blockHeight;

			for (int col = 0; col < ds.COLS; col++) {
				// ignore completely if we have no corners.
				if (tlCorners[row][col] == -1 && trCorners[row][col] == -1
						&& blCorners[row][col] == -1
						&& brCorners[row][col] == -1)
					continue;

				// get the q orientation.
				int posRow = row + ds.blockFieldOuterBuffer;
				int posCol = col + ds.blockFieldOuterBuffer;
				byte qo = blockField[qPane][posRow][posCol];

				if (ds.behavior_qo_border[qo] != DrawSettings.BEHAVIOR_QO_BORDER_INNER
						&& ds.behavior_qo_border[qo] != DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER
						&& ds.behavior_qo_border[qo] != DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY
						&& ds.behavior_qo_border[qo] != DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY_BLEND
						&& ds.behavior_qo_border[qo] != DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE
						&& ds.behavior_qo_border[qo] != DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE)
					continue;

				// x bounds?
				int left_x = ds.getBlockXPosition(qPane, col) + drawOffset.x;
				int right_x = left_x + ds.size_blockWidth;

				int c0;
				int color;

				// go through our corners.
				c0 = tlCorners[row][col];
				if (c0 != -1) {
					color = ds.getColor_borderShine(qPane, qo, c0) ;
					tempRect.left = left_x;
					tempRect.top = top_y;
					tempRect.right = left_x + ds.size_borderWidth;
					tempRect.bottom = top_y + ds.size_borderHeight;

					tempColorPaint.setColor(color);
					tempColorPaint
							.setAlpha((int) (Color.alpha(color) * alphaMult));
					canvas.drawRect(tempRect, tempColorPaint);

					// draw rightward, if appropriate.
					if (c0 == DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX
							|| c0 == DrawSettings.CORNER_INNER_RIGHT_TOP_CONCAVE)
						drawBorderShineRightward(ds, canvas, tempRect, c0,
								trCorners, qo, qPane, row, col, shineAlpha,
								drawOffset);

					// draw downward, if appropriate.
					if (c0 == DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX
							|| c0 == DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONCAVE)
						drawBorderShineDownward(ds, canvas, tempRect, c0,
								blCorners, qo, qPane, row, col, shineAlpha,
								drawOffset);

				}

				// top-right
				c0 = trCorners[row][col];
				if (c0 != -1) {
					color = ds.getColor_borderShine(qPane, qo, c0) ;
					tempRect.left = right_x - ds.size_borderWidth;
					tempRect.right = right_x;
					tempRect.top = top_y;
					tempRect.bottom = top_y + ds.size_borderHeight;

					tempColorPaint.setColor(color);
					tempColorPaint
							.setAlpha((int) (Color.alpha(color) * alphaMult));
					canvas.drawRect(tempRect, tempColorPaint);

					// draw downward, if appropriate.
					if (c0 == DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX
							|| c0 == DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONCAVE)
						drawBorderShineDownward(ds, canvas, tempRect, c0,
								brCorners, qo, qPane, row, col, shineAlpha,
								drawOffset);
				}

				// bottom-left
				c0 = blCorners[row][col];
				if (c0 != -1) {
					color = ds.getColor_borderShine(qPane, qo, c0) ;
					tempRect.left = left_x;
					tempRect.right = left_x + ds.size_borderWidth;
					tempRect.top = bottom_y - ds.size_borderHeight;
					tempRect.bottom = bottom_y;

					tempColorPaint.setColor(color);
					tempColorPaint
							.setAlpha((int) (Color.alpha(color) * alphaMult));
					canvas.drawRect(tempRect, tempColorPaint);

					// draw rightward, if appropriate.
					if (c0 == DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX
							|| c0 == DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONCAVE)
						drawBorderShineRightward(ds, canvas, tempRect, c0,
								brCorners, qo, qPane, row, col, shineAlpha,
								drawOffset);
				}

				// bottom-right.
				c0 = brCorners[row][col];
				if (c0 != -1) {
					color = ds.getColor_borderShine(qPane, qo, c0) ;
					tempRect.left = right_x - ds.size_borderWidth;
					tempRect.right = right_x;
					tempRect.top = bottom_y - ds.size_borderHeight;
					tempRect.bottom = bottom_y;

					tempColorPaint.setColor(color);
					tempColorPaint
							.setAlpha((int) (Color.alpha(color) * alphaMult));
					canvas.drawRect(tempRect, tempColorPaint);
				}
			}
		}

		// Now draw the inset border shines.
		for (int row = ds.displayedRows - 1; row >= 0; row--) {
			// y bounds for this block?
			int top_y = ds.getBlockYPosition(qPane, row) + drawOffset.y;

			for (int col = 0; col < ds.COLS; col++) {

				// get the q orientation.
				int posRow = row + ds.blockFieldOuterBuffer;
				int posCol = col + ds.blockFieldOuterBuffer;
				int qo = blockField[qPane][posRow][posCol];

				if (ds.behavior_qo_border[qo] != DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INSET
						&& ds.behavior_qo_border[qo] != DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI
						&& ds.behavior_qo_border[qo] != DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_HORIZONTAL_OVER
						&& ds.behavior_qo_border[qo] != DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_VERTICAL_OVER)
					continue;

				// x bounds?
				int left_x = ds.getBlockXPosition(qPane, col) + drawOffset.x;

				// DRAAAAWWWW!
				tempDstRect.set(left_x, top_y,
						left_x + ds.size_blockWidth,
						top_y + ds.size_blockHeight);
				tempColorPaint.setAlpha(shineAlpha);
				canvas.drawBitmap(
						customBorderShine_byQPaneQOrientation[qPane][qo],
						customBorderShineBounds_byQPaneQOrientation[qPane][qo],
						tempDstRect, tempColorPaint);
			}
		}
	}

	
	
	private void drawBorderDrawablesToCanvas(DrawSettings ds, Canvas canvas,
			byte[][][] blockField, BlockDrawerConfigRange configRange,
			int qPane, byte[][] tlCorners, byte[][] trCorners,
			byte[][] blCorners, byte[][] brCorners, int alpha, boolean simplifiedColors,
			Offset drawOffset) {

		float alphaMult = alpha / 255.0f;
		// We draw BorderDrawables three different ways.

		// First, when drawing BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER, we draw
		// corners and Drawables
		// as if drawing a Shine. We also look for "custom" or "friendly"
		// borders; we draw them
		// in a separate pass.

		// "custom" borders are drawn directly as bitmaps onto the canvas.

		// Friendly borders are a bit more difficult. We draw the underlying
		// border "color"
		// (which may be a color or a gradient drawable), then the shine on top.

		// iterate from top-left across and down. Draw every corner found.
		// Corners exist in a particular direction (diagonal):
		// XY CONVEX if this qo has inner border, and X and Y are both
		// different.
		// XY CONCAVE if this qo has inner border, X and Y are both the same,
		// and XY is different.
		// XY_(-X)Y CONCAVE EXTEND if X has (-X)Y CONCAVE.
		// XY_X(-Y) CONCAVE EXTEND if Y has X(-Y) CONCAVE.

		// We draw corners in a solid-color rectangle with dimensions
		// borderWidth * borderHeight, placed according to XY, and colored
		// according to either XY in most cases, or the "extended" corner
		// orientation if extended. In other words, CONCAVE corners extend
		// into neighboring blocks and are colored consistently with the
		// original color.

		// In addition to drawing colors, we also draw our ShineDrawables
		// to extend from corner to corner. For horizontal borders, we
		// match vertical dimensions to the border and horizontal to sit
		// flush between the corners drawn above.

		// Do these things. We start from the top-left (top row, min column)
		// and iterate rightward, then downward. We draw corner rectangles
		// upon discovery, then shines leftward and downward. Shines extend
		// from CONVEX and CONCAVE EXTEND corners, but not from CONCAVE.

		// Lastly, it is worth noting that inner borders only connect
		// the same QOrientation with itself. We can therefore check
		// for specific QOrientations, rather than use complex QInteractions.
		// We iterate by QOrientation first, drawing the borders for it
		// before moving on to the next.

		// Draw our corners block-by-block, and extend each rightward and
		// downward if appropriate.

		boolean hasCustomBorders = false;
		boolean hasFriendlyOrVolatileBorders = false;

		canvas.getClipBounds(tempClipRect);
		
		// OPTIMIZATION ASSUMPTION:
		// The conversion between ConfigRange row <-> index, and col <-> index,
		// is just a constant offset.  We thus don't actually need to call the
		// conversion method every time, just the once, and then increment as we go.
		
		final int y_step = ds.size_blockHeight ;
		final int x_step = ds.size_blockWidth ;

		// iterate from top to bottom.  At each step, set bottom_y to the
		// current top_y, and increment top_y by y_step.
		int bottom_y, top_y = ds.getBlockYPosition(qPane, configRange.rowFirst-1) + drawOffset.y ;
		int posRow = configRange.indexRowFirst-1 ;
		for (int row = configRange.rowFirst; row < configRange.rowBound; row++) {
			// y bounds for this block?
			bottom_y = top_y ;
			top_y -= y_step ;
			
			posRow++ ;

			int col = configRange.columnFirst - 1;
			for (int posCol = configRange.indexColFirst; posCol < configRange.indexColBound; posCol++) {
				col++ ;
				
				// get the q orientation.
				int qo = blockField[qPane][posRow][posCol];
				int behavior = ds.behavior_qo_border[qo];
				int bitmap_behavior = ds.behavior_qo_bitmap[qo] ;

				if (behavior == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY
						|| behavior == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY_BLEND
						|| behavior == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE) {
					hasFriendlyOrVolatileBorders = true;
					continue;
				}

				if (behavior == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INSET
						|| behavior == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI
						|| behavior == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_HORIZONTAL_OVER
						|| behavior == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_VERTICAL_OVER
						|| (bitmap_behavior == DrawSettings.BEHAVIOR_QO_BITMAP_CHEVRON_BORDER ) ) {
					hasCustomBorders = true;
					continue;
				}

				if (behavior != DrawSettings.BEHAVIOR_QO_BORDER_INNER
						&& behavior != DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER
						&& behavior != DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE)
					continue;

				// ignore completely if we have no corners.
				if (tlCorners[row][col] == -1 && trCorners[row][col] == -1
						&& blCorners[row][col] == -1
						&& brCorners[row][col] == -1)
					continue;

				// x bounds?
				int left_x = ds.getBlockXPosition(qPane, col) + drawOffset.x;
				int right_x = left_x + ds.size_blockWidth;

				// SPECIAL CASE: as an impromtu optimization, we can draw the
				// border of a LOW detail
				// square quite easily (clip the inside and color fill).
				if (ds.drawDetail == DrawSettings.DRAW_DETAIL_LOW
						&& tlCorners[row][col] == DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX
						&& trCorners[row][col] == DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX
						&& blCorners[row][col] == DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX
						&& brCorners[row][col] == DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX) {
					canvas.save();
					canvas.clipRect(left_x + ds.size_borderWidth, top_y
							+ ds.size_borderHeight, right_x
							- ds.size_borderWidth, bottom_y
							- ds.size_borderHeight, Region.Op.DIFFERENCE);
					
					int color = simplifiedColors 
							? ds.colorSimplified_qOrientationQPaneBorder[qo][qPane]
							: ds.color_qOrientationQPaneBorder[qo][qPane] ;
					borderPaint.setColor(color);
					borderPaint.setAlpha(alpha);
					canvas.drawRect(left_x, top_y, right_x, bottom_y,
							borderPaint);
					canvas.restore();
					continue;
				}

				int c0;

				// go through our corners.
				c0 = blCorners[row][col];
				if (c0 != -1) {
					// draw the corner here
					Drawable d = null ;
					int color ;
					if ( simplifiedColors ) {
						color = ds.colorSimplified_qOrientationQPaneBorder[qo][qPane] ;
					} else {
						d = innerBorder_byQPaneQOrientationCornerCornerDirection[qPane][qo][c0][c0][DIRECTION_NONE];
						color = innerBorderColorSubstitute_byQPaneQOrientationCornerCorner[qPane][qo][c0][c0];
					}
					tempRect.left = left_x;
					tempRect.top = bottom_y - ds.size_borderHeight;
					tempRect.right = left_x + ds.size_borderWidth;
					tempRect.bottom = bottom_y;

					if (Rect.intersects(tempClipRect, tempRect)) {
						if (d != null) {
							d.setAlpha(alpha);
							d.setBounds(tempRect);
							d.draw(canvas);
						} else {
							tempColorPaint.setColor(color) ;
							tempColorPaint
									.setAlpha((int) (Color.alpha(color) * alphaMult));
							canvas.drawRect(tempRect, tempColorPaint);
						}
					}

					// draw rightward, if appropriate.
					if (c0 == DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX
							|| c0 == DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONCAVE)
						drawBorderRightward(ds, canvas, tempClipRect, tempRect,
								c0, brCorners, qo, qPane, row, col, alpha, simplifiedColors,
								drawOffset);

					// draw upward, if appropriate.
					if (c0 == DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX
							|| c0 == DrawSettings.CORNER_INNER_LEFT_TOP_CONCAVE)
						drawBorderUpward(ds, canvas, tempClipRect, tempRect,
								c0, tlCorners, qo, qPane, row, col, alpha, simplifiedColors,
								drawOffset);
				}

				// bottom-right
				c0 = brCorners[row][col];
				if (c0 != -1) {
					// draw the corner here
					Drawable d = null ;
					int color ;
					if ( simplifiedColors ) {
						color = ds.colorSimplified_qOrientationQPaneBorder[qo][qPane] ;
					} else {
						d = innerBorder_byQPaneQOrientationCornerCornerDirection[qPane][qo][c0][c0][DIRECTION_NONE];
						color = innerBorderColorSubstitute_byQPaneQOrientationCornerCorner[qPane][qo][c0][c0];
					}
					tempRect.left = right_x - ds.size_borderWidth;
					tempRect.right = right_x;
					tempRect.top = bottom_y - ds.size_borderHeight;
					tempRect.bottom = bottom_y;

					if (Rect.intersects(tempClipRect, tempRect)) {
						if (d != null) {
							d.setAlpha(alpha);
							d.setBounds(tempRect);
							d.draw(canvas);
						} else {
							tempColorPaint.setColor(color);
							tempColorPaint
									.setAlpha((int) (Color.alpha(color) * alphaMult));
							canvas.drawRect(tempRect, tempColorPaint);
						}
					}

					// draw upward, if appropriate.
					if (c0 == DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX
							|| c0 == DrawSettings.CORNER_INNER_RIGHT_TOP_CONCAVE)
						drawBorderUpward(ds, canvas, tempClipRect, tempRect,
								c0, trCorners, qo, qPane, row, col, alpha, simplifiedColors,
								drawOffset);
				}

				// top-left
				c0 = tlCorners[row][col];
				if (c0 != -1) {
					// draw the corner here
					Drawable d = null ;
					int color ;
					if ( simplifiedColors ) {
						color = ds.colorSimplified_qOrientationQPaneBorder[qo][qPane] ;
					} else {
						d = innerBorder_byQPaneQOrientationCornerCornerDirection[qPane][qo][c0][c0][DIRECTION_NONE];
						color = innerBorderColorSubstitute_byQPaneQOrientationCornerCorner[qPane][qo][c0][c0];
					}
					tempRect.left = left_x;
					tempRect.right = left_x + ds.size_borderWidth;
					tempRect.top = top_y;
					tempRect.bottom = top_y + ds.size_borderHeight;

					if (Rect.intersects(tempClipRect, tempRect)) {
						if (d != null) {
							d.setAlpha(alpha);
							d.setBounds(tempRect);
							d.draw(canvas);
						} else {
							tempColorPaint.setColor(color);
							tempColorPaint
									.setAlpha((int) (Color.alpha(color) * alphaMult));
							canvas.drawRect(tempRect, tempColorPaint);
						}
					}

					// draw rightward, if appropriate.
					if (c0 == DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX
							|| c0 == DrawSettings.CORNER_INNER_RIGHT_TOP_CONCAVE)
						drawBorderRightward(ds, canvas, tempClipRect, tempRect,
								c0, trCorners, qo, qPane, row, col, alpha, simplifiedColors,
								drawOffset);
				}

				// top-right.
				c0 = trCorners[row][col];
				if (c0 != -1) {
					// draw the corner here
					Drawable d = null ;
					int color ;
					if ( simplifiedColors ) {
						color = ds.colorSimplified_qOrientationQPaneBorder[qo][qPane] ;
					} else {
						d = innerBorder_byQPaneQOrientationCornerCornerDirection[qPane][qo][c0][c0][DIRECTION_NONE];
						color = innerBorderColorSubstitute_byQPaneQOrientationCornerCorner[qPane][qo][c0][c0];
					}
					tempRect.left = right_x - ds.size_borderWidth;
					tempRect.right = right_x;
					tempRect.top = top_y;
					tempRect.bottom = top_y + ds.size_borderHeight;

					if (Rect.intersects(tempClipRect, tempRect)) {
						if (d != null) {
							d.setAlpha(alpha);
							d.setBounds(tempRect);
							d.draw(canvas);
						} else {
							tempColorPaint.setColor(color);
							tempColorPaint
									.setAlpha((int) (Color.alpha(color) * alphaMult));
							canvas.drawRect(tempRect, tempColorPaint);
						}
					}
				}
			}
		}

		// Now draw the custom borders.
		if (hasCustomBorders) {
			top_y = ds.getBlockYPosition(qPane, configRange.rowBound) + drawOffset.y ;
			for ( posRow = configRange.indexRowBound - 1; posRow >= configRange.indexRowFirst; posRow-- ) {
				// y bounds for this block?
				top_y += y_step ;

				int left_x = ds.getBlockXPosition(qPane, configRange.columnFirst-1) + drawOffset.x ;
				for (int posCol = configRange.indexColFirst; posCol < configRange.indexColBound; posCol++) {
					left_x += x_step ;
					
					// get the q orientation.
					int qo = blockField[qPane][posRow][posCol];

					if ( customBorder_byQPaneQOrientation[qPane][qo] == null )
						continue ;

					// DRAAAAWWWW!
					tempDstRect.set(left_x, top_y,
							left_x + ds.size_blockWidth,
							top_y + ds.size_blockHeight);
					tempColorPaint.setAlpha(alpha);
					canvas.drawBitmap(
							customBorder_byQPaneQOrientation[qPane][qo],
							customBorderBounds_byQPaneQOrientation[qPane][qo],
							tempDstRect, tempColorPaint);
				}
			}
		}

		// Finally, the friendly borders. This is probably the most difficult
		// one.
		if (hasFriendlyOrVolatileBorders) {
			// a friendly border is drawn in two steps, a border (color or
			// drawable) and
			// a shine applied atop it.

			// First: draw ALL friendly borders (before any shines!)
			regionOffset.x = drawOffset.x + canvasTranslationOffset.x;
			regionOffset.y = drawOffset.y + canvasTranslationOffset.y;

			for (int qo = 0; qo < QOrientations.NUM; qo++) {
				if (ds.behavior_qo_border[qo] != DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY
						&& ds.behavior_qo_border[qo] != DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY_BLEND
						&& ds.behavior_qo_border[qo] != DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE)
					continue;

				regionOffset.x = drawOffset.x + canvasTranslationOffset.x;
				regionOffset.y = drawOffset.y + canvasTranslationOffset.y;
				setRegionQOrientationBorderLayer(ds, qoBorderPath,
						blockField, qPane, qo, regionOffset);

				// SAVE CANVAS CLIP
				canvas.save();
				canvas.clipPath(qoBorderPath);  // intersection
				// canvas.clipRegion(differenceMask, Region.Op.DIFFERENCE) ;
				int color = simplifiedColors
						? ds.colorSimplified_qOrientationQPaneBorder[qo][qPane]
						: ds.color_qOrientationQPaneBorder[qo][qPane] ;
				borderPaint.setColor(color);
				borderPaint.setAlpha(alpha);

				canvas.drawPaint(borderPaint);

				// Now draw friendly blends, if we have any. The clip is
				// currently in place.
				if (!simplifiedColors && ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY_BLEND) {
					
					top_y = ds.getBlockYPosition(qPane, configRange.rowFirst-1) + drawOffset.y ;
					posRow = configRange.indexRowFirst-1 ;
					for (int row = configRange.rowFirst; row < configRange.rowBound; row++) {
						// y bounds for this block?
						bottom_y = top_y ;
						top_y -= y_step ;
						
						posRow++ ;

						int col = configRange.columnFirst-1 ;
						for (int posCol = configRange.indexColFirst; posCol < configRange.indexColBound; posCol++) {
							col++ ;
							
							if (qo != blockField[qPane][posRow][posCol])
								continue;

							// x bounds?
							int left_x = ds.getBlockXPosition(qPane, col)
									+ drawOffset.x;
							int right_x = left_x + ds.size_blockWidth;

							// friendly drawable?
							Drawable d ;
							
							if ( simplifiedColors ) {
								d = (Drawable)findFriendlyBlendObject(blockField,
										qPane, posRow, posCol,
										friendlyBorderBlendSimplified_byQPaneQOrientationFromToDirection);
							} else {
								d = (Drawable)findFriendlyBlendObject(blockField,
										qPane, posRow, posCol,
										friendlyBorderBlend_byQPaneQOrientationFromToDirection);
							}
							
							if (d != null && alpha > 0) {
								d.setAlpha((int) (alpha)); // TODO: add alpha
															// support?
								d.setBounds(left_x, top_y, right_x, bottom_y);
								d.draw(canvas);
							}
						}
					}
				}

				// RESTORE CANVAS CLIP
				canvas.restore();
			}

			// this is a hack to avoid a full-opacity shine display.
			alphaMult = alpha / 255.0f;

			// now draw friendly shines.
			if ( !simplifiedColors ) {
				top_y = ds.getBlockYPosition(qPane, configRange.rowFirst-1) + drawOffset.y ;
				posRow = configRange.indexRowFirst-1 ;
				for (int row = configRange.rowFirst; row < configRange.rowBound; row++) {
					// y bounds for this block?
					bottom_y = top_y ;
					top_y -= y_step ;
					
					posRow++ ;

					int col = configRange.columnFirst-1 ;
					for (int posCol = configRange.indexColFirst; posCol < configRange.indexColBound; posCol++) {
						col++ ;
						
						byte qo = blockField[qPane][posRow][posCol];
						
						if (ds.behavior_qo_border[qo] != DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY
								&& ds.behavior_qo_border[qo] != DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY_BLEND
								&& ds.behavior_qo_border[qo] != DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE)
							continue;
						
						// ignore completely if we have no corners.
						if (tlCorners[row][col] == -1 && trCorners[row][col] == -1
								&& blCorners[row][col] == -1
								&& brCorners[row][col] == -1)
							continue;
	
						// x bounds?
						int left_x = ds.getBlockXPosition(qPane, col)
								+ drawOffset.x;
						int right_x = left_x + ds.size_blockWidth;
	
						int c0;
						int color;
	
						// go through our corners.
						c0 = blCorners[row][col];
						if (c0 != -1) {
							color = ds.getColor_borderShine(qPane, qo, c0) ;
							tempRect.left = left_x;
							tempRect.top = bottom_y - ds.size_borderHeight;
							tempRect.right = left_x + ds.size_borderWidth;
							tempRect.bottom = bottom_y;
	
							tempColorPaint.setColor(color);
							tempColorPaint
									.setAlpha((int) (Color.alpha(color) * alphaMult));
							canvas.drawRect(tempRect, tempColorPaint);
	
							// draw rightward, if appropriate.
							if (c0 == DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX
									|| c0 == DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONCAVE)
								drawBorderShineRightward(ds, canvas, tempRect, c0,
										brCorners, qo, qPane, row, col, alpha,
										drawOffset);
	
							// draw upward, if appropriate.
							if (c0 == DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX
									|| c0 == DrawSettings.CORNER_INNER_LEFT_TOP_CONCAVE)
								drawBorderShineUpward(ds, canvas, tempRect, c0,
										tlCorners, qo, qPane, row, col, alpha,
										drawOffset);
	
						}
	
						// bottom-right
						c0 = brCorners[row][col];
						if (c0 != -1) {
							color = ds.getColor_borderShine(qPane, qo, c0) ;
							tempRect.left = right_x - ds.size_borderWidth;
							tempRect.right = right_x;
							tempRect.top = bottom_y - ds.size_borderHeight;
							tempRect.bottom = bottom_y;
	
							tempColorPaint.setColor(color);
							tempColorPaint
									.setAlpha((int) (Color.alpha(color) * alphaMult));
							canvas.drawRect(tempRect, tempColorPaint);
	
							// draw downward, if appropriate.
							if (c0 == DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX
									|| c0 == DrawSettings.CORNER_INNER_RIGHT_TOP_CONCAVE)
								drawBorderShineUpward(ds, canvas, tempRect, c0,
										trCorners, qo, qPane, row, col, alpha,
										drawOffset);
						}
	
						// top-left
						c0 = tlCorners[row][col];
						if (c0 != -1) {
							color = ds.getColor_borderShine(qPane, qo, c0) ;
							tempRect.left = left_x;
							tempRect.right = left_x + ds.size_borderWidth;
							tempRect.top = top_y;
							tempRect.bottom = top_y + ds.size_borderHeight;
	
							tempColorPaint.setColor(color);
							tempColorPaint
									.setAlpha((int) (Color.alpha(color) * alphaMult));
							canvas.drawRect(tempRect, tempColorPaint);
	
							// draw rightward, if appropriate.
							if (c0 == DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX
									|| c0 == DrawSettings.CORNER_INNER_RIGHT_TOP_CONCAVE)
								drawBorderShineRightward(ds, canvas, tempRect, c0,
										trCorners, qo, qPane, row, col, alpha,
										drawOffset);
						}
	
						// top-right.
						c0 = trCorners[row][col];
						if (c0 != -1) {
							color = ds.getColor_borderShine(qPane, qo, c0) ;
							tempRect.left = right_x - ds.size_borderWidth;
							tempRect.right = right_x;
							tempRect.top = top_y;
							tempRect.bottom = top_y + ds.size_borderHeight;
	
							tempColorPaint.setColor(color);
							tempColorPaint
									.setAlpha((int) (Color.alpha(color) * alphaMult));
							canvas.drawRect(tempRect, tempColorPaint);
						}
					}
				}
			}
		}
	}

	/**
	 * Iterates through the provided blockfield, setting the values in
	 * tempTLCorners, tempTRCorners, etc. Uses qPane within the blockfield.
	 * Corners are determined by the specified draw settings border behavior.
	 * 
	 * @param blockfield
	 * @param qPane
	 */
	private void setCornerArrays(DrawSettings ds, byte[][][] blockfield,
			int qPane, byte[][] tlCorners, byte[][] trCorners,
			byte[][] blCorners, byte[][] brCorners) {
		tempConnected[1][1] = true;
		for (int row = Math.min(ds.ROWS - 1, tlCorners.length - 1); row >= 0; row--) {
			for (int col = 0; col < ds.COLS; col++) {

				tlCorners[row][col] = trCorners[row][col] = blCorners[row][col] = brCorners[row][col] = -1;

				int posRow = row + ds.blockFieldOuterBuffer;
				int posCol = col + ds.blockFieldOuterBuffer;

				int qo = blockfield[qPane][posRow][posCol];

				if (ds.behavior_qo_border[qo] != DrawSettings.BEHAVIOR_QO_BORDER_INNER
						&& ds.behavior_qo_border[qo] != DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER
						&& ds.behavior_qo_border[qo] != DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY
						&& ds.behavior_qo_border[qo] != DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY_BLEND
						&& ds.behavior_qo_border[qo] != DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE
						&& ds.behavior_qo_border[qo] != DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE)
					continue;

				// examine neighbors to determine corners
				// We use x/y notation for connected.
				if (ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_INNER) {
					for (int r = -1; r <= 1; r++)
						for (int c = -1; c <= 1; c++)
							if (r != 0 || c != 0)
								tempConnected[1 + c][1 - r] = false;
				} else if (ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER
						|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE) {
					for (int r = -1; r <= 1; r++)
						for (int c = -1; c <= 1; c++)
							if (r != 0 || c != 0)
								tempConnected[1 + c][1 - r] = qo == blockfield[qPane][posRow
										+ r][posCol + c];
				} else if (ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE) {
					for (int r = -1; r <= 1; r++)
						for (int c = -1; c <= 1; c++)
							if (r != 0 || c != 0) {
								int qoHere = blockfield[qPane][posRow + r][posCol
										+ c];
								tempConnected[1 + c][1 - r] = ds.behavior_qo_border[qoHere] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE
										&& ds.color_qOrientationQPaneBorder[qo][qPane] == ds.color_qOrientationQPaneBorder[qoHere][qPane];
							}
				} else {
					// friendly connects with friendly.
					for (int r = -1; r <= 1; r++) {
						for (int c = -1; c <= 1; c++) {
							if (r != 0 || c != 0) {
								int qoHere = blockfield[qPane][posRow + r][posCol
										+ c];
								tempConnected[1 + c][1 - r] = ds.behavior_qo_border[qoHere] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY
										|| ds.behavior_qo_border[qoHere] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY_BLEND;
							}
						}
					}
				}

				int X, Y;

				// top-left
				X = 0;
				Y = 0;
				if (!tempConnected[X][1] && !tempConnected[1][Y])
					tlCorners[row][col] = DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX;
				else if (tempConnected[X][1] && tempConnected[X][Y]
						&& !tempConnected[1][Y])
					tlCorners[row][col] = DrawSettings.CORNER_INNER_RIGHT_TOP_CONCAVE;
				else if (tempConnected[1][Y] && tempConnected[X][Y]
						&& !tempConnected[X][1])
					tlCorners[row][col] = DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONCAVE;
				else if (tempConnected[1][Y] && tempConnected[X][1]
						&& !tempConnected[X][Y])
					tlCorners[row][col] = DrawSettings.CORNER_INNER_LEFT_TOP_CONCAVE;
				// top-right
				X = 2;
				Y = 0;
				if (!tempConnected[X][1] && !tempConnected[1][Y])
					trCorners[row][col] = DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX;
				else if (tempConnected[X][1] && tempConnected[X][Y]
						&& !tempConnected[1][Y])
					trCorners[row][col] = DrawSettings.CORNER_INNER_LEFT_TOP_CONCAVE;
				else if (tempConnected[1][Y] && tempConnected[X][Y]
						&& !tempConnected[X][1])
					trCorners[row][col] = DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONCAVE;
				else if (tempConnected[1][Y] && tempConnected[X][1]
						&& !tempConnected[X][Y])
					trCorners[row][col] = DrawSettings.CORNER_INNER_RIGHT_TOP_CONCAVE;
				// bottom-left
				X = 0;
				Y = 2;
				if (!tempConnected[X][1] && !tempConnected[1][Y])
					blCorners[row][col] = DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX;
				else if (tempConnected[X][1] && tempConnected[X][Y]
						&& !tempConnected[1][Y])
					blCorners[row][col] = DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONCAVE;
				else if (tempConnected[1][Y] && tempConnected[X][Y]
						&& !tempConnected[X][1])
					blCorners[row][col] = DrawSettings.CORNER_INNER_LEFT_TOP_CONCAVE;
				else if (tempConnected[1][Y] && tempConnected[X][1]
						&& !tempConnected[X][Y])
					blCorners[row][col] = DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONCAVE;
				// bottom-right
				X = 2;
				Y = 2;
				if (!tempConnected[X][1] && !tempConnected[1][Y])
					brCorners[row][col] = DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX;
				else if (tempConnected[X][1] && tempConnected[X][Y]
						&& !tempConnected[1][Y])
					brCorners[row][col] = DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONCAVE;
				else if (tempConnected[1][Y] && tempConnected[X][Y]
						&& !tempConnected[X][1])
					brCorners[row][col] = DrawSettings.CORNER_INNER_RIGHT_TOP_CONCAVE;
				else if (tempConnected[1][Y] && tempConnected[X][1]
						&& !tempConnected[X][Y])
					brCorners[row][col] = DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONCAVE;
			}
		}
	}

	/**
	 * Iterates through the provided blockfield, setting the values in
	 * tempTLCorners, tempTRCorners, etc. Uses qPane within the blockfield.
	 * Corners are determined by exact QO matches - "walls" appear between any
	 * non-identical QO, regardless of behavior or other considerations. 'NO' is
	 * un-cornered.
	 * 
	 * @param blockfield
	 * @param qPane
	 */
	private void setQOCornerArays(DrawSettings ds, byte[][][] blockfield,
			int qPane, byte[][] tlCorners, byte[][] trCorners,
			byte[][] blCorners, byte[][] brCorners) {
		tempConnected[1][1] = true;
		for (int row = Math.min(ds.ROWS - 1, tlCorners.length - 1); row >= 0; row--) {
			for (int col = 0; col < ds.COLS; col++) {

				tlCorners[row][col] = trCorners[row][col] = blCorners[row][col] = brCorners[row][col] = -1;

				int posRow = row + ds.blockFieldOuterBuffer;
				int posCol = col + ds.blockFieldOuterBuffer;

				int qo = blockfield[qPane][posRow][posCol];

				if (qo == QOrientations.NO)
					continue;

				for (int r = -1; r <= 1; r++)
					for (int c = -1; c <= 1; c++)
						if (r != 0 || c != 0)
							tempConnected[1 + c][1 - r] = qo == blockfield[qPane][posRow
									+ r][posCol + c];

				int X, Y;

				// top-left
				X = 0;
				Y = 0;
				if (!tempConnected[X][1] && !tempConnected[1][Y])
					tlCorners[row][col] = DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX;
				else if (tempConnected[X][1] && tempConnected[X][Y]
						&& !tempConnected[1][Y])
					tlCorners[row][col] = DrawSettings.CORNER_INNER_RIGHT_TOP_CONCAVE;
				else if (tempConnected[1][Y] && tempConnected[X][Y]
						&& !tempConnected[X][1])
					tlCorners[row][col] = DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONCAVE;
				else if (tempConnected[1][Y] && tempConnected[X][1]
						&& !tempConnected[X][Y])
					tlCorners[row][col] = DrawSettings.CORNER_INNER_LEFT_TOP_CONCAVE;
				// top-right
				X = 2;
				Y = 0;
				if (!tempConnected[X][1] && !tempConnected[1][Y])
					trCorners[row][col] = DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX;
				else if (tempConnected[X][1] && tempConnected[X][Y]
						&& !tempConnected[1][Y])
					trCorners[row][col] = DrawSettings.CORNER_INNER_LEFT_TOP_CONCAVE;
				else if (tempConnected[1][Y] && tempConnected[X][Y]
						&& !tempConnected[X][1])
					trCorners[row][col] = DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONCAVE;
				else if (tempConnected[1][Y] && tempConnected[X][1]
						&& !tempConnected[X][Y])
					trCorners[row][col] = DrawSettings.CORNER_INNER_RIGHT_TOP_CONCAVE;
				// bottom-left
				X = 0;
				Y = 2;
				if (!tempConnected[X][1] && !tempConnected[1][Y])
					blCorners[row][col] = DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX;
				else if (tempConnected[X][1] && tempConnected[X][Y]
						&& !tempConnected[1][Y])
					blCorners[row][col] = DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONCAVE;
				else if (tempConnected[1][Y] && tempConnected[X][Y]
						&& !tempConnected[X][1])
					blCorners[row][col] = DrawSettings.CORNER_INNER_LEFT_TOP_CONCAVE;
				else if (tempConnected[1][Y] && tempConnected[X][1]
						&& !tempConnected[X][Y])
					blCorners[row][col] = DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONCAVE;
				// bottom-right
				X = 2;
				Y = 2;
				if (!tempConnected[X][1] && !tempConnected[1][Y])
					brCorners[row][col] = DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX;
				else if (tempConnected[X][1] && tempConnected[X][Y]
						&& !tempConnected[1][Y])
					brCorners[row][col] = DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONCAVE;
				else if (tempConnected[1][Y] && tempConnected[X][Y]
						&& !tempConnected[X][1])
					brCorners[row][col] = DrawSettings.CORNER_INNER_RIGHT_TOP_CONCAVE;
				else if (tempConnected[1][Y] && tempConnected[X][1]
						&& !tempConnected[X][Y])
					brCorners[row][col] = DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONCAVE;
			}
		}
	}

	private void drawBorderShineRightward(DrawSettings ds, Canvas canvas,
			Rect topCornerRect, int topCornerType, byte[][] bottomCorners,
			int qo, int qPane, int row, int col, int shineAlpha,
			Offset drawOffset) {
		// end at the first bottom corner we see.
		int lastCol;
		int bottomCornerType;
		try {
			lastCol = col;
			while (bottomCorners[row][lastCol] == -1)
				lastCol++;
			bottomCornerType = bottomCorners[row][lastCol];
		} catch (RuntimeException e) {
			throw e;
		}

		// get the drawable, and if not null, adjust the rect,
		// alpha, and draw.
		Drawable drawable = innerBorderShine_byQPaneQOrientationCornerCornerDirection == null ? null
				: innerBorderShine_byQPaneQOrientationCornerCornerDirection[qPane][qo][topCornerType][bottomCornerType][DIRECTION_RIGHT];
		drawBorderDrawableRightward(ds, null, null, null, null, drawable, 0x00,
				canvas, null, topCornerRect, qo, qPane, row, col, lastCol,
				shineAlpha, drawOffset);
	}

	private void drawBorderRightward(DrawSettings ds, Canvas canvas,
			Rect existingClipRect, Rect topCornerRect, int topCornerType,
			byte[][] bottomCorners, int qo, int qPane, int row, int col,
			int alpha, boolean simplifiedColors, Offset drawOffset) {
		// end at the first bottom corner we see.
		int lastCol;
		int bottomCornerType;
		try {
			lastCol = col;
			while (bottomCorners[row][lastCol] == -1)
				lastCol++;
			bottomCornerType = bottomCorners[row][lastCol];
		} catch (RuntimeException e) {
			throw e;
		}

		// get the drawable, and if not null, adjust the rect,
		// alpha, and draw.
		Bitmap prerendered = null;
		Rect prerenderedBounds = null;
		
		Bitmap prerenderedStretchable = null;
		Rect prerenderedStretchableBounds = null;
		
		Drawable drawable =  null ;
		int colorSubstitute ;
		
		if ( simplifiedColors ) {
			colorSubstitute = ds.colorSimplified_qOrientationQPaneBorder[qo][qPane] ;
		} else {
			if (!GlobalTestSettings.BLOCK_DRAWER_PREVENT_PRERENDERED_BORDER_FIXED_WIDTH_OPTIMIZATION
					&& PRERENDERED_BLOCK_BORDER_WIDTH == ds.size_borderWidth
					&& lastCol - col < NUM_PRERENDERED_BORDER_WIDTHS
					&& innerBorderBitmap_byQPaneQOrientationCornerCornerDirectionWidth != null
					&& innerBorderBitmap_byQPaneQOrientationCornerCornerDirectionWidth[qPane][qo] != null) {
	
				prerendered = innerBorderBitmap_byQPaneQOrientationCornerCornerDirectionWidth[qPane][qo][topCornerType][bottomCornerType][DIRECTION_RIGHT][lastCol
						- col];
				prerenderedBounds = innerBorderBitmapBounds_byQPaneQOrientationCornerCornerDirectionWidth[qPane][qo][topCornerType][bottomCornerType][DIRECTION_RIGHT][lastCol
						- col];
	
			}
			
			if (!GlobalTestSettings.BLOCK_DRAWER_PREVENT_PRERENDERED_BORDER_STETCHABLE_WIDTH_OPTIMIZATION
					&& innerBorderStretchableBitmap_byQPaneQOrientationCornerCornerDirection != null
					&& innerBorderStretchableBitmap_byQPaneQOrientationCornerCornerDirection[qPane][qo] != null) {
	
				prerenderedStretchable = innerBorderStretchableBitmap_byQPaneQOrientationCornerCornerDirection[qPane][qo][topCornerType][bottomCornerType][DIRECTION_RIGHT];
				prerenderedStretchableBounds = innerBorderStretchableBitmapBounds_byQPaneQOrientationCornerCornerDirection[qPane][qo][topCornerType][bottomCornerType][DIRECTION_RIGHT];
	
			}
	
			drawable = innerBorder_byQPaneQOrientationCornerCornerDirection == null ? null
					: innerBorder_byQPaneQOrientationCornerCornerDirection[qPane][qo][topCornerType][bottomCornerType][DIRECTION_RIGHT];
			colorSubstitute = innerBorderColorSubstitute_byQPaneQOrientationCornerCorner == null ? 0x00
					: innerBorderColorSubstitute_byQPaneQOrientationCornerCorner[qPane][qo][topCornerType][bottomCornerType];
		}
		
		drawBorderDrawableRightward(ds, prerendered, prerenderedBounds,
				prerenderedStretchable, prerenderedStretchableBounds, drawable,
				colorSubstitute, canvas, existingClipRect, topCornerRect, qo,
				qPane, row, col, lastCol, alpha, drawOffset);
		// TODO: for profiling
		/*
		 * switch( lastCol - col ) { case 0: drawBorderDrawableRightward0(
		 * prerendered, drawable, colorSubstitute, canvas, existingClipRect,
		 * topCornerRect, qo, qPane, row, col, lastCol, shineAlpha, drawOffset )
		 * ; break ; case 1: drawBorderDrawableRightward1( prerendered,
		 * drawable, colorSubstitute, canvas, existingClipRect, topCornerRect,
		 * qo, qPane, row, col, lastCol, shineAlpha, drawOffset ) ; break ; case
		 * 2: drawBorderDrawableRightward2( prerendered, drawable,
		 * colorSubstitute, canvas, existingClipRect, topCornerRect, qo, qPane,
		 * row, col, lastCol, shineAlpha, drawOffset ) ; break ; case 3:
		 * drawBorderDrawableRightward3( prerendered, drawable, colorSubstitute,
		 * canvas, existingClipRect, topCornerRect, qo, qPane, row, col,
		 * lastCol, shineAlpha, drawOffset ) ; break ; case 4:
		 * drawBorderDrawableRightward4( prerendered, drawable, colorSubstitute,
		 * canvas, existingClipRect, topCornerRect, qo, qPane, row, col,
		 * lastCol, shineAlpha, drawOffset ) ; break ; case 5:
		 * drawBorderDrawableRightward5( prerendered, drawable, colorSubstitute,
		 * canvas, existingClipRect, topCornerRect, qo, qPane, row, col,
		 * lastCol, shineAlpha, drawOffset ) ; break ; case 6:
		 * drawBorderDrawableRightward6( prerendered, drawable, colorSubstitute,
		 * canvas, existingClipRect, topCornerRect, qo, qPane, row, col,
		 * lastCol, shineAlpha, drawOffset ) ; break ; default:
		 * drawBorderDrawableRightwardMore( prerendered, drawable,
		 * colorSubstitute, canvas, existingClipRect, topCornerRect, qo, qPane,
		 * row, col, lastCol, shineAlpha, drawOffset ) ; break ; }
		 */
	}

	private void drawBorderDrawableRightward(DrawSettings ds,
			Bitmap prerendered, Rect prerenderedBounds,
			Bitmap prerenderedStretchable, Rect prerenderedStretchableBounds,
			Drawable drawable, int colorSubstitute, Canvas canvas,
			Rect existingClipRect, Rect topCornerRect, int qo, int qPane,
			int row, int col, int lastCol, int alpha, Offset drawOffset) {

		tempDstRect.set(
				topCornerRect.right,
				topCornerRect.top,
				topCornerRect.left + (lastCol - col + 1)
						* ds.size_blockWidth - ds.size_borderWidth,
				topCornerRect.bottom);

		if (prerendered != null) {
			borderPaint.setColor(0xffffffff) ;
			borderPaint.setAlpha(alpha) ;
			canvas.drawBitmap(prerendered, prerenderedBounds, tempDstRect, borderPaint);
			return;
		}

		// ASSUMPTION:
		// topCornerRect.left = drawSettings.getBlockXPosition(qPane, col) +
		// drawOffset.x
		// topCornerRect.right is = drawSettings.getBlockXPosition(qPane, col) +
		// drawOffset.x + drawSettings.borderWidth
		//
		// We would like the right-edge to be (
		// drawSettings.getBlockXPosition(qPane, lastCol) + drawOffset.x +
		// drawSettings.size_blockWidth - drawSettings.size_borderWidth ),
		// equivalent to topCornerRect.left + (lastCol - col + 1) *
		// drawSettings.size_blockWidth - drawSettings.size_borderWidth
		tempDstRect.set(
				topCornerRect.right,
				topCornerRect.top,
				topCornerRect.left + (lastCol - col + 1)
						* ds.size_blockWidth - ds.size_borderWidth,
				topCornerRect.bottom);

		if (prerenderedStretchable != null) {
			borderPaint.setColor(0xffffffff) ;
			borderPaint.setAlpha(alpha) ;
			canvas.drawBitmap(prerenderedStretchable,
					prerenderedStretchableBounds, tempDstRect, borderPaint);
		} else if (drawable != null) {
			drawable.setAlpha(alpha);
			drawable.setBounds(tempDstRect);
			drawable.draw(canvas);
		} else {
			borderPaint.setColor(colorSubstitute);
			borderPaint.setAlpha(alpha) ;
			canvas.drawRect(tempDstRect, borderPaint);
		}
	}

	private void drawBorderShineDownward(DrawSettings ds, Canvas canvas,
			Rect topCornerRect, int topCornerType, byte[][] bottomCorners,
			int qo, int qPane, int row, int col, int shineAlpha,
			Offset drawOffset) {
		// end at the first bottom corner we see.
		int lastRow = row;
		while (bottomCorners[lastRow][col] == -1 && lastRow > 0)
			lastRow--;
		int bottomCornerType = bottomCorners[lastRow][col];

		if (bottomCornerType == -1)
			bottomCornerType = topCornerType;

		// get the drawable, and if not null, adjust the rect,
		// alpha, and draw.
		Drawable drawable = innerBorderShine_byQPaneQOrientationCornerCornerDirection != null ? innerBorderShine_byQPaneQOrientationCornerCornerDirection[qPane][qo][topCornerType][bottomCornerType][DIRECTION_DOWN]
				: null;
		drawBorderDrawableDownward(ds, null, null, drawable, 0x00, canvas,
				null, topCornerRect, qo, qPane, row, lastRow, col, shineAlpha,
				drawOffset);
	}
	
	private void drawBorderShineUpward(DrawSettings ds, Canvas canvas,
			Rect bottomCornerRect, int bottomCornerType, byte[][] topCorners,
			int qo, int qPane, int row, int col, int shineAlpha,
			Offset drawOffset) {
		// end at the first bottom corner we see.
		int firstRow = row;
		while (topCorners[firstRow][col] == -1
				&& firstRow + 1 < topCorners.length)
			firstRow++;
		int topCornerType = topCorners[firstRow][col];

		if (topCornerType == -1)
			topCornerType = bottomCornerType;

		// get the drawable, and if not null, adjust the rect,
		// alpha, and draw.
		Drawable drawable = innerBorderShine_byQPaneQOrientationCornerCornerDirection != null ? innerBorderShine_byQPaneQOrientationCornerCornerDirection[qPane][qo][topCornerType][bottomCornerType][DIRECTION_DOWN]
				: null;
		drawBorderDrawableUpward(ds, null, null, null, null, drawable, 0x00,
				canvas, null, bottomCornerRect, qo, qPane, firstRow, row, col,
				shineAlpha, drawOffset);
	}

	private void drawBorderUpward(DrawSettings ds, Canvas canvas,
			Rect existingClipRect, Rect bottomCornerRect, int bottomCornerType,
			byte[][] topCorners, int qo, int qPane, int row, int col,
			int alpha, boolean simplifiedColors, Offset drawOffset) {
		int firstRow = row;
		while (topCorners[firstRow][col] == -1
				&& firstRow + 1 < topCorners.length)
			firstRow++;
		int topCornerType = topCorners[firstRow][col];

		if (topCornerType == -1)
			topCornerType = bottomCornerType;

		// get the drawable, and if not null, adjust the rect,
		// alpha, and draw.
		Bitmap prerendered = null;
		Rect prerenderedBounds = null;
		
		Bitmap prerenderedStretchable = null;
		Rect prerenderedStretchableBounds = null;
		
		Drawable drawable = null ;
		int colorSubstitute ;
		
		if ( simplifiedColors ) {
			colorSubstitute = ds.colorSimplified_qOrientationQPaneBorder[qo][qPane] ;
		} else {
			if (!GlobalTestSettings.BLOCK_DRAWER_PREVENT_PRERENDERED_BORDER_FIXED_WIDTH_OPTIMIZATION
					&& PRERENDERED_BLOCK_BORDER_HEIGHT == ds.size_borderHeight
					&& firstRow - row < NUM_PRERENDERED_BORDER_WIDTHS
					&& innerBorderBitmap_byQPaneQOrientationCornerCornerDirectionWidth != null
					&& innerBorderBitmap_byQPaneQOrientationCornerCornerDirectionWidth[qPane][qo] != null) {
	
				prerendered = innerBorderBitmap_byQPaneQOrientationCornerCornerDirectionWidth[qPane][qo][topCornerType][bottomCornerType][DIRECTION_DOWN][firstRow
						- row];
				prerenderedBounds = innerBorderBitmapBounds_byQPaneQOrientationCornerCornerDirectionWidth[qPane][qo][topCornerType][bottomCornerType][DIRECTION_DOWN][firstRow
						- row];
			}
	
			
			if (!GlobalTestSettings.BLOCK_DRAWER_PREVENT_PRERENDERED_BORDER_STETCHABLE_WIDTH_OPTIMIZATION
					&& innerBorderStretchableBitmap_byQPaneQOrientationCornerCornerDirection != null
					&& innerBorderStretchableBitmap_byQPaneQOrientationCornerCornerDirection[qPane][qo] != null) {
	
				prerenderedStretchable = innerBorderStretchableBitmap_byQPaneQOrientationCornerCornerDirection[qPane][qo][topCornerType][bottomCornerType][DIRECTION_DOWN];
				prerenderedStretchableBounds = innerBorderStretchableBitmapBounds_byQPaneQOrientationCornerCornerDirection[qPane][qo][topCornerType][bottomCornerType][DIRECTION_DOWN];
			}
	
			drawable = innerBorder_byQPaneQOrientationCornerCornerDirection != null ? innerBorder_byQPaneQOrientationCornerCornerDirection[qPane][qo][topCornerType][bottomCornerType][DIRECTION_DOWN]
					: null;
			colorSubstitute = innerBorderColorSubstitute_byQPaneQOrientationCornerCorner != null ? innerBorderColorSubstitute_byQPaneQOrientationCornerCorner[qPane][qo][topCornerType][bottomCornerType]
					: 0x00;
		}
		
		drawBorderDrawableUpward(ds, prerendered, prerenderedBounds,
				prerenderedStretchable, prerenderedStretchableBounds, drawable,
				colorSubstitute, canvas, existingClipRect, bottomCornerRect,
				qo, qPane, firstRow, row, col, alpha, drawOffset);
	}

	private void drawBorderDrawableDownward(DrawSettings ds,
			Bitmap prerendered, Bitmap prerenderedStretchable,
			Drawable drawable, int colorSubstitute, Canvas canvas,
			Rect existingClipRect, Rect topCornerRect, int qo, int qPane,
			int row, int lastRow, int col, int alpha, Offset drawOffset) {
		// We don't need the rect to draw a prerendered.
		if (prerendered != null) {
			borderPaint.setColor(0xffffffff) ;
			borderPaint.setAlpha(alpha) ;
			canvas.drawBitmap(prerendered, topCornerRect.left,
					topCornerRect.bottom, borderPaint);
			return;
		}

		tempDstRect.set(topCornerRect.left, topCornerRect.bottom,
				topCornerRect.right, ds.getBlockYPosition(qPane, lastRow)
						+ drawOffset.y + ds.size_blockHeight
						- ds.size_borderHeight);

		// if ( existingClipRect == null || Rect.intersects(existingClipRect,
		// tempDstRect) ) {
		if (prerenderedStretchable != null) {
			borderPaint.setColor(0xffffffff) ;
			borderPaint.setAlpha(alpha) ;
			canvas.drawBitmap(prerenderedStretchable, null, tempDstRect, borderPaint);
		} else if (drawable != null) {
			drawable.setAlpha(alpha);
			drawable.setBounds(tempDstRect);
			drawable.draw(canvas);
		} else {
			borderPaint.setColor(colorSubstitute);
			borderPaint.setAlpha(alpha) ;
			canvas.drawRect(tempDstRect, borderPaint);
		}
		// }
	}

	private void drawBorderDrawableUpward(DrawSettings ds, Bitmap prerendered,
			Rect prerenderedBounds, Bitmap prerenderedStretchable,
			Rect prerenderedStretchableBounds, Drawable drawable,
			int colorSubstitute, Canvas canvas, Rect existingClipRect,
			Rect bottomCornerRect, int qo, int qPane, int row, int lastRow,
			int col, int alpha, Offset drawOffset) {

		tempDstRect.set(bottomCornerRect.left, bottomCornerRect.bottom
				- (row - lastRow + 1) * ds.size_blockHeight
				+ ds.size_borderHeight, bottomCornerRect.right,
				bottomCornerRect.top);

		if (prerendered != null) {
			borderPaint.setColor(0xffffffff) ;
			borderPaint.setAlpha(alpha) ;
			canvas.drawBitmap(prerendered, prerenderedBounds, tempDstRect, borderPaint);
			return;
		}

		// ASSUMPTION:
		// bottomCornerRect.top is drawSettings.getBlockYPosition(qPane,
		// lastRow) + drawOffset.y - drawSettings.size_borderHeight.
		// bottomCornerRect.bottom is drawSettings.getBlockYPosition(qPane,
		// lastRow) + drawOffset.y
		//
		// We want the destination bottom to = (
		// drawSettings.getBlockYPosition(qPane, row) + drawOffset.y +
		// drawSettings.size_borderHeight )
		//
		// One way to get this is
		// bottomCornerRect.bottom - ( row - lastRow + 1 ) *
		// drawSettings.size_blockHeight + drawSettings.size_borderHeight

		if (prerenderedStretchable != null) {
			borderPaint.setColor(0xffffffff) ;
			borderPaint.setAlpha(alpha) ;
			canvas.drawBitmap(prerenderedStretchable,
					prerenderedStretchableBounds, tempDstRect, borderPaint);
		} else if (drawable != null) {
			drawable.setAlpha(alpha);
			drawable.setBounds(tempDstRect);
			drawable.draw(canvas);
		} else {
			borderPaint.setColor(colorSubstitute);
			borderPaint.setAlpha(alpha) ;
			canvas.drawRect(tempDstRect, borderPaint);
		}
	}

	private static final short GLOW_SET_INDEX_NONE = 255; // completely empty.
	private static final short GLOW_SET_INDEX_FULL = -1; // full square

	private void setGlowSetIndices(DrawSettings ds, short[][] setArray,
			int[][] regions, int regionNum, int extraRows) {
		// first: reset to NONE.
		ArrayOps.fill(setArray, GLOW_SET_INDEX_NONE);

		// 6/15/12: before optimization, stress-tests put this method at 13.4%
		// of CPU time (huge!)
		// after optimization, it is at at 2.0% of CPU time. HUZZAH.

		// Use the same basic optimization as setOuterShadowWhatevers. That is,
		// rather than
		// filling 'tempConnected' and querying for an index, we work in
		// reverse: iterate through
		// the glow regions and extend each into its neighbors by subtracting
		// the relevant
		// "connected" offset.
		//
		// One complication: unlike drop shadow glows, we prefer to sanity fix
		// all values.
		// Do this as the final step.

		// First pass: extend glows into all neighboring squares.
		// index row / col into regions, which does not have
		// blockFieldOuterBuffers. Our setArray does.
		for (int row = 0; row < ds.displayedRows + extraRows; row++) {
			int posRow = row + ds.blockFieldOuterBuffer;
			for (int col = 0; col < ds.COLS; col++) {
				int posCol = col + ds.blockFieldOuterBuffer;

				if (regions[row][col] == regionNum) {
					// ayyup. Glow into all neighbors.
					for (int r = -1; r < 2; r++)
						for (int c = -1; c < 2; c++)
							if (r != 0 || c != 0) // an offset
								setArray[posRow + r][posCol + c] -= IBN_OFFSET_CONNECTED_DIRECTION[1 - c][1 + r];
					// remember to REVERSE the perspective
					// ("OFFSET_CONNECTED_DIRECTION" is
					// FROM posRow+r, posCol+c, NOT "towards" it)
					// Thus if r = -1, c = -1 (up and left), we adjust by the
					// down-right direction offset.
				}
			}
		}

		// Second pass: fix the incorrect results in the first pass. For every
		// square exactly
		// over a glow, set to FULL. Otherwise, sanitize.
		for (int row = 0; row < ds.displayedRows + extraRows; row++) {
			int posRow = row + ds.blockFieldOuterBuffer;
			for (int col = 0; col < ds.COLS; col++) {
				int posCol = col + ds.blockFieldOuterBuffer;

				if (regions[row][col] == regionNum)
					setArray[posRow][posCol] = GLOW_SET_INDEX_FULL;
				else
					setArray[posRow][posCol] = indexByNeighbors_sanityFix(setArray[posRow][posCol]);
			}
		}
	}

	private boolean setBorderGlowSetIndices(DrawSettings ds,
			short[][] setArray, byte[][][] chunkLocking, int[][] glowRegions,
			int qPane, int extraRows) {
		// first: reset to NONE.
		ArrayOps.fill(setArray, GLOW_SET_INDEX_NONE);

		// 6/15/12: before optimization (in Quantro stress tests) this method
		// accounted for only 3.2% of CPU time.
		// is it worth optimizing? Possibly.
		// After optimization, accounted for PENDING PENDING

		// This method is fairly complex. Glows extend based on region
		// ADJACENCY, not region presence.
		// For that reason, we leave off optimizing it for now, especially since
		// its sister method
		// floodRegions is such a CPU hog.

		boolean hasGlows = false;

		for (int posRow = 0; posRow < 2 * ds.blockFieldOuterBuffer
				+ ds.displayedRows + extraRows; posRow++) {
			int row = posRow - ds.blockFieldOuterBuffer;
			boolean rowWithin = 0 <= row && row < ds.displayedRows;
			for (int posCol = 0; posCol < setArray[0].length; posCol++) {
				int col = posCol - ds.blockFieldOuterBuffer;
				boolean colWithin = 0 <= col && col < ds.COLS;
				boolean within = rowWithin && colWithin;

				// We have certain rules for determining a glow region.

				// Skip outside the boundaries; we will be setting the bottom
				// row as a special case later.
				/*
				 * if ( row < 0 || row >= ds.displayedRows || col < 0 || col >=
				 * ds.COLS ) continue ;
				 */

				// First: if this location is not a region, and does not have a
				// neighboring
				// region within the 4-neighborhood, skip.
				if ((!within || glowRegions[row][col] == 0)
						&& (row <= 0 || !colWithin || glowRegions[row - 1][col] == 0)
						&& (row >= ds.displayedRows - 1 || !colWithin || glowRegions[row + 1][col] == 0)
						&& (col <= 0 || !rowWithin || glowRegions[row][col - 1] == 0)
						&& (col >= ds.COLS - 1 || !rowWithin || glowRegions[row][col + 1] == 0))
					continue;

				if (within && glowRegions[row][col] != 0) {
					// Next: IF this is a region, mark any neighboring regions
					// which are not 0
					// and are not this.
					int region = glowRegions[row][col];
					for (int xOff = -1; xOff < 2; xOff++)
						for (int yOff = -1; yOff < 2; yOff++)
							tempConnected[1 + xOff][1 + yOff] = true;

					for (int xOff = -1; xOff < 2; xOff++) {
						for (int yOff = -1; yOff < 2; yOff++) {
							if (xOff != 0 || yOff != 0) {
								if (row - yOff >= 0
										&& row - yOff < ds.displayedRows
										&& col + xOff >= 0
										&& col + xOff < ds.COLS)
									tempConnected[1 + xOff][1 + yOff] = (glowRegions[row
											- yOff][col + xOff] == 0 || glowRegions[row
											- yOff][col + xOff] == region);
							}
						}
					}

					// Also: mark any place where a falling chunk landed on row
					// 0.
					if (row == 0) {
						if (chunkLocking != null) {
							if (chunkLocking[qPane][ds.blockFieldOuterBuffer][posCol] != 0)
								tempConnected[1][2] = false;
							if (col > 0
									&& chunkLocking[qPane][ds.blockFieldOuterBuffer][posCol - 1] != 0
									&& glowRegions[row][col - 1] != 0)
								tempConnected[0][2] = false;
							if (col < ds.COLS - 1
									&& chunkLocking[qPane][ds.blockFieldOuterBuffer][posCol + 1] != 0
									&& glowRegions[row][col + 1] != 0)
								tempConnected[2][2] = false;
						}
					}
				} else {
					// Or, If this is NOT a region, it might be participating in
					// a neighboring region
					// glow. The criteria is as follows: if we have a 4-way
					// neighbor that is a region,
					// check the neighboring diagonals for a different region
					// (or the "bottom edge" for
					// a falling block). Mark it as not connected.
					for (int xOff = -1; xOff < 2; xOff++)
						for (int yOff = -1; yOff < 2; yOff++)
							tempConnected[1 + xOff][1 + yOff] = true;
					int region;

					// look left
					if (rowWithin && col > 0 && glowRegions[row][col - 1] != 0) {
						region = glowRegions[row][col - 1];
						if (row > 0 && glowRegions[row - 1][col - 1] != 0
								&& glowRegions[row - 1][col - 1] != region) {
							// log("found left, then down for " + row +
							// ", " + col ) ;
							tempConnected[0][2] = false;
						}
						if (row < ds.displayedRows - 1
								&& glowRegions[row + 1][col - 1] != 0
								&& glowRegions[row + 1][col - 1] != region) {
							// log("found left, then up for " + row +
							// ", " + col) ;
							tempConnected[0][0] = false;
						}
						if (row == 0
								&& chunkLocking != null
								&& chunkLocking[qPane][ds.blockFieldOuterBuffer][posCol - 1] != 0) {
							// log( 
							// "found left, then down, at bottom for " + row +
							// ", " + col) ;
							tempConnected[0][2] = false;
						}
					}
					// look right
					if (rowWithin && col < ds.COLS - 1
							&& glowRegions[row][col + 1] != 0) {
						region = glowRegions[row][col + 1];
						if (row > 0 && glowRegions[row - 1][col + 1] != 0
								&& glowRegions[row - 1][col + 1] != region) {
							// log("found right, then down for " + row +
							// ", " + col) ;
							tempConnected[2][2] = false;
						}
						if (row < ds.displayedRows - 1
								&& glowRegions[row + 1][col + 1] != 0
								&& glowRegions[row + 1][col + 1] != region) {
							// log("found right, then up for " + row +
							// ", " + col) ;
							tempConnected[2][0] = false;
						}
						if (row == 0
								&& chunkLocking != null
								&& chunkLocking[qPane][ds.blockFieldOuterBuffer][posCol + 1] != 0) {
							// log( 
							// "found right, then down, at bottom for " + row +
							// ", " + col) ;
							tempConnected[2][2] = false;
						}
					}
					// look down
					if (colWithin && row > 0 && glowRegions[row - 1][col] != 0) {
						region = glowRegions[row - 1][col];
						if (col > 0 && glowRegions[row - 1][col - 1] != 0
								&& glowRegions[row - 1][col - 1] != region) {
							// log("found down, then left for " + row +
							// ", " + col) ;
							tempConnected[0][2] = false;
						}
						if (col < ds.COLS - 1
								&& glowRegions[row - 1][col + 1] != 0
								&& glowRegions[row - 1][col + 1] != region) {
							// log("found down, then right for " + row +
							// ", " + col) ;
							tempConnected[2][2] = false;
						}
					}
					// look up
					if (colWithin && row < ds.displayedRows - 1
							&& glowRegions[row + 1][col] != 0) {
						region = glowRegions[row + 1][col];
						if (col > 0 && glowRegions[row + 1][col - 1] != 0
								&& glowRegions[row + 1][col - 1] != region) {
							// log("found up, then left for " + row +
							// ", " + col) ;
							tempConnected[0][0] = false;
						}
						if (col < ds.COLS - 1
								&& glowRegions[row + 1][col + 1] != 0
								&& glowRegions[row + 1][col + 1] != region) {
							// log("found up, then right for " + row +
							// ", " + col) ;
							tempConnected[2][0] = false;
						}
					}
				}

				// include if anything's here.
				boolean include = false;
				for (int xOff = -1; xOff < 2; xOff++)
					for (int yOff = -1; yOff < 2; yOff++)
						include = include || !tempConnected[1 + xOff][1 + yOff];

				if (include) {
					indexByNeighbors_sanityFix(tempConnected, 1, 1);
					setArray[posRow][posCol] = indexByNeighbors(tempConnected,
							1, 1);
					hasGlows = true;
				}
			}
		}

		// We have set the "top" of the bottom-level glow, but not the bottom.
		// Set the bottom now!
		if (chunkLocking != null) {
			for (int i = 0; i <= 2; i++)
				for (int j = 0; j <= 2; j++)
					tempConnected[i][j] = true;
			for (int posCol = 0; posCol < setArray[0].length; posCol++) {
				int col = posCol - ds.blockFieldOuterBuffer;
				// slide left...
				for (int i = 0; i < 2; i++)
					tempConnected[i][0] = tempConnected[i + 1][0];
				tempConnected[2][0] = col >= ds.COLS - 1
						|| (glowRegions[0][col + 1] == 0 || chunkLocking[qPane][ds.blockFieldOuterBuffer][col
								+ ds.blockFieldOuterBuffer + 1] == 0);

				boolean include = false;
				for (int xOff = -1; xOff < 2; xOff++)
					for (int yOff = -1; yOff < 2; yOff++)
						include = include || !tempConnected[1 + xOff][1 + yOff];

				if (include) {
					// always sane.
					short index = indexByNeighbors(tempConnected, 1, 1);
					setArray[0][posCol] = index;
					hasGlows = true;
				}
			}
		}

		return hasGlows;
	}

	private float[] drawGlowSetArrayToCanvas_floatArray = new float[20];

	private void drawGlowSetArrayToCanvas(DrawSettings ds, Canvas canvas,
			short[][] setArray, BlockDrawerConfigRange configRange, int color,
			ColorFilter colorFilter, ColorFilter alphaFilter, int qPane,
			Bitmap glowBitmapSheet, Rect glowBitmapSheetBounds,
			Path[] glowPathByNeighbors, float alphaNormalized,
			Offset drawOffset) {
		// Here's our filter. Why can't we mutate this??? It's just a float array!
		/*
		 * drawGlowSetArrayToCanvas_floatArray[0] = Color.red(color) / 255f ;
		 * drawGlowSetArrayToCanvas_floatArray[6] = Color.green(color) / 255f ;
		 * drawGlowSetArrayToCanvas_floatArray[12] = Color.blue(color) / 255f ;
		 */
		// glow set arrays are stored as an alpha channel only. We add color
		// information when drawing.
		if (ds.glowDrawStyle == DrawSettings.GLOW_DRAW_STYLE_FLARE
				&& GlobalTestSettings.BLOCK_DRAWER_FORCE_GLOW_MATRIX_ALLOCATION) {
			drawGlowSetArrayToCanvas_floatArray[4] = Color.red(color);
			drawGlowSetArrayToCanvas_floatArray[9] = Color.green(color);
			drawGlowSetArrayToCanvas_floatArray[14] = Color.blue(color);
			drawGlowSetArrayToCanvas_floatArray[18] = alphaNormalized;

			ColorMatrixColorFilter filter = new ColorMatrixColorFilter(
					drawGlowSetArrayToCanvas_floatArray);

			tempColorFilterPaint.setColorFilter(filter);
		}

		// NOTE: This is the ONLY ColorMatrixColorFilter allocation which occurs
		// during
		// frame-progression in the game (other allocations occur in this file,
		// but they
		// are only used during setup). We want to eliminate this allocation.
		// Assuming
		// that CMCFs are immutable (we might be able to mutate a CMCF by
		// mutating the underlying
		// float array, but this behavior is undocumented and I don't want to
		// rely on it),
		// one approach is to create a large number of CMCFs in setup to cover a
		// range of alpha
		// values. Note that this is only relevant for FLARE glows, not FADE or
		// BOX glows,
		// which do not use CMCFs.
		//
		// Before the change, we:
		// 1. draw the Alpha_8 image to an ARGB_8888 temp bitmap (keep alpha;
		// color is black).
		// 2. draw the ARGB_8888 with a color-and-alpha CMCF filter.
		//
		// This is 2 draws (3 if you count clearing the temp bitmap before the
		// first draw),
		// applying both color and alpha information. Here is an alternative:
		//
		// 1. draw the Alpha_8 image to an ARGB_8888 temp bitmap using a
		// Lighting or PorterDuff color filter paint (keep alpha; color is the
		// glow color)
		// 2. draw the ARGB_8888 with an alpha CMCF filter that retains color.
		//
		// This is still 2 draws, but eliminates the CMCF allocation. We would
		// need:
		// 1. a collection of paints (or, possibly, color filters) to color the
		// glows.
		// 2. a range of CMCFs to multiply the alpha channel.
		//
		// We can play around with different CMCF alpha ranges. For example, 80k
		// is not a huge
		// overhead and this gives us 1000 degrees of precision (probably
		// ranging in 0 to 9.99).

		int alpha = Math
				.max(0,
						Math.min(255, Math.round(alphaNormalized
								* Color.alpha(color))));
		color = Color.argb(alpha, Color.red(color), Color.green(color),
				Color.blue(color));

		tempColorPaint.setColor(color);
		replaceColorPaint.setColor(color);
		maskFirstPaint.setColor(color);

		tempGlowColorFilterPaint.setColorFilter(colorFilter);
		tempGlowAlphaFilterPaint.setColorFilter(alphaFilter);

		// log("drawGlowSetArray with color " + color + " alpha " +
		// alphaNormalized + " sheet " + glowBitmapSheet + " regions " +
		// glowPathByNeighbors) ;

		int lastSetDrawn = Integer.MIN_VALUE;
		boolean prerendered = false;

		// although we use configRange, we differ from standard practice
		// (which is to iterate from __First to __Bound, and then call
		// __ToIndex() to convert to index values). This is because we
		// expect important information to be stored around the edges of the
		// range. Furthermore, we expect it to be offset by magnitude
		// of __Inset. Iterate over the full range of indices, converting
		// to row / column when we need.

		// We precalculate the iteration range here, because repeatedly
		// calling colToIndex(), especially in an inner for-loop, is an
		// optimization hot-spot.
		int posRowFirst = configRange.indexRowFirst - configRange.insetRow ;
		int posRowBound = configRange.indexRowBound + configRange.insetRow ;
		int posColFirst = configRange.indexColFirst - configRange.insetColumn ;
		int posColBound = configRange.indexColBound + configRange.insetColumn ;
		
		int rowFirst = configRange.indexToRow(posRowFirst) ;
		int colFirst = configRange.indexToCol(posColFirst) ;
		
		// iterate from bottom to top: at the top of the loop, set bottom_y to
		// the previous top_y, and increment top_y by height.
		int bottom_y, top_y = ds.getBlockYPosition(qPane, rowFirst-1) + drawOffset.y ;
		final int y_step = ds.size_blockHeight ;
		for (int posRow = posRowFirst; posRow < posRowBound; posRow++) {
			bottom_y = top_y ;
			top_y -= y_step ;
			
			// iterate from left to right: at the top of the loop, set left_x to the
			// previous right_x, and move right_x by the width.
			int left_x, right_x = ds.getBlockXPosition(qPane, colFirst) + drawOffset.x ;
			final int x_step = ds.size_blockWidth ;
			
			for (int posCol = posColFirst; posCol < posColBound; posCol++) {
				// x bounds?
				left_x = right_x ;
				right_x += x_step ;
				
				// skip if none
				if (setArray[posRow][posCol] == GLOW_SET_INDEX_NONE)
					continue;

				int index = setArray[posRow][posCol];

				if (ds.glowDrawStyle == DrawSettings.GLOW_DRAW_STYLE_BOX
						|| glowBitmapSheet == null) {
					if (index == GLOW_SET_INDEX_FULL)
						canvas.drawRect(left_x, top_y, right_x, bottom_y,
								tempColorPaint);
					else {
					    tempPath.set(glowPathByNeighbors[setArray[posRow][posCol]]);
					    tempPath.offset(left_x, top_y);
						canvas.save();
						canvas.clipPath(tempPath);
						canvas.drawPaint(tempColorPaint);
						canvas.restore();
					}
				} else if (ds.glowDrawStyle == DrawSettings.GLOW_DRAW_STYLE_FADE) {
					if (index == GLOW_SET_INDEX_FULL)
						canvas.drawRect(left_x, top_y, right_x, bottom_y,
								tempColorPaint);
					else {
						if (lastSetDrawn != index) {
							indexByNeighbors_sheetRect(tempSrcRect, index,
									sheetBlockWidth, sheetBlockHeight);
							// Note: the fastest way to do this is to draw
							// 1. replaceColor to the filtered bitmap
							// 2. the glow sheet rect using DST_IN
							// however, this doesn't work; Android does not
							// apply color filters when images are drawn with an offset.
                            // It's messed up.

							// Instead, do this 3-step process:
							// 1. fill with clear paint
							// 2. draw the glow sheet (color 0, alpha)
							// 3. apply the color/alpha paint with SRC_IN.

							// 1. fill with clear paint
							renderScratchColorFilteredCanvas
									.drawPaint(clearPaint);
							// 2. draw the glow sheet (color 0, alpha)
							renderScratchColorFilteredCanvas.drawBitmap(
									glowBitmapSheet, tempSrcRect,
									renderScratchBounds, null);
							// 3. apply the color/alpha paint with SRC_IN.
							renderScratchColorFilteredCanvas
									.drawPaint(maskFirstPaint);

							lastSetDrawn = index;
							prerendered = true;
						}
						tempDstRect.set(left_x, top_y,
								left_x + ds.size_blockWidth,
								top_y + ds.size_blockHeight);
						canvas.drawBitmap(renderScratchColorFilteredBitmap,
								renderScratchBounds, tempDstRect, null);
					}
				} else if (ds.glowDrawStyle == DrawSettings.GLOW_DRAW_STYLE_FLARE) {
					if (index == GLOW_SET_INDEX_FULL)
						canvas.drawRect(left_x, top_y, right_x, bottom_y,
								tempColorPaint);
					else {
						if (GlobalTestSettings.BLOCK_DRAWER_FORCE_GLOW_MATRIX_ALLOCATION) {
							if (lastSetDrawn != index) {
								indexByNeighbors_sheetRect(tempSrcRect, index,
										sheetBlockWidth, sheetBlockHeight);
								renderScratchCanvas.drawPaint(clearPaint);
								renderScratchCanvas.drawBitmap(glowBitmapSheet,
										tempSrcRect, renderScratchBounds, null);
								lastSetDrawn = index;

								// we either apply the ColorFilter now
								// (prerender)
								// or later.
								if (posCol + 1 < setArray[0].length
										&& setArray[posRow][posCol + 1] == lastSetDrawn) {
									prerendered = true;
									renderScratchColorFilteredCanvas
											.drawPaint(clearPaint);
									renderScratchColorFilteredCanvas
											.drawBitmap(renderScratchBitmap,
													renderScratchBounds,
													renderScratchBounds,
													tempColorFilterPaint);
								} else
									prerendered = false;
							}
							// draw this to canvas
							tempDstRect.set(left_x, top_y,
									left_x + ds.size_blockWidth, top_y
											+ ds.size_blockHeight);
							if (prerendered)
								canvas.drawBitmap(
										renderScratchColorFilteredBitmap,
										renderScratchBounds, tempDstRect, null);
							else
								canvas.drawBitmap(renderScratchBitmap,
										renderScratchBounds, tempDstRect,
										tempColorFilterPaint);
						} else {
							// two steps. One, draw the sheet bitmap to
							// glowRenderColorFilteredPlaceholder...
							// applying the glow color filter, but not the alpha
							// filter.
							// Two, draw from there to the canvas applying the
							// alpha filter.
							// We can apply the same situational optimization of
							// applying the
							// alpha filter to a second temporary canvas, if it
							// looks like the next
							// glow to draw matches this one.
							if (lastSetDrawn != index) {
								indexByNeighbors_sheetRect(tempSrcRect, index,
										sheetBlockWidth, sheetBlockHeight);
								renderScratchCanvas.drawPaint(clearPaint);
								renderScratchCanvas.drawBitmap(glowBitmapSheet,
										tempSrcRect, renderScratchBounds,
										tempGlowColorFilterPaint);
								lastSetDrawn = index;

								// we either apply the ColorFilter now
								// (prerender)
								// or later.
								if (posCol + 1 < setArray[0].length
										&& setArray[posRow][posCol + 1] == lastSetDrawn) {
									prerendered = true;
									renderScratchColorFilteredCanvas
											.drawPaint(clearPaint);
									renderScratchColorFilteredCanvas
											.drawBitmap(renderScratchBitmap,
													renderScratchBounds,
													renderScratchBounds,
													tempGlowAlphaFilterPaint);
								} else
									prerendered = false;
							}
							// draw this to canvas
							tempDstRect.set(left_x, top_y,
									left_x + ds.size_blockWidth, top_y
											+ ds.size_blockHeight);
							if (prerendered)
								canvas.drawBitmap(
										renderScratchColorFilteredBitmap,
										renderScratchBounds, tempDstRect, null);
							else
								canvas.drawBitmap(renderScratchBitmap,
										renderScratchBounds, tempDstRect,
										tempGlowAlphaFilterPaint);
						}
					}
				}
			}
		}
	}

	int[] draw3DLayerToCanvasWallOrder = new int[4];

	private void draw3DLayerToCanvas(DrawSettings ds, Canvas canvas,
			byte[][][] blockField, byte[][][] maskField,
			BlockDrawerConfigRange configRange, int prismSideAlpha,
			int prismEdgeAlpha, int extrudeSideAlpha, int extrudeEdgeAlpha,
			float pulseScaleAlpha, byte[][] tlCorners, byte[][] trCorners,
			byte[][] blCorners, byte[][] brCorners, byte[][] qo_tlCorners,
			byte[][] qo_trCorners, byte[][] qo_blCorners,
			byte[][] qo_brCorners, byte[][] mask_tlCorners,
			byte[][] mask_trCorners, byte[][] mask_blCorners,
			byte[][] mask_brCorners, short[][] qo_sets, boolean fullDetail,
			Offset drawOffset, boolean fillWithBackground) {

		// There are 2 basic structures that need drawing: small, inset prisms,
		// and extruded walls. Inset prisms occur once per block, so we can do
		// a standard row/column sweep. Extruded walls are a little harder,
		// as they are best performed in separate row/column sweeps.

		float prismTop, prismLeft;

		fillPaint.setColor(ds.color_background_piece);

		int pulseAlpha = Math.round(255.f * Math.abs(pulseScaleAlpha));

		boolean hasExtrudedBorderSides = false;
		boolean hasExtrudedQOBox = false;

		boolean drawPrism = prismSideAlpha > 0 || prismEdgeAlpha > 0;
		boolean drawExtrudedWalls = extrudeSideAlpha > 0
				|| extrudeEdgeAlpha > 0;
		boolean drawExtrudedBox = pulseScaleAlpha != 0;

		// Draw prisms currentnly unused.
		for (int row = configRange.rowFirst; row < configRange.rowBound; row++) {
			int r = configRange.rowToIndex(row);
			// y bounds for this block?
			int top_y = ds.getBlockYPosition(0, row) + drawOffset.y;
			int top_y_q1 = Integer.MIN_VALUE;
			
			int left_x = ds.getBlockXPosition(0, configRange.columnFirst-1) + drawOffset.x ;
			int x_step = ds.size_blockWidth ;
			for (int c = configRange.indexColFirst; c < configRange.indexColBound; c++) {
				// x bounds?
				left_x += x_step ;
				int left_x_q1 = Integer.MIN_VALUE;
				
				// Draw
				int qo = blockField[0][r][c];
				int behavior = ds.behavior_qo_3d[qo];

				// This block is "masked" if the mask field projects 3d behavior
				// into the square.
				boolean masked = maskField != null
						&& ds.behavior_qo_3d[maskField[0][r][c]] != DrawSettings.BEHAVIOR_QO_3D_NONE;

				switch (behavior) {
				case DrawSettings.BEHAVIOR_QO_3D_PAINT_Q_ORIENTATION_SMALL_PRISM:
				case DrawSettings.BEHAVIOR_QO_3D_PAINT_Q_ORIENTATION_SMALL_PRISM_SIDES_ONLY:
					if (drawPrism && !masked) {
						// Draw a full prism here. Depending on behavior, draw
						// either sides only, or with a top/bottom.
						sidePaint
								.setColor(ds.color_qOrientationQPaneFill[qo][0]);
						sidePaint
								.setAlpha((int) (prismSideAlpha * ds.alphamult_qOrientationFill[qo]));

						prismTop = top_y
								+ (ds.size_blockHeight - ds.size_smallPrismHeight)
								/ 2;
						prismLeft = left_x
								+ (ds.size_blockWidth - ds.size_smallPrismWidth)
								/ 2;

						drawRectangularPrism(
								canvas,
								fillWithBackground ? fillPaint : sidePaint,
								null,
								ds.size_smallPrismWidth,
								ds.size_smallPrismHeight,
								ds.size_qXOffset,
								ds.size_qYOffset,
								prismLeft,
								prismTop,
								behavior == DrawSettings.BEHAVIOR_QO_3D_PAINT_Q_ORIENTATION_SMALL_PRISM_SIDES_ONLY);
					}
					break;

				case DrawSettings.BEHAVIOR_QO_3D_PAINT_STANDARD_SMALL_PRISM:
				case DrawSettings.BEHAVIOR_QO_3D_PAINT_STANDARD_SMALL_PRISM_SIDES_ONLY:
					if (drawPrism && !masked) {
						// Draw a full prism here. Depending on behavior, draw
						// either sides only, or with a top/bottom.
						sidePaint.setColor(ds.color_prismSides);
						sidePaint
								.setAlpha((int) (prismSideAlpha * ds.alphamult_qOrientationFill[qo]));

						edgePaint.setColor(ds.color_prismEdges);
						edgePaint
								.setAlpha((int) (prismEdgeAlpha * ds.alphamult_qOrientationFill[qo]));

						prismTop = top_y
								+ (ds.size_blockHeight - ds.size_smallPrismHeight)
								/ 2;
						prismLeft = left_x
								+ (ds.size_blockWidth - ds.size_smallPrismWidth)
								/ 2;

						drawRectangularPrism(
								canvas,
								fillWithBackground ? fillPaint : sidePaint,
								fillWithBackground ? fillPaint : edgePaint,
								ds.size_smallPrismWidth,
								ds.size_smallPrismHeight,
								ds.size_qXOffset,
								ds.size_qYOffset,
								prismLeft,
								prismTop,
								behavior == DrawSettings.BEHAVIOR_QO_3D_PAINT_STANDARD_SMALL_PRISM_SIDES_ONLY);
					}
					break;

				case DrawSettings.BEHAVIOR_QO_3D_PAINT_BORDER_EXTRUDED_SIDES_ONLY:
					hasExtrudedBorderSides = true;
					break;

				case DrawSettings.BEHAVIOR_QO_3D_PAINT_EXTRUDED_QO_PULSE_BOX:
					hasExtrudedQOBox = true;
					if (drawExtrudedBox && !masked) {
						// draw the Consts.QPANE_1 side of the box. Use the
						// appropriate
						// region, according
						// to the provided set. Draw at 255.f * pulseScaleAlpha
						// remember to use top_y + ds.size_qYOffset, etc.
						if (top_y_q1 == Integer.MIN_VALUE)
							top_y_q1 = top_y + ds.size_qYOffset;
						if (left_x_q1 == Integer.MIN_VALUE)
							left_x_q1 = left_x + ds.size_qXOffset;

						int color = ds.color_qOrientationQPaneFill[qo][Consts.QPANE_1];
						tempColorPaint.setColor(color);
						tempColorPaint.setAlpha(pulseAlpha);

						tempPath.set(this.innerBorderPath_byNeighbors[qo_sets[r][c]]);
						tempPath.offset(left_x_q1, top_y_q1);   // already includes drawOffset
						canvas.save();
						canvas.clipPath(tempPath, Region.Op.DIFFERENCE);
						canvas.drawRect(left_x_q1, top_y_q1,
								left_x_q1 + ds.size_blockWidth, top_y_q1
										+ ds.size_blockHeight,
								tempColorPaint);
						canvas.restore();
					}
					break;
				}
			}
		}

		// Draw from corner to corner. Unlike the border shine procedure, we
		// draw from the
		// the true corner (convex or concave) that matches the position. A
		// CONVEX
		// corner gets drawn in the opposite direction of its position - i.e., a
		// TOP LEFT CONVEX corner starts a wall that is drawn rightward and
		// downward.
		// A CONCAVE corner gets drawn in the same direction as its position -
		// i.e.,
		// a BOTTOM RIGHT CONCAVE corner starts a wall that is drawn rightward
		// and
		// downward.
		//
		// Walls are horizontally or vertically until they hit the corresponding
		// corner, which will be the first corner in the same line - e.g., a
		// rightward
		// wall beginning in the TOP LEFT will stop the first time it reaches a
		// TOP LEFT
		// or TOP RIGHT corner, provided that that corner is a real corner and
		// not
		// just a reflected one (remember that CONCAVE corners are also listed
		// in their
		// adjacent blocks!).

		// We draw walls in two sweeps - first we draw the walls in the opposite
		// direction of QOffset, because they will be obscured by the others.
		// Then
		// we draw them in the direction of QOffset. That is, if QYOffset is
		// positive
		// (towards the bottom) then we draw TOP walls first, then BOTTOM walls.

		// The wall(s) begining in the TL corner are LEFT and TOP
		// The wall(s) beginning in the TR corner are RIGHT and TOP
		// The walls beginning in the BL corner are LEFT and BOTTOM
		// The walls beginning in the BR corner are RIGHT and BOTTOM.

		if (ds.size_qXOffset > 0 && ds.size_qYOffset > 0) {
			draw3DLayerToCanvasWallOrder[0] = WALL_SIDE_LEFT;
			draw3DLayerToCanvasWallOrder[1] = WALL_SIDE_TOP;
			draw3DLayerToCanvasWallOrder[2] = WALL_SIDE_RIGHT;
			draw3DLayerToCanvasWallOrder[3] = WALL_SIDE_BOTTOM;
		} else if (ds.size_qXOffset > 0 && ds.size_qYOffset <= 0) { // up-right
			draw3DLayerToCanvasWallOrder[0] = WALL_SIDE_LEFT;
			draw3DLayerToCanvasWallOrder[1] = WALL_SIDE_BOTTOM;
			draw3DLayerToCanvasWallOrder[2] = WALL_SIDE_RIGHT;
			draw3DLayerToCanvasWallOrder[3] = WALL_SIDE_TOP;
		} else if (ds.size_qXOffset <= 0 && ds.size_qYOffset > 0) {
			draw3DLayerToCanvasWallOrder[0] = WALL_SIDE_RIGHT;
			draw3DLayerToCanvasWallOrder[1] = WALL_SIDE_TOP;
			draw3DLayerToCanvasWallOrder[2] = WALL_SIDE_LEFT;
			draw3DLayerToCanvasWallOrder[3] = WALL_SIDE_BOTTOM;
		} else {
			draw3DLayerToCanvasWallOrder[0] = WALL_SIDE_RIGHT;
			draw3DLayerToCanvasWallOrder[1] = WALL_SIDE_BOTTOM;
			draw3DLayerToCanvasWallOrder[2] = WALL_SIDE_LEFT;
			draw3DLayerToCanvasWallOrder[3] = WALL_SIDE_TOP;
		}

		// MASK WALLS
		canvas.save();
		if (maskField != null && mask_tlCorners != null
				&& mask_trCorners != null && mask_blCorners != null
				&& mask_brCorners != null) {
			for (int i = 0; i < 4; i++) {
				mask3DWallsOnCanvas(
						ds,
						canvas,
						maskField,
						configRange,
						draw3DLayerToCanvasWallOrder[i],
						DrawSettings.BEHAVIOR_QO_3D_PAINT_EXTRUDED_QO_PULSE_BOX,
						mask_tlCorners, mask_trCorners, mask_blCorners,
						mask_brCorners, drawOffset, fillWithBackground);
			}
			// include q0, q1 in our mask - otherwise we can get walls that
			// "cut across"
			// the masked area.
			// Draw prisms currentnly unused.
			for (int row = configRange.rowFirst; row < configRange.rowBound; row++) {
				int r = configRange.rowToIndex(row);
				// y bounds for this block?
				int top_y = ds.getBlockYPosition(0, row) + drawOffset.y;
				int top_y_q1 = Integer.MIN_VALUE;
				for (int col = configRange.columnFirst; col < configRange.columnBound; col++) {
					int c = configRange.colToIndex(col);
					// x bounds?
					int left_x = ds.getBlockXPosition(0, col) + drawOffset.x;

					// Draw
					int qo = maskField[0][r][c];
					int behavior = ds.behavior_qo_3d[qo];
					if (behavior == DrawSettings.BEHAVIOR_QO_3D_NONE)
						continue;

					if (top_y_q1 == Integer.MIN_VALUE)
						top_y_q1 = top_y + ds.size_qYOffset;
					int left_x_q1 = left_x + ds.size_qXOffset;

					canvas.clipRect(left_x, top_y,
							left_x + ds.size_blockWidth,
							top_y + ds.size_blockHeight,
							Region.Op.DIFFERENCE);
					canvas.clipRect(left_x_q1, top_y_q1,
							left_x_q1 + ds.size_blockWidth,
							top_y_q1 + ds.size_blockHeight,
							Region.Op.DIFFERENCE);
				}
			}
		}

		if (drawExtrudedWalls && (hasExtrudedBorderSides || hasExtrudedQOBox)
				&& tlCorners != null && trCorners != null && blCorners != null
				&& brCorners != null) {
			for (int i = 0; i < 4; i++) {
				draw3DWallsToCanvas(
						ds,
						canvas,
						blockField,
						configRange,
						draw3DLayerToCanvasWallOrder[i],
						extrudeSideAlpha,
						extrudeEdgeAlpha,
						DrawSettings.BEHAVIOR_QO_3D_PAINT_BORDER_EXTRUDED_SIDES_ONLY,
						tlCorners, trCorners, blCorners, brCorners, fullDetail,
						drawOffset, fillWithBackground);
			}
		}

		if (drawExtrudedBox && hasExtrudedQOBox) {
			if (qo_tlCorners != null && qo_trCorners != null
					&& qo_blCorners != null && qo_brCorners != null) {
				for (int i = 0; i < 4; i++) {
					draw3DWallsToCanvas(
							ds,
							canvas,
							blockField,
							configRange,
							draw3DLayerToCanvasWallOrder[i],
							pulseAlpha,
							pulseAlpha,
							DrawSettings.BEHAVIOR_QO_3D_PAINT_EXTRUDED_QO_PULSE_BOX,
							qo_tlCorners, qo_trCorners, qo_blCorners,
							qo_brCorners, fullDetail, drawOffset,
							fillWithBackground);
				}
			}
		}

		canvas.restore();

		if (drawExtrudedBox && hasExtrudedQOBox) {

			// Draw box tops
			for (int row = configRange.rowFirst; row < configRange.rowBound; row++) {
				int r = configRange.rowToIndex(row);
				// y bounds for this block?
				int top_y = ds.getBlockYPosition(0, row) + drawOffset.y;
				for (int col = configRange.columnFirst; col < configRange.columnBound; col++) {
					int c = configRange.colToIndex(col);
					// x bounds?
					int left_x = ds.getBlockXPosition(0, col) + drawOffset.x;

					// Draw
					int qo = blockField[0][r][c];
					int behavior = ds.behavior_qo_3d[qo];

					// This block is "masked" if the mask field projects 3d
					// behavior into the square.
					boolean masked = maskField != null
							&& ds.behavior_qo_3d[maskField[0][r][c]] != DrawSettings.BEHAVIOR_QO_3D_NONE;

					if (behavior == DrawSettings.BEHAVIOR_QO_3D_PAINT_EXTRUDED_QO_PULSE_BOX
							&& !masked) {
						// draw the Consts.QPANE_0 side of the box. Use the
						// appropriate
						// region, according
						// to the provided set. Draw at 255.f * pulseScaleAlpha
						int color = ds.color_qOrientationQPaneFill[qo][Consts.QPANE_0];
						tempColorPaint.setColor(color);
						tempColorPaint.setAlpha(pulseAlpha);

						int index = qo_sets[r][c];
						tempPath.set(innerBorderPath_byNeighbors[index]);
						tempPath.offset(left_x, top_y); // already includes drawOffset
						canvas.save();
						canvas.clipPath(tempPath, Region.Op.DIFFERENCE);
						canvas.drawRect(left_x, top_y,
								left_x + ds.size_blockWidth,
								top_y + ds.size_blockHeight,
								tempColorPaint);
						canvas.restore();
					}
				}
			}
		}
	}

	private void draw3DWallsToCanvas(DrawSettings ds, Canvas canvas,
			byte[][][] blockField, BlockDrawerConfigRange configRange,
			int wallSide, int extrudeSideAlpha, int extrudeEdgeAlpha,
			int behavior_3d, byte[][] tlCorners, byte[][] trCorners,
			byte[][] blCorners, byte[][] brCorners, boolean fullDetail,
			Offset drawOffset, boolean fillWithBackground) {

		// new Exception("stack trace here").printStackTrace() ;
		/*
		 * log( 
		 * "************************************************************");
		 * log( 
		 * "************************************************************");
		 * log("***"); log("***"); log( 
		 * "*** draw3DWallsToCanvas"); for (int row = blockField[0].length - 1;
		 * row >= 0; row--) { StringBuilder sb = new StringBuilder(); for (int c
		 * = 0; c < blockField[0][0].length; c++)
		 * sb.append(QCombinations.encode(blockField, row, c)).append(" ");
		 * log(sb.toString()); } log("*** tlCorners"); for (int
		 * row = tlCorners.length - 1; row >= 0; row--) { StringBuilder sb = new
		 * StringBuilder(); for (int c = 0; c < tlCorners[0].length; c++)
		 * sb.append(tlCorners[row][c]).append(" "); log(sb.toString());
		 * } log("*** trCorners"); for (int row = trCorners.length - 1;
		 * row >= 0; row--) { StringBuilder sb = new StringBuilder(); for (int c
		 * = 0; c < trCorners[0].length; c++)
		 * sb.append(trCorners[row][c]).append(" "); log(sb.toString());
		 * } log("*** blCorners"); for (int row = blCorners.length - 1;
		 * row >= 0; row--) { StringBuilder sb = new StringBuilder(); for (int c
		 * = 0; c < blCorners[0].length; c++)
		 * sb.append(blCorners[row][c]).append(" "); log(sb.toString());
		 * } log("*** brCorners"); for (int row = brCorners.length - 1;
		 * row >= 0; row--) { StringBuilder sb = new StringBuilder(); for (int c
		 * = 0; c < brCorners[0].length; c++)
		 * sb.append(brCorners[row][c]).append(" "); log(sb.toString());
		 * }
		 * 
		 * log("***") ; log("***") ; log( 
		 * "************************************************************") ;
		 * log( 
		 * "************************************************************") ;
		 */

		// draw them
		place3DWallsOnCanvas(STYLE_WALL_PLACEMENT_DRAW, ds, canvas, blockField,
				configRange, wallSide, extrudeSideAlpha, extrudeEdgeAlpha,
				behavior_3d, tlCorners, trCorners, blCorners, brCorners,
				fullDetail, drawOffset, fillWithBackground);
	}

	private void mask3DWallsOnCanvas(DrawSettings ds, Canvas canvas,
			byte[][][] blockField, BlockDrawerConfigRange configRange,
			int wallSide, int behavior_3d, byte[][] tlCorners,
			byte[][] trCorners, byte[][] blCorners, byte[][] brCorners,
			Offset drawOffset, boolean fillWithBackground) {

		// draw them
		place3DWallsOnCanvas(STYLE_WALL_PLACEMENT_MASK, ds, canvas, blockField,
				configRange, wallSide, 0, 0, behavior_3d, tlCorners, trCorners,
				blCorners, brCorners, false, drawOffset, fillWithBackground);
	}

	private static final int STYLE_WALL_PLACEMENT_DRAW = 0;
	private static final int STYLE_WALL_PLACEMENT_MASK = 1;

	private void place3DWallsOnCanvas(int placementStyle, DrawSettings ds,
			Canvas canvas, byte[][][] blockField,
			BlockDrawerConfigRange configRange, int wallSide,
			int extrudeSideAlpha, int extrudeEdgeAlpha, int behavior_3d,
			byte[][] tlCorners, byte[][] trCorners, byte[][] blCorners,
			byte[][] brCorners, boolean fullDetail, Offset drawOffset,
			boolean fillWithBackground) {

		// We use the corners arrays to find walls of the specified side,
		// then draw them by calling draw3D wall. If 'fullDetail' is true,
		// we also draw shading on top of the wall.

		// Set our source points according to the bitmap we will use to draw
		// shadows.
		if (fullDetail && ds.drawDetail >= DrawSettings.DRAW_DETAIL_MID) {
			Bitmap b = innerBorderExtrudedWallShadow_bySide[wallSide];
			for (int i = 0; i < 8; i++)
				tempPointsSrc[i] = 0.0f;
			tempPointsSrc[2] = tempPointsSrc[6] = b.getWidth();
			tempPointsSrc[5] = tempPointsSrc[7] = b.getHeight();
		}

		fillPaint.setColor(ds.color_background_piece);

		
		for (int r = configRange.indexRowFirst; r < configRange.indexRowBound; r++) {
			int row = configRange.indexToRow(r);
			for (int c = configRange.indexColFirst; c < configRange.indexColBound; c++) {
				int qo = blockField[0][r][c];

				boolean drawHere = false;
				if (behavior_3d == DrawSettings.BEHAVIOR_QO_3D_PAINT_BORDER_EXTRUDED_SIDES_ONLY
						&& (ds.behavior_qo_3d[qo] == DrawSettings.BEHAVIOR_QO_3D_PAINT_BORDER_EXTRUDED_SIDES_ONLY || ds.behavior_qo_3d[qo] == DrawSettings.BEHAVIOR_QO_3D_PAINT_EXTRUDED_QO_PULSE_BOX))
					drawHere = true;
				else if (behavior_3d == DrawSettings.BEHAVIOR_QO_3D_PAINT_EXTRUDED_QO_PULSE_BOX
						&& ds.behavior_qo_3d[qo] == DrawSettings.BEHAVIOR_QO_3D_PAINT_EXTRUDED_QO_PULSE_BOX)
					drawHere = true;

				if (!drawHere)
					continue;

				sidePaint.setColor(ds.color_qOrientationQPaneFill[qo][0]);
				if (behavior_3d == DrawSettings.BEHAVIOR_QO_3D_PAINT_BORDER_EXTRUDED_SIDES_ONLY)
					sidePaint
							.setAlpha((int) (extrudeSideAlpha * ds.alphamult_qOrientationFill[qo]));
				else
					sidePaint.setAlpha(extrudeSideAlpha);
				
				int col = configRange.indexToCol(c) ;

				// We might need to draw a lot of walls out of this. Up
				// to four, actually. Each corner can have up to two walls
				// coming out of it.
				boolean fromTL = false, fromTR = false, fromBL = false, fromBR = false;
				switch (wallSide) {
				case WALL_SIDE_TOP:
					fromTL = tlCorners[row][col] == DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX;
					fromTR = trCorners[row][col] == DrawSettings.CORNER_INNER_RIGHT_TOP_CONCAVE;
					break;
				case WALL_SIDE_LEFT:
					fromTL = tlCorners[row][col] == DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX;
					fromBL = blCorners[row][col] == DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONCAVE;
					break;
				case WALL_SIDE_RIGHT:
					fromTR = trCorners[row][col] == DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX;
					fromBR = brCorners[row][col] == DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONCAVE;
					break;
				case WALL_SIDE_BOTTOM:
					fromBL = blCorners[row][col] == DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX;
					fromBR = brCorners[row][col] == DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONCAVE;
					break;
				}

				// Horizontal?
				int firstCornerX = 0;
				int firstCornerY = 0;
				int length = 0;
				if (wallSide == WALL_SIDE_TOP) {
					// It is impossible to have a wall coming from TL and from
					// TR at
					// the same time.
					length = 0;
					if (fromTL) {
						// chart a wall from here to the first corner we find
						// moving rightward.
						firstCornerX = ds.getBlockXPosition(0, col)
								+ drawOffset.x;
						firstCornerY = ds.getBlockYPosition(0, row)
								+ drawOffset.y;
						if (ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_INNER
								|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER
								|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE
								|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE) {
							firstCornerX += ds.size_borderWidth;
							firstCornerY += ds.size_borderHeight;
						}
						if (trCorners[row][col] == DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX) {
							// only the length of this block.
							length = ds.size_blockWidth;
							if (ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_INNER
									|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER
									|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE
									|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE) {
								length -= ds.size_borderWidth * 2;
							}
						} else {
							// move rightward to the first corner
							int colHere = col + 1;
							for (; true; colHere++) {
								if (tlCorners[row][colHere] == DrawSettings.CORNER_INNER_LEFT_TOP_CONCAVE) {
									length = (colHere - col)
											* ds.size_blockWidth;
									break;
								} else if (trCorners[row][colHere] == DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX) {
									length = (colHere - col + 1)
											* ds.size_blockWidth;
									if (ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_INNER
											|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER
											|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE
											|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE)
										length -= ds.size_borderWidth * 2;
									break;
								}
							}
						}
					} else if (fromTR) {
						// chart a wall from here to the first corner we find
						// moving rightward.
						firstCornerX = ds.getBlockXPosition(0, col + 1)
								+ drawOffset.x;
						firstCornerY = ds.getBlockYPosition(0, row)
								+ drawOffset.y;
						if (ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_INNER
								|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER
								|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE
								|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE) {
							firstCornerX -= ds.size_borderWidth;
							firstCornerY += ds.size_borderHeight;
						}
						// move rightward to the first corner
						int colHere = col + 1;
						for (; true; colHere++) {
							if (tlCorners[row][colHere] == DrawSettings.CORNER_INNER_LEFT_TOP_CONCAVE) {
								length = (colHere - col - 1)
										* ds.size_blockWidth;
								if (ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_INNER
										|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER
										|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE
										|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE)
									length += ds.size_borderWidth * 2;
								break;
							} else if (trCorners[row][colHere] == DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX) {
								length = (colHere - col)
										* ds.size_blockWidth;
								break;
							}
						}
					}

					if (length > 0) {
						if (placementStyle == STYLE_WALL_PLACEMENT_MASK) {
							mask3DWall(canvas, firstCornerX, firstCornerY,
									length, 0, ds.size_qXOffset,
									ds.size_qYOffset);
						} else if (placementStyle == STYLE_WALL_PLACEMENT_DRAW) {
							// Draw.
							draw3DWall(canvas, fillWithBackground ? fillPaint
									: sidePaint, null, firstCornerX,
									firstCornerY, length, 0,
									ds.size_qXOffset,
									ds.size_qYOffset);
							// Draw the shadow bitmap.
							if (fullDetail
									&& ds.drawDetail >= DrawSettings.DRAW_DETAIL_MID
									&& behavior_3d == DrawSettings.BEHAVIOR_QO_3D_PAINT_BORDER_EXTRUDED_SIDES_ONLY) {
								// this is a horizontal wall. Set our
								// destination points
								// to an unskewed rectangle assuming the top
								// edge is q0.
								// Skew the bottom in a direction determined by
								// qY and qX (if
								// in the same direction, skew to the right by
								// |qX|; otherwise
								// skew to the left). Finally, if qY is
								// negative, shift
								// by qX/qY to put the bottom edge on q0, not
								// the top.
								for (int i = 0; i < 4; i++) {
									tempPointsDst[i * 2] = firstCornerX;
									tempPointsDst[i * 2 + 1] = firstCornerY;
								}
								tempPointsDst[2] = tempPointsDst[6] = firstCornerX
										+ length;
								tempPointsDst[5] = tempPointsDst[7] = firstCornerY
										+ Math.abs(ds.size_qYOffset);
								// now skew the bottom
								if (ds.size_qYOffset > 0 == ds
										.size_qXOffset > 0) {
									tempPointsDst[4] += Math.abs(ds
											.size_qXOffset);
									tempPointsDst[6] += Math.abs(ds
											.size_qXOffset);
								} else {
									tempPointsDst[4] -= Math.abs(ds
											.size_qXOffset);
									tempPointsDst[6] -= Math.abs(ds
											.size_qXOffset);
								}
								// finally, shift.
								if (ds.size_qYOffset < 0) {
									for (int i = 0; i < 4; i++) {
										tempPointsDst[i * 2] += ds
												.size_qXOffset;
										tempPointsDst[i * 2 + 1] += ds
												.size_qYOffset;
									}
								}
								tempMatrix.setPolyToPoly(tempPointsSrc, 0,
										tempPointsDst, 0, 4);
								// this.tempColorPaint.setAlpha(extrudeSideAlpha);
								canvas.drawBitmap(
										innerBorderExtrudedWallShadow_bySide[wallSide],
										tempMatrix, null); // tempColorPaint) ;
							}
						}

						length = 0;
					}
				}
				if (wallSide == WALL_SIDE_BOTTOM) {

					// It is impossible to have a wall coming from BL and from
					// BR at
					// the same time.
					length = 0;
					if (fromBL) {
						// chart a wall from here to the first corner we find
						// moving rightward.
						firstCornerX = ds.getBlockXPosition(0, col)
								+ drawOffset.x;
						firstCornerY = ds.getBlockYPosition(0, row - 1)
								+ drawOffset.y;
						if (ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_INNER
								|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER
								|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE
								|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE) {
							firstCornerX += ds.size_borderWidth;
							firstCornerY -= ds.size_borderHeight;
						}
						if (brCorners[row][col] == DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX) {
							// only the length of this block.
							length = ds.size_blockWidth;
							if (ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_INNER
									|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER
									|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE
									|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE) {
								length -= ds.size_borderWidth * 2;
							}
						} else {
							// move rightward to the first corner
							int colHere = col + 1;
							for (; true; colHere++) {
								if (blCorners[row][colHere] == DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONCAVE) {
									length = (colHere - col)
											* ds.size_blockWidth;
									break;
								} else if (brCorners[row][colHere] == DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX) {
									length = (colHere - col + 1)
											* ds.size_blockWidth;
									if (ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_INNER
											|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER
											|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE
											|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE)
										length -= ds.size_borderWidth * 2;
									break;
								}
							}
						}
					} else if (fromBR) {
						// chart a wall from here to the first corner we find
						// moving rightward.
						firstCornerX = ds.getBlockXPosition(0, col + 1)
								+ drawOffset.x;
						firstCornerY = ds.getBlockYPosition(0, row - 1)
								+ drawOffset.y;
						if (ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_INNER
								|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER
								|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE
								|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE) {
							firstCornerX -= ds.size_borderWidth;
							firstCornerY -= ds.size_borderHeight;
						}
						// move rightward to the first corner
						int colHere = col + 1;
						for (; true; colHere++) {
							if (blCorners[row][colHere] == DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONCAVE) {
								length = (colHere - col - 1)
										* ds.size_blockWidth;
								if (ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_INNER
										|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER
										|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE
										|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE)
									length += ds.size_borderWidth * 2;
								break;
							} else if (brCorners[row][colHere] == DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX) {
								length = (colHere - col)
										* ds.size_blockWidth;
								break;
							}
						}
					}

					if (length > 0) {
						if (placementStyle == STYLE_WALL_PLACEMENT_MASK) {
							mask3DWall(canvas, firstCornerX, firstCornerY,
									length, 0, ds.size_qXOffset,
									ds.size_qYOffset);
						} else if (placementStyle == STYLE_WALL_PLACEMENT_DRAW) {
							// Draw.
							draw3DWall(canvas, fillWithBackground ? fillPaint
									: sidePaint, null, firstCornerX,
									firstCornerY, length, 0,
									ds.size_qXOffset,
									ds.size_qYOffset);
							// Draw the shadow bitmap.
							this.tempColorPaint.setAlpha(extrudeSideAlpha);
							if (fullDetail
									&& ds.drawDetail >= DrawSettings.DRAW_DETAIL_MID
									&& behavior_3d == DrawSettings.BEHAVIOR_QO_3D_PAINT_BORDER_EXTRUDED_SIDES_ONLY) {
								// this is a horizontal wall. Set our
								// destination points
								// to an unskewed rectangle assuming the top
								// edge is q0.
								// Skew the bottom in a direction determined by
								// qY and qX (if
								// in the same direction, skew to the right by
								// |qX|; otherwise
								// skew to the left). Finally, if qY is
								// negative, shift
								// by qX/qY to put the bottom edge on q0, not
								// the top.
								for (int i = 0; i < 4; i++) {
									tempPointsDst[i * 2] = firstCornerX;
									tempPointsDst[i * 2 + 1] = firstCornerY;
								}
								tempPointsDst[2] = tempPointsDst[6] = firstCornerX
										+ length;
								tempPointsDst[5] = tempPointsDst[7] = firstCornerY
										+ Math.abs(ds.size_qYOffset);
								// now skew the bottom
								if (ds.size_qYOffset > 0 == ds
										.size_qXOffset > 0) {
									tempPointsDst[4] += Math.abs(ds
											.size_qXOffset);
									tempPointsDst[6] += Math.abs(ds
											.size_qXOffset);
								} else {
									tempPointsDst[4] -= Math.abs(ds
											.size_qXOffset);
									tempPointsDst[6] -= Math.abs(ds
											.size_qXOffset);
								}
								// finally, shift.
								if (ds.size_qYOffset < 0) {
									for (int i = 0; i < 4; i++) {
										tempPointsDst[i * 2] += ds
												.size_qXOffset;
										tempPointsDst[i * 2 + 1] += ds
												.size_qYOffset;
									}
								}
								tempMatrix.setPolyToPoly(tempPointsSrc, 0,
										tempPointsDst, 0, 4);
								canvas.drawBitmap(
										innerBorderExtrudedWallShadow_bySide[wallSide],
										tempMatrix, null); // tempColorPaint) ;
							}
						}
					}
				}

				if (wallSide == WALL_SIDE_LEFT) {
					// It is impossible to have a wall coming from TL and from
					// BL at
					// the same time.
					length = 0;
					if (fromTL) {
						// chart a wall from here to the first corner we find
						// moving downward.
						firstCornerX = ds.getBlockXPosition(0, col)
								+ drawOffset.x;
						firstCornerY = ds.getBlockYPosition(0, row)
								+ drawOffset.y;
						if (ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_INNER
								|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER
								|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE
								|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE) {
							firstCornerX += ds.size_borderWidth;
							firstCornerY += ds.size_borderHeight;
						}
						if (blCorners[row][col] == DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX) {
							// only the length of this block.
							length = ds.size_blockHeight;
							if (ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_INNER
									|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER
									|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE
									|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE) {
								length -= ds.size_borderHeight * 2;
							}
						} else {
							// move downward to the first corner
							int rowHere = row - 1;
							for (; true; rowHere--) {
								if (tlCorners[rowHere][col] == DrawSettings.CORNER_INNER_LEFT_TOP_CONCAVE) {
									length = (row - rowHere)
											* ds.size_blockHeight;
									break;
								} else if (blCorners[rowHere][col] == DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX) {
									length = (row - rowHere + 1)
											* ds.size_blockHeight;
									if (ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_INNER
											|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER
											|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE
											|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE)
										length -= ds.size_borderHeight * 2;
									break;
								}
							}
						}
					} else if (fromBL) {
						// chart a wall from here to the first corner we find
						// moving downward.
						firstCornerX = ds.getBlockXPosition(0, col)
								+ drawOffset.x;
						firstCornerY = ds.getBlockYPosition(0, row - 1)
								+ drawOffset.y;
						if (ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_INNER
								|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER
								|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE
								|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE) {
							firstCornerX += ds.size_borderWidth;
							firstCornerY -= ds.size_borderHeight;
						}
						// move rightward to the first corner
						int rowHere = row - 1;
						for (; true; rowHere--) {
							if (tlCorners[rowHere][col] == DrawSettings.CORNER_INNER_LEFT_TOP_CONCAVE) {
								length = (row - rowHere)
										* ds.size_blockWidth;
								if (ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_INNER
										|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER
										|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE
										|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE)
									length += ds.size_borderHeight * 2;
								break;
							} else if (blCorners[rowHere][col] == DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX) {
								length = (row - rowHere)
										* ds.size_blockHeight;
								break;
							}
						}
					}

					if (length > 0) {
						if (placementStyle == STYLE_WALL_PLACEMENT_MASK) {
							mask3DWall(canvas, firstCornerX, firstCornerY,
									length, 0, ds.size_qXOffset,
									ds.size_qYOffset);
						} else if (placementStyle == STYLE_WALL_PLACEMENT_DRAW) {
							// Draw.
							draw3DWall(canvas, fillWithBackground ? fillPaint
									: sidePaint, null, firstCornerX,
									firstCornerY, 0, length,
									ds.size_qXOffset,
									ds.size_qYOffset);
							// Draw the shadow bitmap.
							this.tempColorPaint.setAlpha(extrudeSideAlpha);
							if (fullDetail
									&& ds.drawDetail >= DrawSettings.DRAW_DETAIL_MID
									&& behavior_3d == DrawSettings.BEHAVIOR_QO_3D_PAINT_BORDER_EXTRUDED_SIDES_ONLY) {
								// this is a vertical wall. Set our destination
								// points
								// to an unskewed rectangle assuming the left
								// edge is q0.
								// Skew the right side in a direction determined
								// by qY and qX (if
								// in the same direction, skew downward by |qX|;
								// otherwise
								// skew to upward). Finally, if qX is negative,
								// shift
								// by qX/qY to put the right edge on q0, not the
								// left.
								for (int i = 0; i < 4; i++) {
									tempPointsDst[i * 2] = firstCornerX;
									tempPointsDst[i * 2 + 1] = firstCornerY;
								}
								tempPointsDst[2] = tempPointsDst[6] = firstCornerX
										+ Math.abs(ds.size_qXOffset);
								tempPointsDst[5] = tempPointsDst[7] = firstCornerY
										+ length;
								// now skew the right side
								if (ds.size_qYOffset > 0 == ds
										.size_qXOffset > 0) {
									tempPointsDst[3] += Math.abs(ds
											.size_qYOffset);
									tempPointsDst[7] += Math.abs(ds
											.size_qYOffset);
								} else {
									tempPointsDst[3] -= Math.abs(ds
											.size_qYOffset);
									tempPointsDst[7] -= Math.abs(ds
											.size_qYOffset);
								}
								// finally, shift.
								if (ds.size_qXOffset < 0) {
									for (int i = 0; i < 4; i++) {
										tempPointsDst[i * 2] += ds
												.size_qXOffset;
										tempPointsDst[i * 2 + 1] += ds
												.size_qYOffset;
									}
								}
								tempMatrix.setPolyToPoly(tempPointsSrc, 0,
										tempPointsDst, 0, 4);
								canvas.drawBitmap(
										innerBorderExtrudedWallShadow_bySide[wallSide],
										tempMatrix, null); // tempColorPaint) ;
							}
						}
					}

				}

				if (wallSide == WALL_SIDE_RIGHT) {

					// It is impossible to have a wall coming from TR and from
					// BR at
					// the same time.
					length = 0;
					if (fromTR) {
						// chart a wall from here to the first corner we find
						// moving rightward.
						firstCornerX = ds.getBlockXPosition(0, col + 1)
								+ drawOffset.x;
						firstCornerY = ds.getBlockYPosition(0, row)
								+ drawOffset.y;
						if (ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_INNER
								|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER
								|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE
								|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE) {
							firstCornerX -= ds.size_borderWidth;
							firstCornerY += ds.size_borderHeight;
						}
						if (brCorners[row][col] == DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX) {
							// only the length of this block.
							length = ds.size_blockHeight;
							if (ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_INNER
									|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER
									|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE
									|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE) {
								length -= ds.size_borderHeight * 2;
							}
						} else {
							// move downward to the first corner
							int rowHere = row - 1;
							for (; true; rowHere--) {
								if (trCorners[rowHere][col] == DrawSettings.CORNER_INNER_RIGHT_TOP_CONCAVE) {
									length = (row - rowHere)
											* ds.size_blockHeight;
									break;
								} else if (brCorners[rowHere][col] == DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX) {
									length = (row - rowHere + 1)
											* ds.size_blockHeight;
									if (ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_INNER
											|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER
											|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE
											|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE)
										length -= ds.size_borderHeight * 2;
									break;
								}
							}
						}
					} else if (fromBR) {
						// chart a wall from here to the first corner we find
						// moving rightward.
						firstCornerX = ds.getBlockXPosition(0, col + 1)
								+ drawOffset.x;
						firstCornerY = ds.getBlockYPosition(0, row - 1)
								+ drawOffset.y;
						if (ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_INNER
								|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER
								|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE
								|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE) {
							firstCornerX -= ds.size_borderWidth;
							firstCornerY -= ds.size_borderHeight;
						}
						// move downward to the first corner
						int rowHere = row - 1;
						for (; true; rowHere--) {
							// log("rowHere: " + rowHere + ", col:" +
							// col) ;
							if (trCorners[rowHere][col] == DrawSettings.CORNER_INNER_RIGHT_TOP_CONCAVE) {
								length = (row - rowHere - 1)
										* ds.size_blockHeight;
								if (ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_INNER
										|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER
										|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE
										|| ds.behavior_qo_border[qo] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE)
									length += ds.size_borderHeight * 2;
								break;
							} else if (brCorners[rowHere][col] == DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX) {
								length = (row - rowHere)
										* ds.size_blockHeight;
								break;
							}
						}
					}

					if (length > 0) {
						if (placementStyle == STYLE_WALL_PLACEMENT_MASK) {
							mask3DWall(canvas, firstCornerX, firstCornerY,
									length, 0, ds.size_qXOffset,
									ds.size_qYOffset);
						} else if (placementStyle == STYLE_WALL_PLACEMENT_DRAW) {
							// Draw.
							// TEST TEST TEST TEST
							draw3DWall(canvas, fillWithBackground ? fillPaint
									: sidePaint, null, firstCornerX,
									firstCornerY, 0, length,
									ds.size_qXOffset,
									ds.size_qYOffset);
							// Draw the shadow bitmap.
							this.tempColorPaint.setAlpha(extrudeSideAlpha);
							if (fullDetail
									&& ds.drawDetail >= DrawSettings.DRAW_DETAIL_MID
									&& behavior_3d == DrawSettings.BEHAVIOR_QO_3D_PAINT_BORDER_EXTRUDED_SIDES_ONLY) {
								// this is a vertical wall. Set our destination
								// points
								// to an unskewed rectangle assuming the left
								// edge is q0.
								// Skew the right side in a direction determined
								// by qY and qX (if
								// in the same direction, skew downward by |qX|;
								// otherwise
								// skew to upward). Finally, if qX is negative,
								// shift
								// by qX/qY to put the right edge on q0, not the
								// left.
								for (int i = 0; i < 4; i++) {
									tempPointsDst[i * 2] = firstCornerX;
									tempPointsDst[i * 2 + 1] = firstCornerY;
								}
								tempPointsDst[2] = tempPointsDst[6] = firstCornerX
										+ Math.abs(ds.size_qXOffset);
								tempPointsDst[5] = tempPointsDst[7] = firstCornerY
										+ length;
								// now skew the right side
								if (ds.size_qYOffset > 0 == ds
										.size_qXOffset > 0) {
									tempPointsDst[3] += Math.abs(ds
											.size_qYOffset);
									tempPointsDst[7] += Math.abs(ds
											.size_qYOffset);
								} else {
									tempPointsDst[3] -= Math.abs(ds
											.size_qYOffset);
									tempPointsDst[7] -= Math.abs(ds
											.size_qYOffset);
								}
								// finally, shift.
								if (ds.size_qXOffset < 0) {
									for (int i = 0; i < 4; i++) {
										tempPointsDst[i * 2] += ds
												.size_qXOffset;
										tempPointsDst[i * 2 + 1] += ds
												.size_qYOffset;
									}
								}
								tempMatrix.setPolyToPoly(tempPointsSrc, 0,
										tempPointsDst, 0, 4);
								canvas.drawBitmap(
										innerBorderExtrudedWallShadow_bySide[wallSide],
										tempMatrix, null); // tempColorPaint) ;
							}
						}
					}
				}
			}
		}
	}


	private void drawRowNegativeOneToCanvas(DrawSettings ds, Canvas canvas,
			int qPane, int alpha, Offset o) {

		if (rowNegativeOneBorder_byQPane != null) {
			Bitmap b = rowNegativeOneBorder_byQPane[qPane];
			Rect bounds = rowNegativeOneBorderBounds_byQPane[qPane];
			if (b != null) {
				tempColorPaint.setAlpha(ds.alpha_rowNegativeOneBorder);

				int left_x = ds.getBlockXPosition(qPane, 0) + o.x;
				int top_y = ds.getBlockYPosition(qPane, -1)
						- ds.size_borderHeight + o.y;

				tempDstRect.set(left_x, top_y, left_x + bounds.width(), top_y
						+ bounds.height());
				canvas.drawBitmap(b, bounds, tempDstRect, tempColorPaint);
			}
		}
	}

	/*
	 * private void clipFullWidthRowToCanvas( Canvas canvas, int left, int
	 * right, int qPane, int row, Offset o, int extendByPixels ) { int top_y =
	 * drawSettings.getBlockYPosition(qPane, row) + o.y - 1 - extendByPixels;
	 * int bottom_y = drawSettings.getBlockYPosition(qPane, row-1) + o.y + 2 +
	 * extendByPixels ;
	 * 
	 * canvas.clipRect(left, top_y, right, bottom_y, Region.Op.UNION) ; }
	 */

	private void clipFullWidthRowNegativeOneToCanvasIntersection(Canvas canvas, int left,
			int right, int qPane, Offset o, int extendByPixels) {
		reset(tempClipPath);
		clipFullWidthRowNegativeOne(tempClipPath, left, right, qPane, o,
				extendByPixels);
		canvas.clipPath(tempClipPath);
	}

	private void clipFullWidthRowNegativeOne(Path p, int left, int right,
			int qPane, Offset o, int extendByPixels) {
		if (rowNegativeOneBorderBounds_byQPane != null) {
			Rect bounds = rowNegativeOneBorderBounds_byQPane[qPane];
			if (bounds != null) {
				int top_y = mDrawSettings.getBlockYPosition(qPane, -1)
						- mDrawSettings.size_borderHeight + o.y;
				int bottom_y = top_y + bounds.height();

				unionRect(p, left - extendByPixels, top_y - extendByPixels, right
						+ extendByPixels, bottom_y + extendByPixels,
						Path.Direction.CW);
			}
		}
	}

	private Path pathParallelogram(Path path, float x1canvas, float y1canvas,
			float side1vectx, float side1vecty, float side2vectx,
			float side2vecty) {

		// Make a path.
		final float[] points = new float[4 * 4];
		points[0] = points[14] = x1canvas;
		points[1] = points[15] = y1canvas;
		points[2] = points[4] = x1canvas + side1vectx;
		points[3] = points[5] = y1canvas + side1vecty;
		points[6] = points[8] = points[2] + side2vectx;
		points[7] = points[9] = points[3] + side2vecty;
		points[10] = points[12] = x1canvas + side2vectx;
		points[11] = points[13] = y1canvas + side2vecty;

		path.moveTo(points[0], points[1]);
		for (int i = 0; i < 3; i++)
			path.lineTo(points[i * 4 + 2], points[i * 4 + 3]);
		path.close();

		return path;
	}

	/**
	 * 
	 * @param canvas
	 * @param drawRegion
	 * @param paint
	 * @param x1canvasCoord
	 * @param y1canvasCoord
	 * @param x2canvasCoord
	 * @param y2canvasCoord
	 * @param qLengthCanvasCoord
	 * @param qVectX
	 * @param qVectY
	 */
	private void drawQRectangle(DrawSettings ds, Canvas canvas,
			Rect drawRegion, Paint paint, float x1canvasCoord,
			float y1canvasCoord, float x2canvasCoord, float y2canvasCoord,
			float qLengthCanvasCoord, float qVectX, float qVectY) {

		reset(tempPath);
		pathQRectangle(tempPath, x1canvasCoord, y1canvasCoord,
				x2canvasCoord, y2canvasCoord, qLengthCanvasCoord, qVectX,
				qVectY);
		canvas.save();
		canvas.clipPath(tempPath, Region.Op.INTERSECT);
		canvas.drawRect(drawRegion, paint);
		canvas.restore();
	}

	/**
	 * 
	 * @param path
	 * @param x1canvasCoord
	 * @param y1canvasCoord
	 * @param x2canvasCoord
	 * @param y2canvasCoord
	 * @param qLengthCanvasCoord
	 * @param qVectX
	 * @param qVectY
	 */
	private Path pathQRectangle(Path path, float x1canvasCoord,
			float y1canvasCoord, float x2canvasCoord, float y2canvasCoord,
			float qLengthCanvasCoord, float qVectX, float qVectY) {

		// Draw a rectangle which has two sides parallel
		// to the Q-axis. qVectX,Y gives canvas-coordinates
		// for the visual effect of moving 1 "canvas coord" along
		// the "q axis".

		float qOffsetX = qVectX * qLengthCanvasCoord;
		float qOffsetY = qVectY * qLengthCanvasCoord;

		// Make a path.
		final float[] points = new float[4 * 4];
		points[0] = points[14] = x1canvasCoord;
		points[1] = points[15] = y1canvasCoord;
		points[2] = points[4] = x2canvasCoord;
		points[3] = points[5] = y2canvasCoord;
		points[6] = points[8] = x2canvasCoord + qOffsetX; // p2 in the q pane
		points[7] = points[9] = y2canvasCoord + qOffsetY;
		points[10] = points[12] = x1canvasCoord + qOffsetX;
		points[11] = points[13] = y1canvasCoord + qOffsetY;

		path.moveTo(points[0], points[1]);
		for (int i = 0; i < 3; i++)
			path.lineTo(points[i * 4 + 2], points[i * 4 + 3]);
		path.close();
		return path;
	}

	private float[] draw3DWall_points = new float[4 * 4];

	/**
	 * A generic call to draw a "3D" wall. Specify corner coordinates, x/y
	 * dimensions for a vector, and the 3D "depth".
	 */
	private void draw3DWall(Canvas canvas, Paint sidePaint, Paint edgePaint,
			float top_corner_left, float top_corner_top, float length_x,
			float length_y, float depth_x_offset, float depth_y_offset) {

		// Here are the draw3DWall_points we use.
		draw3DWall_points[0] = draw3DWall_points[14] = top_corner_left;
		draw3DWall_points[1] = draw3DWall_points[15] = top_corner_top;
		draw3DWall_points[2] = draw3DWall_points[4] = top_corner_left
				+ length_x;
		draw3DWall_points[3] = draw3DWall_points[5] = top_corner_top + length_y;
		draw3DWall_points[6] = draw3DWall_points[8] = top_corner_left
				+ length_x + depth_x_offset;
		draw3DWall_points[7] = draw3DWall_points[9] = top_corner_top + length_y
				+ depth_y_offset;
		draw3DWall_points[10] = draw3DWall_points[12] = top_corner_left
				+ depth_x_offset;
		draw3DWall_points[11] = draw3DWall_points[13] = top_corner_top
				+ depth_y_offset;

		// Draw a 3D wall.
		// Wall first, then edge accents.
		reset(tempPath);
		tempPath.moveTo(draw3DWall_points[0], draw3DWall_points[1]);
		for (int i = 0; i < 3; i++)
			tempPath.lineTo(draw3DWall_points[i * 4 + 2],
					draw3DWall_points[i * 4 + 3]);
		tempPath.close();
		canvas.save();
		canvas.clipPath(tempPath, Region.Op.INTERSECT);
		canvas.drawPaint(sidePaint);
		canvas.restore();

		// Edges. There are four of them.
		/*
		 * canvas.save() ; canvas.clipRect(drawRegion) ;
		 * canvas.drawLines(draw3DWall_points, edgePaint) ; canvas.restore() ;
		 */
	}

	/**
	 * A generic call to draw a "3D" wall. Specify corner coordinates, x/y
	 * dimensions for a vector, and the 3D "depth".
	 */
	private void mask3DWall(Canvas canvas, float top_corner_left,
			float top_corner_top, float length_x, float length_y,
			float depth_x_offset, float depth_y_offset) {

		// Here are the draw3DWall_points we use.
		final float[] draw3DWall_points = new float[4 * 4];
		draw3DWall_points[0] = draw3DWall_points[14] = top_corner_left;
		draw3DWall_points[1] = draw3DWall_points[15] = top_corner_top;
		draw3DWall_points[2] = draw3DWall_points[4] = top_corner_left
				+ length_x;
		draw3DWall_points[3] = draw3DWall_points[5] = top_corner_top + length_y;
		draw3DWall_points[6] = draw3DWall_points[8] = top_corner_left
				+ length_x + depth_x_offset;
		draw3DWall_points[7] = draw3DWall_points[9] = top_corner_top + length_y
				+ depth_y_offset;
		draw3DWall_points[10] = draw3DWall_points[12] = top_corner_left
				+ depth_x_offset;
		draw3DWall_points[11] = draw3DWall_points[13] = top_corner_top
				+ depth_y_offset;

		// Draw a 3D wall.
		// Wall first, then edge accents.
		reset(tempPath);
		tempPath.moveTo(draw3DWall_points[0], draw3DWall_points[1]);
		for (int i = 0; i < 3; i++)
			tempPath.lineTo(draw3DWall_points[i * 4 + 2],
					draw3DWall_points[i * 4 + 3]);
		tempPath.close();
		canvas.clipPath(tempPath, Region.Op.DIFFERENCE);
	}

	private void drawRectangularPrism(Canvas canvas, Paint sidePaint,
			Paint edgePaint, float baseWidth, float baseHeight,
			float depth_x_offset, float depth_y_offset, float top_side_left,
			float top_side_top, boolean sidesOnly) {

		// Draw:
		// bottom
		// sides
		// top
		// "frame"

		float bottom_side_left = top_side_left + depth_x_offset;
		float bottom_side_top = top_side_top + depth_y_offset;

		// The bottom
		if (!sidesOnly) {
			canvas.save();
			canvas.clipRect(bottom_side_left, bottom_side_top, bottom_side_left
					+ baseWidth, bottom_side_top + baseHeight,
					Region.Op.INTERSECT);
			canvas.drawRect(bottom_side_left - 3, bottom_side_top - 3,
					bottom_side_left + baseWidth + 3, bottom_side_top
							+ baseHeight + 3, sidePaint);
			canvas.restore();
		}

		// sides
		// "top" side
		draw3DWall(canvas, sidePaint, edgePaint, top_side_left, top_side_top,
				baseWidth, 0, depth_x_offset, depth_y_offset);
		// "left" side
		draw3DWall(canvas, sidePaint, edgePaint, top_side_left, top_side_top,
				0, baseHeight, depth_x_offset, depth_y_offset);
		// "bottom" side
		draw3DWall(canvas, sidePaint, edgePaint, top_side_left, top_side_top
				+ baseHeight, baseWidth, 0, depth_x_offset, depth_y_offset);
		// "right" side
		draw3DWall(canvas, sidePaint, edgePaint, top_side_left + baseWidth,
				top_side_top, 0, baseHeight, depth_x_offset, depth_y_offset);

		// The top
		if (!sidesOnly) {
			canvas.save();
			canvas.clipRect(top_side_left, top_side_top, top_side_left
					+ baseWidth, top_side_top + baseHeight, Region.Op.INTERSECT);
			canvas.drawRect(top_side_left - 3, top_side_top - 3, top_side_left
					+ baseWidth + 3, top_side_top + baseHeight + 3, sidePaint);
			canvas.restore();
		}
	}

	/**
	 * Steps through the blockField at the specified qPane, looking for
	 * instances of markQO. Sets the provided region to exactly the area covered
	 * by the "QOrientation Border" of the provided block type. Returns the
	 * region given.
	 * 
	 * @param path
	 *            A path to set to cover the border
	 * @param blockField
	 *            The blockField to examine in this check
	 * @param qPane
	 *            Which pane of the blockField to examine
	 * @param markQO
	 *            Which qOrientation to mark in the region
	 * @param ds
	 * @param drawOffset
	 *            A canvas-coordinate offset to set with
	 * @return Returns the path provided, so this can be called with ( new
	 *         Region(), ... )
	 */
	private Path setRegionQOrientationBorderLayer(DrawSettings ds,
			Path path, byte[][][] blockField, int qPane, int markQO,
			Offset drawOffset) {

		reset(path);

		if (ds.behavior_qo_border[markQO] == DrawSettings.BEHAVIOR_QO_BORDER_INNER
				|| ds.behavior_qo_border[markQO] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER
				|| ds.behavior_qo_border[markQO] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE
				|| ds.behavior_qo_border[markQO] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY
				|| ds.behavior_qo_border[markQO] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY_BLEND
				|| ds.behavior_qo_border[markQO] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE) {

			boolean friendly = ds.behavior_qo_border[markQO] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY
					|| ds.behavior_qo_border[markQO] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY_BLEND;

			boolean unfriendly = ds.behavior_qo_border[markQO] == DrawSettings.BEHAVIOR_QO_BORDER_INNER;

			for (int row = 0; row < ds.displayedRows; row++) {
				int top_y = ds.getBlockYPosition(qPane, row) + drawOffset.y;
				int bottom_y = top_y + ds.size_blockHeight;
				int r = row + ds.blockFieldOuterBuffer;

				for (int col = 0; col < ds.COLS; col++) {
					int c = col + ds.blockFieldOuterBuffer;

					int qo = blockField[qPane][r][c];

					if (qo == markQO) {
						// Mark the "inner boundaries" here. Mark for any
						// neighbor that
						// isn't markQO.
						int left_x = ds.getBlockXPosition(qPane, col)
								+ drawOffset.x;
						int right_x = left_x + ds.size_blockWidth;

						for (int rOff = -1; rOff <= 1; rOff++) {
							for (int cOff = -1; cOff <= 1; cOff++) {
								// Include?
								if ((!friendly && blockField[qPane][r + rOff][c
										+ cOff] != qo)
										|| (friendly && blockField[qPane][r
												+ rOff][c + cOff] == QOrientations.NO)
										|| (unfriendly)) {
									// Union the boundary here.
									// Top of border determined
									// by whether rOff > -1; bottom determined
									// by whether rOff < 1.
									// Similarly, left and right determined by
									// cOff.
									int border_top = rOff > -1 ? top_y
											: bottom_y - ds.size_borderHeight;
									int border_bottom = rOff < 1 ? bottom_y
											: border_top + ds.size_borderHeight;
									int border_left = cOff < 1 ? left_x
											: right_x - ds.size_borderWidth;
									int border_right = cOff > -1 ? right_x
											: border_left + ds.size_borderWidth;

									unionRect(path, border_left, border_top,
											border_right, border_bottom,
											Path.Direction.CW);
								}
							}
						}
					}
				}
			}
		}

		else if (ds.behavior_qo_border[markQO] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INSET) {
			for (int row = 0; row < ds.displayedRows; row++) {
				int top_y = ds.getBlockYPosition(qPane, row) + drawOffset.y
						+ ds.size_innerBorderYInset;
				int bottom_y = top_y + ds.size_blockHeight
						- ds.size_innerBorderYInset * 2;
				int r = row + ds.blockFieldOuterBuffer;

				for (int col = 0; col < ds.COLS; col++) {
					int c = col + ds.blockFieldOuterBuffer;

					int qo = blockField[qPane][r][c];

					if (qo == markQO) {
						// Mark the region here.
						int left_x = ds.getBlockXPosition(qPane, col)
								+ drawOffset.x + ds.size_innerBorderXInset;
						int right_x = left_x + ds.size_blockWidth
								- ds.size_innerBorderXInset * 2;

						unionRect(path, left_x, top_y,
                                left_x + ds.size_innerBorderWidth, bottom_y,
								Path.Direction.CW);
						unionRect(path, right_x - ds.size_innerBorderWidth, top_y,
								right_x, bottom_y, Path.Direction.CW);
						unionRect(path, left_x, top_y, right_x, top_y
								+ ds.size_innerBorderHeight, Path.Direction.CW);
						unionRect(path, left_x, bottom_y - ds.size_innerBorderHeight, right_x, bottom_y, Path.Direction.CW);
					}
				}
			}
		}

		// draw custom border regions
		else if (ds.behavior_qo_border[markQO] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_HORIZONTAL_OVER
				|| ds.behavior_qo_border[markQO] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI_CHAIN_LINK_VERTICAL_OVER
				|| ds.behavior_qo_border[markQO] == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_MINI) {
			for (int row = 0; row < ds.displayedRows; row++) {
				int top_y = ds.getBlockYPosition(qPane, row) + drawOffset.y;
				int r = row + ds.blockFieldOuterBuffer;

				for (int col = 0; col < ds.COLS; col++) {
					int c = col + ds.blockFieldOuterBuffer;

					int qo = blockField[qPane][r][c];

					if (qo == markQO) {
						// Mark the region here.
						int left_x = ds.getBlockXPosition(qPane, col) + drawOffset.x;

						tempPath.set(customBorderPath_byQPane_QOrientation[qPane][markQO]);
						tempPath.offset(left_x, top_y);

						op(path, tempPath, Path.Op.UNION);
					}
				}
			}
		}

		return path;
	}

	/**
	 * Steps through the blockField at the specified qPane, looking for blocks
	 * with a QPane outer border layer. We set the provided region to the space
	 * described by the QPane outer border.
	 */
	private Region setRegionQPaneBorderLayer(DrawSettings ds, Region region,
			byte[][][] blockField, int qPane, Offset drawOffset,
			boolean obeyBorderBehavior) {

		region.setEmpty();

		for (int row = 0; row < ds.displayedRows; row++) {
			int top_y = ds.getBlockYPosition(qPane, row) + drawOffset.y;
			int bottom_y = top_y + ds.size_blockHeight;
			int r = row + ds.blockFieldOuterBuffer;

			for (int col = 0; col < ds.COLS; col++) {
				int left_x = ds.getBlockXPosition(qPane, col) + drawOffset.x;
				int right_x = left_x + ds.size_blockWidth;
				int c = col + ds.blockFieldOuterBuffer;

				int qo = blockField[qPane][r][c];
				int behavior = ds.behavior_qo_border[qo];

				switch (behavior) {
				case DrawSettings.BEHAVIOR_QO_BORDER_Q_PANE_INSET:
					int borderBounds_l = left_x + ds.size_innerBorderXInset;
					int borderBounds_r = right_x - ds.size_innerBorderXInset;
					int borderBounds_t = top_y + ds.size_innerBorderYInset;
					int borderBounds_b = bottom_y - ds.size_innerBorderYInset;

					region.op(borderBounds_l, borderBounds_t, borderBounds_r,
							borderBounds_b, Region.Op.UNION);
					region.op(borderBounds_l + ds.size_innerBorderWidth,
							borderBounds_t + ds.size_innerBorderHeight,
							borderBounds_r - ds.size_innerBorderWidth,
							borderBounds_b - ds.size_innerBorderHeight,
							Region.Op.DIFFERENCE);
					// log("setRegionQPaneBorderLayer UNION: [" +
					// borderBounds_l + ", " + borderBounds_t + ", " +
					// borderBounds_r + ", " + borderBounds_b + "]") ;
					// log("setRegionQPaneBorderLayer DIFFE: [" +
					// (borderBounds_l+ds.size_innerBorderWidth) + ", " +
					// (borderBounds_t+ds.size_innerBorderHeight) + ", " +
					// (borderBounds_r-ds.size_innerBorderWidth) + ", " +
					// (borderBounds_b-ds.size_innerBorderHeight) + "]") ;

					break;
				}

				// Now draw any outer borders that appear here
				// (i.e., outer borders drawn around neighboring blocks).
				// To draw a border here, it must be the case that 1: this
				// location does
				// NOT contribute to Q_PANE_OUTER borders, and 2: a neighbor
				// DOES. We
				// draw the neighbor's border in this block.
				if (behavior != DrawSettings.BEHAVIOR_QO_BORDER_Q_PANE_OUTER) {
					for (int rOff = -1; rOff <= 1; rOff++) {
						for (int cOff = -1; cOff <= 1; cOff++) {
							int qoAtOffset = blockField[qPane][r + rOff][c
									+ cOff];
							// Include?
							// We include the border if:
							// 1. the block at this offset projects a border
							// into this block
							// 2. this offset puts beyond the bounds of the
							// blockField, and ds.behavior_border
							// implies that we should draw a "field wall" in
							// this direction.
							if ((ds.behavior_qo_border[qoAtOffset] == DrawSettings.BEHAVIOR_QO_BORDER_Q_PANE_OUTER)
									|| (obeyBorderBehavior && (ds.behavior_border == DrawSettings.BEHAVIOR_BORDER_ROW_NEGATIVE_ONE
											&& row == 0 && rOff == -1))) {
								// Union the boundary here.
								// Top of border determined
								// Top of border: for rOff 0 or 1, is top_y.
								// by whether rOff < 1; bottom determined by
								// whether rOff > -1.
								// Similarly, left and right determined by cOff.
								int border_top = rOff > -1 ? top_y : bottom_y
										- ds.size_borderHeight;
								int border_bottom = rOff < 1 ? bottom_y
										: border_top + ds.size_borderHeight;
								int border_left = cOff < 1 ? left_x : right_x
										- ds.size_borderWidth;
								int border_right = cOff > -1 ? right_x
										: border_left + ds.size_borderWidth;

								// if ( row == 0 && col == 5 && rOff == 0 &&
								// cOff == -1 )
								// log( 
								// "border portion - q pane outer.  [" +
								// border_left + ", " + border_top + ", " +
								// border_right + ", " + border_bottom + "]") ;
								region.op(border_left, border_top,
										border_right, border_bottom,
										Region.Op.UNION);
							}
						}
					}
				}
			}
		}

		// Return the provided region object
		return region;
	}

	private Region setRegionFillLayer(DrawSettings ds, Region region,
			byte[][][] blockField, int qPane, Offset drawOffset) {

		// Step through the blockField, drawing the color
		// for each thing in the right place.

		// The "fill layer" is simple enough; for now,
		// it either fills the square, or is not drawn
		// at all.

		// corner_x_offset, corner_y_offset give the distance
		// between the top-left of the view and the top-left of
		// block blockField[qPane][0][0].

		region.setEmpty();

		for (int row = 0; row < ds.displayedRows; row++) {
			// y bounds for this block?
			int top_y = ds.getBlockYPosition(qPane, row) + drawOffset.y;
			int bottom_y = top_y + ds.size_blockHeight;
			for (int col = 0; col < ds.COLS; col++) {

				// Draw
				int qo = blockField[qPane][row + ds.blockFieldOuterBuffer][col
						+ ds.blockFieldOuterBuffer];
				int behavior = ds.behavior_qo_fill[qo];

				// if ( qo != QOrientations.NO )
				// log("drawFillLayeToCanvas: qo is " + qo +
				// ", behavior is " + behavior ) ;
				if (behavior == DrawSettings.BEHAVIOR_QO_FILL_PAINT_NONE)
					continue;

				// x bounds?
				int left_x = ds.getBlockXPosition(qPane, col) + drawOffset.x;
				int right_x = left_x + ds.size_blockWidth;

				switch (behavior) {
				// Is it a generic fill?
				case DrawSettings.BEHAVIOR_QO_FILL_PAINT_Q_ORIENTATION:
					region.op(left_x, top_y, right_x, bottom_y, Region.Op.UNION);
					// canvas.drawRect(left_x-3, top_y-3, right_x+3, bottom_y+3,
					// p) ;
					// log("drawFillLayerToCanvas: draw with [" + left_x
					// + ", " + top_y + ", " + right_x + ", " + bottom_y +
					// ", with paint " + p) ;
					break;

				case DrawSettings.BEHAVIOR_QO_FILL_PAINT_Q_ORIENTATION_INSET:
					region.op(left_x + ds.size_innerBorderXInset
							+ ds.size_innerBorderWidth, top_y
							+ ds.size_innerBorderYInset
							+ ds.size_innerBorderHeight, right_x
							- ds.size_innerBorderXInset
							- ds.size_innerBorderWidth, bottom_y
							- ds.size_innerBorderYInset
							- ds.size_innerBorderHeight, Region.Op.UNION);
					// canvas.drawRect(left_x, top_y, right_x, bottom_y, p) ;
					break;

				case DrawSettings.BEHAVIOR_QO_FILL_PAINT_Q_PANE:
					region.op(left_x, top_y, right_x, bottom_y, Region.Op.UNION);
					// canvas.drawRect(left_x-3, top_y-3, right_x+3, bottom_y+3,
					// p) ;
					break;
				}
			}
		}

		return region;
	}

	private static final int MIN_FLOOD_NEIGHBORHOOD = 0; // 0
	private static final int FLOOD_NEIGHBORHOOD_NONE = 0; // 0
	private static final int FLOOD_NEIGHBORHOOD_FOUR = 1; // 1
	private static final int MAX_FLOOD_NEIGHBORHOOD = 2; // 2

	private static final int[] NEIGHBORHOOD_4_ROW_OFFSET = new int[] { -1, 1,
			0, 0 };
	private static final int[] NEIGHBORHOOD_4_COL_OFFSET = new int[] { 0, 0,
			-1, 1 };

	private static final int MIN_FLOOD_STARTING = 2;
	private static final int FLOOD_STARTING_EXACT_BLOCKS = 2;
	private static final int FLOOD_STARTING_EXACT_BLOCKS_AND_NEIGHBORHOOD_FOUR = 3;
	private static final int FLOOD_STARTING_EXACT_BLOCKS_AND_NEIGHBORHOOD_EIGHT = 4;
	private static final int MAX_FLOOD_STARTING = 5;

	private static final int MIN_FLOOD_TO = 5;
	private static final int FLOOD_TO_SAME = 5;
	private static final int FLOOD_TO_NO_BORDER = 6;
	private static final int FLOOD_TO_NO_BORDER_OR_NO_STARTING_OR_NO_CHANGE = 7;
	private static final int MAX_FLOOD_TO = 8;

	private static final int MIN_FLOOD_COMPARE_WITHIN = 8;
	private static final int FLOOD_COMPARE_WITHIN_FIELD = 8;
	private static final int FLOOD_COMPARE_WITHIN_FIELD_AND_STARTING = 9;
	private static final int MAX_FLOOD_COMPARE_WITHIN = 10;

	private static final int MIN_FLOOD_LIMIT = 10;
	private static final int FLOOD_LIMIT_NONE = 10;
	private static final int FLOOD_LIMIT_STARTING_BLOCKS_AND_NEIGHBORHOOD_FOUR = 11;
	private static final int MAX_FLOOD_LIMIT = 12;

	private static final int MIN_FLOOD_INCLUDE_REGION = 12;
	private static final int FLOOD_INCLUDE_REGION_ALL = 12;
	private static final int FLOOD_INCLUDE_REGION_GROWN = 13;
	private static final int FLOOD_INCLUDE_REGION_ALL_MERGE_NOT_NEIGHBORS = 14;
	private static final int FLOOD_INCLUDE_REGION_ALL_STARTING_AND_OTHER = 15; // Include
																				// all
																				// regions
																				// within
																				// "starting"
																				// as
																				// their
																				// own
																				// unique
																				// region,
																				// but
																				// label
																				// all
																				// non-starting
																				// using
																				// the
																				// same
																				// region
																				// number.
	private static final int MAX_FLOOD_INCLUDE_REGION = 16;

	/**
	 * Performs regions floods within floodWithin, starting in startingBlocks.
	 * Regions are numbered started with firstRegionNum, and marked within
	 * 'markWithin.'
	 * 
	 * As of 1/17/12, the initial implementation, Regions are flooded very
	 * simply; basically, we directly examine QOrientions for equality.
	 * 
	 * Starting 1/18/12, we are starting fancy glow effects for Quantro mode,
	 * which need a slightly more complicated flood behavior. It works as
	 * follows:
	 * 
	 * - we allow flood according to the FLOOD_NEIGHBORHOOD_* setting given: no
	 * flood, flood in 4 directions, flood in 8 directions.
	 * 
	 * - we start floods in locations determined by FLOOD_STARTING_*: exactly
	 * those blocks present in startingBlocks, those extended into a
	 * neighborhood of 4 or 8, etc.
	 * 
	 * - we flood from A-to-B according to FLOOD_TO_*: an exact match of the
	 * same QOrientation, or any blocks which do not have a border between them
	 * (e.g. drawn with 'friendly' borders). NO_BORDER_OR_NO_STARTING allows a
	 * flood between blocks with a border, if neither block occurs in
	 * 'starting.'
	 * 
	 * - we flood starting based on our criteria to all blocks to all blocks in
	 * its neighborhood which match FLOOD_TO_, a condition we check according to
	 * FLOOD_COMPARE. For *_WITHIN_FIELD, we flood from A-to-B if it matches the
	 * FLOOD_TO_ considering those blocks shown in floodWithin. For
	 * *_WITHIN_FIELD_AND_STARTING, we flood from A-to-B if it matches in
	 * floodWithin, *and* either matches in startingBlocks or both are NO in
	 * startingBlocks.
	 * 
	 * - we flood away from starting blocks only up to the specified LIMIT.
	 * LIMIT_NONE does not limit by distance. LIMIT_STARTING_AND_NEIGHBORHOOD_
	 * will only allow floods into starting blocks or those within the
	 * neighborhood of them.
	 * 
	 * - we include flooded regions according to INCLUDE_REGION. ALL will
	 * include every region flooded according to the above. GROWN will include
	 * only those regions which have grown beyond the size present in
	 * startingBlocks. ALL_MERGE_NON_NEIGHBORS will include all regions, but
	 * will greedily merge together regions which are NOT neighbors according to
	 * our flood neighborhood: if set, the regions returned may not necessarily
	 * be contiguous, but any contiguous portion will obey all flood settings (a
	 * flood within them is always possible).
	 * 
	 * Given the settings specified above, the original flood behavior can be
	 * replicated using:
	 * 
	 * FLOOD_NEIGHBORHOOD_FOUR FLOOD_STARTING_EXACT_BLOCKS FLOOD_TO_SAME
	 * FLOOD_COMPARE_WITHIN_FIELD FLOOD_LIMIT_NONE includeNoGrow ?
	 * FLOOD_INCLUDE_REGION_ALL : FLOOD_INCLUDE_REGION_GROWN
	 * 
	 * 'includeNoGrow' indicates whether a region should be included if it does
	 * not grow beyond the blocks included in 'startingBlocks.'
	 * 
	 * Returns the number of regions added, which is >= 0.
	 */
	private int floodRegions(DrawSettings ds, byte[][][] startingBlocks,
			Offset startingBlocksLL, Offset startingBlocksUR,
			Offset startOffset, byte[][][] floodWithin, Offset floodWithinLL,
			Offset floodWithinUR, int qPane, int[][] markWithin,
			int firstRegionNum, int floodNeighborhood, int floodStarting,
			int floodTo, int floodCompareWithin, int floodLimit,
			int floodIncludeRegion) {

		return floodRegions(ds, startingBlocks, startingBlocksLL,
				startingBlocksUR, startOffset, floodWithin, floodWithinLL,
				floodWithinUR, qPane, markWithin, firstRegionNum, 0,
				floodNeighborhood, floodStarting, floodTo, floodCompareWithin,
				floodLimit, floodIncludeRegion);
	}

	/**
	 * Performs regions floods within floodWithin, starting in startingBlocks.
	 * Regions are numbered started with firstRegionNum, and marked within
	 * 'markWithin.'
	 * 
	 * As of 1/17/12, the initial implementation, Regions are flooded very
	 * simply; basically, we directly examine QOrientions for equality.
	 * 
	 * Starting 1/18/12, we are starting fancy glow effects for Quantro mode,
	 * which need a slightly more complicated flood behavior. It works as
	 * follows:
	 * 
	 * - we allow flood according to the FLOOD_NEIGHBORHOOD_* setting given: no
	 * flood, flood in 4 directions, flood in 8 directions.
	 * 
	 * - we start floods in locations determined by FLOOD_STARTING_*: exactly
	 * those blocks present in startingBlocks, those extended into a
	 * neighborhood of 4 or 8, etc.
	 * 
	 * - we flood from A-to-B according to FLOOD_TO_*: an exact match of the
	 * same QOrientation, or any blocks which do not have a border between them
	 * (e.g. drawn with 'friendly' borders). NO_BORDER_OR_NO_STARTING allows a
	 * flood between blocks with a border, if neither block occurs in
	 * 'starting.'
	 * 
	 * - we flood starting based on our criteria to all blocks to all blocks in
	 * its neighborhood which match FLOOD_TO_, a condition we check according to
	 * FLOOD_COMPARE. For *_WITHIN_FIELD, we flood from A-to-B if it matches the
	 * FLOOD_TO_ considering those blocks shown in floodWithin. For
	 * *_WITHIN_FIELD_AND_STARTING, we flood from A-to-B if it matches in
	 * floodWithin, *and* either matches in startingBlocks or both are NO in
	 * startingBlocks.
	 * 
	 * - we flood away from starting blocks only up to the specified LIMIT.
	 * LIMIT_NONE does not limit by distance. LIMIT_STARTING_AND_NEIGHBORHOOD_
	 * will only allow floods into starting blocks or those within the
	 * neighborhood of them.
	 * 
	 * - we include flooded regions according to INCLUDE_REGION. ALL will
	 * include every region flooded according to the above. GROWN will include
	 * only those regions which have grown beyond the size present in
	 * startingBlocks. ALL_MERGE_NON_NEIGHBORS will include all regions, but
	 * will greedily merge together regions which are NOT neighbors according to
	 * our flood neighborhood: if set, the regions returned may not necessarily
	 * be contiguous, but any contiguous portion will obey all flood settings (a
	 * flood within them is always possible).
	 * 
	 * Given the settings specified above, the original flood behavior can be
	 * replicated using:
	 * 
	 * FLOOD_NEIGHBORHOOD_FOUR FLOOD_STARTING_EXACT_BLOCKS FLOOD_TO_SAME
	 * FLOOD_COMPARE_WITHIN_FIELD FLOOD_LIMIT_NONE includeNoGrow ?
	 * FLOOD_INCLUDE_REGION_ALL : FLOOD_INCLUDE_REGION_GROWN
	 * 
	 * 'includeNoGrow' indicates whether a region should be included if it does
	 * not grow beyond the blocks included in 'startingBlocks.'
	 * 
	 * Returns the number of regions added, which is >= 0.
	 * 
	 * 
	 * 6/15: this method is a very hungry one in our stress tests. First step to
	 * optimization is to break it up into component methods so they can be
	 * individually profiled.
	 * 
	 * @param startingBlocks
	 * @param startRowOffset
	 *            : when indexing into startingBlocks, we should add this value
	 *            to get the corresponding index into floodWithin and
	 *            markWithin.
	 * @param startColOffset
	 *            : when indexing into startingBlocks, we should add this value
	 *            to get the corresponding index into floodWithin and
	 *            markWithin.
	 * @param floodWithin
	 * @param qPane
	 * @param markWithin
	 * @param firstRegionNum
	 * @param includeNoGrow
	 * @return
	 */

	private byte[][][][] floodRegions_shrinkMarginsFields = new byte[2][][][];

	private int floodRegions(DrawSettings ds, byte[][][] startingBlocks,
			Offset startingBlocksLL, Offset startingBlocksUR,
			Offset startOffset, byte[][][] floodWithin, Offset floodWithinLL,
			Offset floodWithinUR, int qPane, int[][] markWithin,
			int firstRegionNum, int extraRows, int floodNeighborhood,
			int floodStarting, int floodTo, int floodCompareWithin,
			int floodLimit, int floodIncludeRegion) {

		// check settings!
		if (floodNeighborhood < MIN_FLOOD_NEIGHBORHOOD
				|| floodNeighborhood > MAX_FLOOD_NEIGHBORHOOD)
			throw new IllegalArgumentException("Invalid flood neighborhood: "
					+ floodNeighborhood);
		if (floodStarting < MIN_FLOOD_STARTING
				|| floodStarting > MAX_FLOOD_STARTING)
			throw new IllegalArgumentException("Invalid flood starting: "
					+ floodStarting);
		if (floodTo < MIN_FLOOD_TO || floodTo > MAX_FLOOD_TO)
			throw new IllegalArgumentException("Invalid flood to: " + floodTo);
		if (floodCompareWithin < MIN_FLOOD_COMPARE_WITHIN
				|| floodCompareWithin > MAX_FLOOD_COMPARE_WITHIN)
			throw new IllegalArgumentException("Invalid flood compare within: "
					+ floodCompareWithin);
		if (floodLimit < MIN_FLOOD_LIMIT || floodLimit > MAX_FLOOD_LIMIT)
			throw new IllegalArgumentException("Invalid flood limit: "
					+ floodLimit);
		if (floodIncludeRegion < MIN_FLOOD_INCLUDE_REGION
				|| floodIncludeRegion > MAX_FLOOD_INCLUDE_REGION)
			throw new IllegalArgumentException("Invalid flood include region: "
					+ floodIncludeRegion);

		// We use tempFlood2 to indicate that a piece has been flooded already.
		// This is necessary because not every flood is added to markWithin,
		// only
		// those that meet our glow settings.
		ArrayOps.setEmpty(tempFlood2);
		ArrayOps.setEmpty(tempFlood);
		tempFloodLBA.boundNone();
		// We use an LBA to avoid constantly reseting false values to false.

		// 6/15/12: After a few optimizations, accounts for 10.9% of Quantro
		// CPU. Can we improve this any more?
		// 1st: use tempFloodLBA to avoid clearing the array every time. Reduced
		// to 7.5%.
		// 2nd: the option FLOOD_INCLUDE_REGION_ALL_MERGE_NOT_NEIGHBORS causes a
		// merge of
		// non-adjacent regions to minimize the number of regions found.
		// However,
		// a quick examination revealed that this option serves no real purpose
		// (it is used in Quantro only, and the regions returned are then
		// compared
		// using != -> there is no iteration through region numbers, which would
		// have
		// benefitted from the change). We are keeping this method the same and
		// calling it with a different option (FLOOD_INCLUDE_REGION_ALL).
		// Before: this 8.7%, greedilyMerge 3.7%, setLockGlows 12.3%,
		// drawGlowSetArray 9.3%.
		// After: this 6.6%, greedilyMerge 0%, setLockGlows 9.6%,
		// drawGlowSetArray 9.7%.
		// 3rd: short-circuit through an immediate tempFlood2 check. If true,
		// skip EVERYTHING for that row/col combo.
		// Before: 6.6%, of which 55.7% is self
		// After: 8.1!!!! what? Redo-ing... 8.1% again. wtf?
		// 4th: restrict the iteration bounds to avoid the
		// "bounds check and continue" that occurred
		// every loop iteration.
		// Before: 8.1
		// After: 5.6%! Of this, 52.7% is still 'this' method.
		// 5th: further restrict iteration bounds to only the non-empty qo's in
		// floodWithin.
		// After: 6.8%. Hrmm. Of course, getting 8.0 after removing this, so...

		int regionNum = firstRegionNum;

		int rowMin, rowMax, colMin, colMax;
		if (floodWithinLL == null)
			rowMin = colMin = 0;
		else {
			rowMin = floodWithinLL.y;
			colMin = floodWithinLL.x;
		}
		if (floodWithinUR == null) {
			rowMax = ds.displayedRows + extraRows;
			colMax = ds.COLS;
		} else {
			rowMax = floodWithinUR.y;
			colMax = floodWithinUR.x;
		}

		int startOffsetX, startOffsetY;
		if (startOffset == null)
			startOffsetX = startOffsetY = 0;
		else {
			startOffsetX = startOffset.x;
			startOffsetY = startOffset.y;
		}

		int rowMinIter = rowMin, rowMaxIter = rowMax, colMinIter = colMin, colMaxIter = colMax;
		// there are also starting bounds to consider. We use the max/min
		// of current settings and bounding area.
		// If any of the following are true, we do NOT want to consider the
		// row/col (copied from
		// a loop-internal check). Convert these to row/col min/maxes.
		// startingBlocksLL != null && ( startRow < startingBlocksLL.y - margin
		// || startCol < startingBlocksLL.x - margin )
		// startingBlocksUR != null && ( startRow >= startingBlocksUR.y + margin
		// || startCol >= startingBlocksUR.x + margin )
		// startRow < 0 || startRow >= startingBlocks[qPane].length
		// startCol < 0 || startCol >= startingBlocks[qPane][0].length
		// first: make sure row/col stay within startingBounds.

		rowMinIter = Math.max(rowMinIter, startOffsetY); // we subtract this to
															// get row in
															// startingBlocks
		colMinIter = Math.max(colMinIter, startOffsetX); // we subtract this to
															// get col in
															// startingBlocks
		rowMaxIter = Math.min(rowMaxIter, startOffsetY
				+ startingBlocks[qPane].length);
		colMaxIter = Math.min(colMaxIter, startOffsetX
				+ startingBlocks[qPane][0].length);
		// that covers the hard-boundaries. What about the provided ones? Some
		// have
		// an additional margin...
		int margin = floodStarting == FLOOD_STARTING_EXACT_BLOCKS ? 0 : 1;
		if (startingBlocksLL != null) {
			rowMinIter = Math.max(rowMinIter, startOffsetY + startingBlocksLL.y
					- margin);
			colMinIter = Math.max(colMinIter, startOffsetX + startingBlocksLL.x
					- margin);
		}
		if (startingBlocksUR != null) {
			rowMaxIter = Math.min(rowMaxIter, startOffsetY + startingBlocksUR.y
					- margin);
			colMaxIter = Math.min(colMaxIter, startOffsetX + startingBlocksUR.x
					- margin);
		}

		tempOffset.setRowCol(rowMinIter + ds.blockFieldOuterBuffer, colMinIter
				+ ds.blockFieldOuterBuffer);
		tempOffset2.setRowCol(rowMaxIter + ds.blockFieldOuterBuffer, colMaxIter
				+ ds.blockFieldOuterBuffer);

		floodRegions_shrinkMarginsFields[0] = startingBlocks;
		floodRegions_shrinkMarginsFields[1] = floodWithin;
		if (!shrinkMargins(tempOffset, tempOffset2,
				floodRegions_shrinkMarginsFields))
			return 0; // no new regions added

		rowMinIter = tempOffset.getRow() - ds.blockFieldOuterBuffer;
		rowMaxIter = tempOffset2.getRow() - ds.blockFieldOuterBuffer;
		colMinIter = tempOffset.getCol() - ds.blockFieldOuterBuffer;
		colMaxIter = tempOffset2.getCol() - ds.blockFieldOuterBuffer;

		// we use these for "ONLY_TWO_REGIONS" include settings.
		boolean hasWithinStarting = false;
		boolean hasWithoutStarting = false;

		for (int row = rowMinIter; row < rowMaxIter; row++) {
			int r = row + ds.blockFieldOuterBuffer;
			int startR = r - startOffsetY;
			// int startRow = startR - ds.blockFieldOuterBuffer ;

			for (int col = colMinIter; col < colMaxIter; col++) {

				// SHORT CIRCUIT!
				if (tempFlood2[row][col])
					continue;

				int c = col + ds.blockFieldOuterBuffer;
				int startC = c - startOffsetX;
				// int startCol = startC - ds.blockFieldOuterBuffer ;

				/*
				 * // check that this block is within our limits. int margin =
				 * floodStarting == FLOOD_STARTING_EXACT_BLOCKS ? 0 : 1 ;
				 * 
				 * if ( startingBlocksLL != null && ( startRow <
				 * startingBlocksLL.y - margin || startCol < startingBlocksLL.x
				 * - margin ) ) continue ; else if ( startingBlocksUR != null &&
				 * ( startRow >= startingBlocksUR.y + margin || startCol >=
				 * startingBlocksUR.x + margin ) ) continue ; else if ( startRow
				 * < 0 || startRow >= startingBlocks[qPane].length ) continue ;
				 * else if ( startCol < 0 || startCol >=
				 * startingBlocks[qPane][0].length ) continue ;
				 */

				boolean startOK = flood_shouldStartHere(floodStarting,
						startingBlocks, qPane, startR, startC);

				if (startOK && markWithin[row][col] < firstRegionNum
						&& !tempFlood2[row][col]) {
					// clear our loosely bounded tempFlood
					tempFloodLBA.clear().boundNone();
					// start marking here.
					tempStackR.empty();
					tempStackC.empty();

					tempStackR.push(row); // changed from r->row for
											// optimization
					tempStackC.push(col); // changed from c->col for
											// optimization.

					boolean startedWithinStartingBlocks = startingBlocks[qPane][startR][startC] != QOrientations.NO;

					while (tempStackR.count() > 0) {
						int rowHere = tempStackR.pop();
						int colHere = tempStackC.pop();

						int qHere = floodWithin[qPane][rowHere
								+ ds.blockFieldOuterBuffer][colHere
								+ ds.blockFieldOuterBuffer];

						if (qHere == 0
								|| ds.behavior_qo_lock_glow[qHere] == DrawSettings.BEHAVIOR_QO_LOCK_GLOW_NONE)
							continue;

						tempFlood2[rowHere][colHere] = tempFlood[rowHere][colHere] = true;
						// extend tempFlood's bounds...
						tempFloodLBA.bound(0, rowHere).bound(1, colHere);

						// 6/15/2012: moved to a method for profiling
						flood_floodToNeighbors(ds, floodNeighborhood, floodTo,
								floodCompareWithin, floodLimit, startingBlocks,
								startOffsetX, startOffsetY, floodWithin, qPane,
								rowHere, colHere, rowMin, rowMax, colMin,
								colMax, tempStackR, tempStackC, tempFlood2);

					}

					// fill with regionNum, but ONLY if we extended beyond the
					// boundaries of startingBlocks or includeNoGrow is true.
					// TODO: This results in a lot of wasted effort for falling
					// chunks.
					boolean include = flood_shouldIncludeRegion(ds,
							floodIncludeRegion, startingBlocks, startOffsetX,
							startOffsetY, floodWithin, qPane, rowMin, rowMax,
							colMin, colMax);

					if (include) {
						if (floodIncludeRegion == FLOOD_INCLUDE_REGION_ALL_STARTING_AND_OTHER) {
							// we need a number for this region. If not
							// startedWithinStarting,
							// use firstRegionNum. Otherwise, take if
							// !hasWithinStarting,
							// set regionNum += 1 and take regionNum. Otherwise,
							// take regionNum.
							int num;
							if (startedWithinStartingBlocks) {
								num = hasWithinStarting ? regionNum
										: regionNum + 1;
								hasWithinStarting = true;
							} else {
								num = firstRegionNum;
								hasWithoutStarting = true;
							}

							for (int i = rowMin; i < rowMax; i++) {
								for (int j = colMin; j < colMax; j++) {
									if (tempFlood[i][j])
										markWithin[i][j] = num;
								}
							}
							if (startedWithinStartingBlocks)
								regionNum = num + 1;

						} else if (floodIncludeRegion == FLOOD_INCLUDE_REGION_ALL_MERGE_NOT_NEIGHBORS) {
							// 6/15: encapsulated in a method for profiling +
							// optimization.
							if (!floodRegions_greedilyMergeIntoDisjointRegion(
									tempFlood, markWithin, firstRegionNum,
									regionNum, rowMin, rowMax, colMin, colMax))
								regionNum++;
						} else {
							for (int i = rowMin; i < rowMax; i++) {
								for (int j = colMin; j < colMax; j++) {
									if (tempFlood[i][j])
										markWithin[i][j] = regionNum;
								}
							}
							regionNum++;

						}

					}
				}

			}
		}

		if (floodIncludeRegion == FLOOD_INCLUDE_REGION_ALL_STARTING_AND_OTHER
				&& regionNum > firstRegionNum) {
			if (!hasWithinStarting)
				return 0; // if nothing to start, include nothing at all.
		}

		return regionNum - firstRegionNum;

	}

	/**
	 * Investigates the local region around qPane,r,c; returns whether we should
	 * start a flood from that location according to our floodStarting behavior.
	 * 
	 * @param floodStarting
	 * @param startingBlocks
	 * @param qPane
	 * @param r
	 * @param c
	 * @return
	 */
	private boolean flood_shouldStartHere(int floodStarting,
			byte[][][] startingBlocks, int qPane, int r, int c) {
		boolean startOK = false;
		switch (floodStarting) {
		case FLOOD_STARTING_EXACT_BLOCKS_AND_NEIGHBORHOOD_EIGHT:
			// check diagonal 4
			startOK = startOK
					|| (r + 1 < startingBlocks[qPane].length
							&& c + 1 < startingBlocks[qPane][r].length && startingBlocks[qPane][r + 1][c + 1] != 0);
			startOK = startOK
					|| (r - 1 >= 0 && c + 1 < startingBlocks[qPane][r].length && startingBlocks[qPane][r - 1][c + 1] != 0);
			startOK = startOK
					|| (r + 1 < startingBlocks[qPane].length && c - 1 >= 0 && startingBlocks[qPane][r + 1][c - 1] != 0);
			startOK = startOK
					|| (r - 1 >= 0 && c - 1 >= 0 && startingBlocks[qPane][r - 1][c - 1] != 0);
		case FLOOD_STARTING_EXACT_BLOCKS_AND_NEIGHBORHOOD_FOUR:
			// check neighborhood 4. neighborhood-8 falls through to here;
			// it also needs to check its neighborhood.
			startOK = startOK
					|| (r + 1 < startingBlocks[qPane].length && startingBlocks[qPane][r + 1][c] != 0);
			startOK = startOK
					|| (r - 1 >= 0 && startingBlocks[qPane][r - 1][c] != 0);
			startOK = startOK
					|| (c + 1 < startingBlocks[qPane][r].length && startingBlocks[qPane][r][c + 1] != 0);
			startOK = startOK
					|| (c - 1 >= 0 && startingBlocks[qPane][r][c - 1] != 0);
		case FLOOD_STARTING_EXACT_BLOCKS:
			startOK = startOK || startingBlocks[qPane][r][c] != 0;
		}

		return startOK;
	}

	private boolean flood_shouldIncludeRegion(DrawSettings ds,
			int floodIncludeRegion, byte[][][] startingBlocks,
			int startOffsetX, int startOffsetY, byte[][][] floodWithin,
			int qPane, int rowMin, int rowMax, int colMin, int colMax) {
		boolean include = floodIncludeRegion == FLOOD_INCLUDE_REGION_ALL
				|| floodIncludeRegion == FLOOD_INCLUDE_REGION_ALL_MERGE_NOT_NEIGHBORS
				|| floodIncludeRegion == FLOOD_INCLUDE_REGION_ALL_STARTING_AND_OTHER;
		for (int i = rowMin; i < rowMax && !include; i++) {
			int rHere = i + ds.blockFieldOuterBuffer;
			for (int j = colMin; j < colMax && !include; j++) {
				int cHere = j + ds.blockFieldOuterBuffer;
				include = include
						|| (tempFlood[i][j] && startingBlocks[qPane][rHere
								- startOffsetY][cHere - startOffsetX] != floodWithin[qPane][rHere][cHere]);
			}
		}

		return include;
	}

	// we use 'row' to refer to the actual row/column number (and index into
	// tempFlood2, e.g.).
	// 'rowPos' is the blockFieldOuterBuffer-adjusted position within the
	// fields.
	private void flood_floodToNeighbors(DrawSettings ds, int floodNeighborhood,
			int floodTo, int floodCompareWithin, int floodLimit,
			byte[][][] startingBlocks, int startOffsetX, int startOffsetY,
			byte[][][] floodWithin, int qPane, int row, int col, int rowMin,
			int rowMax, int colMin, int colMax, IntStack rStack,
			IntStack cStack, boolean[][] rowColMarkedAlready) {

		// get some important values...
		int rowPos = row + ds.blockFieldOuterBuffer;
		int colPos = col + ds.blockFieldOuterBuffer;

		int qo = floodWithin[qPane][rowPos][colPos];

		int rowPos_start = rowPos - startOffsetY;
		int colPos_start = colPos - startOffsetX;

		int qo_start = startingBlocks[qPane][rowPos_start][colPos_start];

		if (floodNeighborhood >= FLOOD_NEIGHBORHOOD_FOUR) {
			// if 4 or 8...
			for (int i = 0; i < NEIGHBORHOOD_4_ROW_OFFSET.length; i++) {
				int rOff = NEIGHBORHOOD_4_ROW_OFFSET[i];
				int cOff = NEIGHBORHOOD_4_COL_OFFSET[i];

				// Check min/max before any other access attempts...
				if (row + rOff < rowMin || row + rOff >= rowMax)
					continue;
				if (col + cOff < colMin || col + cOff >= colMax)
					continue;

				// Attempt expansion in this direction.
				int rowPosThere = rowPos + rOff;
				int colPosThere = colPos + cOff;
				int qoThere = floodWithin[qPane][rowPosThere][colPosThere];
				int rowThere = row + rOff;
				int colThere = col + cOff;

				int rowPosThere_start = rowPosThere - startOffsetY;
				int colPosThere_start = colPosThere - startOffsetY;

				int qoThere_start = (rowPosThere_start >= 0
						&& rowPosThere_start < startingBlocks[qPane].length
						&& colPosThere_start >= 0 && colPosThere_start < startingBlocks[qPane][rowPosThere_start].length) ? startingBlocks[qPane][rowPosThere_start][colPosThere_start]
						: 0;

				// Already marked?
				if (rowColMarkedAlready[rowThere][colThere])
					continue;
				// a NO?
				if (qoThere == QOrientations.NO)
					continue;
				// Check flood limit.
				if (floodLimit == FLOOD_LIMIT_STARTING_BLOCKS_AND_NEIGHBORHOOD_FOUR
						&& !(qoThere_start != QOrientations.NO
								|| startingBlocks[qPane][rowPosThere_start - 1][colPosThere_start] != QOrientations.NO
								|| startingBlocks[qPane][rowPosThere_start + 1][colPosThere_start] != QOrientations.NO
								|| startingBlocks[qPane][rowPosThere_start][colPosThere_start - 1] != QOrientations.NO || startingBlocks[qPane][rowPosThere_start][colPosThere_start + 1] != QOrientations.NO))
					continue;
				// Check FLOOD_TO behavior.
				if (!floodsTo(ds, qo, qoThere, floodTo, qo_start,
						qoThere_start, qPane))
					continue;
				// Check FLOOD_TO within other fields
				if (floodCompareWithin == FLOOD_COMPARE_WITHIN_FIELD_AND_STARTING) {
					if (!(qo_start == 0 && qoThere_start == 0)
							&& !floodsTo(ds, qo_start, qoThere_start, floodTo,
									qo_start, qoThere_start, qPane))
						continue;
				}

				// If we get here, these conditions have been checked:
				// FLOOD_TO,
				// FLOOD_COMPARE_WITHIN,
				// FLOOD_LIMIT
				tempStackR.push(rowThere);
				tempStackC.push(colThere);
			}
		}
	}

	boolean[] floodRegions_greedilyMergeIntoDisjointRegion_regionOK = new boolean[16];

	/**
	 * Attempts to merge the provided region (newRegion) into a disjoint region
	 * within 'regions', indicated by its number.
	 * 
	 * If a disjoint region is found, every 'true' in newRegion has its
	 * corresponding location set to that region number within 'regions', and
	 * 'true' is returned.
	 * 
	 * If there is no disjoint region available, we instead add a new region to
	 * 'regions' using 'regionNum' as its number, and return false.
	 * 
	 * @param newRegion
	 * @param regions
	 * @param firstRegionNum
	 * @param regionNum
	 * @param rowMin
	 * @param rowMax
	 * @param colMin
	 * @param colMax
	 * @return
	 */
	private boolean floodRegions_greedilyMergeIntoDisjointRegion(
			boolean[][] newRegion, int[][] regions, int firstRegionNum,
			int regionNum, int rowMin, int rowMax, int colMin, int colMax) {

		// is our array long enough?
		while (floodRegions_greedilyMergeIntoDisjointRegion_regionOK.length < regionNum
				- firstRegionNum)
			floodRegions_greedilyMergeIntoDisjointRegion_regionOK = new boolean[floodRegions_greedilyMergeIntoDisjointRegion_regionOK.length * 2];
		for (int i = 0; i < floodRegions_greedilyMergeIntoDisjointRegion_regionOK.length; i++)
			floodRegions_greedilyMergeIntoDisjointRegion_regionOK[i] = true;

		// we index into this such that floodRegions_gre..._regionOK[0]
		// indicates firstRegionNum is OK.

		// now eliminate those regions which neighbor 'newRegion.' To avoid
		// a lot of redundant checks, we:
		// 1. Iterate through newRegion ONCE. For each 'true,' check all four
		// directions (this could possible by optimized further, but it's
		// a big enough improvement for now) and mark all those regions found
		// as ineligible.

		// ASSUMPTIONS: Regions don't actually overlap.
		// A value in regions[][] >= firstRegionNum is EQUIVALENT to a region
		// (i.e., the "no region" number is < firstRegionNum, and no values
		// >= regionNum exist).

		for (int i = rowMin; i < rowMax; i++) {
			for (int j = colMin; j < colMax; j++) {
				if (newRegion[i][j]) {
					// check here!
					if (i > rowMin && regions[i - 1][j] >= firstRegionNum)
						floodRegions_greedilyMergeIntoDisjointRegion_regionOK[regions[i - 1][j]
								- firstRegionNum] = false;
					if (i < rowMax - 1 && regions[i + 1][j] >= firstRegionNum)
						floodRegions_greedilyMergeIntoDisjointRegion_regionOK[regions[i + 1][j]
								- firstRegionNum] = false;
					if (j > colMin && regions[i][j - 1] >= firstRegionNum)
						floodRegions_greedilyMergeIntoDisjointRegion_regionOK[regions[i][j - 1]
								- firstRegionNum] = false;
					if (j < colMax - 1 && regions[i][j + 1] >= firstRegionNum)
						floodRegions_greedilyMergeIntoDisjointRegion_regionOK[regions[i][j + 1]
								- firstRegionNum] = false;
				}
			}
		}

		// is there an OK region left?
		int newRegionNum = regionNum;
		for (int i = 0; i < regionNum - firstRegionNum; i++) {
			if (floodRegions_greedilyMergeIntoDisjointRegion_regionOK[i]) {
				newRegionNum = i + firstRegionNum;
				break;
			}
		}

		// place!
		for (int i = rowMin; i < rowMax; i++)
			for (int j = colMin; j < colMax; j++)
				if (newRegion[i][j])
					regions[i][j] = newRegionNum;

		// Was this a merged region?
		return newRegionNum < regionNum;

		// THE BELOW IS UNOPTIMIZED CODE.
	}

	private boolean floodsTo(DrawSettings ds, int qo1, int qo2, int floodTo,
			int startingQ1, int startingQ2, int qPane) {
		if (qo2 == 0)
			return false;
		if (floodTo == FLOOD_TO_SAME && qo1 != qo2)
			return false;
		if (floodTo == FLOOD_TO_NO_BORDER
				|| (floodTo == FLOOD_TO_NO_BORDER_OR_NO_STARTING_OR_NO_CHANGE && (startingQ1 != 0 || startingQ2 != 0))) {
			int bb1 = ds.behavior_qo_border[qo1];
			int bb2 = ds.behavior_qo_border[qo2];
			if (bb1 != DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER
					&& bb1 != DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE
					&& bb1 != DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY
					&& bb1 != DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY_BLEND
					&& bb1 != DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE
					&& bb1 != DrawSettings.BEHAVIOR_QO_BORDER_Q_PANE_OUTER)
				return false; // ALWAYS has a full border.
			// No change?
			if (qo1 == startingQ1 && qo2 == startingQ2)
				return true;
			if ((bb1 == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER || bb1 == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_VOLATILE)
					&& qo1 != qo2)
				return false; // Doesn't match QOrientation; has a border.
			if (((bb1 == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE
					&& (bb2 != DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_INNER_CLIQUE) || ds.color_qOrientationQPaneBorder[qo1][qPane] != ds.color_qOrientationQPaneBorder[qo2][qPane])))
				return false;
			if ((bb1 == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY || bb1 == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY_BLEND)
					&& !(bb2 == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY || bb2 == DrawSettings.BEHAVIOR_QO_BORDER_Q_ORIENTATION_FRIENDLY_BLEND))
				return false; // Friendly to something that is not friendly.
			if (bb1 == DrawSettings.BEHAVIOR_QO_BORDER_Q_PANE_OUTER
					&& bb2 != DrawSettings.BEHAVIOR_QO_BORDER_Q_PANE_OUTER)
				return false; // One QPane, one not.
		}

		return true;
	}

	private Object findFriendlyBlendObject(byte[][][] blockField,
			int qPane, int r, int c, Object[][][][] objects) {
		int qo = blockField[qPane][r][c];
		Object o = null;

		if (objects != null && objects[qPane][qo] != null) {
			int qo1 = blockField[qPane][r + 1][c];
			if (objects[qPane][qo][qo1][DIRECTION_UP] != null)
				o = objects[qPane][qo][qo1][DIRECTION_UP];
			qo1 = blockField[qPane][r - 1][c];
			if (objects[qPane][qo][qo1][DIRECTION_DOWN] != null)
				o = objects[qPane][qo][qo1][DIRECTION_DOWN];
			qo1 = blockField[qPane][r][c - 1];
			if (objects[qPane][qo][qo1][DIRECTION_LEFT] != null)
				o = objects[qPane][qo][qo1][DIRECTION_LEFT];
			qo1 = blockField[qPane][r][c + 1];
			if (objects[qPane][qo][qo1][DIRECTION_RIGHT] != null)
				o = objects[qPane][qo][qo1][DIRECTION_RIGHT];
			if (o != null)
				return o;

			// now try to "extend" a friendly blend from a neighbor square.
			// Our proceedure is: if a neighbor is the same QO, it has
			// a friendly neighbor, and the two neighbor relationships
			// are perpendicular (NOT linear), then take the blend that we would
			// use.
			for (int direction = 0; direction < NUM_CONNECTED_DIRECTIONS; direction++) {
				int qoNeighbor = 0;
				int rNeighbor = r, cNeighbor = c;
				switch (direction) {
				case DIRECTION_UP:
					rNeighbor--;
					break;
				case DIRECTION_DOWN:
					rNeighbor++;
					break;
				case DIRECTION_LEFT:
					cNeighbor--;
					break;
				case DIRECTION_RIGHT:
					cNeighbor++;
					break;
				}
				qoNeighbor = blockField[qPane][rNeighbor][cNeighbor];
				if (qoNeighbor == qo) {
					// whelp, try looking for the neighbor for this block.
					qo1 = blockField[qPane][rNeighbor + 1][cNeighbor];
					if ((direction == DIRECTION_LEFT || direction == DIRECTION_RIGHT)
							&& objects[qPane][qo][qo1][DIRECTION_UP] != null)
						o = objects[qPane][qo][qo1][DIRECTION_UP];
					qo1 = blockField[qPane][rNeighbor - 1][cNeighbor];
					if ((direction == DIRECTION_LEFT || direction == DIRECTION_RIGHT)
							&& objects[qPane][qo][qo1][DIRECTION_DOWN] != null)
						o = objects[qPane][qo][qo1][DIRECTION_DOWN];
					qo1 = blockField[qPane][rNeighbor][cNeighbor - 1];
					if ((direction == DIRECTION_UP || direction == DIRECTION_DOWN)
							&& objects[qPane][qo][qo1][DIRECTION_LEFT] != null)
						o = objects[qPane][qo][qo1][DIRECTION_LEFT];
					qo1 = blockField[qPane][rNeighbor][cNeighbor + 1];
					if ((direction == DIRECTION_UP || direction == DIRECTION_DOWN)
							&& objects[qPane][qo][qo1][DIRECTION_RIGHT] != null)
						o = objects[qPane][qo][qo1][DIRECTION_RIGHT];
				}
				if (o != null)
					return o;
			}
		}

		return o;
	}

	// //////////////////////////////////////////////////////////////////////////
	//
	// PRERENDERED ELEMENTS
	//
	// Complex draw styles will rely on prerendered bitmaps to display shadows
	// and other visual effects. Here are some helper methods.
	//
	// NOTE: Prerendered elements assume an origin in the top-left, in [x][y]
	// form.
	// Always convert data to this format before use.
	//
	// //////////////////////////////////////////////////////////////////////////

	// BY NEIGHBORS
	// Some elements are drawn w.r.t. a particular block, and are dependent on
	// its immediate 2d neighbors. These methods allow the use of arrays to
	// store these structures and a means to determine the appropriate index.

	/**
	 * These are the canonical representations for shadow shapes, by integers.
	 * This array enumerates the canonical ints, and provides a simple indexing
	 * system.
	 */
	private static final int[] INDEX_BY_NEIGHBORS_CANONICAL_REPRESENTATIONS = new int[] {
			0, 16, 17, 19, 48, 49, 50, 51, 53, 55, 80, 81, 83, 85, 86, 87, 95,
			112, 113, 114, 115, 117, 118, 119, 121, 123, 127, 240, 241, 243,
			245, 247, 255, };

	/**
	 * Returns the number of unique indexes which indexByNeighbors() returns,
	 * where 0 is the minimum of indexByNeighbors and the value returned here is
	 * the maximum plus 1.
	 */
	private static int indexByNeighbors_num() {
		// Naive implementation. Technically, if a block is not connected
		// up or left, then it is not connected up-left diagonal (regardless
		// of the content of the block there).
		return 256;
	}

	private static short[] indexByNeighbors_sanityFix_cache = new short[256];
	static {
		boolean[][] connected = new boolean[3][3];
		for (int index = 0; index < 256; index++) {
			neighborsByIndex(index, connected, 1, 1);
			indexByNeighbors_sanityFix(connected, 1, 1);
			indexByNeighbors_sanityFix_cache[index] = indexByNeighbors(
					connected, 1, 1);
		}
	}

	/**
	 * "Fixes" the connected array to remove "connected" neighbors that cannot
	 * be considered connected.
	 * 
	 * @param connected
	 * @param x
	 * @param y
	 * @return
	 */
	private static boolean indexByNeighbors_sanityFix(boolean[][] connected,
			int x, int y) {
		boolean changed = false;
		if (connected[x - 1][y + 1]
				&& !(connected[x][y + 1] || connected[x - 1][y])) {
			connected[x - 1][y + 1] = false;
			changed = true;
		}
		if (connected[x + 1][y + 1]
				&& !(connected[x][y + 1] || connected[x + 1][y])) {
			connected[x + 1][y + 1] = false;
			changed = true;
		}
		if (connected[x + 1][y - 1]
				&& !(connected[x][y - 1] || connected[x + 1][y])) {
			connected[x + 1][y - 1] = false;
			changed = true;
		}
		if (connected[x - 1][y - 1]
				&& !(connected[x][y - 1] || connected[x - 1][y])) {
			connected[x - 1][y - 1] = false;
			changed = true;
		}

		return changed;
	}

	/**
	 * Similar to the array-parameterized version, except corrects an index into
	 * its "sanity-fixed" equivalent.
	 * 
	 * PRECONDITION: 'index' is >= 0 and < indexByNeighbors_num().
	 * 
	 * @param index
	 * @return
	 */
	private static short indexByNeighbors_sanityFix(short index) {
		return indexByNeighbors_sanityFix_cache[index];
	}

	/**
	 * Uses the boolean array indicated "connectedness" to determine the
	 * neighbor index to use. connected[row][col] is the block in question. If
	 * 'false', we assume the block is disconnected from all others. If 'true',
	 * we check the immediate neighbors (row +/- 1, col +/- 1) for
	 * connectedness.
	 * 
	 * The value returned is guaranteed to be in [-1, indexByNeighbors_num()-1],
	 * and is deterministic based on the true/false values provided.
	 * 
	 * If the value returned is -1, then the specified array is completely
	 * invalid (for whatever reason) and we refuse to process it.
	 */
	private static short indexByNeighbors(boolean[][] connected, int x, int y) {
		if (!connected[x][y])
			return -1;

		int index = 0; // we add values to this index as we go.

		// left, down, right, up.
		if (connected[x - 1][y])
			index += IBN_BIT_1;
		if (connected[x][y + 1])
			index += IBN_BIT_2;
		if (connected[x + 1][y])
			index += IBN_BIT_3;
		if (connected[x][y - 1])
			index += IBN_BIT_4;

		// diagonal neighbors. Note that we can only connect to diagonal
		// neighbors
		// if there is a connection through adjacent neighbors!
		if (connected[x - 1][y + 1]
				&& (connected[x][y + 1] || connected[x - 1][y]))
			index += IBN_BIT_5;
		if (connected[x + 1][y + 1]
				&& (connected[x][y + 1] || connected[x + 1][y]))
			index += IBN_BIT_6;
		if (connected[x + 1][y - 1]
				&& (connected[x][y - 1] || connected[x + 1][y]))
			index += IBN_BIT_7;
		if (connected[x - 1][y - 1]
				&& (connected[x][y - 1] || connected[x - 1][y]))
			index += IBN_BIT_8;

		return (short) index;
	}

	/**
	 * The inverse of indexByNeighbors. Sets
	 * 'connected[xPos-1:xPos+1][yPos-1:yPos+1]' to the appropriate neighbors
	 * arrangement. Returns whether provided index was valid; if returns false,
	 * the state of 'connected' is unspecified.
	 */
	private static boolean neighborsByIndex(int index, boolean[][] connected,
			int x, int y) {
		if (index < 0 || index > 255)
			return false;

		connected[x][y] = true;
		connected[x - 1][y] = (index / IBN_BIT_1) % 2 == 1; // left
		connected[x][y + 1] = (index / IBN_BIT_2) % 2 == 1; // down
		connected[x + 1][y] = (index / IBN_BIT_3) % 2 == 1; // right
		connected[x][y - 1] = (index / IBN_BIT_4) % 2 == 1; // up

		connected[x - 1][y + 1] = (connected[x - 1][y] || connected[x][y + 1])
				&& (index / IBN_BIT_5) % 2 == 1; // left-down
		connected[x + 1][y + 1] = (connected[x + 1][y] || connected[x][y + 1])
				&& (index / IBN_BIT_6) % 2 == 1; // right-down
		connected[x + 1][y - 1] = (connected[x + 1][y] || connected[x][y - 1])
				&& (index / IBN_BIT_7) % 2 == 1; // right-up
		connected[x - 1][y - 1] = (connected[x - 1][y] || connected[x][y - 1])
				&& (index / IBN_BIT_8) % 2 == 1; // left-up

		return true;
	}

	private static final int IBN_BIT_1 = 0x80;
	private static final int IBN_BIT_2 = 0x40;
	private static final int IBN_BIT_3 = 0x20;
	private static final int IBN_BIT_4 = 0x10;
	private static final int IBN_BIT_5 = 0x8;
	private static final int IBN_BIT_6 = 0x4;
	private static final int IBN_BIT_7 = 0x2;
	private static final int IBN_BIT_8 = 0x1;

	private static final int[] IBN_BIT_LIST = new int[] { IBN_BIT_1, IBN_BIT_2,
			IBN_BIT_3, IBN_BIT_4, IBN_BIT_5, IBN_BIT_6, IBN_BIT_7, IBN_BIT_8 };

	// ALIAS FOR EASY ACCESS
	// Note the reflection: this is indexed (x, y), not (row, col). Transpose
	// this matrix
	// to visualize X/Y.
	private static final int[][] IBN_OFFSET_CONNECTED_DIRECTION = new int[][] {
			new int[] { IBN_BIT_8, IBN_BIT_1, IBN_BIT_5 }, // up-left, left,
															// down-left
			new int[] { IBN_BIT_4, 0, IBN_BIT_2 }, // up, center, down
			new int[] { IBN_BIT_7, IBN_BIT_3, IBN_BIT_6 } // up-right, right,
															// down-right
	};

	// Note on the below: transformations are represented in "original index"
	// form.
	// In other words, one should read IBN_TRANSFORM_ROT_CCW as:
	// In the first position, put the value that WAS in BIT4.
	// In the second position, put the value that WAS in BIT1.
	// etc.

	private static final int[] IBN_TRANSFORM_ROT_CCW = new int[] { IBN_BIT_4,
			IBN_BIT_1, IBN_BIT_2, IBN_BIT_3, IBN_BIT_8, IBN_BIT_5, IBN_BIT_6,
			IBN_BIT_7 };

	private static final int[] IBN_TRANSFORM_ROT_180 = new int[] { IBN_BIT_3,
			IBN_BIT_4, IBN_BIT_1, IBN_BIT_2, IBN_BIT_7, IBN_BIT_8, IBN_BIT_5,
			IBN_BIT_6 };

	private static final int[] IBN_TRANSFORM_ROT_CW = new int[] { IBN_BIT_2,
			IBN_BIT_3, IBN_BIT_4, IBN_BIT_1, IBN_BIT_6, IBN_BIT_7, IBN_BIT_8,
			IBN_BIT_5 };

	private static final int[] IBN_TRANSFORM_FLIP_H = new int[] { IBN_BIT_3,
			IBN_BIT_2, IBN_BIT_1, IBN_BIT_4, IBN_BIT_6, IBN_BIT_5, IBN_BIT_8,
			IBN_BIT_7 };

	private static final int[] IBN_TRANSFORM_FLIP_V = new int[] { IBN_BIT_1,
			IBN_BIT_4, IBN_BIT_3, IBN_BIT_2, IBN_BIT_8, IBN_BIT_7, IBN_BIT_6,
			IBN_BIT_5 };

	private static final int[] IBN_TRANSFORM_FLIP_D = new int[] { IBN_BIT_2,
			IBN_BIT_1, IBN_BIT_4, IBN_BIT_3, IBN_BIT_5, IBN_BIT_8, IBN_BIT_7,
			IBN_BIT_6 };

	private static final int TRANSFORM_TYPE_ROT_CCW = 0;
	private static final int TRANSFORM_TYPE_ROT_180 = 1;
	private static final int TRANSFORM_TYPE_ROT_CW = 2;
	private static final int TRANSFORM_TYPE_FLIP_H = 3;
	private static final int TRANSFORM_TYPE_FLIP_V = 4;
	private static final int TRANSFORM_TYPE_FLIP_D = 5;

	private static final int[][] IBN_TRANSFORM = new int[][] {
			IBN_TRANSFORM_ROT_CCW, IBN_TRANSFORM_ROT_180, IBN_TRANSFORM_ROT_CW,
			IBN_TRANSFORM_FLIP_H, IBN_TRANSFORM_FLIP_V, IBN_TRANSFORM_FLIP_D };

	private static final Matrix[] IBN_TRANSFORM_MATRIX = new Matrix[] { null,
			null, null, null, null, null };

	/**
	 * For 0 <= index <= 255, the "canonical representation" is the minimum
	 * possible value attainable through rotations and reflections - in other
	 * words, it represents a canonical neighborhood setup that can be easily
	 * transformed into the index provided.
	 * 
	 * This method provides a re-implementation of Python code used to generate
	 * canonical set numbers.
	 * 
	 * @param index
	 * @return
	 */
	private int indexByNeighbors_toCanonicalRepresentation(int index) {
		// get the transformations and apply them to the index.
		int[] transforms = indexByNeighbors_transformsToReachCanonical(index);

		for (int i = 0; i < transforms.length; i++)
			index = indexByNeighbors_applyTransform(index, transforms[i]);
		return index;
	}

	/**
	 * For 0 <= index <= 255, sets the provided Rect's fields to enclose exactly
	 * the region of a shadow sheet bitmap specified by the index. We assume
	 * 'blockWidth, blockHeight' are the dimensions of each shadow sheet
	 * element, and there is no space between elements (pixels are adjacent
	 * between adjacent elements, with no overlap).
	 */
	private void indexByNeighbors_sheetRect(Rect rect, int index,
			int blockWidth, int blockHeight) {
		int row = index / 16;
		int col = index % 16;

		rect.left = blockWidth * col;
		rect.top = blockHeight * row;
		rect.right = rect.left + blockWidth;
		rect.bottom = rect.top + blockHeight;
	}

	private int[] indexByNeighbors_transformsToReachCanonical(int index) {
		// max of 2 transforms - 1 rotation to put the first 4 bits in
		// min order, and possibly 1 reflection.

		// TEST TEST TEST
		int origIndex = index;

		int[] transforms = new int[2];
		int num = 0;
		int numRots = 0;

		int minVal = index;

		int x;
		int[] rots = new int[] { TRANSFORM_TYPE_ROT_CCW,
				TRANSFORM_TYPE_ROT_180, TRANSFORM_TYPE_ROT_CW };
		for (int i = 0; i < rots.length; i++) {
			x = indexByNeighbors_applyTransform(index, rots[i]);
			if (x < minVal) {
				minVal = x;
				transforms[0] = rots[i];
				num = numRots = 1;
			}
		}

		index = minVal;

		// up to 2 reflections.
		if (minVal > indexByNeighbors_applyTransform(index,
				TRANSFORM_TYPE_FLIP_D)) {
			transforms[numRots] = TRANSFORM_TYPE_FLIP_D;
			num += 1;
		} else {
			// try H, V, and both together.
			x = indexByNeighbors_applyTransform(index, TRANSFORM_TYPE_FLIP_H);
			if (x < minVal) {
				transforms[numRots] = TRANSFORM_TYPE_FLIP_H;
				num = numRots + 1;
				minVal = x;
			}
			x = indexByNeighbors_applyTransform(index, TRANSFORM_TYPE_FLIP_V);
			if (x < minVal) {
				transforms[numRots] = TRANSFORM_TYPE_FLIP_V;
				num = numRots + 1;
				minVal = x;
			}
			x = indexByNeighbors_applyTransform(x, TRANSFORM_TYPE_FLIP_H);
			if (x < minVal) {
				// This is the result of flipping vertical, then horizontal.
				// this is equivalent to a 180 rotation.
				transforms[num] = TRANSFORM_TYPE_FLIP_H;
				num += 1;
				minVal = x;
			}
		}

		if (num < transforms.length) {
			int[] t = new int[num];
			for (int i = 0; i < num; i++)
				t[i] = transforms[i];
			return t;
		}

		return transforms;
	}

	private int indexByNeighbors_applyTransform(int val, int transformType) {
		int res = 0;
		int[] transform = IBN_TRANSFORM[transformType];
		for (int i = 0; i < transform.length; i++) {
			if ((val & transform[i]) > 0)
				res += IBN_BIT_LIST[i];
		}
		// log("applyTransform type " + transformType + " to " + val +
		// " and got " + res) ;
		return res;
	}

	/**
	 * Returns a Matrix which, when applied to a Bitmap, reverses the
	 * transformations provided. In other words, if the transforms are the
	 * output of indexByNeighbors_transformsToReachCanonical, they represent a
	 * series of operations to transform an arbitrary image to canonical form.
	 * 
	 * The reversed matrix (returned) can be applied to a canonical Bitmap to
	 * produce the arbitrary version.
	 * 
	 * @param transforms
	 * @return
	 */
	private Matrix indexByNeighbors_reverseTransformMatrix(int[] transforms) {
		Matrix m = new Matrix(); // identity matrix

		// construct the transform as a matrix, then invert. Do the
		// steps in order.
		for (int i = 0; i < transforms.length; i++) {
			int t = transforms[i];

			Matrix tm = IBN_TRANSFORM_MATRIX[t];

			if (tm == null) {
				tm = new Matrix();
				switch (t) {
				case TRANSFORM_TYPE_ROT_CCW:
					tm.setRotate(270);
					break;
				case TRANSFORM_TYPE_ROT_180:
					tm.setRotate(180);
					break;
				case TRANSFORM_TYPE_ROT_CW:
					tm.setRotate(90);
					break;
				case TRANSFORM_TYPE_FLIP_H:
					tm.preScale(-1, 1);
					break;
				case TRANSFORM_TYPE_FLIP_V:
					tm.preScale(1, -1);
					break;
				case TRANSFORM_TYPE_FLIP_D:
					// first flip H, then rotate CW.
					tm.preRotate(90);
					tm.preScale(-1, 1);
					break;
				}

				IBN_TRANSFORM_MATRIX[t] = tm;
			}

			// was once preConcat; testing the alternative.
			m.postConcat(tm);
		}

		Matrix inv = new Matrix();

		if (!m.invert(inv)) {
			throw new IllegalStateException("cannot invert matrix!");
		}

		return inv;
	}

	// RENDERING
	// Render these structures according to the provided neighborhod and
	// drawSettings.

	/**
	 * Renders an edge shadow bitmap using the 'edgeShadow' settings which is
	 * shrunk to inset by the provided parameters.
	 */
	private Bitmap prerenderInsetFillShadowBitmap(Bitmap b, DrawSettings ds,
			Context context, int xInset, int yInset, float gaussianRadius,
			int edgeShadowAlpha) throws IOException {

		Bitmap edgeBitmap = loadExactShadowSquareFromAssets(context,
				ds.size_blockWidth, gaussianRadius, ds.loadImagesSize);

		// Whelp, that's it. Put them in a canvas at the appropriate locations.
		if (b == null) {
			if ( GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP )
				log("Allocate Bitmap: inset fill shadow");
			b = Bitmap.createBitmap(ds.size_blockWidth,
					ds.size_blockHeight, Bitmap.Config.ALPHA_8);
		}

		Canvas c = new Canvas(b);
		Rect dstRect = new Rect(xInset, yInset,
				mDrawSettings.size_blockWidth - xInset,
				mDrawSettings.size_blockHeight - yInset);
		Paint p = new Paint();
		ColorMatrixColorFilter filterEdgeShadow = new ColorMatrixColorFilter(
				new float[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
						0, 0, edgeShadowAlpha / 255.0f, 0 });
		// RED -> 0 GREEN -> 0 BLUE -> 0 ALPHA scaled by draw settings.

		p.setColorFilter(filterEdgeShadow);
		p.setDither(false);
		Rect srcRect = new Rect();
		srcRect.left = edgeBitmap.getWidth() / 3;
		srcRect.right = 2 * edgeBitmap.getWidth() / 3;
		srcRect.top = edgeBitmap.getHeight() / 3;
		srcRect.bottom = 2 * edgeBitmap.getHeight() / 3;

		c.drawBitmap(edgeBitmap, srcRect, dstRect, p);

		return b;
	}

	/**
	 * Renders and returns (possibly retrieving from the cache, if available) an
	 * inset drop-shadow image. This image will be top-left aligned. If drop
	 * shadows extend upward or leftward, this method will need to be refactored
	 * slightly.
	 */
	private Bitmap renderInsetDropShadowBitmap(Bitmap b, DrawSettings ds,
			Context context, float xInsetProportion, float yInsetProportion,
			int xInset, int yInset, float[] gaussianRadius,
			int[] shadowXOffset, int[] shadowYOffset, int[] shadowAlpha) {

		// closest block width?
		int blockWidth;
		if (GlobalTestSettings.FORCE_LOAD_LARGE_RESOURCES)
			blockWidth = 80;
		else if (ds.size_blockWidth < 25)
			blockWidth = 20;
		else if (ds.size_blockWidth < 50)
			blockWidth = 40;
		else
			blockWidth = 80;

		try {
			int maxXOff = 0, maxYOff = 0;
			/*
			 * Disabled: we have no drop shadows that extend past the full
			 * block, and this makes our "bounding" more complicated. for (int i
			 * = 0; i < ds.size_outerShadowXOffset.length; i++) { maxXOff =
			 * (int) Math.max(maxXOff, ds.size_outerShadowXOffset[i]); maxYOff =
			 * (int) Math.max(maxYOff, ds.size_outerShadowYOffset[i]); }
			 */
			if (b == null) {
				if ( GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP )
					log("Allocate Bitmap: inset drop shadow.  Extra pixels "
							+ maxXOff + ", " + maxYOff + "; inset " + xInset + ", "
							+ yInset);
				b = Bitmap.createBitmap(ds.size_blockWidth + maxXOff,
						ds.size_blockHeight + maxYOff,
						Bitmap.Config.ALPHA_8);
			}
			Canvas c = new Canvas(b);
			// drop shadows are NOT drawn over the inset square.
			tempRect.set(xInset, yInset, ds.size_blockWidth - xInset,
					ds.size_blockHeight - yInset);
			c.clipRect(tempRect, Region.Op.DIFFERENCE);

			String inset;
			if (xInsetProportion <= 0.1)
				inset = "0.1";
			else
				inset = "0.15";
			String assetName = "inset_" + inset + ".png";

			// render it ourselves.
			for (int i = 0; i < gaussianRadius.length; i++) {

				// approximate radius!
				String radius;
				if (gaussianRadius[i] < 0.05)
					radius = "0";
				else if (gaussianRadius[i] < 0.1)
					radius = "0.05";
				else
					radius = "0.1";

				File shadowDir = new File(
						new File(new File("game"), "shadows"), "drop");
				File fileDir = new File(new File(shadowDir, "" + blockWidth
						+ "x" + blockWidth), radius);

				String assetPath = new File(fileDir, assetName).getPath();
				AssetManager as = context.getAssets();

				BufferedInputStream buf = new BufferedInputStream(
						as.open(assetPath));
				Bitmap bshad = BitmapFactory.decodeStream(buf);
				buf.close();
				if ( GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP )
					log("Allocate Bitmap: load path " + assetPath);

				// Set source and dest rectangles, then offset dest.
				tempSrcRect.set(0, 0, bshad.getWidth(), bshad.getHeight());
				tempDstRect.set(0, 0, ds.size_blockWidth,
						ds.size_blockHeight);
				tempDstRect.offset(shadowXOffset[i], shadowYOffset[i]);

				int prevAlpha = tempColorPaint.getAlpha();
				tempColorPaint.setAlpha(shadowAlpha[i]);

				c.drawBitmap(bshad, tempSrcRect, tempDstRect, tempColorPaint);
				tempColorPaint.setAlpha(prevAlpha);

				bshad.recycle();
			}
		} catch (IOException e) {
			e.printStackTrace();
			return null;
		}

		return b;
	}
	
	
	private Bitmap renderBorderChevronInnerShadowBitmap( 
			Bitmap b, DrawSettings ds,
			Context context, float[] gaussianRadius,
			float[] shadowXOffset, float[] shadowYOffset, int[] shadowAlpha ) {
		
		try {
			if (b == null) {
				if ( GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP )
					log("Allocate Bitmap: renderBorderChevronInnerShadowBitmap") ;
				b = Bitmap.createBitmap(
						ds.size_blockWidth,
						ds.size_blockHeight,
						Bitmap.Config.ALPHA_8) ;
			}
			Canvas c = new Canvas(b);

			// render it ourselves.
			for (int i = 0; i < gaussianRadius.length; i++) {
				Bitmap bshad = loadDetailChevronShadowBitmapFromAssets(
						context, ds.size_blockWidth,
						gaussianRadius[i], shadowXOffset[i], shadowYOffset[i], ds.loadImagesSize) ;

				// Set source and dest rectangles, then offset dest.
				tempSrcRect.set(0, 0, bshad.getWidth(), bshad.getHeight());
				tempDstRect.set(0, 0, ds.size_blockWidth,
						ds.size_blockHeight);
				
				int prevAlpha = tempColorPaint.getAlpha();
				tempColorPaint.setAlpha(shadowAlpha[i]);

				c.drawBitmap(bshad, tempSrcRect, tempDstRect, tempColorPaint);
				tempColorPaint.setAlpha(prevAlpha);

				bshad.recycle();
			}
		} catch (IOException e) {
			e.printStackTrace();
			return null;
		}

		return b;
		
	}
	
	

	private void renderFullSizeEdgeShadowToRenderScratch(DrawSettings ds,
			Context context, float alphaScale) throws IOException {
		// find an inner shadow with no offset.
		float radius = 0;
		for (int i = 0; i < ds.proportion_innerShadowGaussianRadius.length; i++) {
			if (ds.proportion_innerShadowXOffset[i] == 0
					&& ds.proportion_innerShadowYOffset[i] == 0) {
				radius = ds.proportion_innerShadowGaussianRadius[i];
				break;
			}
		}
		Bitmap edgeBitmap = loadExactShadowSquareFromAssets(context,
				ds.size_blockWidth, radius, ds.loadImagesSize);

		// Whelp, that's it. Put them in a canvas at the appropriate locations.
		Paint p = new Paint();
		ColorMatrixColorFilter filterEdgeShadow = new ColorMatrixColorFilter(
				new float[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
						0, 0, alphaScale, 0 });// 0,0,0,ds.alpha_edgeShadow /
												// 255.0f,0 } ) ;
		// RED -> 0 GREEN -> 0 BLUE -> 0 ALPHA scaled by draw settings.

		p.setColorFilter(filterEdgeShadow);
		p.setDither(false);
		Rect srcRect = new Rect();
		srcRect.left = edgeBitmap.getWidth() / 3;
		srcRect.right = 2 * edgeBitmap.getWidth() / 3;
		srcRect.top = edgeBitmap.getHeight() / 3;
		srcRect.bottom = 2 * edgeBitmap.getHeight() / 3;

		renderScratchCanvas.drawPaint(clearPaint);
		renderScratchCanvas.drawBitmap(edgeBitmap, srcRect,
				renderScratchBounds, p);
	}

	private Bitmap prerenderInnerBorderExtrudedWallShadow(
			BlockDrawerPreallocatedBitmaps preallocated, DrawSettings ds,
			Context context, int wallSide) throws IOException {

		// what defines the bitmap? Well, size is actually irrelevant,
		// although we prefer current block size, so we should specify it.
		// besides that and shadow radius, nothing else is important.
		Bitmap b;

		StringBuilder sb = new StringBuilder();
		sb.append("innerBorderExtrudedWallShadow");
		sb.append("_").append(ds.size_blockWidth).append("_")
				.append(ds.size_blockHeight);
		sb.append("_").append(ds.proportion_extrudedWallShadowGaussianRadius);

		String key = sb.toString();

		boolean rendered = preallocated.hasBlockSizeBitmapInUse(key)
				|| (preallocated.hasBlockSizeBitmap(key) && preallocated
						.getRenderedDrawSettings() != null);

		b = preallocated.getBlockSizeBitmap(key, ds.size_blockWidth,
				ds.size_blockHeight, Bitmap.Config.ARGB_8888);

		if (b == null) {
			if ( GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP )
				log("Allocate Bitmap: inner border extruded wall shadow");
			b = Bitmap.createBitmap(ds.size_blockWidth,
					ds.size_blockHeight, Bitmap.Config.ARGB_8888);
		}

		if (!rendered) {
			Bitmap edgeBitmap = loadExactShadowSquareFromAssets(context,
					ds.size_blockWidth,
					ds.proportion_extrudedWallShadowGaussianRadius,
					ds.loadImagesSize);

			// middle section?
			tempSrcRect.set(edgeBitmap.getWidth() / 3,
					edgeBitmap.getHeight() / 3,
					2 * (edgeBitmap.getWidth() / 3),
					2 * (edgeBitmap.getHeight() / 3));

			// Initially we attempted to "skew" this bitmap here, then
			// stretch the result in X,Y to draw to the Canvas. This resulted
			// in a draw bug due to the skew angle being exaggerated when the
			// rectangle was stretched. Instead, we retain the bitmap as-is;
			// it will be resized later.
			Canvas c = new Canvas(b);
			Paint p = new Paint();

			ColorMatrixColorFilter filter = new ColorMatrixColorFilter(
					new float[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
							0, 0, 0, ds.alpha_extrudedWallShadow / 255.0f, 0 });
			// RED -> 0 GREEN -> 0 BLUE -> 0 ALPHA scaled by draw settings.
			p.setColorFilter(filter);

			// draw.
			tempDstRect.set(0, 0, b.getWidth(), b.getHeight());
			c.drawPaint(clearPaint);
			c.drawBitmap(edgeBitmap, tempSrcRect, tempDstRect, p);
		}

		return b;
	}

	private static final int SHEET_SET_EXACT = 0;
	private static final int SHEET_SET_OVERSIZED = 1;

	/**
	 * Using 256 scaled draws, copies the shadow sheet specified by
	 * 'blurRadius', 'xOffset' and 'yOffset' to the provided canvas.
	 * 
	 * The sheet will be selected as that which is closest to blurRadius, the
	 * offsets, and the destination block dimensions - note that "closest" is
	 * purely the judgement of this method. This sheet will be scaled according
	 * to the provided blockWidth and blockHeight, and drawn in 256 steps to a
	 * (16 * blockWidth) x (16 * blockHeight) area of the provided canvas.
	 * 
	 * 256 draws are necessary, because the shadow sheet represents 256
	 * independent regions immediately adjacent to each other. Scaling the
	 * entire sheet will result in "bleed-through" between these areas, whereas
	 * scaling each of the 256 regions individually will maintain independence.
	 * 
	 * The provided canvas will not be cleared or altered in any way other than
	 * drawing the shadow sheet to it. Shadows are represented as white rgb(1.0,
	 * 1.0, 1.0), with alpha (opacity) ranging from 1.0 to 0.0. A color filter
	 * will be applied to the draw using the provided r,g,b settings. For
	 * example, a typical shadow application uses rgba = (0, 0, 0, a) with a in
	 * (0, 1). This produces a black shadow with partial transparency even at
	 * its most opaque sections.
	 */
	private synchronized void drawShadowSheet(
			DrawSettings ds, Context context, Bitmap loadInto,
			int sheetSet, float blurRadius, float xOffset, float yOffset,
			Canvas sheet, Offset topLeft, int blockWidth, int blockHeight,
			float a) throws IOException {

		// retrieve from cache...
		Bitmap sheetBitmap = loadRawSheetFromAssets(
				context, loadInto,
				blockWidth, blurRadius, sheetSet, xOffset, yOffset, ds.loadImagesSize);

		// We have the image.
		int bitmapBlockWidth = sheetBitmap.getWidth() / 16;
		int bitmapBlockHeight = sheetBitmap.getHeight() / 16;

		// now.... COUPLE!
		// this color filter reduces the source image to black, but
		// retains the alpha channel (multiplied by 'a').
		ColorMatrixColorFilter filter = new ColorMatrixColorFilter(new float[] {
				0, 0, 0, 0, 0,
				0, 0, 0, 0, 0,
				0, 0, 0, 0, 0,
				0, 0, 0, a, 0 });
		tempColorFilterPaint.setColorFilter(filter);

		Rect r = new Rect(0, 0, blockWidth, blockHeight);

		for (int i = 0; i < 256; i++) {
			indexByNeighbors_sheetRect(tempSrcRect, i, bitmapBlockWidth,
					bitmapBlockHeight);
			indexByNeighbors_sheetRect(tempDstRect, i, blockWidth, blockHeight);

			// offset destination rectangle.
			if (topLeft != null)
				tempDstRect.offset(topLeft.x, topLeft.y);

			// draw
			renderScratchCanvas.drawPaint(clearPaint);
			renderScratchCanvas.drawBitmap(sheetBitmap, tempSrcRect, r, null);
			sheet.drawBitmap(renderScratchBitmap, r, tempDstRect,
					tempColorFilterPaint);
		}

		if ( loadInto == null ) {
			sheetBitmap.recycle();
		}
		
		// that's it, we done.
	}

	private Bitmap renderFlashBitmap(Bitmap b, DrawSettings ds,
			Context context, int burstColor, int stripeColor, int wInset,
			int hInset) throws IOException {

		if (b == null) {
			if ( GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP )
				log("Allocate Bitmap: flash bitmap");
			b = Bitmap.createBitmap(ds.size_blockWidth,
					ds.size_blockHeight, Bitmap.Config.ARGB_8888);
		}

		// check cache for these
		Bitmap[] detailBitmaps = loadDetailBitmapsFromAssets(context,
				ds.size_blockWidth, ds.loadImagesSize);

		// We draw into a bitmap of the block size, using the specified inset,
		// with the specified colors as filters. We draw the stripe twice over.

		Canvas canvas = new Canvas(b);
		canvas.drawPaint(clearPaint);

		ColorMatrixColorFilter burstFilter = new ColorMatrixColorFilter(
				new float[] { Color.red(burstColor) / 255.f, 0, 0, 0, 0, 0,
						Color.green(burstColor) / 255.f, 0, 0, 0, 0, 0,
						Color.blue(burstColor) / 255.f, 0, 0, 0, 0, 0, 1, 0

				});
		ColorMatrixColorFilter stripeFilter = new ColorMatrixColorFilter(
				new float[] { Color.red(stripeColor) / 255.f, 0, 0, 0, 0, 0,
						Color.green(stripeColor) / 255.f, 0, 0, 0, 0, 0,
						Color.blue(stripeColor) / 255.f, 0, 0, 0, 0, 0, 1, 0 });

		// log("constructing flash bitmap with burst color " +
		// Color.red(burstColor) + ", " + Color.green(burstColor) + ", " +
		// Color.blue(burstColor)) ;
		// log("constructing flash bitmap with stripe color " +
		// Color.red(stripeColor) + ", " + Color.green(stripeColor) + ", " +
		// Color.blue(stripeColor)) ;

		tempRect.top = hInset;
		tempRect.left = wInset;
		tempRect.bottom = ds.size_blockHeight - hInset;
		tempRect.right = ds.size_blockWidth - wInset;

		// draw!
		tempColorFilterPaint.setColorFilter(burstFilter);
		canvas.drawBitmap(detailBitmaps[DETAIL_CODE_FLASH_BURST], null,
				tempRect, tempColorFilterPaint);
		tempColorFilterPaint.setColorFilter(stripeFilter);
		canvas.drawBitmap(detailBitmaps[DETAIL_CODE_FLASH_STRIPE], null,
				tempRect, tempColorFilterPaint);
		canvas.drawBitmap(detailBitmaps[DETAIL_CODE_FLASH_STRIPE], null,
				tempRect, tempColorFilterPaint);

		// return the bitmap we made.
		return b;
	}

	private Bitmap renderChevronBitmap(Bitmap b, DrawSettings ds,
			Context context, int chevronColorLeft, int chevronColorRight,
			boolean inverted, boolean shallow, byte matchQOBorder, int matchQPBorder,
			int wInset, int hInset) {

		if (b == null) {
			if ( GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP )
				log("Allocate Bitmap: chevron bitmap");
			b = Bitmap.createBitmap(ds.size_blockWidth,
					ds.size_blockHeight, Bitmap.Config.ARGB_8888);
		}

		// A Chevron is a simple path shape. The path exists within inset.
		// A SHALLOW chevron is bounded
		// by 22.5% block height, with vertical stroke height 15% block.
		// Translated to inset region dimensions, this is 28.125% region
		// height, with stroke height 18.75%.
		//
		// A NON-SHALLOW Chevron has a vertical spread (for the top or bottom
		// edge, NOT the total) of 50% of the available space.  This
		// results in a 45-degree angle.  It has a perceptual
		// width of the standard border width.  We calculate top and bottom bound,
		// and the vHeight, accordingly.  

		int insetHeight = ds.size_blockHeight - hInset * 2;

		float topBound, bottomBound, vHeight;

		if (!shallow) {
			// determine vertical height to create the perceptual border
			// height.  We calculate this as follows:
			// the angle is 45 degrees: we cover 1/2 the available vertical
			// space in 1/2 the available horizontal space.
			// Take the cosine of this and multiply it by the perceptual
			// width to get the vertical height (make a diagram to understand
			// why: take a right triangle with Adjacent = perceptual width,
			// Hypotenuse = vertical height).
			vHeight = (int) Math.round(ds.size_borderWidth * 1.414f) ;
			
			// The vertical difference (i.e. the "travel" for the top edge
			// or bottom edge) is half of the total available space, which
			// is ( blockHeight - 2*hInset ).  Divide this by two to get
			// the vTravel.
			// The used space is thus vTravel + vHeight.  Free space within
			// the inset is then divided between bounds.
			int vTravel = Math.round( (ds.size_blockHeight - 2*hInset ) / 2.0f ) ;
			int usedSpace = (int)Math.round( vTravel + vHeight ) ;
			int freeSpace = ds.size_blockHeight - usedSpace ;
			topBound = freeSpace/2 ;
			bottomBound = ds.size_blockHeight - topBound ;
		} else {
			/*
			topBound = hInset + (int) Math.round(0.28125 * insetHeight);
			bottomBound = ds.size_blockHeight - topBound;
			vHeight = (int) Math.round(0.1875 * insetHeight);
			*/
			topBound = hInset + (int) Math.round(0.125 * insetHeight);
			bottomBound = ds.size_blockHeight - topBound;
			vHeight = (int) Math.round(0.375 * insetHeight);
		}

		int l = wInset;
		int r = ds.size_blockWidth - wInset;
		int m = ds.size_blockHeight / 2;

		// A Chevron points up; an inverted Chevron points down.
		Path chevronPath = path();
		if (inverted) {
			// point down. Draw from left edge (top) clockwise around.
			chevronPath.moveTo(l, topBound);
			chevronPath.lineTo(m, bottomBound - vHeight);
			chevronPath.lineTo(r, topBound);
			chevronPath.lineTo(r, topBound + vHeight);
			chevronPath.lineTo(m, bottomBound);
			chevronPath.lineTo(l, topBound + vHeight);
			chevronPath.close();
		} else {
			// point up. Draw from left edge (top) clockwise around.
			chevronPath.moveTo(l, bottomBound - vHeight);
			chevronPath.lineTo(m, topBound);
			chevronPath.lineTo(r, bottomBound - vHeight);
			chevronPath.lineTo(r, bottomBound);
			chevronPath.lineTo(m, topBound + vHeight);
			chevronPath.lineTo(l, bottomBound);
			chevronPath.close();
		}
		
		if ( matchQOBorder >= 0 && matchQPBorder >= 0 ) {
			// get the correct colors.
			Drawable d = this.makeBorderDrawable(
					ds, matchQPBorder, matchQOBorder, true,
					DrawSettings.CORNER_INNER_LEFT_TOP_CONVEX,
					DrawSettings.CORNER_INNER_LEFT_BOTTOM_CONVEX,
					DIRECTION_DOWN) ;
			
			Drawable d2 = this.makeBorderDrawable(
					ds, matchQPBorder, matchQOBorder, true,
					DrawSettings.CORNER_INNER_RIGHT_TOP_CONVEX,
					DrawSettings.CORNER_INNER_RIGHT_BOTTOM_CONVEX,
					DIRECTION_DOWN) ;
			
			// draw each and sample the pixel value.
			Bitmap tempBitmap = Bitmap.createBitmap(1, insetHeight, Bitmap.Config.ARGB_8888) ;
			Canvas tempCanvas = new Canvas(tempBitmap) ;
			d.setBounds(0, 0, 1, insetHeight) ;
			d.draw(tempCanvas) ;
			
			chevronColorLeft = tempBitmap.getPixel(0, (int)Math.round( topBound - hInset + vHeight/2 ) ) ;
			
			tempCanvas.drawPaint(clearPaint) ;
			d2.setBounds(0, 0, 1, insetHeight) ;
			d2.draw(tempCanvas) ;
			
			chevronColorRight = tempBitmap.getPixel(0, (int)Math.round( topBound - hInset + vHeight/2 ) ) ;
			
			tempBitmap.recycle() ;
		}

		// draw the Chevron...

		Canvas canvas = new Canvas(b);
		canvas.drawPaint(clearPaint);

		Paint chevronPaint = new Paint();
		chevronPaint.setAntiAlias(true);
		chevronPaint.setShader(
				new LinearGradient(l, 0, r, 0, chevronColorLeft, chevronColorRight, Shader.TileMode.CLAMP));
		canvas.drawPath(chevronPath, chevronPaint);

		// return the bitmap we made.
		return b;
	}

	public static final int DETAIL_CODE_FLASH_BURST = 0;
	public static final int DETAIL_CODE_FLASH_STRIPE = 1;
	public static final int NUM_DETAIL_CODES = 2;

	public static final String getDetailBitmapCacheKey(int blockSize,
			int detailCode, int loadImagesSize) {

		StringBuilder sb = new StringBuilder();
		String resString = nextLargestResolutionString(blockSize, blockSize,
				loadImagesSize);

		sb.append("game_details_white");
		sb.append("_").append(resString);

		switch (detailCode) {
		case DETAIL_CODE_FLASH_BURST:
			sb.append("_").append("flash_burst");
			break;
		case DETAIL_CODE_FLASH_STRIPE:
			sb.append("_").append("flash_stripe");
			break;
		}

		return sb.toString();
	}
	
	
	public static final String getDetailChevronShadowBitmapAssetPath(
			int blockSize, float radius, float xOffset, float yOffset, int loadImagesSize) {

		String resString = nextLargestResolutionString(blockSize, blockSize,
				loadImagesSize);

		File detailsResolutionDir = new File(new File(new File(
				new File("game"), "shadows"), "details"), resString);

		String radiusString = nearestBlurRadiusString( radius ) ;
		String offsetString = nearestOffsetString( xOffset, yOffset ) ;

		File assetFile = new File( new File(
				detailsResolutionDir, radiusString ), "chevron" + offsetString + ".png" ) ;
		
		return assetFile.getPath() ;
	}
	

	public static final String getDetailBitmapAssetPath(int blockSize,
			int detailCode, int loadImagesSize) {

		String resString = nextLargestResolutionString(blockSize, blockSize,
				loadImagesSize);

		File detailsResolutionDir = new File(new File(new File(
				new File("game"), "details"), "white"), resString);
		String assetPath = null;

		switch (detailCode) {
		case DETAIL_CODE_FLASH_BURST:
			assetPath = new File(detailsResolutionDir, "flash_burst.png")
					.getPath();
			break;
		case DETAIL_CODE_FLASH_STRIPE:
			assetPath = new File(detailsResolutionDir, "flash_stripe.png")
					.getPath();
			break;
		}

		return assetPath;
	}

	/**
	 * Returns an array, indexed by DETAIL_CODE_*, of detail bitmaps exactly as
	 * loaded from assets. If those bitmaps are present in the cache, they will
	 * be retrieved and returned. If not, they will be loaded from our assets
	 * and inserted into the cache before being returned.
	 */
	public static final Bitmap[] loadDetailBitmapsFromAssets(Context context,
			int blockSize, int loadImagesSize) throws IOException {

		Bitmap[] b = new Bitmap[NUM_DETAIL_CODES];
		AssetManager as = context.getAssets();

		for (int i = 0; i < NUM_DETAIL_CODES; i++) {
			String assetPath = getDetailBitmapAssetPath(blockSize, i,
					loadImagesSize);

			BufferedInputStream buf = new BufferedInputStream(
					as.open(assetPath));
			b[i] = BitmapFactory.decodeStream(buf);
			buf.close();
			if ( GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP )
				log("Allocate Bitmap: load path " + assetPath);
		}

		return b;
	}

	
	
	/**
	 * Returns an array, indexed by DETAIL_CODE_*, of detail bitmaps exactly as
	 * loaded from assets. If those bitmaps are present in the cache, they will
	 * be retrieved and returned. If not, they will be loaded from our assets
	 * and inserted into the cache before being returned.
	 */
	public static final Bitmap loadDetailChevronShadowBitmapFromAssets(
			Context context, int blockSize,
			float radius, float xOffset, float yOffset, int loadImagesSize) throws IOException {

		Bitmap b ;
		AssetManager as = context.getAssets();

		String assetPath = getDetailChevronShadowBitmapAssetPath(
				blockSize, radius, xOffset, yOffset, loadImagesSize ) ;

		BufferedInputStream buf = new BufferedInputStream(
				as.open(assetPath));
		b = BitmapFactory.decodeStream(buf);
		buf.close();
		if ( GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP )
			log("Allocate Bitmap: load path " + assetPath);

		return b;
	}
	
	
	public static final String getExactShadowSquareAssetPath(int blockSize,
			float blurRadius, int loadImagesSize) {

		String resString = nearestResolutionString(blockSize, blockSize,
				loadImagesSize);
		String radString = nearestBlurRadiusString(blurRadius);

		File shadowDir = new File(new File(
				new File(new File("game"), "shadows"), "white"), "exact");
		String assetPath = new File(new File(new File(shadowDir, resString),
				radString), "set_0.png").getPath();

		return assetPath;
	}

	public static final Bitmap loadExactShadowSquareFromAssets(Context context,
			int blockSize, float blurRadius, int loadImagesSize)
			throws IOException {

		String assetPath = getExactShadowSquareAssetPath(blockSize, blurRadius,
				loadImagesSize);
		AssetManager as = context.getAssets();

		BufferedInputStream buf = new BufferedInputStream(as.open(assetPath));
		Bitmap b = BitmapFactory.decodeStream(buf);
		buf.close();
		if ( GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP )
			log("Allocate Bitmap: load path " + assetPath);

		return b;
	}

	public static final String getRawSheetCacheKey(int blockSize,
			float blurRadius, int sheetSet, float xOffset, float yOffset,
			int loadImagesSize) {

		String resString = nextLargestResolutionString(blockSize, blockSize,
				loadImagesSize);
		String radString = nearestBlurRadiusString(blurRadius);
		String setString = sheetSetString(sheetSet);
		String offString = nearestOffsetString(xOffset, yOffset);

		StringBuilder sb = new StringBuilder();
		sb.append("game_shadow_sheet_orig").append("_").append(resString)
				.append("_").append(radString).append("_").append(setString)
				.append("_").append(offString);

		return sb.toString();
	}

	public static final String getRawSheetAssetPath(int blockSize,
			float blurRadius, int sheetSet, float xOffset, float yOffset,
			int loadImagesSize) {
		
		String resString = nextLargestResolutionString(blockSize, blockSize,
				loadImagesSize);
		String radString = nearestBlurRadiusString(blurRadius);
		String setString = sheetSetString(sheetSet);
		String offString = nearestOffsetString(xOffset, yOffset);

		File detailsDir = new File(new File(new File("game"), "shadows"),
				"sheets");
		return new File(new File(new File(detailsDir, resString), radString),
				setString + offString + ".png").getPath();
	}

	public static final String getBackgroundAssetPath(Rect drawRegion,
			String assetName, int imagesSize) {

		int width = drawRegion.width();
		int height = drawRegion.height();

		String imageSizeString = getBackgroundLoadResolutionString(width,
				height, imagesSize);

		return new File(new File(new File(new File("game"), "backgrounds"),
				imageSizeString), assetName + ".png").getPath();
	}

	public static final String getBackgroundLoadResolutionString(int width,
			int height, int imagesSize) {

		int w = getBackgroundLoadResolutionWidth(width, height, imagesSize);
		int h = getBackgroundLoadResolutionHeight(width, height, imagesSize);

		if (w == 0 || h == 0)
			return null;

		return "" + w + "x" + h;
	}

	public static final int getBackgroundLoadResolutionWidth(int width,
			int height, int imageSize) {

		switch (imageSize) {
		case DrawSettings.IMAGES_SIZE_HUGE:
		case DrawSettings.IMAGES_SIZE_LARGE:
			if (height > 400 || width > 240)
				return 480;
			else if (height > 200 || width > 120)
				return 240;
			else
				return 120;
		case DrawSettings.IMAGES_SIZE_MID:
			if (height > 200 || width > 120)
				return 240;
			else
				return 120;
		case DrawSettings.IMAGES_SIZE_SMALL:
			return 120;
		}

		return 0;
	}

	public static final int getBackgroundLoadResolutionHeight(int width,
			int height, int imageSize) {

		switch (imageSize) {
		case DrawSettings.IMAGES_SIZE_HUGE:
		case DrawSettings.IMAGES_SIZE_LARGE:
			if (height > 400 || width > 240)
				return 800;
			else if (height > 200 || width > 120)
				return 400;
			else
				return 200;
		case DrawSettings.IMAGES_SIZE_MID:
			if (height > 200 || width > 120)
				return 400;
			else
				return 200;
		case DrawSettings.IMAGES_SIZE_SMALL:
			return 200;
		}

		return 0;
	}

	/**
	 * Returns the bitmap indicated by the sheet parameters.
	 * The image is loaded from assets and returned in a format
	 * that retains its alpha channel (possibly discarding all other
	 * channels).  If 'loadInto' is provided and valid -- i.e.,
	 * if its dimensions match the dimensions of the load and our
	 * OperatingSystem supports the bitmapIn option for BitmapFactory.Options,
	 * then it is returned with the image data present.
	 * 
	 * Otherwise, the image returned is a newly allocated Bitmap which
	 * can be safely recycled when you're finished with it.
	 * 
	 * @param context
     * @param loadInto
	 * @param blockSize
	 * @param blurRadius
	 * @param sheetSet
	 * @param xOffset
	 * @param yOffset
     * @param loadImagesSize
	 * @throws IOException
	 */
	public static final synchronized Bitmap loadRawSheetFromAssets(
			Context context, Bitmap loadInto,
			int blockSize, float blurRadius, int sheetSet, float xOffset,
			float yOffset, int loadImagesSize) throws IOException {

		Bitmap b = null;
		String assetPath = null;
		int attempt = 0;

		while (b == null) {
			try {
				attempt++;
				assetPath = getRawSheetAssetPath(
						loadInto == null ? blockSize : Integer.MAX_VALUE,
						blurRadius, sheetSet, xOffset, yOffset, loadImagesSize);
				// log("retrieving asset " + assetPath) ;
				AssetManager as = context.getAssets();
				
				BitmapFactory.Options options = new BitmapFactory.Options() ;
				options.inSampleSize = 1 ;
				boolean loadedIntoProvided = false ;
				
				if ( loadInto != null && VersionCapabilities.supportsLoadInBitmap() ) {
					// attempt to load into this bitmap.  Check whether
					// size matches.
					BitmapFactory.Options imgSizeOptions = new BitmapFactory.Options() ;
					imgSizeOptions.inJustDecodeBounds = true ;
					BufferedInputStream buf = new BufferedInputStream(as.open(assetPath));
					BitmapFactory.decodeStream(buf, null, imgSizeOptions);
					buf.close();
					
					if ( imgSizeOptions.outWidth == loadInto.getWidth()
							&& imgSizeOptions.outHeight == loadInto.getHeight() ) {
						// perfect match.
						VersionSafe.setInBitmap(options, loadInto) ;
						loadedIntoProvided = true ;
					} else {
						log("attempt to load into sheet bitmap FAILED due to mis-matched dimensions: "
								+ " provided with " + loadInto.getWidth() + "x" + loadInto.getHeight()
								+ ", on-disc asset is " + imgSizeOptions.outWidth + "x" + imgSizeOptions.outHeight) ;
					}
				}
				BufferedInputStream buf = new BufferedInputStream(
						as.open(assetPath));
				Bitmap b2 = BitmapFactory.decodeStream(buf, null, options);
				buf.close();
				
				// if this is the provided "load into" bitmap, return it exactly.
				if ( loadedIntoProvided ) {
					return b2 ;
				}
				
				b = b2.extractAlpha();
				b2.recycle() ;
				if ( GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP )
					log("Allocate Bitmap: load path " + assetPath);
			} catch (OutOfMemoryError oome) {
				if (QuantroPreferences.getAnalyticsActive(context)) {
					GameViewMemoryCapabilities gvmc = null;
					gvmc = ((QuantroApplication) context
							.getApplicationContext()).getGameViewMemoryCapabilities(null);

					Analytics.logInGameOutOfMemory(gvmc, assetPath, attempt);
				}

				// GC?
				System.gc();

				if (attempt > 1) {
					// downgrade image size
					if (loadImagesSize == DrawSettings.IMAGES_SIZE_LARGE)
						loadImagesSize = DrawSettings.IMAGES_SIZE_MID;
					else if (loadImagesSize == DrawSettings.IMAGES_SIZE_MID)
						loadImagesSize = DrawSettings.IMAGES_SIZE_SMALL;
					else if (loadImagesSize == DrawSettings.IMAGES_SIZE_SMALL)
						throw oome;
				}
			}
		}

		return b;
	}

	private static String sheetSetString(int set) {
		if (set == SHEET_SET_EXACT)
			return "exact";
		else if (set == SHEET_SET_OVERSIZED)
			return "oversized";
		return null;
	}

	private static String nearestOffsetString(float xOffset, float yOffset) {
		if (xOffset < 0)
			return "-0.15-0.15";
		else if (xOffset == 0)
			return "";
		else if (xOffset < 0.1)
			return "+0.05+0.05";
		else
			return "+0.2+0.25";
	}

	private static String nearestResolutionString(int width, int height,
			int loadSize) {

		int dimension = nearestResolutionDimension(width, height, loadSize);
		return "" + dimension + "x" + dimension;
	}

	private static int nearestResolutionDimension(int width, int height,
			int loadSize) {

		if (GlobalTestSettings.FORCE_LOAD_LARGE_RESOURCES)
			return 80;

		int avg = (width + height) / 2;
		if (avg < 40)
			return 20;
		else if (avg < 80)
			return loadSize >= DrawSettings.IMAGES_SIZE_MID ? 40 : 20;
		else
			return loadSize >= DrawSettings.IMAGES_SIZE_LARGE ? 80 : 40; // "80x80"
																			// ;
	}

	private static String nextLargestResolutionString(int width, int height,
			int loadSize) {

		int dimension = nextLargestLoadDimension(width, height, loadSize);
		if ( GlobalTestSettings.BLOCK_DRAWER_LOG_SETUP ) {
			log("nextLargestResolutionString for " + width + " by " + height + " at size " + loadSize + " is " + dimension) ;
		}
		return "" + dimension + "x" + dimension;
	}

	private static int nextLargestLoadDimension(int width, int height,
			int loadSize) {
		if (GlobalTestSettings.FORCE_LOAD_LARGE_RESOURCES)
			return 80;

		int max = Math.max(width, height);
		if (max <= 20)
			return 20;
		else if (max <= 40)
			return loadSize >= DrawSettings.IMAGES_SIZE_MID ? 40 : 20;
		else
			return loadSize >= DrawSettings.IMAGES_SIZE_LARGE ? 80 : 40;
	}

	public static int[] getSupportedBlockSizes(int loadImagesSize) {
		if (GlobalTestSettings.FORCE_LOAD_LARGE_RESOURCES)
			return new int[] { 80 };

		switch (loadImagesSize) {
		case DrawSettings.IMAGES_SIZE_NONE:
			return new int[] {};
		case DrawSettings.IMAGES_SIZE_SMALL:
			return new int[] { 20 };
		case DrawSettings.IMAGES_SIZE_MID:
			return new int[] { 20, 40 };
		case DrawSettings.IMAGES_SIZE_LARGE:
			return new int[] { 20, 40, 80 };
		}

		return null;
	}

	private static String nearestBlurRadiusString(float radius) {
		if (radius == 0)
			return "0";
		else if (radius < 0.075)
			return "0.05";
		else if (radius < 0.15)
			return "0.1";
		else if (radius < 0.25)
			return "0.2";
		else if (radius < 0.35)
			return "0.3";
		else if (radius < 0.45)
			return "0.4";
		else if (radius < 0.63)
			return "0.5";
		else if (radius < 0.88)
			return "0.75";
		else
			return "1.0";
	}

	private int boundDropShadowWidth(DrawSettings ds) {
		int pixels = 1;
		for (int i = 0; i < ds.size_outerShadowGaussianRadius.length; i++) {
			pixels = Math
					.max(pixels,
							Math.abs(ds.size_outerShadowXOffset[i])
									+ (int) Math
											.ceil(ds.size_outerShadowGaussianRadius[i])
									+ 2);
		}
		return pixels;
	}

	private int boundDropShadowHeight(DrawSettings ds) {
		int pixels = 1;
		for (int i = 0; i < ds.size_outerShadowGaussianRadius.length; i++) {
			pixels = Math
					.max(pixels,
							Math.abs(ds.size_outerShadowYOffset[i])
									+ (int) Math
											.ceil(ds.size_outerShadowGaussianRadius[i])
									+ 2);
		}
		return pixels;
	}

	private int estimateDropShadowWidth(DrawSettings ds) {
		int pixels = 1;
		for (int i = 0; i < ds.size_outerShadowGaussianRadius.length; i++) {
			pixels = Math
					.max(pixels,
							Math.abs(ds.size_outerShadowXOffset[i])
									+ Math.min(
											ds.size_blockWidth / 6,
											(int) Math
													.round(ds.size_outerShadowGaussianRadius[i])));
		}
		return pixels;
	}

	private int estimateDropShadowHeight(DrawSettings ds) {
		int pixels = 1;
		for (int i = 0; i < ds.size_outerShadowGaussianRadius.length; i++) {
			pixels = Math
					.max(pixels,
							Math.abs(ds.size_outerShadowYOffset[i])
									+ Math.min(
											ds.size_blockHeight / 6,
											(int) Math
													.round(ds.size_outerShadowGaussianRadius[i])));
		}
		return pixels;
	}

	private static boolean dropShadowSheetsAreExactCopies(DrawSettings ds1,
			DrawSettings ds2) {
		if (ds1 == null || ds2 == null)
			return false;

		if (ds1.drawDetail != ds2.drawDetail)
			return false;

		return sheetsAreExactCopies(ds1.size_blockWidth,
				ds1.size_blockHeight,
				ds1.proportion_outerShadowGaussianRadius,
				ds1.proportion_outerShadowXOffset,
				ds1.proportion_outerShadowYOffset, ds1.alpha_dropShadow,
				ds2.size_blockWidth, ds2.size_blockHeight,
				ds2.proportion_outerShadowGaussianRadius,
				ds2.proportion_outerShadowXOffset,
				ds2.proportion_outerShadowYOffset, ds2.alpha_dropShadow);
	}

	private static boolean fillShadowSheetsAreExactCopies(DrawSettings ds1,
			DrawSettings ds2) {
		if (ds1 == null || ds2 == null)
			return false;

		if (ds1.drawDetail != ds2.drawDetail)
			return false;

		return sheetsAreExactCopies(ds1.size_blockWidth,
				ds1.size_blockHeight,
				ds1.proportion_innerShadowGaussianRadius,
				ds1.proportion_innerShadowXOffset,
				ds1.proportion_innerShadowYOffset, ds1.alpha_innerShadow,
				ds2.size_blockWidth, ds2.size_blockHeight,
				ds2.proportion_innerShadowGaussianRadius,
				ds2.proportion_innerShadowXOffset,
				ds2.proportion_innerShadowYOffset, ds2.alpha_innerShadow);
	}

	private static boolean sheetsAreExactCopies(int blockWidth1,
			int blockHeight1, float[] radius1, float[] xOffset1,
			float[] yOffset1, int[] alpha1, int blockWidth2, int blockHeight2,
			float[] radius2, float[] xOffset2, float[] yOffset2, int[] alpha2) {

		return blockWidth1 == blockWidth2
				&& blockHeight1 == blockHeight2
				&& sheetsAreScaledCopies(radius1, xOffset1, yOffset1, alpha1,
						radius2, xOffset2, yOffset2, alpha2);

	}

	private static boolean sheetsAreScaledCopies(float[] radius1,
			float[] xOffset1, float[] yOffset1, int[] alpha1, float[] radius2,
			float[] xOffset2, float[] yOffset2, int[] alpha2) {

		// Returns 'true' if EVERY value matches.
		if (radius1.length != xOffset1.length
				|| radius1.length != yOffset1.length
				|| radius1.length != alpha1.length)
			throw new IllegalArgumentException(
					"Provided arrays match in length at least within each sheet set!  "
							+ radius1.length + ", " + xOffset1.length + ", "
							+ yOffset1.length + ", " + alpha1.length);
		if (radius2.length != xOffset2.length
				|| radius2.length != yOffset2.length
				|| radius2.length != alpha2.length)
			throw new IllegalArgumentException(
					"Provided arrays match in length at least within each sheet set!  "
							+ radius2.length + ", " + xOffset2.length + ", "
							+ yOffset2.length + ", " + alpha2.length);

		if (radius1.length != radius2.length
				|| xOffset1.length != xOffset2.length
				|| yOffset1.length != yOffset2.length
				|| alpha1.length != alpha2.length)
			return false;

		for (int i = 0; i < radius1.length; i++) {
			boolean match = true;
			match = match && radius1[i] == radius2[i];
			match = match && xOffset1[i] == xOffset2[i];
			match = match && yOffset1[i] == yOffset2[i];
			match = match && alpha1[i] == alpha2[i];
			if (!match)
				return false;
		}

		return true;
	}

	private static boolean sheetsAreScaledCopies(float[] radius1,
			float[] xOffset1, float[] yOffset1, float[] alpha1,
			float[] radius2, float[] xOffset2, float[] yOffset2, float[] alpha2) {

		// Returns 'true' if EVERY value matches.
		if (radius1.length != xOffset1.length
				|| radius1.length != yOffset1.length
				|| radius1.length != alpha1.length)
			throw new IllegalArgumentException(
					"Provided arrays match in length at least within each sheet set!");
		if (radius2.length != xOffset2.length
				|| radius2.length != yOffset2.length
				|| radius2.length != alpha2.length)
			throw new IllegalArgumentException(
					"Provided arrays match in length at least within each sheet set!");

		if (radius1.length != radius2.length
				|| xOffset1.length != xOffset2.length
				|| yOffset1.length != yOffset2.length
				|| alpha1.length != alpha2.length)
			return false;

		for (int i = 0; i < radius1.length; i++) {
			boolean match = true;
			match = match && radius1[i] == radius2[i];
			match = match && xOffset1[i] == xOffset2[i];
			match = match && yOffset1[i] == yOffset2[i];
			match = match && alpha1[i] == alpha2[i];
			if (!match)
				return false;
		}

		return true;
	}

	// of length
	// [X][2][Yx]

	// returns whether ars[i][0] == ars[i][1] for all i.
	private static boolean exactMatch(float[][][] ars) {
		for (int i = 0; i < ars.length; i++) {
			if ((ars[i][0] == null) != (ars[i][1] == null))
				return false;
			if (ars[i][0] != null) {
				if (ars[i][0].length != ars[i][1].length)
					return false;
				for (int j = 0; j < ars[i][0].length; j++)
					if (ars[i][0][j] != ars[i][1][j])
						return false;
			}
		}

		return true;
	}

	// of length
	// [X][2][Yx]

	// returns whether ars[i][0] == ars[i][1] for all i.
	private static boolean exactMatch(int[][][] ars) {
		for (int i = 0; i < ars.length; i++) {
			if ((ars[i][0] == null) != (ars[i][1] == null))
				return false;
			if (ars[i][0] != null) {
				if (ars[i][0].length != ars[i][1].length)
					return false;
				for (int j = 0; j < ars[i][0].length; j++)
					if (ars[i][0][j] != ars[i][1][j])
						return false;
			}
		}

		return true;
	}

	/**
	 * Sets the provided region to empty, except for a small rect which should
	 * be well out-of-bounds of any useful bitmap content to draw
	 * ~(Integer.MAX_VALUE/2, Integer.MAX_VALUE/2).
	 * 
	 * This method should be used in place of .setEmpty() for Covered and
	 * Touched regions. There seems to be a bug when using canvas.clipRegion(
	 * ..., Region.Op.DIFFERENCE ) which removes from the clip not just those
	 * pixels in the region, but those which are BELOW the region bounds. This
	 * causes significant problems with redrawing content, since we only blit
	 * backgrounds to the area NOT covered by certain regions (handled by
	 * DIFFERENCE).
	 * 
	 * By including a small rect well below and to the right of any image
	 * content, we hopefully avoid bug manifestations.
	 */
	private void emptyWithOutOfBounds(Path p) {
	    reset(p);
	    unionRect(p, mRectFOutOfBounds, Path.Direction.CW);
	}

	/**
	 * A class used to listen for BackgroundAsset construction. This class is
	 * intended to "bake-in" drop shadows to the sides of the loaded Bitmap.
	 * 
	 * TODO: Add support for a "Skin Asset" so we can bake custom shadows in.
	 * 
	 * TODO: Add support for multiple backgrounds in our preallocated background
	 * set.
	 * 
	 * @author Jake
	 * 
	 */
	private class BackgroundAssetBuilderListener implements
			BackgroundBuilderListener<BackgroundAsset> {

		SkinAsset mSkinAsset;

		private BackgroundAssetBuilderListener(SkinAsset sa) {
			mSkinAsset = sa;
		}

		@Override
		public void bbl_buildStarting(BackgroundBuilder<BackgroundAsset> bb,
				BackgroundAsset ba) {
			// nothing to do here.
		}

		@Override
		public void bbl_buildFinishing(BackgroundBuilder<BackgroundAsset> bb,
				BackgroundAsset ba) {
			// here's where we bake our shadows in. It's okay if we end
			// up throwing an exception; the built object (BackgroundAsset)
			// will re-throw it when used. Typically we would throw an
			// exception if our shadow structures are recycled, in which case
			// the background asset will shortly be recycled as well.

			try {
				if (!ba.isPrerendered()) {
					log("bbl_buildFinishing background NOT prerendered");
					Rect bounds = new Rect();
					Bitmap bgBitmap = ba.getBitmap(bounds);
					// TODO: Use our provided SkinAsset to draw these edge shadows.
					if (bgBitmap != null)
						drawEdgeDropShadowsToBitmap(mDrawSettings, bgBitmap,
								bounds, 255);
				} else {
					log("bbl_buildFinishing background IS prerendered");
				}
				if (ba.isPreallocated() && mHasPreallocatedBitmaps) {
					Rect bounds = new Rect();
					Bitmap bgBitmap = ba.getBitmap(bounds);
					if (bgBitmap != null)
						mPreallocatedBitmaps.setBackgroundBitmapBounds(bgBitmap,
								ba.getBackground(), bounds);
				}
			} catch ( RuntimeException e ) {
				log("Exception caught in BackgroundAssetBuilderListener " + e.getMessage()) ;
				log(Log.getStackTraceString(e)) ;
				throw e ;
			}
			log("bbl_buildFinishing complete") ;
		}

		@Override
		public void bbl_buildFinished(BackgroundBuilder<BackgroundAsset> bb,
				BackgroundAsset ba) {
			// nothing to do here.
			log("bbl_buildFinished") ;
		}

	}

	private static class GradientShaderFactory extends ShapeDrawable.ShaderFactory {
		
		private enum Orientation {
			/**
			 * draw the gradient from the left to the right 
			 */
			LEFT_RIGHT,
			
			/**
			 * draw the gradient from the right to the left  
			 */
			RIGHT_LEFT,
			
			
			/**
			 * draw the gradient from the top to the bottom
			 */
			TOP_BOTTOM,
			
			
			/**
			 * draw the gradient from the bottom to the top  
			 */
			BOTTOM_TOP,
			

			/**
			 * draw the gradient from the top-left to the bottom-right
			 */
			TL_BR,

			
			/**
			 * draw the gradient from the top-right to the bottom-left 
			 */
			TR_BL,
			
			/**
			 * draw the gradient from the bottom-left to the top-right  
			 */
			BL_TR,

			/**
			 * draw the gradient from the bottom-right to the top-left  
			 */
			BR_TL,
 
		}
		
		private int [] mColors ;
		private float [] mPositions ;
		private Orientation mOrientation ;
		
		private GradientShaderFactory( int [] colors, float [] positions, Orientation orientation ) {
			mColors = colors ;
			mPositions = positions ;
			mOrientation = orientation ;
		}

		@Override
		public Shader resize(int width, int height) {
			LinearGradient lg = null ;
			Shader.TileMode tileMode = Shader.TileMode.REPEAT ;		// for easily spotted bugs
			switch( mOrientation ) {
			case LEFT_RIGHT:
				lg = new LinearGradient( 0, 0, width, 0, mColors, mPositions, tileMode) ;
				break ;
			case RIGHT_LEFT:
				lg = new LinearGradient( width, 0, 0, 0, mColors, mPositions, tileMode) ;
				break ;
			case TOP_BOTTOM:
				lg = new LinearGradient( 0, 0, 0, height, mColors, mPositions, tileMode) ;
				break ;
			case BOTTOM_TOP:
				lg = new LinearGradient( 0, height, 0, 0, mColors, mPositions, tileMode) ;
				break ;
			case TL_BR:
				lg = new LinearGradient( 0, 0, width, height, mColors, mPositions, tileMode) ;
				break ;
			case TR_BL:
				lg = new LinearGradient( width, 0, 0, height, mColors, mPositions, tileMode) ;
				break ;
			case BL_TR:
				lg = new LinearGradient( 0, height, width, 0, mColors, mPositions, tileMode) ;
				break ;
			case BR_TL:
				lg = new LinearGradient( width, height, 0, 0, mColors, mPositions, tileMode) ;
				break ;
			}
			
			return lg ;
		}
		
	}
	
	
	/**
	 * Creates and returns a new Drawable object which draws the specified gradient.
	 * 
	 * There is no guarantee that the object returned is an instance of GradientDrawable.
	 * 
	 * @param colors An array giving the colors for this gradient.
	 * @param positions If non-null, the relative positions [0, 1] for each color.
	 * 		Must be the same length as 'colors' if non-null.  If null, a uniform
	 * 		placement is assumed.
	 * @param direction One of DIRECTION_*.
	 * @return
	 */
	private static Drawable makeGradientDrawable( int [] colors, float [] positions, int direction ) {
		if ( positions == null || (positions.length == 2 && positions[0] == 0 && positions[1] == 1)) {
			// make a GradientDrawable
			GradientDrawable.Orientation gdo ;
			switch( direction ) {
			case DIRECTION_LEFT:
				gdo = GradientDrawable.Orientation.RIGHT_LEFT ;
				break ;
			case DIRECTION_RIGHT:
				gdo = GradientDrawable.Orientation.LEFT_RIGHT ;
				break ;
			case DIRECTION_UP:
				gdo = GradientDrawable.Orientation.BOTTOM_TOP ;
				break ;
			case DIRECTION_DOWN:
				gdo = GradientDrawable.Orientation.TOP_BOTTOM ;
				break ;
			default:
				throw new IllegalArgumentException("Can't make a gradient drawable for direction " + direction) ;
			}
			
			return new GradientDrawable( gdo, colors ) ;
		} else {
			// make a GradientShaderFactory, put it in a PaintDrawable, and
			// return that drawable.
			GradientShaderFactory.Orientation gsfo ;
			switch( direction ) {
			case DIRECTION_LEFT:
				gsfo = GradientShaderFactory.Orientation.RIGHT_LEFT ;
				break ;
			case DIRECTION_RIGHT:
				gsfo = GradientShaderFactory.Orientation.LEFT_RIGHT ;
				break ;
			case DIRECTION_UP:
				gsfo = GradientShaderFactory.Orientation.BOTTOM_TOP ;
				break ;
			case DIRECTION_DOWN:
				gsfo = GradientShaderFactory.Orientation.TOP_BOTTOM ;
				break ;
			default:
				throw new IllegalArgumentException("Can't make a gradient drawable for direction " + direction) ;
			}
			
			PaintDrawable pd = new PaintDrawable() ;
			pd.setShape(new RectShape()) ;
			pd.setShaderFactory( new GradientShaderFactory( colors, positions, gsfo ) ) ;
			return pd ;
		}
	}
	

	/**
	 * Which "stable field" is drawn by drawStable?  Could be standard Stable,
	 * the minimum horiz. profile field, or the "initial" field (which for 
	 * "transition" states is the previous stable).
	 * @author Jake
	 *
	 */
	private enum DrawStableFieldType {
		/**
		 * The "stable state" for this Slice: after any transitions or
		 * piece-locks.
		 */
		STABLE,
		
		/**
		 * The "minimum profile" arrangement for this slice: for piece previews,
		 * rotated to have a minimum width.
		 */
		MINIMUM_PROFILE,
		
		/**
		 * The "initial" state for this slice: before any transitions or
		 * piece-locks.
		 */
		INITIAL,
		
		
		/**
		 * Most likely the same blockfield as "initial" but given special
		 * consideration for Push state slices.
		 */
		PUSHING_PRE,
		
		
		/**
		 * Most likely the same blockfield as "stable" but given special
		 * consideration for Push state slices.
		 */
		PUSHING_POST,
	}
	
}
